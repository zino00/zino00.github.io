

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=&#34;auto&#34;>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/favicon.jpg">
  <link rel="icon" href="/img/favicon.jpg">
  <meta name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="description" content="学习计算机网络课程过程中的笔记">
  <meta name="author" content="John Doe">
  <meta name="keywords" content="">
  
  <title>计算机网络学习笔记 - Zino&#39;s Blog</title>

  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.6.0/dist/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/github-markdown-css@4.0.0/github-markdown.min.css" />
  <link  rel="stylesheet" href="/lib/hint/hint.min.css" />

  
    
    
      
      <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@10.7.2/styles/github-gist.min.css" />
    
  

  
    <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css" />
  



<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_kmeydafke9r.css">


<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->


  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    var CONFIG = {"hostname":"zino00.github.io","root":"/","version":"1.8.11","typing":{"enable":true,"typeSpeed":70,"cursorChar":"","loop":false},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"copy_btn":true,"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":1},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":true,"baidu":"f45dcd001d67e8f9d84f91248ea31abf","google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null}},"search_path":"/local-search.xml"};
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
<meta name="generator" content="Hexo 5.4.0"></head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand"
       href="/">&nbsp;<strong>Zino's Blog</strong>&nbsp;</a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" data-toggle="modal" data-target="#modalSearch">&nbsp;<i
                class="iconfont icon-search"></i>&nbsp;</a>
          </li>
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="banner" id="banner" parallax=true
         style="background: url('/img/post.jpg') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="page-header text-center fade-in-up">
            <span class="h2" id="subtitle" title="计算机网络学习笔记">
              
            </span>

            
              <div class="mt-3">
  
  
    <span class="post-meta">
      <i class="iconfont icon-date-fill" aria-hidden="true"></i>
      <time datetime="2022-06-30 17:50" pubdate>
        2022年6月30日 下午
      </time>
    </span>
  
</div>

<div class="mt-1">
  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      26.6k 字
    </span>
  

  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      286
       分钟
    </span>
  

  
  
    
      <!-- 不蒜子统计文章PV -->
      <span id="busuanzi_container_page_pv" style="display: none">
        <i class="iconfont icon-eye" aria-hidden="true"></i>
        <span id="busuanzi_value_page_pv"></span> 次
      </span>
    
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">计算机网络学习笔记</h1>
            
            <div class="markdown-body">
              <h1 id="第1章-计算机网络和因特网"><a class="markdownIt-Anchor" href="#第1章-计算机网络和因特网"></a> 第1章 计算机网络和因特网</h1>
<h2 id="11-什么是因特网"><a class="markdownIt-Anchor" href="#11-什么是因特网"></a> 1.1 什么是因特网</h2>
<h3 id="111-具体构成描述"><a class="markdownIt-Anchor" href="#111-具体构成描述"></a> 1.1.1 具体构成描述</h3>
<ul>
<li>
<p>因特网是一个世界范围的计算机网络，即它是一个互联了遍及全世界数十亿计算设备的网络。</p>
</li>
<li>
<p><strong>端系统</strong>通过<strong>通信链路</strong>（communication link)和<strong>分组交换机</strong>（packet switch)连接到一起。</p>
</li>
<li>
<p><strong>分组交换机</strong>从它的一条入通信链路接收到达的分组，并从它的一条出通信链路转发该分组。两种最著名的分组交换机类型是<strong>路由器</strong>（router)和<strong>链路层交换机</strong>(link-layer switch)。</p>
</li>
<li>
<p>端系统通过<strong>因特网服务提供商</strong>（Internet Service Provider,<strong>ISP</strong>)接入因特网</p>
</li>
<li>
<p>端系统、分组交换机和其他因特网部件都要运行一系列<strong>协议</strong>(protocol),这些协议控制因特网中信息的接收和发送。<strong>TCP</strong>(<code>Transmission Control Protocol</code>,传输控制协议）和<strong>IP</strong><br>
(<code>Internet Protocol</code>,网际协议）是因特网中两个最为重要的协议。IP协议定义了在路由器和端系统之间发送和接收的分组格式。</p>
</li>
<li>
<p><strong>协议</strong>(<code>protocol</code>)定义了在两个或多个通信实体之间交换的报文的格式和顺序，以及报文发送和/或接收一条报文或其他事件所采取的动作。</p>
</li>
</ul>
<h2 id="12-网络边缘"><a class="markdownIt-Anchor" href="#12-网络边缘"></a> 1.2 网络边缘</h2>
<p>与因特网相连的计算机和其他设备，因为它们位于因特网的边缘，故而被称为<strong>端系统</strong></p>
<p>端系统也称为<strong>主机</strong>（host)，又可以分为</p>
<ul>
<li>客户(client)</li>
<li>服务器（server)</li>
</ul>
<h3 id="121-接入网"><a class="markdownIt-Anchor" href="#121-接入网"></a> 1.2.1 接入网</h3>
<p><strong>接入网</strong>，这是指将端系统物理连接到其<strong>边缘路由器</strong>（edgerouter)的网络。</p>
<p><strong>边缘路由器</strong>是端系统到任何其他远程端系统的路径上的第一台路由器</p>
<ol>
<li>
<p>家庭接入：DSL、电缆、FTTH、拨号和卫星</p>
<ul>
<li>
<p>数字用户线（Digital Subscriber Line，<br>
DSL)</p>
<p>家庭电话线同时承载了数据和传统的电话信号， 它们用不同的频率进行编码：<br>
• 高速下行信道， 位于50kHz 到 1 MHz 频段；<br>
• 中速上行信道， 位于 4kHz 到 50kHz 频段；<br>
• 普通的双向电话信道， 位于0 到 4kHz 频段。</p>
</li>
<li>
<p>电缆因特网接入（cable Internet access)</p>
</li>
<li>
<p>光纤到户（Fiber To The Home, FTTH)</p>
</li>
</ul>
</li>
<li>
<p>企业（和家庭）接入：以太网和WiFi</p>
<p><img src="/posts/9d1d146e/image-20220224113740807.png" srcset="/img/loading.gif" lazyload alt="image-20220224113740807"></p>
<ul>
<li>以太网用户使用双绞铜线与一台以太网交换机相连</li>
</ul>
</li>
<li>
<p>广域无线接入：3G和TLE</p>
</li>
</ol>
<h3 id="122-物理媒体"><a class="markdownIt-Anchor" href="#122-物理媒体"></a> 1.2.2 物理媒体</h3>
<p>物理媒体分成两种类型： 导引型媒体（ guided media ) 和非导引型媒体（unguided media)。</p>
<ul>
<li>
<p>对于导引型媒体，电波沿着固体媒体前行，如光缆、双绞铜线或同轴电缆。</p>
</li>
<li>
<p>对于非导引型媒体，电波在空气或外层空间中传播，例如在无线局域网或数字卫星频道中</p>
</li>
</ul>
<h2 id="13-网络核心"><a class="markdownIt-Anchor" href="#13-网络核心"></a> 1.3 网络核心</h2>
<ul>
<li>
<p>路由器</p>
</li>
<li>
<p>网络的网络</p>
</li>
</ul>
<h3 id="131-分组交换"><a class="markdownIt-Anchor" href="#131-分组交换"></a> 1.3.1 分组交换</h3>
<p>特点</p>
<ul>
<li>不需要资源预留</li>
<li>按需使用资源，可能要排队等待：同时有其它分组发送。</li>
<li>如，因特网。</li>
</ul>
<p>为了从源端系统向目的端系统发送一个<strong>报文</strong>， 源将长报文划分为较小的数据块， 称之为<strong>分组</strong>(packet)。</p>
<p>在源和目的地之间， 每个分组都通过<strong>通信链路</strong>和<strong>分组交换机</strong>（ packet switch )传送。 （ 交换机主要有两类： <strong>路由器</strong>（ router) 和<strong>链路层交换机</strong> ( link-layer switch ) )</p>
<p><strong>分组</strong>以等于该链路最大传输速率的速度传输通过通信链路。</p>
<p><img src="/posts/9d1d146e/image-20220224165531713.png" srcset="/img/loading.gif" lazyload alt="image-20220224165531713"></p>
<ol>
<li>
<p><strong>存储转发传输</strong></p>
<ul>
<li>
<p>存储转发传输是指在交换机能够开始向输出链路传输该分组的第一个比特之前， 必须接收到整个分组。</p>
</li>
<li>
<p>由N条速率均为R的链路组成的路径（ 所以，在源和目的地之间有 N-1 台路由器） ， 从源到目的地发送一个分组。应用如上相同的逻辑， 我们看到端到端时延是：</p>
<p><img src="/posts/9d1d146e/image-20220423104930824.png" srcset="/img/loading.gif" lazyload alt="image-20220423104930824"></p>
</li>
<li>
<p>分组交换机具有一个<strong>输出缓存</strong>（ output buffer, 也称为输出队列（ output queue)), 它用于存储路由器准备发往那条链路的分组。分组要承受输出缓存的<strong>排队时延</strong></p>
</li>
<li>
<p>因为缓存空间的大小是有限的， 一个到达的分组可能发现该缓存已被其他等待传输的分组完全充满了。 在此情况下， 将出现<strong>分组丢失（丢包）</strong>( packet loss), 到达的分组或已经排队的分组之一将被丢弃。</p>
</li>
</ul>
</li>
<li>
<p><strong>转发表和路由选择协议</strong></p>
<p>每台路由器具有一个<strong>转发表</strong>( forwarding table), 用于将目的地址（ 或目的地址的一部分）映射成为输出链路。</p>
<p><strong>路由选择协议</strong>可以决定从每台路由器到每个目的地的最短路径， 并使用这些最短路径结果来配置路由器中的转发表。</p>
</li>
</ol>
<h3 id="132-电路交换"><a class="markdownIt-Anchor" href="#132-电路交换"></a> 1.3.2 电路交换</h3>
<p>特点：</p>
<ul>
<li>预留端到端资源：端系统之间通信路径上所需要的资源 (缓存，链路带宽)。建立连接。</li>
<li>发送方以恒定速率向接收方传送数据。</li>
<li>如，电话网络。</li>
</ul>
<p>在电路交换网络中， 在端系统间通信会话期间， <strong>预留了端系统间沿路径通信所需要的资源</strong>（ 缓存， 链路传输速率）。</p>
<p>在发送方能够发送信息之前， 该网络必须在发送方和接收方之间建立一条连接。 这是一个名副其实的连接， 因为此时沿着发送方和接收方之间路径上的交换机都将为该连接维护连接状态。 用电话的术语来说， 该连接被称为一条电路( circuit )0 当网络创建这种电路时， 它也在连接期间在该网络链路上预留了恒定的传输速率（ 表示为每条链路传输容量的一部分）。 既然已经为该发送方- 接收方连接预留了带宽，则发送方能够以确保的恒定速率向接收方传送数据。</p>
<ol>
<li><strong>电路交换网络中的复用</strong></li>
</ol>
<p>链路中的电路是通过<strong>频分复用</strong>（ Frequency- Division Multiplexing， FDM ) 或 <strong>时分复用</strong>(Time- Division Multiplexing, TDM) 来实现的。</p>
<ul>
<li>对于 <strong>FDM</strong> ， 链路的频谱由跨越链路创建的所有连接共享。特别是， 在连接期间链路为每条连接专用一个频段。 在电话网络中， 这个频段的宽度通常为 4kHz ( 即每秒 4000 周期）。毫无疑问， 该频段的宽度称为带宽（ bandwidth )。</li>
<li>对于一条 <strong>TDM</strong> 链路， 时间被划分为固定期间的帧， 并且每个帧又被划分为固定数量的时隙。 当网络跨越一条链路创建一条连接时， 网络在每个帧中为该连接指定一个时隙。这些时隙专门由该连接单独使用， 一个时隙（ 在每个帧内） 可用于传输该连接的数据。</li>
</ul>
<p><img src="/posts/9d1d146e/image-20220224170445880.png" srcset="/img/loading.gif" lazyload alt="image-20220224170445880"></p>
<ol start="2">
<li>
<p>分组交换和电路交换的对比</p>
<p>分组交换：</p>
<ul>
<li>
<p>优点</p>
<p>①它提供了比电路交换更好的带宽共享；</p>
<p>②它比电路交换更简单、 更有效， 实现成本更低。</p>
</li>
<li>
<p>缺点</p>
<p>分组交换不适合实时服务 （ 例如， 电话和视频会议）， 因为它的端到端时延是可变的和不可预测的（ 主要是因为排队时延的变动和不可预测所致）</p>
</li>
</ul>
<p>电路交换</p>
<ul>
<li>
<p>优点</p>
<p>电路交换⽹络可以在响应时间内保证⼀定量的端到端带宽。如今⼤部分分组交换⽹络（包括因特⽹）⽆法保证端到端带宽。</p>
</li>
<li>
<p>缺点</p>
<p>FDM需要复杂的模拟硬件来将信号转换为合适的频率。</p>
</li>
</ul>
</li>
</ol>
<h3 id="133-网络的网络"><a class="markdownIt-Anchor" href="#133-网络的网络"></a> 1.3.3 网络的网络</h3>
<h2 id="14-分组交换网中的时延-丢包和吞吐量"><a class="markdownIt-Anchor" href="#14-分组交换网中的时延-丢包和吞吐量"></a> 1.4 分组交换网中的时延、丢包和吞吐量</h2>
<h3 id="141-分组交换网中的时延概述"><a class="markdownIt-Anchor" href="#141-分组交换网中的时延概述"></a> 1.4.1 分组交换网中的时延概述</h3>
<p><img src="/posts/9d1d146e/image-20220224181540152.png" srcset="/img/loading.gif" lazyload alt="image-20220224181540152"></p>
<p><strong>时延的类型</strong></p>
<ol>
<li>
<p>处理时延<br>
检査分组首部和决定将该分组导向何处所需要的时间是处理时延的一部分。 处理时延也能够包括其他因素， 如检査比特级别的差错所需要的时间</p>
<p>高速路由器的处理时延通常是微秒或更低的数量级。</p>
</li>
<li>
<p>排队时延<br>
在队列中， 当分组在链路上等待传输时， 它经受排队时延。 一个特定分组的排队时延长度将取决于先期到达的正在排队等待向链路传输的分组数量。</p>
<p>实际的排队时延可以是毫秒到微秒量级。</p>
</li>
<li>
<p>传输时延<br>
假定分组以先到先服务方式传输一这在分组交换网中是常见的方式， 仅当所有已经到达的分组被传输后， 才能传输刚到达的分组。 用 L 比特表示该分组的长度， 用 R bps( 即 b/s)表示从路由器 A 到路由器 B 的链路传输速率**。传输时延是 L/R**这是将所有分组的比特推向链路 （ 即传输， 或者说发射）所需要的时间。</p>
<p>实际的传输时延通常在毫秒到微秒量级。</p>
</li>
<li>
<p>传播时延<br>
一旦一个比特被推向链路， 该比特需要向路由器 B 传播。 从该链路的起点到路由器 B传播所需要的时间是传播时延。传播时延等于两台路由器之间的距离除以传播速率。 即传播时延是d/s,其中d是路由器A和路由器B之间的距离，s是该链路的传播速率。</p>
<p>在广域网中， 传播时延为毫秒量级。</p>
</li>
<li>
<p>传输时延和传播时延的比较<br>
传输时延和传播时延之间的差异是微妙而重要的。 <strong>传输时延</strong>是路由器推出分组所需要的时间， 它是分组长度和链路传输速率的函数， 而与两台路由器之间的距离无关。 另一方面，<strong>传播时延</strong>是一个比特从一台路由器传播到另一台路由器所需要的时间， 它是两台路由器之间距离的函数， 而与分组长度或链路传输速率无关。</p>
</li>
</ol>
<p>如果令d<sub>proc</sub>,d<sub>queue</sub>,d<sub>trans</sub>,d<sub>prop</sub>分别表示处理时延、排队时延、传输时延和传播时延，则节点的总时延由下式给定：<br>
d<sub>total</sub>=d<sub>proc</sub>+d<sub>queue</sub>+d<sub>trans</sub>+d<sub>prop</sub></p>
<h3 id="142-排队时延和丢包"><a class="markdownIt-Anchor" href="#142-排队时延和丢包"></a> 1.4.2 排队时延和丢包</h3>
<p><strong>排队时延</strong></p>
<p>a表示分组到达队列的平均速率(a的单位是分组/秒，即pkt/s)</p>
<p>R是传输速率，即从队列中推出比特的速率（以bps即b/s为单位）。</p>
<p>假定所有分组都是由L比特组成的。 则比特到达队列的平均速率<br>
是 La bps。</p>
<p>比率La/R被称为流量强度（ traffic intensity)， 它在估计排队时延的范围方面经常起着重要的作用。 如果 La/R &gt; 1，则比特到达队列的平均速率超过从该队列传输出去的速率。排队时延将趋向无穷大</p>
<p><strong>丢包</strong></p>
<p>一条链路前的队列只有有限的容量， 随着流量强度接近1，排队时延并不真正趋向无穷大。 相反， 到达的分组将发现一个满的队列。 由于没有地方存储这个分组， 路由器将丢弃 (drop) 该分组， 即该分组将会丢失（lost )。</p>
<h3 id="143-端到端时延"><a class="markdownIt-Anchor" href="#143-端到端时延"></a> 1.4.3 端到端时延</h3>
<p>d<sub>end-end</sub>=N(d<sub>proc</sub>+d<sub>trans</sub>+d<sub>prop</sub>)</p>
<p>d<sub>tran</sub>=L/R</p>
<h3 id="144-计算机网络中的吞吐量"><a class="markdownIt-Anchor" href="#144-计算机网络中的吞吐量"></a> 1.4.4 计算机网络中的吞吐量</h3>
<p>在任何时间瞬间的瞬时吞吐量 （ instantaneous throughput ) 是主机 B 接收到该文件的速率（ 以 bps 计）</p>
<p>如果该文件由 F 比特组成， 主机 B 接收到所有 F 比特用去 r 秒，则文件传送的平均吞吐量 （ average throughput ) 是 F/T bps。</p>
<p><img src="/posts/9d1d146e/image-20220423113712304.png" srcset="/img/loading.gif" lazyload alt="image-20220423113712304"></p>
<p>N条链路的传输速率分别是R1 ，R2， …，Rn  我们发现从服务器到客户的文件传输吞吐量是 min{R1，R2 ••• ， Rn} 这同样仍是沿着服务器和客户之间路径的瓶颈链路的速率</p>
<h2 id="15-协议层次及其服务模型"><a class="markdownIt-Anchor" href="#15-协议层次及其服务模型"></a> 1.5 协议层次及其服务模型</h2>
<h3 id="151-分层的体系结构"><a class="markdownIt-Anchor" href="#151-分层的体系结构"></a> 1.5.1 分层的体系结构</h3>
<ol>
<li>
<p>协议分层</p>
<p>各层的所有协议被称为<strong>协议</strong>栈 （ protocol stack )。 因特网的协议栈由5个层次组成： 物理层 、 链路层、 网络层、 运输层和应用层</p>
<p><img src="/posts/9d1d146e/net.jpg" srcset="/img/loading.gif" lazyload alt="net"></p>
<p><img src="/posts/9d1d146e/image-20220224183243758.png" srcset="/img/loading.gif" lazyload alt="image-20220224183243758"></p>
<ul>
<li>
<p>(1) <strong>应用层</strong><br>
应用层是网络应用程序及它们的应用层协议存留的地方。</p>
<p><strong>应用层协议</strong> ( application- layer protocol ) 定义了运行在不同端系统上的应用程序进程如何相互传递报文</p>
<p>因特网的应用层包括许多协议， 例如 HTTP ( 它提供了 Web 文档的请求和传送） 、 SMTP ( 它提供了电子邮件报文的传输） 和 FTP (它提供两个端系统之间的文件传送）。</p>
<p>应用层协议分布在多个端系统上， 而一个端系统中的应用程序使用协议与另一个端系统中的应用程序交换信息分组。 我们把这种位于应用层的信息分组称为<strong>报文</strong> （ message)</p>
</li>
<li>
<p>(2) <strong>运输层</strong><br>
因特网的运输层在应用程序端点之间传送应用层报文。</p>
<p><strong>运输层协议</strong>为运行在不同主机上的应用进程之间提供了<strong>逻辑通信 (logic conmmunication)</strong> 功能。</p>
<p>在因特网中， 有两种运输协议， 即 <strong>TCP 和 UDP</strong>， 利用其中的任一个都能运输应用层报文。</p>
<p><strong>TCP</strong> 向它的应用程序提供了面向连接的服务。 这种服务包括了应用层报文向目的地的确保传递和流量控制 （ 即发送方/接收方速率匹配）。 TCP 也将长报文划分为短报文， 并提供拥塞控制机制， 因此当网络拥塞时， 源抑制其传输速率。</p>
<p><strong>UDP</strong> 协议向它的应用程序提供无连接服务。这是一种不提供不必要服务的服务，没有可靠性，没有流量控制，也没有拥塞控制。</p>
<p>在本书中， 我们把运输层的分组称为<strong>报文段</strong>（ segment )</p>
</li>
<li>
<p>(3) <strong>网络层</strong><br>
因特网的网络层负责将称为<strong>数据报</strong> (datagram) 的网络层分组从一台主机移动到另一台主机。 在一台源主机中的因特网运输层协议（ TCP 或 UDP) 向网络层递交运输层报文段和目的地址， 就像你通过邮政服务寄信件时提供一个目的地址一样。</p>
<p>因特网的网络层包括著名的<strong>网际协议 IP</strong>， 该协议定义了在数据报中的各个字段以及端系统和路由器如何作用于这些字段。 IP 仅有一个， 所有具有网络层的因特网组件必须运行IP。</p>
<p>因特网的网络层也包括决定路由的<strong>路由选择协议</strong>， 它根据该路由将数据报从源传输到目的地。</p>
<p>网络层的分组称为<strong>数据报</strong> ( datagram)</p>
</li>
<li>
<p>(4) <strong>链路层</strong></p>
<p>链路层的任务是将整个帧从一个网络元素移动到邻近的网络元素</p>
<p>因特网的网络层通过源和目的地之间的一系列路由器路由数据报。 为了将分组从一个节点（ 主机或路由器） 移动到路径上的下一个节点， 网络层必须依靠该链路层的服务。 特别是在每个节点， 网络层将数据报下传给链路层， 链路层沿着路径将数据报传递给下一个节点。 在该下一个节点，链路层将数据报上传给网络层。</p>
<p>在本书中， 我们把链路层分组称为<strong>帧</strong>（frame)</p>
</li>
<li>
<p>（5）<strong>物理层</strong><br>
物理层的任务是将该帧中的一个个比特从一个节点移动到下一个节点。</p>
</li>
<li>
<blockquote>
<ul>
<li>应⽤层报⽂：应⽤程序想发送和通过传输层的数据；</li>
<li>传输层报文段：由传输层⽣成并且封装有传输层头信息的应⽤层报⽂</li>
<li>⽹络层数据报：封装有⽹络层头信息的传输层报文段</li>
<li>链路层帧：封装有链路层头信息的⽹络层数据报</li>
</ul>
</blockquote>
</li>
</ul>
</li>
</ol>
<h3 id="152-封装"><a class="markdownIt-Anchor" href="#152-封装"></a> 1.5.2 封装</h3>
<p>封装 （ encapsulation ):</p>
<ul>
<li>在发送主机端， 一个<strong>应用层报文</strong> (<code>application-layer message</code>) (图 1-24 中的 M) 被传送给运输层。</li>
<li>在最简单的情况下，运输层收取到报文并附上附加信息 （ 所谓<strong>运输层首部信息</strong>， 图 1-24 中的 H<sub>l</sub>,)， 该首部将被接收端的运输层使用。 应用层报文和运输层首部信息一道构成了<strong>运输层报文段</strong> （<code>transportlayer segment</code>)。 运输层报文段因此封装了应用层报文。 附加的信息也许包括了下列信息：
<ul>
<li>允许接收端运输层向上向适当的应用程序交付报文的信息；</li>
<li>差错检测位信息， 该信息让接收方能够判断报文中的比特是否在途中已被改变。</li>
</ul>
</li>
<li>运输层则向网络层传递该报文段， 网络层增加了如源和目的端系统地址等<strong>网络层首部信息</strong>（ 图1-24 中的 H<sub>n</sub>)， 生成了<strong>网络层数据报</strong> ( <code>network-layer datagram</code>)</li>
<li>该数据报接下来被传递给链路层， 链路层（ 自然而然地）增加它自己的<strong>链路层首部信息</strong>并生成<strong>链路层帧</strong>（ <code>link-layer frame</code>)。</li>
</ul>
<p>所以我们看到， 在每一层， 一个分组具有两种类型的字段： <strong>首部字段</strong>和<strong>有效载荷字段</strong> ( payload field )，有效载荷通常是来自上一层的分组</p>
<h2 id="18小结"><a class="markdownIt-Anchor" href="#18小结"></a> 1.8小结</h2>
<h1 id="第2章-应用层"><a class="markdownIt-Anchor" href="#第2章-应用层"></a> 第2章 应用层</h1>
<h2 id="21-应用层协议原理"><a class="markdownIt-Anchor" href="#21-应用层协议原理"></a> 2.1 应用层协议原理</h2>
<h3 id="211-网络应用程序体系结构"><a class="markdownIt-Anchor" href="#211-网络应用程序体系结构"></a> 2.1.1 网络应用程序体系结构</h3>
<p>现代网络应用程序中所使用的两种主流体系结构之一：</p>
<ol>
<li>
<p>客户-服务器体系结构</p>
<p>在客户-服务器体系结构（ client-server architecture) 中， 有一个总是打开的主机称为服务器，它服务于来自许多其他称为客户的主机的请求。</p>
<p><strong>特点：</strong></p>
<ul>
<li>服务器具有特定的周知的IP地址</li>
<li>集中结构，一对多</li>
<li>服务器共享资源，客户机资源不共享，客户之间不直接进行通信</li>
<li>服务器可能负载过重</li>
<li>网络带宽限制</li>
</ul>
</li>
<li>
<p>对等（P2P)体系结构</p>
<ul>
<li>非集中结构，多对多</li>
<li>节点具备客户与服务器双重特性</li>
<li>充分利用终端资源</li>
<li>可扩展性好</li>
</ul>
</li>
</ol>
<p><img src="/posts/9d1d146e/image-20220402133154076.png" srcset="/img/loading.gif" lazyload alt="image-20220402133154076"></p>
<h3 id="212-进程通信"><a class="markdownIt-Anchor" href="#212-进程通信"></a> 2.1.2 进程通信</h3>
<p>一个进程可以被认为是运行在端系统中的一个程序</p>
<ul>
<li>
<p>当多个进程运行在相同的端系统上时， 它们使用进程间通信机制相互通信。 进程间通信的规则由端系统上的操作系统确定。</p>
</li>
<li>
<p>在两个不同端系统上的进程， 通过跨越计算机网络交换<strong>报文</strong>（ message) 而相互通信。</p>
</li>
</ul>
<ol>
<li>
<p><strong>客户和服务器进程</strong></p>
<p>在一对进程之间的通信会话场景中， 发起通信（ 即在该会话开始时发起与其他进程的联系） 的进程被标识为<strong>客户</strong>， 在会话开始时等待联系的进程是<strong>服务器</strong>。</p>
<p>在 Web 中， 一个浏览器进程向一台 Web 服务器进程发起联系， 因此该浏览器进程是<strong>客户</strong>， 而该 Web 服务器进程是服务器。 在 P2P 文件共享中， 当对等方 A 请求对等方 B 发送一个特定的文件时， 在这个特定的通信会话中对等方 A 是<strong>客户</strong>， 而对等方 B 是<strong>服务器</strong>。</p>
</li>
<li>
<p><strong>进程和计算机网络之间的接口</strong></p>
<p>进程通过一个称为<strong>套接字（ socket )</strong> 的软件接口向网络发送报文和从网络接收报文。</p>
<p>套接字是应用程序与网络之间的<strong>API（应用程序编程接口）</strong></p>
</li>
<li>
<p><strong>进程寻址</strong></p>
<p>在一台主机上运行的进程为了向在另一台主机上运行的进程发送分组，接收进程需要有一个地址。为了标识该接收进程，需要定义两种信息： ①主机的地址； ②在目的主机中指定接收进程的标识符。</p>
<p>主机由其 <strong>IP 地址</strong>(IP address) 标识。</p>
<p><strong>目的地端口号</strong>（port number)用于在目的主机中指定接收进程的标识符</p>
</li>
</ol>
<h3 id="213-可供应用程序使用的运输服务"><a class="markdownIt-Anchor" href="#213-可供应用程序使用的运输服务"></a> 2.1.3 可供应用程序使用的运输服务</h3>
<p>我们大体能够从四个方面对应用程序服务要求进行分类： <strong>可靠数据传输、 吞吐量、 定时和安全性</strong>。</p>
<h3 id="214-因特网提供的运输服务"><a class="markdownIt-Anchor" href="#214-因特网提供的运输服务"></a> 2.1.4 因特网提供的运输服务</h3>
<p>因特网 （ 更一般的是 TCP/IP 网络） 为应用程序提供两个运输层协议， 即 UDP 和 TCP。</p>
<ol>
<li>
<p><strong>TCP服务</strong></p>
<ul>
<li>面向连接: 客户机和服务器之间所需连接的建立</li>
<li>可靠传输：在发送和接收进程之间</li>
<li>流量控制: 发送方不会淹没接收方</li>
<li>拥塞控制:当网络过载时抑制发送方</li>
<li>并不提供: 定时，最小带宽保证</li>
</ul>
</li>
<li>
<p><strong>UDP服务</strong></p>
<p>在发送进程及接收进程之间的不可靠数据传输</p>
<p>不提供：建立连接，可靠性，流量控制，拥塞控制，定时或带宽保证</p>
</li>
</ol>
<p>为什么需要UDP：</p>
<blockquote>
<p>当应用程序<strong>对传输的可靠性要求不高</strong>，但是对<strong>传输速度和延迟要求较高</strong>时，可以用UDP协议来替代TCP协议在传输层控制数据的转发。</p>
<p>UDP适合于<strong>实时数据传输</strong>，如<strong>语音</strong>和<strong>视频通信</strong>，因为它们即使偶尔丢失一两个数据包，也不会对接收结果产生太大影响。例如：我们在看视频的时候偶尔丢一两个包也不影响体验。</p>
</blockquote>
<h3 id="215-应用层协议"><a class="markdownIt-Anchor" href="#215-应用层协议"></a> 2.1.5 应用层协议</h3>
<p><strong>应用层协议</strong> ( application- layer protocol ) 定义了运行在不同端系统上的应用程序进程如何相互传递报文</p>
<p>特别的，应用层协议定义了：</p>
<ul>
<li>交换的报文类型， 例如请求报文和响应报文。</li>
<li>各种报文类型的语法， 如报文中的各个字段及这些字段是如何描述的。</li>
<li>字段的语义， 即这些字段中的信息的含义。</li>
<li>确定一个进程何时以及如何发送报文，对报文进行响应的规则。</li>
</ul>
<h2 id="22-web和http"><a class="markdownIt-Anchor" href="#22-web和http"></a> 2.2 Web和HTTP</h2>
<h3 id="221-http概况"><a class="markdownIt-Anchor" href="#221-http概况"></a> 2.2.1 HTTP概况</h3>
<p>Web的应用层协议是<strong>超文本传输协议（HyperText Transfer Protocol，HTTP)</strong>, 它是 Web的核心。 HTTP 由两个程序实现： 一个客户程序和一个服务器程序。 客户程序和服务器程序运行在不同的端系统中， 通过交换HTTP 报文进行会话。 HTTP定义了这些报文的结构以及客户和服务器进行报文交换的方式。</p>
<p><strong>web术语：</strong></p>
<ul>
<li>
<p>Web页面由对象组成</p>
<ul>
<li>一个基本HTML文件</li>
<li>多个引用对象：图片，java小程序，视频文件</li>
</ul>
</li>
<li>
<p>每个对象可由URL寻址</p>
</li>
<li>
<p>URL( Uniform Resource Locator 统一资源定位符)的例子:</p>
</li>
</ul>
<p><img src="/posts/9d1d146e/image-20220402140838360.png" srcset="/img/loading.gif" lazyload alt="image-20220402140838360"></p>
<p><strong>HTTP使用TCP作为它的支撑运输协议:</strong></p>
<ul>
<li>客户机向服务器发起TCP连接(产生套接字) ，端口80</li>
<li>服务器从客户机接受TCP连接</li>
<li>在浏览器(HTTP客户机)和Web服务器(HTPP服务器)之间交换HTTP报文 (应用层协议报文)</li>
<li>关闭TCP连接</li>
</ul>
<p><strong>HTTP是“无状态的”：</strong></p>
<ul>
<li>服务器不保留有关客户机过去请求的任何信息</li>
<li>用户的状态信息由Cookies来实现</li>
</ul>
<h3 id="222-非持续连接和持续连接"><a class="markdownIt-Anchor" href="#222-非持续连接和持续连接"></a> 2.2.2 非持续连接和持续连接</h3>
<ol>
<li>
<p><strong>非持久HTTP</strong></p>
<p>每个HTTP请求/响应对经过一个单独TCP连接发送</p>
<p>HTTP/1.0使用非持久HTTP</p>
</li>
</ol>
<ul>
<li>
<p><strong>往返时间RTT的定义:</strong> 从客户机到服务器发送一个小分组并返回所历经的时间.</p>
</li>
<li>
<p><strong>响应时间(1个HTML文件):</strong></p>
<ul>
<li>建立TCP连接：1个RTT</li>
<li>对HTTP请求和响应返回的前几个字节：1个RTT</li>
<li>文件传输时间</li>
</ul>
</li>
<li>
<p><strong>总响应 = 2RTT+传输时间</strong></p>
</li>
<li>
<p><strong>非持久HTTP缺点:</strong></p>
<ul>
<li>串行访问时间长，每一个对象经受两倍 RTT 的交付时延</li>
<li>并行访问资源占用多，必须为每一个请求的对象建立和维护一个全新的连接。</li>
</ul>
</li>
</ul>
<ol start="2">
<li>
<p><strong>持久HTTP</strong></p>
<p>多个对象能够经过客户机和服务器之间的单个TCP连接发送</p>
<p>HTTP/1.1以默认模式使用持久连接</p>
</li>
</ol>
<ul>
<li>
<p>在发送响应后，保持TCP连接持续打开</p>
</li>
<li>
<p>后继HTTP报文通过该连接持续发送</p>
</li>
</ul>
<h3 id="223-http报文格式"><a class="markdownIt-Anchor" href="#223-http报文格式"></a> 2.2.3 HTTP报文格式</h3>
<p>HTTP报文有两种： <strong>请求报文和响应报文</strong>。</p>
<ol>
<li>
<p><strong>HTTP请求报文</strong></p>
<p><img src="/posts/9d1d146e/image-20220402142759631.png" srcset="/img/loading.gif" lazyload alt="image-20220402142759631"></p>
</li>
</ol>
<ul>
<li>
<p>通用格式：</p>
<p><strong>请求行</strong>（ request line )：第1行，方法字段，URL字段，HTTP 版本字段</p>
<ul>
<li>
<p>方法字段可以取几种不同的值， 包括 GET、 POST、 HEAD、 PUT 和 DELETE</p>
</li>
<li>
<p>方法类型：</p>
<ul>
<li>
<p>GET：最常用，请求访问网页，实体主体为空</p>
</li>
<li>
<p>POST：常用，提交表单同时请求访问网页，如使用搜索引擎，实体主体中为表单输入值</p>
</li>
<li>
<p>HEAD：少用，测试用，与GET区别在于响应中去掉请求的对象</p>
</li>
<li>
<p>PUT：很少用，向URL字段中定义的路径，上载在实体主体中文件</p>
</li>
<li>
<p>DELETE，很少用，删除在URL字段中定义的文件</p>
</li>
</ul>
</li>
</ul>
<p><strong>首部行</strong>（header line)：一般多行</p>
<ul>
<li>host:www.someschool.edu 指明了对象所在的主机</li>
<li>Connection: dose 首部行， 该浏览器告诉服务器不要麻烦地使用持续连接， 它要求服务器在发送完被请求的对象后就关闭这条连接</li>
<li>User-agent ：首部行用来指明用户代理，即向服务器发送请求的浏览器的类型。 因为服务器可以有效地为不同类型的用户代理实际发送相同对象的不同版本</li>
<li>Accept- language：首部行表示用户想得到该对象的法语版本</li>
</ul>
</li>
</ul>
<p><strong>实体主体</strong>：可为空</p>
<p><img src="/posts/9d1d146e/image-20220402142817548.png" srcset="/img/loading.gif" lazyload alt="image-20220402142817548"></p>
<ol>
<li>
<p><strong>HTTP响应报文</strong></p>
<p><img src="/posts/9d1d146e/image-20220402143506343.png" srcset="/img/loading.gif" lazyload alt="image-20220402143506343"></p>
</li>
</ol>
<ul>
<li>
<p>通用格式：</p>
<p>**状态行：**第1行，版本字段，状态码字段，短语字段</p>
<ul>
<li>一些常见的状态码和相关的短语包括：
<ul>
<li>200 0K： 请求成功， 信息在返回的响应报文中。</li>
<li>301 Moved Permanently： 请求的对象已经被永久转移了， 新的 URL 定义在响应报文的 Location: 首部行中。 客户软件将自动获取新的 URL。</li>
<li>400 Bad Request： 一个通用差错代码， 指示该请求不能被服务器理解。</li>
<li>404 Not Found： 被请求的文档不在服务器上。</li>
<li>505 HTTP Version Not Supported： 服务器不支持请求报文使用的 HTTP 协议版本</li>
</ul>
</li>
</ul>
<p>**首部行：**一般多行</p>
<ul>
<li>服务器用 Cmmection: dose 首部行告诉客户， 发送完报文后将关闭该 TCP 连接。</li>
<li>Date： 首部行指示服务器产生并发送该响应报文的日期和时间。 值得提的是， 这个时间不是指对象创建或者最后修改的时间， 而是服务器从它的文件系统中检索到该对象， 将该对象插入响应报文， 并发送该响应报文的时间。</li>
<li>Server： 首部行指示该报文是由一台 Apache Web 服务器产生的， 它类似于 HTTP 请求报文中的 User- agent: 首部行。</li>
<li>Last- Modified ： 首部行指示了对象创建或者最后修改的日期和时间。 Last- Modified ：首部行对既可能在本地客户也可能在网络缓存服务器上的对象缓存来说非常重要。 我们将很快详细地讨论缓存服务器 （ 也叫代理服务器）。</li>
<li>Content-Length： 首部行指示了被发送对象中的字节数。</li>
<li>Content- Type： 首部行指示了实体体中的对象是 HTML 文本。</li>
</ul>
<p>**实体主体：**报文的主体</p>
</li>
</ul>
<p><img src="/posts/9d1d146e/image-20220402143709761.png" srcset="/img/loading.gif" lazyload alt="image-20220402143709761"></p>
<h3 id="224-用户与服务器的交互cookie"><a class="markdownIt-Anchor" href="#224-用户与服务器的交互cookie"></a> 2.2.4 用户与服务器的交互：cookie</h3>
<p>cookie 技术有4个组件：</p>
<ul>
<li>
<p>①在 HTTP 响应报文中的一个 cookie 首部行；</p>
</li>
<li>
<p>②在 HTTP 请求报文中的一个 cookie 首部行；</p>
</li>
<li>
<p>③在用户端系统中保留有一个 cookie 文件， 并由用户的浏览器进行管理；</p>
</li>
<li>
<p>④位于Web站点的一个后端数据库。</p>
</li>
</ul>
<p><img src="/posts/9d1d146e/image-20220402145130143.png" srcset="/img/loading.gif" lazyload alt="image-20220402145130143"></p>
<h3 id="225-web缓存"><a class="markdownIt-Anchor" href="#225-web缓存"></a> 2.2.5 Web缓存</h3>
<p>Web 缓存器（ Web cache) 也叫<strong>代理服务器（ proxy server)</strong>， 它是能够代表初始 Web 服务器来满足 HTTP 请求的网络实体。</p>
<ul>
<li>对象在缓存中：缓存返回对象</li>
<li>否则缓存向起始服务器请求对象，然后向客户机返回对象</li>
</ul>
<p>好处：</p>
<ul>
<li>
<p>1）减小客户机请求的响应时间；</p>
</li>
<li>
<p>2）减少机构内部网与因特网接入链路的通信量</p>
</li>
</ul>
<h3 id="226-条件get方法"><a class="markdownIt-Anchor" href="#226-条件get方法"></a> 2.2.6 条件GET方法</h3>
<p>HTTP 协议有一种机制， 允许缓存器证实它的对象是最新的。 这种机制就是<strong>条件 GET ( conditional GET) 方法</strong>。 如果：</p>
<p>①请求报文使用 GET方法；</p>
<p>②请求报文中包含一个 “ If- Modified - Since:” 首部行。 那么， 这个 HTTP 请求报文就是一个条件 GET 请求报文。</p>
<p>缓存器通过发送一个条件 GET 执行最新检查</p>
<p><img src="/posts/9d1d146e/image-20220424210534316.png" srcset="/img/loading.gif" lazyload alt="image-20220424210534316"></p>
<p>该条件 GET 报文告诉服务器， 仅当自指定日期之后该对象被修改过， 才发送该对象</p>
<h2 id="225-文件传输协议"><a class="markdownIt-Anchor" href="#225-文件传输协议"></a> 2.2.5 文件传输协议</h2>
<p>双TCP连接</p>
<ul>
<li>控制连接，端口21（http带内控制，ftp带外控制）</li>
<li>数据连接，端口20</li>
</ul>
<p>通过操作命令实现远程交互式访问</p>
<ul>
<li>登录，用户名，密码</li>
<li>浏览文件</li>
<li>选择文件，下载</li>
</ul>
<p>为什么要有两条连接：</p>
<blockquote>
<p>控制连接控制FTP命令</p>
<p>数据连接用于文件传送</p>
<p>两条连接使得FTP更加简单、更容易实现、更有效率。同时在文件传输过程中，还可以利用控制连接控制传输进程，如用户可以请求终止、暂停传输等</p>
</blockquote>
<h2 id="23-因特网中的电子邮件"><a class="markdownIt-Anchor" href="#23-因特网中的电子邮件"></a> 2.3 因特网中的电子邮件</h2>
<p>电子邮件系统3个主要组成部分： <strong>用户代理</strong> （ user agent)、 <strong>邮件服务器</strong> （ mail server) 和<strong>简单邮件传输协议</strong>（ Simple Mail Transfer Protocol, <strong>SMTP</strong>)。</p>
<h3 id="231-smtp"><a class="markdownIt-Anchor" href="#231-smtp"></a> 2.3.1 SMTP</h3>
<ul>
<li>
<p>SMTP是一个相对简单的基于文本的协议</p>
<p>报文必须以7比特ASCII格式</p>
<p>二进值文件可通过MIME编码后再传</p>
</li>
<li>
<p>SMTP服务器端使用端口号25</p>
</li>
<li>
<p>采用命令/响应交互</p>
<p>命令：HELO，MAIL FROM, RCPT TO, DATA, QUIT</p>
<p>响应：状态码及短语</p>
</li>
<li>
<p>传输的三个阶段</p>
<p>握手，传输，关闭</p>
</li>
</ul>
<p>SMTP交互示例：</p>
<p><img src="/posts/9d1d146e/image-20220402154034434.png" srcset="/img/loading.gif" lazyload alt="image-20220402154034434"></p>
<h3 id="232-与http的对比"><a class="markdownIt-Anchor" href="#232-与http的对比"></a> 2.3.2 与HTTP的对比</h3>
<p>共同特征：</p>
<p>持续的 HTTP 和 SMTP 都使用持续连接</p>
<p>区别：</p>
<ul>
<li>
<p>首先， HTTP 主要是一个拉协议 （ pull protocol ),即在方便的时候， 某些人在 Web 服务器上装载信息， 用户使用 HTTP 从该服务器拉取这些信息。 特别是 TCP 连接是由想接收文件的机器发起的。 另一方面， SMTP 基本上是一个推协议 ( push protocol) , 即发送邮件服务器把文件推向接收邮件服务器。 特别是， 这个 TCP连接是由要发送该文件的机器发起的。</p>
</li>
<li>
<p>第二个区别就是我们前面间接地提到过的， SMTP 要求每个报文（ 包括它们的体） 采用 7 比特 ASCII 码格式。 如果某报文包含了非 7 比特 ASCII 字符（ 如具有重音的法文字符） 或二进制数据 （ 如图形文件） ， 则该报文必须按照7 比特 ASCII 码进行编码。 HTTP 数据则不受这种限制。</p>
</li>
<li>
<p>第三个重要区别是如何处理一个既包含文本又包含图形 （ 也可能是其他媒体类型） 的文档。 如我们在 2. 2 节知道的那样， HTTP 把每个对象封装到它自己的 HTTP 响应报文中，而 SMTP 则把所有报文对象放在一个报文之中。</p>
</li>
</ul>
<h3 id="233-邮件报文格式"><a class="markdownIt-Anchor" href="#233-邮件报文格式"></a> 2.3.3 邮件报文格式</h3>
<p><img src="/posts/9d1d146e/image-20220402154441163.png" srcset="/img/loading.gif" lazyload alt="image-20220402154441163"></p>
<p><img src="/posts/9d1d146e/image-20220402154457074.png" srcset="/img/loading.gif" lazyload alt="image-20220402154457074"></p>
<h3 id="234-邮件访问协议"><a class="markdownIt-Anchor" href="#234-邮件访问协议"></a> 2.3.4 邮件访问协议</h3>
<p><img src="/posts/9d1d146e/image-20220402154724156.png" srcset="/img/loading.gif" lazyload alt="image-20220402154724156"></p>
<p>SMTP 用来将邮件从发送方的邮件服务器传输到接收方的邮件服务器； SMTP 也用来将邮件从发送方的用户代理传送到发送<br>
方的邮件服务器。 如 POP3 这样的邮件访问协议用来将邮件从接收方的邮件服务器传送到接收方的用户代理</p>
<p>邮件访问协议：从服务器获取邮件</p>
<ul>
<li>
<p>POP3: 邮局协议 （ Post Office Protocol ）</p>
<ul>
<li>授权 (代理 &lt;–&gt;服务器) 并下载</li>
</ul>
</li>
<li>
<p>IMAP4: 因特网邮件访问协议</p>
<ul>
<li>更多功能</li>
<li>操作存储在服务器上的报文</li>
</ul>
</li>
</ul>
<h2 id="24-dns因特网的目录服务"><a class="markdownIt-Anchor" href="#24-dns因特网的目录服务"></a> 2.4 DNS:因特网的目录服务</h2>
<p>域名系统( Domain Name System, DNS) 是：</p>
<ul>
<li>
<p>①一个由分层的 DNS 服务器 （ DNS) 实现的分布式数据库；</p>
</li>
<li>
<p>②一个使得主机能够査询分布式数据库的应用层协议。</p>
</li>
</ul>
<p>DNS 服务器通常是运行 BIND ( Berkeley Internet Name Domain ) 软件 [ BIND 2012 ] 的UNIX 机器。 <strong>DNS 协议运行在 UDP 之上， 使用 53 号端口。</strong></p>
<h3 id="241-dns提供的服务"><a class="markdownIt-Anchor" href="#241-dns提供的服务"></a> 2.4.1 DNS提供的服务</h3>
<ul>
<li>主机名到IP地址的转换</li>
<li>主机别名 ( host aliasing)</li>
<li>邮件服务器别名</li>
<li>负载分配（load distribution)</li>
</ul>
<h3 id="242-dns工作机理概述"><a class="markdownIt-Anchor" href="#242-dns工作机理概述"></a> 2.4.2 DNS工作机理概述</h3>
<ol>
<li>
<p>分布式、 层次数据库</p>
<p>为了处理扩展性问题， DNS 使用了大量的 DNS 服务器， 它们以层次方式组织， 并且分布在全世界范围内。 没有一台 DNS 服务器拥有因特网上所有主机的映射。 相反 ，这些映射分布在所有的 DNS 服务器上。</p>
<p>大致说来， 有 3 种类型的 DNS 服务器：</p>
<ul>
<li>根 DNS服务器</li>
<li>顶级域 （ Top- Level Domain， TLD) DNS 服务器</li>
<li>权威 DNS 服务器。</li>
</ul>
<p><img src="/posts/9d1d146e/image-20220402161351957.png" srcset="/img/loading.gif" lazyload alt="image-20220402161351957"></p>
<p>下图利用了<strong>递归查询</strong> （ recursive query ) 和<strong>迭代查询</strong> （ iterative query )。</p>
<p>从 <a target="_blank" rel="noopener" href="http://cse.nyu.edu">cse.nyu.edu</a> 到 <a target="_blank" rel="noopener" href="http://dns.nyu.edu">dns.nyu.edu</a> 发出的査询是递归査询， 因为该査询以自己的名义请求edu 来获得该映射。</p>
<p>而后继的 3 个査询是迭代査询， 因为所有的回答都是直接返回给 <a target="_blank" rel="noopener" href="http://dns.nyu.edu">dns.nyu.edu</a>。</p>
<p><img src="/posts/9d1d146e/image-20220402162935662.png" srcset="/img/loading.gif" lazyload alt="image-20220402162935662"></p>
<p><strong>递归查询</strong></p>
<p><img src="/posts/9d1d146e/image-20220402163041113.png" srcset="/img/loading.gif" lazyload alt="image-20220402163041113"></p>
</li>
<li>
<p>DNS缓存</p>
<p>为了改善时延性能并减少在因特网上到处传输的 DNS 报文数量，DNS 广泛使用了缓存技术。 DNS 缓存的原理非常简单。 在一个请求链中， 当某 DNS服务器接收一个 DNS 回答（ 例如， 包含某主机名到 IP 地址的映射） 时， 它能将映射缓存在本地存储器中。</p>
</li>
</ol>
<h3 id="243-dns记录和报文"><a class="markdownIt-Anchor" href="#243-dns记录和报文"></a> 2.4.3 DNS记录和报文</h3>
<p><img src="/posts/9d1d146e/image-20220402163520140.png" srcset="/img/loading.gif" lazyload alt="image-20220402163520140"></p>
<p>TTL 是该记录的生存时间， 它决定了资源记录应当从缓存中删除的时间。 在下面给出的记录例子中， 我们忽略掉 TTL 字段。 Name 和 Value 的值取决于 Type：</p>
<ul>
<li>如果 Type = A， 则 Name 是主机名， Value 是该主机名对应的 IP 地址。 因此， 一条类型为 A 的资源记录提供了标准的主机名到 IP 地址的映射。 例如 （ <a target="_blank" rel="noopener" href="http://relayl.bar.foo.com">relayl.bar.foo.com</a>, 145.37.93.126， A ) 就是一条类型 A 记录。</li>
<li>如果 Type = NS, 则 Name 是个域（ 如 <a target="_blank" rel="noopener" href="http://foo.com">foo.com</a>), 而 Value 是个知道如何获得该域中主机 IP 地址的权威 DNS 服务器的主机名。 这个记录用于沿着査询链来路由 DNS査询。 例如 （ <a target="_blank" rel="noopener" href="http://fbo.com">fbo.com</a>, <a target="_blank" rel="noopener" href="http://dns.foo.com">dns.foo.com</a>, NS) 就是一条类型为 NS 的记录。</li>
<li>如果 Type = CNAME， 则 Value 是别名为 Name 的主机对应的规范主机名。 该记录能够向査询的主机提供一个主机名对应的规范主机名， 例如（ <a target="_blank" rel="noopener" href="http://foo.com">foo.com</a>, <a target="_blank" rel="noopener" href="http://relay1.bar.foo.com">relay1.bar.foo.com</a>, CNAME) 就是一条 CNAME 类型的记录。</li>
<li>如果 Type = MX， 则 Value 是个别名为 Name 的邮件服务器的规范主机名。 举例来说， （ <a target="_blank" rel="noopener" href="http://foo.com">foo.com</a>，<a target="_blank" rel="noopener" href="http://mail.bar.foo.com">mail.bar.foo.com</a>, MX ) 就是一条 MX 记录。 MX 记录允许邮件服务器主机名具有简单的别名。 值得注意的是， 通过使用 MX 记录， 一个公司的邮件服务器和其他服务器（ 如它的 Web 服务器） 可以使用相同的别名。 为了获得邮件服务器的规范主机名， DNS 客户应当请求一条 MX 记录； 而为了获得其他服务器的规范主机名， DNS 客户应当请求 CNAME 记录。</li>
</ul>
<h1 id="第3章-运输层"><a class="markdownIt-Anchor" href="#第3章-运输层"></a> 第3章 运输层</h1>
<h2 id="31-概述和运输层服务"><a class="markdownIt-Anchor" href="#31-概述和运输层服务"></a> 3.1 概述和运输层服务</h2>
<p>运输层协议为运行在不同主机上的应用进程之间提供了<strong>逻辑通信 (logic conmmunication)</strong> 功能。</p>
<p>从应用程序的角度看， 通过逻辑通信， 运行不同进程的主机好像直接相连一样； 实际上， 这些主机也许位于地球的两侧， 通过很多路由器及多种不同类型的链路相连。</p>
<p>运输协议运行在<strong>端系统</strong>中</p>
<ul>
<li>
<p>发送方：在发送端， 运输层将从发送应用程序进程接收到的报文转换成运输层分组 ，传向网络层，网路层将其封装成网络层分组 （ 即数据报） 并向目的地发送。</p>
</li>
<li>
<p>接收方：在接收端， 网络层从数据报中提取运输层报文段， 并将该报文段向上交给运输层。 运输层则处理接收到的报文段， 使该报文段中的数据为接收应用进程使用。</p>
</li>
</ul>
<p>应用程序可供使用的运输协议不止一个</p>
<ul>
<li>因特网：TCP和UDP</li>
</ul>
<h3 id="311-运输层和网络层的关系"><a class="markdownIt-Anchor" href="#311-运输层和网络层的关系"></a> 3.1.1 运输层和网络层的关系</h3>
<p>网络层: 主机间的逻辑通信</p>
<p>运输层: 进程间的逻辑通信</p>
<h3 id="312-因特网运输层概述"><a class="markdownIt-Anchor" href="#312-因特网运输层概述"></a> 3.1.2 因特网运输层概述</h3>
<p>因特网网络层协议有一个名字叫 <strong>IP， 即网际协议</strong>。 IP为主机之间提供了逻辑通信。 IP 的服务模型是<strong>尽力而为交付服务</strong> （best- effort delivery service)。 这意味着 IP 尽它 “ 最大的努力” 在通信的主机之间交付报文段， 但它并不做任何确保。 特别是， 它不确保报文段的交付， 不保证报文段的按序交付， 不保证报文段中数据的完整性。 由于这些原因， IP 被称为<strong>不可靠服务</strong> （ unreliable service )</p>
<p>两种协议：</p>
<ul>
<li>
<p>一种是UDP ( 用户数据报协议），它为调用它的应用程序提供了一种不可靠、 无连接的服务。</p>
</li>
<li>
<p>另一种是 TCP ( 传输控制协议），它为调用它的应用程序提供了一种可靠的、 面向连接的服务。</p>
<ul>
<li>
<p>可靠数据传输</p>
<p>通过使用<strong>流量控制 、 序号 、 确认和定时器</strong>,TCP 确保正确地 、 按序地将数据从发送进程交付给接收进程。 这样， TCP 就将两个端系统间的不可靠 IP 服务转换成了一种进程间的<strong>可靠数据传输服务</strong></p>
</li>
<li>
<p>拥塞控制</p>
<p>TCP 拥塞控制防止任何一条TCP连接用过多流量来淹没通信主机之间的链路和交换设备。 TC力求为每个通过一条拥塞网络链路的连接平等地共享网络链路带宽。</p>
<p>通过调节 TCP 连接的发送端发送进网络的流量速率来做到</p>
</li>
</ul>
</li>
</ul>
<p>UDP 和 TCP 最基本的责任：</p>
<ul>
<li>将两个端系统间 IP 的交付服务扩展为运行在端系统上的两个进程之间的交付服务。 将主机间交付扩展到进程间交付被称为运输层的<strong>多路复用</strong>(transport-layer multiplexing) 与<strong>多路分解</strong>（demultiplexing)。</li>
</ul>
<h2 id="32-多路复用与多路分解"><a class="markdownIt-Anchor" href="#32-多路复用与多路分解"></a> 3.2 多路复用与多路分解</h2>
<p><strong>多路分解</strong> <strong>（ demultiplexing)。</strong></p>
<p>将运输层报文段中的数据交付到正确的套接字</p>
<p><strong>多路复用（ multiplexing)</strong></p>
<p>在源主机从不同套接字中收集数据块， 并为每个数据块封装上首部信息 （ 这将在以后用于分解） 从而生成报文段， 然后将报文段传递到网络层</p>
<p><img src="/posts/9d1d146e/image-20220405184918486.png" srcset="/img/loading.gif" lazyload alt="image-20220405184918486"></p>
<p>运输层多路复用要求：</p>
<ul>
<li>①套接字有唯一标识符;</li>
<li>②每个报文段有特殊字段来指示该报文段所要交付到的套接字。</li>
</ul>
<p>这些特殊字段是源端口号字段 （source port number field ) 和目的端口号字段（destination port number field)。</p>
<p><strong>端口号</strong>是一个 16 比特的数， 其大小在 0 ~ 65535 之间。 0 ~1023 范围的端口号称为周知端口号（ well- known port<br>
number), 是受限制的， 这是指它们保留给诸如 HTTP ( 它使用端口号 80) 和 FTP ( 它使用端口号 21) 之类的周知应用层协议来使用。</p>
<p><img src="/posts/9d1d146e/image-20220405185512467.png" srcset="/img/loading.gif" lazyload alt="image-20220405185512467"></p>
<ol>
<li>
<p><strong>无连接的多路复用与多路分解</strong></p>
<p>UDP套接字由二元组全面标识 :</p>
<p>(目的地IP地址, 目的地端口号)</p>
<p>当主机接收UDP段时:</p>
<ul>
<li>
<p>在段中检查目的地端口号</p>
</li>
<li>
<p>将UDP段定向到具有该端口号的套接字</p>
</li>
</ul>
<p>具有不同源IP地址和/或源端口号的IP数据报（目的IP地址和端口号相同）定向到相同的套接字</p>
</li>
<li>
<p><strong>面向连接的多路复用与多路分解</strong></p>
<p>TCP套接字由四元组（<strong>4-tuple</strong>）标识:</p>
<ul>
<li>
<p>源IP地址</p>
</li>
<li>
<p>源端口号</p>
</li>
<li>
<p>目的IP地址</p>
</li>
<li>
<p>目的端口号</p>
</li>
</ul>
<p>接收主机使用这四个值来将段定向到适当的套接字</p>
</li>
<li>
<p><strong>Web服务器与TCP</strong></p>
<p>服务器主机可能支持许多并行的TCP套接字：</p>
<ul>
<li>每个套接字由其自己的四元组标识</li>
</ul>
<p>Web服务器对每个连接的客户机具有不同的套接字</p>
<ul>
<li>非持久HTTP将为每个请求具有不同的套接字</li>
</ul>
</li>
</ol>
<h2 id="33-无连接运输udp"><a class="markdownIt-Anchor" href="#33-无连接运输udp"></a> 3.3 无连接运输：UDP</h2>
<p>“尽力而为”服务，UDP段可能：</p>
<ul>
<li>
<p>丢包</p>
</li>
<li>
<p>对应用程序交付失序</p>
</li>
</ul>
<p>无连接</p>
<ul>
<li>
<p>在UDP发送方和接收方之间无握手</p>
</li>
<li>
<p>每个UDP段的处理独立于其他段</p>
</li>
</ul>
<blockquote>
<p><strong>为何要有 UDP协议?</strong>（优点）</p>
</blockquote>
<ul>
<li>
<p>无连接创建(它将增加时延)</p>
</li>
<li>
<p>简单：在发送方、接收方无连接状态</p>
</li>
<li>
<p>段首部小</p>
</li>
<li>
<p>无拥塞控制: UDP能够尽可能快地传输</p>
</li>
</ul>
<p>常用于流媒体应用程序</p>
<ul>
<li>
<p>丢包容忍</p>
</li>
<li>
<p>速率敏感</p>
</li>
</ul>
<p>其他UDP应用</p>
<ul>
<li>
<p>DNS</p>
</li>
<li>
<p>SNMP</p>
</li>
</ul>
<p>当应用程序<strong>对传输的可靠性要求不高</strong>，但是对<strong>传输速度和延迟要求较高</strong>时，可以用UDP协议来替代TCP协议在传输层控制数据的转发。</p>
<p>UDP适合于<strong>实时数据传输</strong>，如<strong>语音</strong>和<strong>视频通信</strong>，因为它们即使偶尔丢失一两个数据包，也不会对接收结果产生太大影响。例如：我们在看视频的时候偶尔丢一两个包也不影响体验。</p>
<h3 id="331-udp报文段结构必考"><a class="markdownIt-Anchor" href="#331-udp报文段结构必考"></a> 3.3.1 UDP报文段结构（必考）</h3>
<p><img src="/posts/9d1d146e/image-20220405192624662.png" srcset="/img/loading.gif" lazyload alt="image-20220405192624662"></p>
<h3 id="332-udp检验和"><a class="markdownIt-Anchor" href="#332-udp检验和"></a> 3.3.2 UDP检验和</h3>
<p>UDP检验和提供了差错检测功能</p>
<p><img src="/posts/9d1d146e/image-20220405193257544.png" srcset="/img/loading.gif" lazyload alt="image-20220405193257544"></p>
<p>步骤：求和，回卷，求反</p>
<h2 id="34-可靠数据传输原理"><a class="markdownIt-Anchor" href="#34-可靠数据传输原理"></a> 3.4 可靠数据传输原理</h2>
<p><strong>可靠数据传输协议（ reliable data transfer protocol)</strong> 为上层实体提供的服务抽象是： 数据可以通过一条可靠的信道进行传输。 借助于可靠信道， 传输数据比特就不会受到损坏(由 0 变为 1， 或者相反） 或丢失， 而且所有数据都是按照其发送顺序进行交付。 这恰好就是 TCP 向调用它的因特网应用所提供的服务模型</p>
<h3 id="341-构造可靠数据传输协议"><a class="markdownIt-Anchor" href="#341-构造可靠数据传输协议"></a> 3.4.1 构造可靠数据传输协议</h3>
<p><img src="/posts/9d1d146e/image-20220426161000253.png" srcset="/img/loading.gif" lazyload alt="image-20220426161000253"></p>
<p>使用有限状态机 (FSM)来定义发送方和接收方</p>
<p><img src="/posts/9d1d146e/image-20220405205700680.png" srcset="/img/loading.gif" lazyload alt="image-20220405205700680"></p>
<h4 id="rdt10"><a class="markdownIt-Anchor" href="#rdt10"></a> rdt1.0</h4>
<p>经完全可靠信道的可靠数据传输</p>
<ul>
<li>
<p>无比特差错</p>
</li>
<li>
<p>无分组丢失</p>
</li>
</ul>
<p><img src="/posts/9d1d146e/image-20220405205611048.png" srcset="/img/loading.gif" lazyload alt="image-20220405205611048"></p>
<p>rdt 的发送端只通过 rdt_Send( data )事件接受来自较高层的数据， 产生一个包含该数据的分组（ 经由 make_pkt( data)动作） ， 并将分组发送到信道中。 实际上， rdtsemd(data)事件是由较高层应用的过程调用产生的（例如，rdt_send()).</p>
<p>在接收端， rdt 通过 rdt_rcv(packet)事件从底层信道接收一个分组， 从分组中取出数据(经由 extract( packet， data) 动作） ， 并将数据上传给较高层（通过deliver_data( data)动作.实际上， rdt_rcv( packet) 事件是由较低层协议的过程调用产生的（ 例如， rdt_rcv())</p>
<h4 id="rdt20"><a class="markdownIt-Anchor" href="#rdt20"></a> rdt2.0</h4>
<p>经具有比特差错信道的可靠数据传输</p>
<ul>
<li>
<p>有比特差错</p>
</li>
<li>
<p>无分组丢失</p>
</li>
</ul>
<p>数据出错后处理方式</p>
<ul>
<li>检错重传</li>
</ul>
<p>rdt2.0新增加机制（与rdt1.0比较）</p>
<p><strong>自动重传请求</strong>(Automatic Repeat reQuest, ARQ) 需要的另外三种协议功能来处理存在比特差错的情况：</p>
<ul>
<li>
<p>差错检错</p>
</li>
<li>
<p>反馈：ACK, NAK</p>
</li>
<li>
<p>重传</p>
</li>
</ul>
<p><img src="/posts/9d1d146e/image-20220405210230073.png" srcset="/img/loading.gif" lazyload alt="image-20220405210230073"></p>
<p>存在一个致命的缺陷</p>
<ul>
<li>没有考虑到 ACK 或 NAK 分组受损的可能性！</li>
</ul>
<h4 id="rdt21"><a class="markdownIt-Anchor" href="#rdt21"></a> rdt2.1</h4>
<p>发送方:</p>
<ul>
<li>
<p>序号seq # 加入分组中</p>
</li>
<li>
<p>两个序号seq. #’s (0,1) 将够用. ( 为什么?  和前一状态区别即可)</p>
</li>
<li>
<p>必须检查是否收到的ACK/NAK受损</p>
</li>
<li>
<p>状态增加一倍</p>
</li>
<li>
<p>状态必须“记住”是否“当前的”分组具有0或1序号</p>
</li>
</ul>
<p>接收方:</p>
<ul>
<li>
<p>必须检查是否接收到的分组是冗余的</p>
<ul>
<li>状态指示是否0或1是所期待的分组序号seq #</li>
</ul>
</li>
<li>
<p>注意: 接收方不能知道是否它的最后的ACK/NAK在发送方已经接收OK</p>
</li>
</ul>
<p><img src="/posts/9d1d146e/image-20220405210352408.png" srcset="/img/loading.gif" lazyload alt="image-20220405210352408"></p>
<p><img src="/posts/9d1d146e/image-20220405210401019.png" srcset="/img/loading.gif" lazyload alt="image-20220405210401019"></p>
<h4 id="rdt22"><a class="markdownIt-Anchor" href="#rdt22"></a> rdt2.2</h4>
<p>一种无NAK的协议，仅使用ACK</p>
<p><img src="/posts/9d1d146e/image-20220405210551597.png" srcset="/img/loading.gif" lazyload alt="image-20220405210551597"></p>
<p><img src="/posts/9d1d146e/image-20220405210602624.png" srcset="/img/loading.gif" lazyload alt="image-20220405210602624"></p>
<h4 id="rdt30"><a class="markdownIt-Anchor" href="#rdt30"></a> rdt3.0</h4>
<p>经具有比特差错的丢包信道的可靠数据传输</p>
<ul>
<li>
<p>有比特差错</p>
</li>
<li>
<p>有分组丢失</p>
</li>
</ul>
<p>现有机制（检错、反馈、重传、序号）还不够</p>
<p>增加定时机制：发送方等待ACK一段“合理的”时间</p>
<ul>
<li>
<p>如在这段时间没有收到ACK则重传</p>
</li>
<li>
<p>如果分组(或ACK)只是延迟(没有丢失)，重传将是冗余的，但序号的使用已经处理了该情况</p>
</li>
</ul>
<p><img src="/posts/9d1d146e/image-20220405210728703.png" srcset="/img/loading.gif" lazyload alt="image-20220405210728703"></p>
<p>接收方仅参考</p>
<p><img src="/posts/9d1d146e/image-20220405210917731.png" srcset="/img/loading.gif" lazyload alt="image-20220405210917731"></p>
<p>分组序号在 0 和 1 之间交替， 因此 rdt3.0 有时被称为比特交替协议</p>
<p><img src="/posts/9d1d146e/image-20220405211003066.png" srcset="/img/loading.gif" lazyload alt="image-20220405211003066"></p>
<h3 id="342-流水线可靠数据传输协议"><a class="markdownIt-Anchor" href="#342-流水线可靠数据传输协议"></a> 3.4.2 流水线可靠数据传输协议</h3>
<p>rdt3.0 性能问题的核心在于它是一个停等协议。</p>
<p><img src="/posts/9d1d146e/image-20220405211042449.png" srcset="/img/loading.gif" lazyload alt="image-20220405211042449"></p>
<p>这种特殊的性能问题的一个简单解决方法是： 不以停等方式运行， 允许发送方发送多个分组而无须等待确认，即流水线技术</p>
<p>流水线技术对可靠数据传输协议可带来如下影响：</p>
<ul>
<li>必须增加序号范围， 因为每个输送中的分组（ 不计算重传的） 必须有一个唯一的序号， 而且也许有多个在输送中的未确认报文。</li>
<li>协议的发送方和接收方两端也许不得不缓存多个分组。 发送方最低限度应当能缓冲那些已发送但没有确认的分组。 如下面讨论的那样， 接收方或许也需要缓存那些已正确接收的分组。</li>
<li>所需序号范围和对缓冲的要求取决于数据传输协议如何处理丢失、 损坏及延时过大的分组。 解决流水线的差错恢复有两种基本方法是： 回退 N 步（ Go- Back- N，GBN ) 和选择重传（Selective Repeat，SR)</li>
</ul>
<p><img src="/posts/9d1d146e/image-20220405211102003.png" srcset="/img/loading.gif" lazyload alt="image-20220405211102003"></p>
<p><strong>Go-Back-N</strong>和<strong>选择重传</strong>都是滑动窗口协议</p>
<p>发送方和接收方都具有一定容量的缓冲区（即窗口），允许发送站连续发送多个帧而不需要等待应答</p>
<p><strong>发送窗口</strong>就是发送端允许连续发送的帧的序号表，发送端可以不等待应答而连续发送的最大帧数称为发送窗口的尺寸</p>
<p><strong>接收窗口</strong>是接收方允许接收的帧的序号表，凡落在接收窗口内的帧，接收方都必须处理，落在接收窗口外的帧被丢弃。接收方每次允许接收的帧数称为接收窗口的尺寸</p>
<h3 id="343-回退n步"><a class="markdownIt-Anchor" href="#343-回退n步"></a> 3.4.3 回退N步</h3>
<p>窗口长度为N是因为流量控制和</p>
<p><img src="/posts/9d1d146e/image-20220405212221066.png" srcset="/img/loading.gif" lazyload alt="image-20220405212221066"></p>
<p>简单来说：位于发送窗口内的分组才允许被发送，位于接收窗口内的分组才能被接收，关键是窗口如何滑动。</p>
<p><strong>特征：累计ACK，全部重传</strong></p>
<p>ACK(n): 确认所有的（包括序号n）的分组 - “累计ACK”</p>
<p>若超时，重传窗口中的未被确认的第一个分组n及所有更高序号的分组</p>
<p><img src="/posts/9d1d146e/image-20220405212405768.png" srcset="/img/loading.gif" lazyload alt="image-20220405212405768"></p>
<p><img src="/posts/9d1d146e/image-20220405212413785.png" srcset="/img/loading.gif" lazyload alt="image-20220405212413785"></p>
<p><img src="/posts/9d1d146e/image-20220405212429639.png" srcset="/img/loading.gif" lazyload alt="image-20220405212429639"></p>
<p>理解累计ACK和回退N个重传</p>
<p>发送方</p>
<ul>
<li>
<p>发送窗口滑动的条件：收到1个确认分组</p>
</li>
<li>
<p>超时重传时，回退N个重传，通常重传多个分组</p>
</li>
</ul>
<p>接收方</p>
<ul>
<li>接收窗口滑动的条件：收到期望序号的分组</li>
<li>累计ACK s：s为期望收到的下一分组序号</li>
<li>对失序分组的处理：丢弃，重发（已按序接收分组的）ACK</li>
</ul>
<p>优点：实现简单，效率高于停等协议，对缓冲区要求不高</p>
<p>Go-Back-N不足：（效率明显高于停等协议）但仍有<strong>不必要重传</strong>的问题</p>
<h3 id="344-选择重传"><a class="markdownIt-Anchor" href="#344-选择重传"></a> 3.4.4 选择重传</h3>
<p>选择重传优点：没有不必要重传的问题</p>
<p>缺点：实现较复杂，对缓冲区有较大要求，同时必须等待超时才会重传，效率相对有所损失</p>
<p><img src="/posts/9d1d146e/image-20220405213248022.png" srcset="/img/loading.gif" lazyload alt="image-20220405213248022"></p>
<p><img src="/posts/9d1d146e/image-20220405213311055.png" srcset="/img/loading.gif" lazyload alt="image-20220405213311055"></p>
<p><img src="/posts/9d1d146e/image-20220405213324206.png" srcset="/img/loading.gif" lazyload alt="image-20220405213324206"></p>
<table>
<thead>
<tr>
<th>机制</th>
<th>用途和说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>检验和</td>
<td>用于检测在一个传输分组中的比特错误。</td>
</tr>
<tr>
<td>定时器</td>
<td>用于检测超时/重传一个分组，可能因为该分组（或其ACK）在信道中丢失了。由于当一个分组被时延但未丢失（过早超时），或当一个分组已被接收方收到但从接收方到发送方的ACK丢失时，可能产生超时事件，所以接收方可能会收到一个分组的多个冗余拷贝。</td>
</tr>
<tr>
<td>序号</td>
<td>用于为从发送方流向接收方的数据分组按顺序编号。所接收分组的序号间的空隙可使该接收方检测出丢失的分组。具有相同序号的分组可使接收方检测出一个分组的冗余拷贝。</td>
</tr>
<tr>
<td>确认</td>
<td>接收方用于告诉发送方一个分组或一组分组已被正确地接收到了。确认报文通常携带着被确认的分组或多个分组的序号。确认可以是逐个的或累积的，这取决于协议。</td>
</tr>
<tr>
<td>否定确认</td>
<td>接收方用于告诉发送方某个分组未被正确地接收。否定确认报文通常携带着未被正确接收的分组的序号。</td>
</tr>
<tr>
<td>窗口、流水线</td>
<td>发送方也许被限制仅发送那些序号落在一个指定范围内的分组。通过允许一次发送多个分组但未被确认，发送方的利用率可在停等操作模式的基础上得到增加。我们很快将会看到，窗口长度可根据接收方接收和缓存报文的能力或网络中的拥塞程度，或两者情况来进行设置。</td>
</tr>
</tbody>
</table>
<h2 id="35-面向连接的运输tcp"><a class="markdownIt-Anchor" href="#35-面向连接的运输tcp"></a> 3.5 面向连接的运输：TCP</h2>
<p>为了提供可靠数据传输， TCP 依赖于前一节所讨论的许多基本原理， 其中包括差错检测、 重传、 累积确认、 定时器以及用于序号和确认号的首部字段。</p>
<h3 id="351-tcp连接"><a class="markdownIt-Anchor" href="#351-tcp连接"></a> 3.5.1 TCP连接</h3>
<p><strong>端到端:</strong></p>
<ul>
<li>
<p>一个发送方, 一个接收方</p>
</li>
<li>
<p>连接状态与端系统有关，不为路由器所知</p>
</li>
</ul>
<p><strong>可靠、有序的字节流</strong></p>
<p><strong>流水线</strong>:</p>
<ul>
<li>TCP拥塞和流量控制设置滑动窗口协议</li>
</ul>
<p><strong>发送和接收缓冲区</strong></p>
<p><strong>全双工数据:</strong></p>
<ul>
<li>
<p>同一连接上的双向数据流</p>
</li>
<li>
<p>MSS: 最大报文段长度（设置该 MSS 要保证一个 TCP报文段（ 当封装在一个 1P 数据报中） 加上 TCP/IP 首部长度 （ 通常 40 字节） 将适合单个链路层帧）</p>
</li>
<li>
<p>MTU: 最大传输单元（链路层）</p>
</li>
</ul>
<p><strong>面向连接:</strong></p>
<ul>
<li>在进行数据交换前，初始化发送方与接收方状态，进行握手(交换控制信息),</li>
</ul>
<p><strong>流量控制:</strong></p>
<ul>
<li>发送方不能淹没接收方</li>
</ul>
<p><strong>拥塞控制</strong>:</p>
<ul>
<li>抑止发送方速率来防止过分占用网络资源</li>
</ul>
<h3 id="352-tcp报文段结构必考"><a class="markdownIt-Anchor" href="#352-tcp报文段结构必考"></a> 3.5.2 TCP报文段结构(必考)</h3>
<p>TCP 报文段由<strong>首部字段</strong>和一个<strong>数据字段</strong>组成。 数据字段包含一块应用数据。 如前所述， MSS 限制了报文段数据字段的最大长度。</p>
<p><img src="/posts/9d1d146e/image-20220407104835276.png" srcset="/img/loading.gif" lazyload alt="image-20220407104835276"></p>
<p>首部包括：</p>
<ul>
<li><strong>源端口号和目的端口号</strong>， 它被用于多路复用/分解来自或送到上层应用的数据。</li>
<li><strong>32比特的序号字段</strong> （ sequence number field ) 和 <strong>32 比特的确认号字段</strong> （ acknowledgment number field )。 这些字段被 TCP 发送方和接收方用来实现可靠数据传输服务， 讨论见后。</li>
<li><strong>16比特的接收窗口字段</strong>（ receive window field )， 该字段用于流量控制。 我们很快就会看到， 该字段用于指示接收方愿意接受的字节数量。</li>
<li><strong>4比特的首部长度字段</strong> ( header length field ), 该字段指示了以 32 比特的字为单位的 TCP 首部长度。 由于 TCP 选项字段的原因， TCP 首部的长度是可变的。 （ 通常，选项字段为空， 所以 TCP 首部的典型长度是 20 字节。）</li>
<li><strong>可选与变长的选项字段</strong>（ options field ) , 该字段用于发送方与接收方协商最大报文段长度（ MSS) 时， 或在高速网络环境下用作窗口调节因子时使用。 首部字段中还定义了一个时间戳选项。 可参见 RFC 854 和 RFC 1323 了解其他细节。</li>
<li><strong>6 比特的标志字段</strong>（ flag field )。
<ul>
<li>ACK比特用于指示确认字段中的值是有效的， 即该报文段包括一个对已被成功接收报文段的确认。</li>
<li>RST、SYN 和 FIN 比特用于连接建立和拆除。</li>
<li>在明确拥塞通告中使用了 CWR 和ECE 比特， 如 3. 7. 2 节中讨论的那样。</li>
<li>当 PSH 比特被置位时， 就指示接收方应立即将数据交给上层。</li>
<li>URG 比特用来指示报文段里存在着被发送端的上层实体置为 “ 紧急” 的数据。 紧急数据的最后一个字节由 16 比特的紧急数据指针字段( urgent data pointer field ) 指出。 当紧急数据存在并给出指向紧急数据尾指针的时候， TCP 必须通知接收端的上层实体（在实践中， PSH、 URG 和紧急数据指针并没有使用）</li>
</ul>
</li>
</ul>
<p><strong>序号和确认号</strong></p>
<p><strong>序号:</strong></p>
<ul>
<li>报文段中第1个数据字节在字节流中的位置编号</li>
</ul>
<p><strong>确认号</strong>:</p>
<ul>
<li>
<p>期望从对方收到下一个字节的序号</p>
</li>
<li>
<p>累计应答</p>
</li>
</ul>
<p>例子：</p>
<p><img src="/posts/9d1d146e/image-20220407111203087.png" srcset="/img/loading.gif" lazyload alt="image-20220407111203087"></p>
<h3 id="353-往返时间的估计与超时"><a class="markdownIt-Anchor" href="#353-往返时间的估计与超时"></a> 3.5.3 往返时间的估计与超时</h3>
<p>问题: 如何设置TCP 超时值?</p>
<p>应大于RTT</p>
<ul>
<li>但RTT是变化的</li>
</ul>
<p>太短: 过早超时</p>
<ul>
<li>不必要的重传</li>
</ul>
<p>太长: 对报文段的丢失响应太慢，导致数据传输时延大</p>
<p>1.<strong>估计往返时间</strong></p>
<p><strong>SampleRTT</strong>: 从发送报文段到接收到ACK的测量时间</p>
<ul>
<li>大多数 TCP的实现仅在某个时刻做一次 SampleRTT 测量， 而不是为每个发送的报文段测量一个 SampleRTT。 这就是说， 在任意时刻， 仅为一个已发送的但目前尚未被确认的报文段估计 SampleRTT， 从而产生一个接近每个 RTT 的新 SampleRTT 值。</li>
</ul>
<p><strong>EstimatedRTT</strong>：TCP 维持的一个 SampleRTT 均值。一旦获得一个新SampleRTT 时，TCP 就会根据下列公式来更新EstimatedRTT</p>
<p><img src="/posts/9d1d146e/image-20220407130626339.png" srcset="/img/loading.gif" lazyload alt="image-20220407130626339"></p>
<p>α推荐值为0.125</p>
<p><strong>DevRTT</strong>：RTT 偏差，用于估算 SampleRTT 一般会偏离 EstimatedRTT 的程度：</p>
<p><img src="/posts/9d1d146e/image-20220407130742411.png" srcset="/img/loading.gif" lazyload alt="image-20220407130742411"></p>
<p>β的推荐值为 0.25</p>
<p><strong>2.设置和管理重传超时间隔</strong></p>
<p>超时间隔设为 EstimatedRTT 加上一定余量。 当SampleRTT 值波动较大时， 这个余量应该大些； 当波动较小时， 这个余量应该小些</p>
<p><img src="/posts/9d1d146e/image-20220407131057903.png" srcset="/img/loading.gif" lazyload alt="image-20220407131057903"></p>
<h3 id="354-可靠数据传输"><a class="markdownIt-Anchor" href="#354-可靠数据传输"></a> 3.5.4 可靠数据传输</h3>
<p>TCP在IP 不可靠的尽力而为服务之上创建了一种<strong>可靠数据传输服务</strong>（ reliable data transfer service).TCP 的可靠数据传输服务确保一个进程从其接收缓存中读出的数据流是无损坏、 无间隙 、 非冗余和按序的数据流；</p>
<p>TCP 发送方有3个与发送和重传有关的主要事件：</p>
<ul>
<li>
<p>从上层应用程序接收数据</p>
<p>一旦第一个主要事件发生， TCP 从应用程序接收数据， 将数据封装在一个报文段中， 并把该报文段交给 IP。 注意到每一个报文段都包含一个序号， 如 3.5.2 节所讲的那样， 这个序号就是该报文段第一个数据字节的字节流编号。 还要注意到如果定时器还没有为某些其他报文段而运行， 则当报文段被传给 IP 时， TCP 就启动该定时器。</p>
</li>
<li>
<p>定时器超时</p>
<p>TCP 通过重传引起超时的报文段来响应超时事件。 然后 TCP重启定时器</p>
</li>
<li>
<p>收到 ACK</p>
<p>到达一个来自接收方的确认报文段（ ACK)( 更确切地说， 是一个包含了有效 ACK 字段值的报文段）。 当该事件发生时， TCP 将 ACK 的值:K 与它的变量 SendBase 进行比较。 TCP 状态变量 SendBase 是最早未被确认的字节的序号。<br>
(因此 SendBase-1 是指接收方已正确按序接收到的数据的最后一个字节的序号如前面指出的那样， TCP 采用累积确认， 所以y 确认了字节编号在y之前的所有字节都已经收到。 如果 y&gt;SendBase, 则该 ACK 是在确认一个或多个先前未被确认的报文段。 因此发送方更新它的 SendBase 变量； 如果当前有未被确认的报文段， TCP 还要重新启动定时器。</p>
</li>
</ul>
<p><img src="/posts/9d1d146e/image-20220407131912762.png" srcset="/img/loading.gif" lazyload alt="image-20220407131912762"></p>
<p><strong>2.超时间隔加倍</strong></p>
<p>每次 TCP 重传时都会将下一次的超时间隔设时间&amp;为先前值的两倍， 而不是用从 EstimaledRTT和 DevRTT 推算岀的值（ 如在 3.5.3 节中所描述的）。</p>
<p>然而， 每当定时器在另两个事件（ 即收到上层应用的数据和收到 ACK) 中的任意一个启动时， Timeoutlnterval 由最近的 EstimatedRTT 值与 DevRTT 值推算得到。</p>
<p><strong>3.快速重传</strong></p>
<p>超时间隔常常相对较长:</p>
<ul>
<li>重传丢失报文段以前有长时延</li>
</ul>
<p>通过冗余ACK，检测丢失的报文段</p>
<ul>
<li>
<p>发送方经常一个接一个的发送报文段</p>
</li>
<li>
<p>如果报文段丢失，将会收到很多重复ACK</p>
</li>
<li>
<p>如果对相同数据，发送方收到3个ACK, 假定被确认的报文段以后的报文段丢失了:</p>
</li>
</ul>
<p><strong>快速重传</strong>: 在定时器超时之前重传</p>
<p><img src="/posts/9d1d146e/image-20220407133650972.png" srcset="/img/loading.gif" lazyload alt="image-20220407133650972"></p>
<p><img src="/posts/9d1d146e/image-20220407133823612.png" srcset="/img/loading.gif" lazyload alt="image-20220407133823612"></p>
<p><strong>TCP 的差错恢复机制也许最好被分类为GBN协议与SR协议的混合体</strong></p>
<p>既不会回退N步，而是至多重传一个报文段</p>
<p>也不会等待超时间隔到达才重传，而是快速重传，收到失序报文段时，接收方会不断发送冗余ACK，达到一定数量发送方就会重传该报文段</p>
<h3 id="355-流量控制"><a class="markdownIt-Anchor" href="#355-流量控制"></a> 3.5.5 流量控制</h3>
<p>TCP 为它的应用程序提供了流量控制服务（ flow- control service ) 以<strong>消除发送方使接收方缓存溢出的可能性</strong>。 流量控制因此是一个速度匹配服务， 即发送方的发送速率与接收方应用程序的读取速率相匹配。</p>
<blockquote>
<p>和拥塞控制的区别：</p>
<p>TCP 发送方也可能因为 <strong>IP 网络的拥塞而被遏制</strong>；</p>
<p>这种形式的发送方的控制被称为拥塞控制 （ congestion control )，</p>
</blockquote>
<p>TCP 通过让发送方维护一个称为接收窗口（ receive window ) 的变量来提供流量控制。通俗地说， 接收窗口用于给发送方一个指示—该接收方还有多少可用的缓存空间。</p>
<p><img src="/posts/9d1d146e/image-20220407134154976.png" srcset="/img/loading.gif" lazyload alt="image-20220407134154976"></p>
<p><img src="/posts/9d1d146e/image-20220407134210923.png" srcset="/img/loading.gif" lazyload alt="image-20220407134210923"></p>
<p>主机 A 在该连接的整个生命周期须保证：<br>
LastByteSent - LastByteAcked ≤ rwnd</p>
<h3 id="356-tcp连接管理"><a class="markdownIt-Anchor" href="#356-tcp连接管理"></a> 3.5.6 TCP连接管理</h3>
<p><a target="_blank" rel="noopener" href="https://www.eet-china.com/mp/a44399.html">关于三次握手和四次回收一个很好的解释</a></p>
<p>TCP是面向连接的协议，TCP连接的建立和释放是每次TCP传输中必不可少的过程。</p>
<p>TCP的传输连接包括三个状态</p>
<ul>
<li>
<p>连接建立</p>
</li>
<li>
<p>数据传输</p>
</li>
<li>
<p>连接释放</p>
</li>
</ul>
<p><img src="/posts/9d1d146e/image-20220407134812668.png" srcset="/img/loading.gif" lazyload alt="image-20220407134812668"></p>
<p><strong>建立连接(三次握手）：</strong></p>
<ul>
<li>第一步： 客户端的 TCP 首先向服务器端的 TCP 发送一个特殊的 TCP 报文段。 该报文段中不包含应用层数据。 但是在报文段的首部（ 参见图 3-29 ) 中的一个标志位( 即 SYN 比特） 被置为 1。 因此， 这个特殊报文段被称为 SYN 报文段。 另外， 客户会随机地选择一个初始序号（ client isn), 并将此编号放置于该起始的 TCP SYN报文段的序号字段中。 该报文段会被封装在一个 IP 数据报中， 并发送给服务器。为了避免某些安全性攻击， 在适当地随机化选择 client.isn 方面有着不少有趣的研究 [ CERT 2001-09]。</li>
<li>第二步： 一旦包含 TCP SYN 报文段的 IP 数据报到达服务器主机（ 假定它的确到达了！ ） ， 服务器会从该数据报中提取出 TCP SYN 报文段， 为该 TCP 连接分配 TCP 缓存和变量， 并向该客户 TCP 发送允许连接的报文段。 （ 我们将在第 8 章看到， 在完成三次握手的第三步之前分配这些缓存和变量， 使得 TCP 易于受到称为 SYN 洪泛的拒绝服务攻击。） 这个允许连接的报文段也不包含应用层数据。 但是， 在报文段的首部却包含 3 个重要的信息。 首先， SYN 比特被置为 1。 其次， 该 TCP 报文段首部的确认号字段被置为 Client_isn + 1。 最后， 服务器选择自己的初始序号(server_isn ) , 并将其放置到 TCP 报文段首部的序号字段中。 这个允许连接的报文段实际上表明了： “ 我收到了你发起建立连接的 SYN 分组， 该分组带有初始序号client_isn。 我同意建立该连接。 我自己的初始序号是 server_isn。 ” 该允许连接的报文段被称为 SYNACK 报文段（ SYNACK segment ).</li>
<li>第三步： 在收到 SYN ACK 报文段后， 客户也要给该连接分配缓存和变量。 客户主机则向服务器发送另外一个报文段； 这最后一个报文段对服务器的允许连接的报文段进行了确认（ 该客户通过将值 server.isn + 1 放置到 TCP 报文段首部的确认字段中来完成此项工作）。 因为连接已经建立了， 所以该 SYN 比特被置为 0。 该三次握手的第三个阶段可以在报文段负载中携带客户到服务器的数据。</li>
</ul>
<blockquote>
<h2 id="tcp协议请求建立连接时为什么要有三次握手第三次握手的作用是什么"><a class="markdownIt-Anchor" href="#tcp协议请求建立连接时为什么要有三次握手第三次握手的作用是什么"></a> TCP协议请求建立连接时，为什么要有三次握手，第三次握手的作用是什么？</h2>
<p>三次握手的主要作用就是为了确认双方的接收和发送能力是否正常，初始序列号，交换窗口大小以及 MSS 等信息。</p>
<p><img src="/posts/9d1d146e/image-20220413204733374.png" srcset="/img/loading.gif" lazyload alt="image-20220413204733374"></p>
<ul>
<li>第一次握手：客户端发送 <code>SYN</code> 报文，并进入 <code>SYN_SENT</code> 状态，等待服务器的确认；</li>
<li>第二次握手：服务器收到 <code>SYN</code> 报文，需要给客户端发送 <code>ACK</code> 确认报文，同时服务器也要向客户端发送一个 <code>SYN</code> 报文，所以也就是向客户端发送 <code>SYN + ACK</code> 报文，此时服务器进入 <code>SYN_RCVD</code> 状态；</li>
<li>第三次握手：客户端收到 <code>SYN + ACK</code> 报文，向服务器发送确认包，客户端进入 <code>ESTABLISHED</code> 状态。待服务器收到客户端发送的 <code>ACK</code> 包也会进入 <code>ESTABLISHED</code> 状态，完成三次握手。</li>
</ul>
<p>第三次握手的作用可以从以下四个方面来理解：</p>
<p><strong>（一）确认双方的收发能力</strong></p>
<p>TCP 建立连接之前，需要确认客户端与服务器双方的收包和发包的能力。</p>
<ol>
<li>
<p>第一次握手：客户端发送网络包，服务端收到了。这样服务端就能得出结论：客户端的发送能力、服务端的接收能力是正常的。</p>
</li>
<li>
<p>第二次握手：服务端发包，客户端收到了。这样客户端就能得出结论：服务端的接收、发送能力，客户端的接收、发送能力是正常的。不过此时服务器并不能确认客户端的接收能力是否正常。</p>
</li>
<li>
<p>第三次握手：客户端发包，服务端收到了。这样服务端就能得出结论：客户端的接收、发送能力正常，服务器自己的发送、接收能力也正常。所以，只有三次握手才能确认双方的接收与发送能力是否正常。</p>
</li>
</ol>
<p><strong>（二）序列号可靠同步</strong></p>
<p>如果是两次握手，服务端无法确定客户端是否已经接收到了自己发送的初始序列号，如果第二次握手报文丢失，那么客户端就无法知道服务端的初始序列号，那 TCP 的可靠性就无从谈起。</p>
<p><strong>（三）阻止重复历史连接的初始化</strong></p>
<p>客户端由于某种原因发送了两个不同序号的 <code>SYN</code> 包，我们知道网络环境是复杂的，旧的数据包有可能先到达服务器。如果是两次握手，服务器收到旧的 <code>SYN</code> 就会立刻建立连接，那么会造成网络异常。</p>
<p>如果是三次握手，服务器需要回复 <code>SYN+ACK</code> 包，客户端会对比应答的序号，如果发现是旧的报文，就会给服务器发 <code>RST</code> 报文，直到正常的 <code>SYN</code> 到达服务器后才正常建立连接。</p>
<p>所以三次握手才有足够的上下文信息来判断当前连接是否是历史连接。</p>
<p><strong>（四）安全问题</strong></p>
<p>我们知道 TCP 新建连接时，内核会为连接分配一系列的内存资源，如果采用两次握手，就建立连接，那会放大 DDOS 攻击。</p>
<p>TCP 作为一种可靠传输控制协议，其核心思想：既要保证数据可靠传输，又要提高传输的效率，而三次握手恰好可以满足以上两方面的需求！</p>
</blockquote>
<p><strong>数据传输：</strong></p>
<p>一旦完成这 3 个步骤， 客户和服务器主机就可以相互发送包括数据的报文段了。 在以后每一个报文段中， SYN 比特都将被置为 0。</p>
<p><strong>断开连接：</strong></p>
<p>客户应用进程发出一个关闭连接命令。 这会引起客户 TCP 向服务器进程发送一个特殊的 TCP 报文段。这个特殊的报文段让其首部中的一个标志位即 FIN 比特 （ 参见图 3-29 ) 被设置为1。</p>
<p>当服务器接收到该报文段后， 就向发送方回送一个确认报文段。 然后， 服务器发送它自己的终止报文段， 其 FIN 比特被置为 1。 最后， 该客户对这个服务器的终止报文段进行确认。 此时， 在两台主机上用于该连接的所有资源都被释放了</p>
<p><img src="/posts/9d1d146e/image-20220407135231102.png" srcset="/img/loading.gif" lazyload alt="image-20220407135231102"></p>
<p><img src="/posts/9d1d146e/image-20220407135318040.png" srcset="/img/loading.gif" lazyload alt="image-20220407135318040"></p>
<p><img src="/posts/9d1d146e/image-20220407135325658.png" srcset="/img/loading.gif" lazyload alt="image-20220407135325658"></p>
<blockquote>
<h2 id="3tcp协议释放连接时为什么要有四次挥手客户端向服务器发送ack为什么服务器能立即关闭客户端还要进行超时等待"><a class="markdownIt-Anchor" href="#3tcp协议释放连接时为什么要有四次挥手客户端向服务器发送ack为什么服务器能立即关闭客户端还要进行超时等待"></a> 3.TCP协议释放连接时，为什么要有四次挥手（客户端向服务器发送ACK），为什么服务器能立即关闭，客户端还要进行超时等待？</h2>
<p>四次挥手过程：</p>
<p><img src="/posts/9d1d146e/image-20220413204656848.png" srcset="/img/loading.gif" lazyload alt="image-20220413204656848"></p>
<ul>
<li>第一次挥手。客户端发起 <code>FIN</code> 包（FIN = 1）,客户端进入 <code>FIN_WAIT_1</code> 状态。TCP 规定，即使 <code>FIN</code> 包不携带数据，也要消耗一个序号。</li>
<li>第二次挥手。服务器端收到 <code>FIN</code> 包，发出确认包 <code>ACK</code>（ack = u + 1），并带上自己的序号 seq=v，服务器端进入了 <code>CLOSE_WAIT</code> 状态。这个时候客户端已经没有数据要发送了，不过服务器端有数据发送的话，客户端依然需要接收。客户端接收到服务器端发送的 <code>ACK</code> 后，进入了 <code>FIN_WAIT_2</code> 状态。</li>
<li>第三次挥手。服务器端数据发送完毕后，向客户端发送 <code>FIN</code> 包（seq=w ack=u+1），半连接状态下服务器可能又发送了一些数据，假设发送 seq 为 w。服务器此时进入了 <code>LAST_ACK</code> 状态。</li>
<li>第四次挥手。客户端收到服务器的 <code>FIN</code> 包后，发出确认包（ACK=1，ack=w+1），此时客户端就进入了 <code>TIME_WAIT</code> 状态。注意此时 TCP 连接还没有释放，必须经过 <code>2*MSL</code> 后，才进入 <code>CLOSED</code> 状态。而服务器端收到客户端的确认包 <code>ACK</code> 后就进入了 <code>CLOSED</code> 状态，可以看出服务器端结束 TCP 连接的时间要比客户端早一些。</li>
</ul>
<blockquote>
<p><strong>四次挥手原因：</strong></p>
</blockquote>
<p>其实在 TCP 握手的时候，接收端发送 <code>SYN+ACK</code> 的包是将一个 <code>ACK</code> 和一个 <code>SYN</code> 合并到一个包中，所以减少了一次包的发送，三次完成握手。</p>
<p>对于四次挥手，因为 TCP 是全双工通信，在主动关闭方发送 FIN 包后，接收端可能还要发送数据，不能立即关闭服务器端到客户端的数据通道，所以也就不能将服务器端的 <code>FIN</code> 包与对客户端的 <code>ACK</code> 包合并发送，只能先确认<code>ACK</code>，只有当服务器的所有报文发送完毕之后，才发送<code>FIN</code>报文断开连接，因此需要四次挥手。</p>
<blockquote>
<p><strong>服务器能立即关闭，客户端还要进行超时等待？</strong></p>
</blockquote>
<p>有两个原因</p>
<ol>
<li>
<p>确认服务器已经收到客户端发送的<code>ACK</code></p>
<p>客户端要超时等待2*<code>MSL</code>，<code>MSL</code> 指的是报文在网络中最大生存时间。在客户端发送对服务器端的 <code>FIN</code> 的确认包 <code>ACK</code> 后，这个 <code>ACK</code> 包是有可能不可达的，服务器端如果收不到 <code>ACK</code> 的话需要重新发送 <code>FIN</code> 包。</p>
<p>所以客户端发送 <code>ACK</code> 后需要留出 <code>2MSL</code> 时间（ACK 到达服务器 + 服务器发送 FIN 重传包，一来一回）等待确认服务器端确实收到了 ACK 包。</p>
<p>也就是说客户端如果等待 <code>2MSL</code> 时间也没有收到服务器端的重传包 <code>FIN</code>，说明可以确认服务器已经收到客户端发送的 <code>ACK</code>。</p>
</li>
<li>
<p>避免新旧连接混淆。</p>
</li>
</ol>
<p>​	在客户端发送完最后一个 <code>ACK</code> 报文段后，在经过 <code>2MSL</code> 时间，就可以使本连接持续的时间内所产生的所有报文都从网络中消失，使下一个新的连接不会出现这种旧的连接请求报文。</p>
<p>​	有些自作主张的路由器会缓存 IP 数据包，如果连接重用了，那么这些延迟收到的包就有可能会跟新连接混在一起。</p>
</blockquote>
<h2 id="36-拥塞控制原理"><a class="markdownIt-Anchor" href="#36-拥塞控制原理"></a> 3.6 拥塞控制原理</h2>
<h3 id="361-拥塞原因与代价"><a class="markdownIt-Anchor" href="#361-拥塞原因与代价"></a> 3.6.1 拥塞原因与代价</h3>
<ol>
<li>当分组的到达速率接近链路容量时， 分组经历<strong>巨大的排队时延</strong></li>
<li>发送方<strong>必须执行重传</strong>以补偿因为缓存溢出而丢弃（ 丢失） 的分组</li>
<li>发送方在遇到大时延时所进行的<strong>不必要重传</strong>会引起路由器利用其链路带宽来转发不必要的分组副本</li>
<li>当分组丢失时, 任何用于传输该分组的上游传输能力都被浪费!</li>
</ol>
<h3 id="362-拥塞控制方法"><a class="markdownIt-Anchor" href="#362-拥塞控制方法"></a> 3.6.2 拥塞控制方法</h3>
<ul>
<li>
<p>端到端拥塞控制</p>
<p>不能从网络得到明确的反馈</p>
<p>从端系统根据观察到的时延和丢失现象推断出拥塞</p>
<p>这是TCP所采用的方法</p>
<ul>
<li>TCP 报文段的丢失 （ 通过超时或 3 次冗余确认而得知） 被认为是网络拥塞的一个迹象， TCP会相应地减小其窗口长度。</li>
<li>我们还将看到关于 TCP 拥塞控制的一些最新建议， 即使用增加的往返时延值作为网络拥塞程度增加的指示。</li>
</ul>
</li>
<li>
<p>网络辅助的拥塞控制</p>
<p>拥塞信息从网络反馈到发送方通常有两种方式：</p>
<ul>
<li>
<p>直接反馈信息可以由网络路由器发给发送方。 这种方式的通知通常采用了一种阻塞<br>
分组 ( choke packet) 的形式（ 主要是说： “ 我拥塞了！ ” ）。</p>
</li>
<li>
<p>更为通用的第二种形式的通知是， 路由器标记或更新从发送方流向接收方的分组中的某个字段来指示拥塞的产生。 一旦收到一个标记的分组后， 接收方就会向发送方通知该网络拥塞指示。 注意到后一种形式的通知至少要经过一个完整的往返时间。</p>
</li>
</ul>
<p><img src="/posts/9d1d146e/image-20220426212443799.png" srcset="/img/loading.gif" lazyload alt="image-20220426212443799"></p>
<p>路由器为端系统提供反馈</p>
<ul>
<li>
<p>一个bit指示一条链路出现拥塞(SNA,DECnet,TCP/IP ECN, ATM)</p>
</li>
<li>
<p>指示发送方按照一定速率发送</p>
</li>
</ul>
</li>
</ul>
<h2 id="37-tcp-拥塞控制"><a class="markdownIt-Anchor" href="#37-tcp-拥塞控制"></a> 3.7 TCP 拥塞控制</h2>
<p>TCP 的拥塞控制是： 每个 RTT 内 cwnd 线性 （ 加性） 增加 1MSS， 然后出现 3 个冗余ACK 事件时 cwnd 减半 （ 乘性减）。 因此， TCP 拥塞控制常常被称为<strong>加性增、 乘性减</strong>( Additive- Increase, Multiplicative- Decrease, <strong>AIMD</strong>) 拥塞控制方式。</p>
<blockquote>
<p>一个 TCP 发送方如何限制它向其连接发送流量的速率呢？</p>
</blockquote>
<p>运行在发送方的 TCP 拥塞控制机制跟踪一个额外的变量， 即<strong>拥塞窗口</strong>( congestion window )拥塞窗口表示为 cwnd ， 它对一个 TCP 发送方能向网络中发送流量的速率进行了限制。 特别是， 在一个发送方中未被确认的数据量不会超过 cwnd 与 rwnd 中的最小值， 即</p>
<p><img src="/posts/9d1d146e/image-20220426213308758.png" srcset="/img/loading.gif" lazyload alt="image-20220426213308758"></p>
<p>发送方的发送速率大概是</p>
<p><img src="/posts/9d1d146e/image-20220426213345683.png" srcset="/img/loading.gif" lazyload alt="image-20220426213345683"></p>
<blockquote>
<p>第二， 一个 TCP 发送方如何感知从它到目的地之间的路径上存在拥塞呢？</p>
</blockquote>
<p>丢失事件 = 超时<em>或者</em> 3个重复ACK</p>
<p>发生丢失事件后，TCP发送方降低速率(拥塞窗口)</p>
<p>TCP 使用确认来触发（ 或计时） 增大它的拥塞窗口长度， TCP 被说成是自计时 （ self- docking) 的。</p>
<blockquote>
<p>第三， 当发送方感知到端到端的拥塞时， 采用何种算法来改变其发送速率呢？</p>
</blockquote>
<ol>
<li>
<p><strong>慢启动</strong></p>
<p>当一条 TCP 连接开始时， <strong>cwnd 的值通常初始置为一个 MSS</strong> 的较小值,这就使得初始发送速率大约为 MSS/RTT。 例如， 如果 MSS = 500 字节且 RTT = 200ms， 则得到的初始发送速率大约只有 20kbps。</p>
<p>发送方对每个确认报文段将拥塞窗口增加一个 MSS，这一过程每过一个 RTT， 发送速率就翻番。 因此， TCP发送速率起始慢， 但在慢启动阶段以指数增长</p>
<figure class="highlight c++"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++">cwnd=l MSS<br>ssthresh=<span class="hljs-number">64</span> KB<br>dupACKcount=<span class="hljs-number">0</span><br></code></pre></div></td></tr></table></figure>
<p>结束慢启动：</p>
<ul>
<li>
<p>第一种：</p>
<p>首先，如果存在一个由<strong>超时指示的丢包事件</strong>（即拥塞） ， TCP 发送方将 cwnd 设置为 1 并重新开始慢启动过程。 它还将第二个状态变量的值 ssthresh ( “ 慢启动阈值” 的速记）设置为 cwnd/2， 即当检测到拥塞时<strong>将 ssthresh 置为拥塞窗口值的一半</strong></p>
<figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c">ssthresh=cwnd/<span class="hljs-number">2</span><br>cwnd=l MSS<br>dupACKcount=<span class="hljs-number">0</span><br></code></pre></div></td></tr></table></figure>
</li>
<li>
<p>第二种：</p>
<p><strong>当 cwnd的值大于等于 ssthresh 时</strong>， 结束慢启动并且 TCP 转移到<strong>拥塞避免模式</strong></p>
</li>
<li>
<p>第三种：</p>
<p>如果<strong>检测到 3 个冗余 ACK</strong> ， 这时 TCP 执行一种快速重传并进人<strong>快速恢复状态</strong></p>
<figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c">ssthresh=cwnd/<span class="hljs-number">2</span><br>cwnd=ssthresh+<span class="hljs-number">3.</span>MSS<br></code></pre></div></td></tr></table></figure>
</li>
</ul>
</li>
<li>
<p><strong>拥塞避免</strong></p>
<p>一旦进入拥塞避免状态， cwnd 的值大约是上次遇到拥塞时的值的一半， 即距离拥塞可能并不遥远！ 因此， TCP 无法每过一个 RTT 再将 cwnd 的值翻番， 而是采用了一种较为保守的方法</p>
<p>超时后的保守机制：</p>
<p><strong>每个 RTT 只将 cwnd 的值增加一个 MSS（线性增长）</strong>。 这能够以几种方式完成。 一种通用的方法是对于 TCP 发送方无论何时到达一个新的确认， 就将 cwnd 增加一个MSS ( MSS/cwnd ) 字节。 例如， 如果 MSS 是 1460 字节并且 cwnd 是 14 600 字节， 则在一个 RTT 内发送 10 个报文段。 每个到达 ACK ( 假定每个报文段一个 ACK) 增加 1/10MSS的拥塞窗口长度， 因此在收到对所有 10 个报文段的确认后， 拥塞窗口的值将增加了一个 MSS</p>
<figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c">cwnd=cwnd+MSS•(MSS/cwnd)<br>dupACKcount=<span class="hljs-number">0</span><br></code></pre></div></td></tr></table></figure>
<p>结束线性增长：</p>
<ul>
<li>
<p>出现超时丢包</p>
<p>cwnd 的值被设置为 1 个 MSS， 当丢包事件出现时， ssthresh 的值被更新为 cwnd 值的一半。重新开始慢启动。</p>
<figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c">ssthresh=cwnd/<span class="hljs-number">2</span><br>cwnd=l MSS<br>dupACKcount=<span class="hljs-number">0</span><br></code></pre></div></td></tr></table></figure>
</li>
<li>
<p>三个连续的ACK</p>
<p>TCP 将 cwnd 的值减半（ 为使测量结果更好， 计及已收到的 3 个冗余的ACK 要加上 3 个 MSS), 并且当收到 3 个冗余的 ACK, 将 ssthresh 的值记录为 cwnd 的值的<br>
一半。</p>
<figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c">ssthresh=cwnd/<span class="hljs-number">2</span><br>cwnd=ssthresh+<span class="hljs-number">3</span>*MSS<br></code></pre></div></td></tr></table></figure>
</li>
</ul>
</li>
<li>
<p><strong>快速恢复</strong></p>
<p>在快速恢复中， 对于引起 TCP 进人快速恢复状态的缺失报文段， 对收到的每个冗余的ACK, cwnd 的值增加一个 MSS。</p>
<figure class="highlight ini"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs ini"><span class="hljs-attr">cwnd</span>=cwnd+MSS<br></code></pre></div></td></tr></table></figure>
<p>结束快速恢复：</p>
<ul>
<li>
<p>出现超时丢包</p>
<p>cwnd 的值被设置为 1 个 MSS， 当丢包事件出现时， ssthresh 的值被更新为 cwnd 值的一半。重新开始慢启动。</p>
<figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c">ssthresh=cwnd/<span class="hljs-number">2</span><br>cwnd=l MSS<br>dupACKcount=<span class="hljs-number">0</span><br></code></pre></div></td></tr></table></figure>
</li>
<li>
<p>当对丢失报文段的一个 ACK 到达时</p>
<p>TCP 在降低cwnd 后进入拥塞避免状态。</p>
<figure class="highlight c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c">cwnd=ssthresh<br>dupACKcount=<span class="hljs-number">0</span><br></code></pre></div></td></tr></table></figure>
</li>
</ul>
</li>
</ol>
<p><img src="/posts/9d1d146e/image-20220426214647713.png" srcset="/img/loading.gif" lazyload alt="image-20220426214647713"></p>
<h2 id="38-小结"><a class="markdownIt-Anchor" href="#38-小结"></a> 3.8 小结</h2>
<p>RAP 网络更新</p>
<p>RAP优点缺点</p>
<p>子网划分</p>
<p>计算IP地址分配</p>
<p>数据包切片</p>
<h1 id="第4章-网络层"><a class="markdownIt-Anchor" href="#第4章-网络层"></a> 第4章 网络层</h1>
<h2 id="41-网络层概述"><a class="markdownIt-Anchor" href="#41-网络层概述"></a> 4.1 网络层概述</h2>
<p>每台路由器的数据平面的主要作用是从其输入链路向其输岀链路转发数据报；</p>
<p>控制平面的主要作用是协调这些本地的每路由器转发动作， 使得数据报沿着源和目的地主机之间的路由器路径最终进行端到端传送。</p>
<p>网络层的作用：将分组从一台发送主机移动到一台接收主机。</p>
<h3 id="411-转发和路由选择数据平面和控制平面"><a class="markdownIt-Anchor" href="#411-转发和路由选择数据平面和控制平面"></a> 4.1.1 转发和路由选择：数据平面和控制平面</h3>
<p><strong>两种重要的网络层功能：</strong></p>
<ul>
<li>转发。 当一个分组到达某路由器的一条输入链路时， 该路由器必须将该分组移动到适当的输出链路。</li>
<li>路由选择。 当分组从发送方流向接收方时， 网络层必须决定这些分组所采用的路由或路径。 计算这些路径的算法被称为路由选择算法（ muting algorithm)</li>
</ul>
<p><img src="/posts/9d1d146e/image-20220603093830226.png" srcset="/img/loading.gif" lazyload alt="image-20220603093830226"></p>
<h3 id="412-网络服务模型"><a class="markdownIt-Anchor" href="#412-网络服务模型"></a> 4.1.2 网络服务模型</h3>
<p>网络服务模型 ( network service model ) 定义了分组在发送与接收端系统之间的端到端运输特性。</p>
<h2 id="42-虚电路和数据报网络"><a class="markdownIt-Anchor" href="#42-虚电路和数据报网络"></a> 4.2 虚电路和数据报网络</h2>
<p>网络层为接在网络上的主机所提供的服务可以有两大类</p>
<ul>
<li>
<p>无连接的网络服务（数据报服务）</p>
</li>
<li>
<p>面向连接的网络服务（虚电路服务）</p>
</li>
</ul>
<h3 id="421-虚电路"><a class="markdownIt-Anchor" href="#421-虚电路"></a> 4.2.1 虚电路</h3>
<p><img src="/posts/9d1d146e/image-20220613131928207.png" srcset="/img/loading.gif" lazyload alt="image-20220613131928207"></p>
<ul>
<li>数据传输前，需建立连接，一个连接被称为一条虚电路VC</li>
<li>虚电路由VC号来标识和区分</li>
<li>虚电路连接的状态需要维持（路径上的交换节点都参与）</li>
<li>虚电路连接涉及资源预留问题</li>
</ul>
<p><img src="/posts/9d1d146e/image-20220613132209227.png" srcset="/img/loading.gif" lazyload alt="image-20220613132209227"></p>
<p>虚电路的三个阶段</p>
<ul>
<li>虚电路建立（信令协议控制）</li>
<li>数据传输</li>
<li>虚电路拆除（信令协议控制）</li>
</ul>
<p><img src="/posts/9d1d146e/image-20220613132243130.png" srcset="/img/loading.gif" lazyload alt="image-20220613132243130"></p>
<h3 id="422-数据报网络"><a class="markdownIt-Anchor" href="#422-数据报网络"></a> 4.2.2 数据报网络</h3>
<ul>
<li>
<p>在网络层无呼叫建立</p>
</li>
<li>
<p>路由器：没有端到端连接的状态</p>
<ul>
<li>无网络级“连接”的概念</li>
</ul>
</li>
<li>
<p>分组使用目的主机地址转发</p>
<ul>
<li>在相同源和目的对可能采用不同的路径</li>
</ul>
</li>
</ul>
<p><img src="/posts/9d1d146e/image-20220613132414507.png" srcset="/img/loading.gif" lazyload alt="image-20220613132414507"></p>
<p><img src="/posts/9d1d146e/image-20220613132545397.png" srcset="/img/loading.gif" lazyload alt="image-20220613132545397"></p>
<h2 id="43-路由器构成"><a class="markdownIt-Anchor" href="#43-路由器构成"></a> 4.3 路由器构成</h2>
<p><strong>路由器的主要功能:</strong></p>
<ul>
<li>运行路由算法以得到转发表</li>
<li>根据转发表对IP分组进行转发</li>
<li>提供多种网络类型接口，完成不同网络的互联</li>
</ul>
<p>分组交换机是指一台通用分组交换设备， 它根据分组首部字段中的值， 从输入链路接口到输出链路接口转移分组。</p>
<ul>
<li>某些分组交换机称为<strong>链路层交换机</strong> ( link- layer switch )( 在第 6 章仔细学习） ， 基于链路层帧中的字段值做出转发决定， 这些交换机因此被称为链路层 （ 第 2 层） 设备。</li>
<li>其他分组交换机称为<strong>路由器</strong>（ router)， 基于网络层数据报中的首部字段值做出转发决定。 路由器因此是网络层（ 第 3 层） 设备。</li>
</ul>
<p><img src="/posts/9d1d146e/image-20220603100424629.png" srcset="/img/loading.gif" lazyload alt="image-20220603100424629"></p>
<ul>
<li>
<p><strong>输入端口</strong>。 输入端口（ input port ) 执行几项重要功能。</p>
<p><img src="/posts/9d1d146e/image-20220613132941437.png" srcset="/img/loading.gif" lazyload alt="image-20220613132941437"></p>
<ul>
<li>执行终结入物理链路的物理层功能， 这显示在图 4-4 中输入端口部分最左侧的方框与输出端口部分最右侧的方框中。</li>
<li>与位于入链路远端的数据链路层交互来执行数据链路层功能， 这显示在输入与输出端口部分中间的方框中。</li>
<li>执行查找功能， 这显示在输入端口最右侧的方框中。  通过査询转发表决定路由器的输出端口， 到达的分组通过路由器的交换结构转发到输出端口。</li>
</ul>
</li>
<li>
<p><strong>交换结构</strong>。 交换结构将路由器的输入端口连接到它的输出端口。 这种交换结构完全包含在路由器之中， 即它是一个网络路由器中的网络！</p>
</li>
<li>
<p><strong>输出端口</strong>。 输出端口存储从交换结构接收的分组， 并通过执行必要的链路层和物理层功能在输出链路上传输这些分组。 当一条链路是双向的时（ 即承载两个方向的流量） ， 输出端口通常与该链路的输入端口成对出现在同一线路卡上。</p>
<p><img src="/posts/9d1d146e/image-20220613132954585.png" srcset="/img/loading.gif" lazyload alt="image-20220613132954585"></p>
</li>
<li>
<p><strong>路由选择处理器</strong>。 路由选择处理器执行控制平面功能。 在传统的路由器中， 它执行路由选择协议（ 我们将在 5.3 节和 5.4 节学习） ， 维护路由选择表与关联链路状态信息， 并为该路由器计算转发表。 在 SDN 路由器中， 路由选择处理器（ 在其他活动中） 负责与远程控制器通信， 目的是接收由远程控制器计算的转发表项， 并在该路由器的输人端口安装这些表项。 路由选择处理器还执行网络管理功能， 我们将在5.7 节学习相关内容</p>
</li>
</ul>
<h3 id="431-输入端口处理和基于目的地转发"><a class="markdownIt-Anchor" href="#431-输入端口处理和基于目的地转发"></a> 4.3.1 输入端口处理和基于目的地转发</h3>
<p>输入端口的线路端接功能与链路层处理实现了用于各个输人链路的物理层和链路层。</p>
<p>在输入端口中执行的査找对于路由器运行是至关重要的,路由器使用转发表来查找输岀端口， 使得到达的分组能经过交换结构转发到该输出端口。</p>
<p><img src="/posts/9d1d146e/image-20220603102722618.png" srcset="/img/loading.gif" lazyload alt="image-20220603102722618"></p>
<p><img src="/posts/9d1d146e/image-20220603105048161.png" srcset="/img/loading.gif" lazyload alt="image-20220603105048161"></p>
<p>路由器用分组目的地址的前缀 ( prefix) 与该表中的表项进<br>
行匹配； 如果存在一个匹配项， 则路由器向与该匹配项相关联的链路转发分组。</p>
<p>当有多个匹配时， 该路由器使用<strong>D</strong> ( longest prefix matching rule)； 即在该表中寻找最长的匹配项， 并向与最长前缀匹配相关联的链路接口转发分组。</p>
<h3 id="432-交换"><a class="markdownIt-Anchor" href="#432-交换"></a> 4.3.2 交换</h3>
<p><img src="/posts/9d1d146e/image-20220603105411092.png" srcset="/img/loading.gif" lazyload alt="image-20220603105411092"></p>
<ul>
<li>
<p>经内存交换</p>
<ul>
<li>
<p>具有交换功能的传统计算机，在CPU的直接控制下</p>
</li>
<li>
<p>分组拷贝到系统的内存</p>
</li>
<li>
<p>速率受内存带宽限制(每数据报跨越两次总线)</p>
</li>
</ul>
</li>
<li>
<p>经总线交换</p>
<ul>
<li>
<p>数据报从输入端口到输出端口内存经一个共享的总线（总线芯片），总线速度快于内存读取速度</p>
</li>
<li>
<p>总线竞争: 任何时刻，总线仅能连通1个输入和1个输出，数据转发速率受总线带宽限制</p>
</li>
<li>
<p>1 Gbps总线, Cisco 1900: 用于接入和企业(非区域或主干)路由器的充足速率</p>
</li>
</ul>
</li>
<li>
<p>经互联网络的交换</p>
<ul>
<li>
<p>克服了总线带宽限制</p>
</li>
<li>
<p>Crossbar一般同时满足多个输入和输出连通</p>
</li>
<li>
<p>一般是路由交换机</p>
</li>
<li>
<p>Cisco 12000: 通过互联网络交换提供60Gbps</p>
</li>
</ul>
</li>
</ul>
<h3 id="433-输出端口处理"><a class="markdownIt-Anchor" href="#433-输出端口处理"></a> 4.3.3 输出端口处理</h3>
<p><img src="/posts/9d1d146e/image-20220603105748253.png" srcset="/img/loading.gif" lazyload alt="image-20220603105748253"></p>
<h2 id="44-网际协议ipv4-寻址-ipv6及其他"><a class="markdownIt-Anchor" href="#44-网际协议ipv4-寻址-ipv6及其他"></a> 4.4 网际协议：IPv4、寻址、IPv6及其他</h2>
<h3 id="441-ipv4数据报格式"><a class="markdownIt-Anchor" href="#441-ipv4数据报格式"></a> 4.4.1 IPv4数据报格式</h3>
<p><img src="/posts/9d1d146e/image-20220603110855556.png" srcset="/img/loading.gif" lazyload alt="image-20220603110855556"></p>
<ul>
<li>版 本（ 号）。 这 4 比特规定了数据报的 IP 协议版本。 通过査看版本号， 路由器能够确定如何解释 IP 数据报的剩余部分。 不同的 IP 版本使用不同的数据报格式。</li>
<li>首 部 长 度。 因为一个 IPv4 数据报可包含一些可变数量的选项（ 这些选项包括IPv4 数据报首部中） ， 故需要用这 4 比特来确定 IP 数据报中载荷（ 例如在这个数 据报中被封装的运输层报文段） 实际开始的地方。<strong>单位是4字节</strong>。 大多数 IP 数据报不包含选项，所以一般的 IP 数据报具有 20 字节的首部</li>
<li>服务类型。 服务类型（ TOS) 比特包含在 IPv4 首部中， 以便使不同类型的 IP 数据报 （ 例如， 一些特别要求低时延、 高吞吐量或可靠性的数据报） 能相互区别开来。 例如， 将实时数据报 （ 如用于 1P 电话应用） 与非实时流量 （如 FTP) 区分开也许是有用的。</li>
<li>数 据 报 长 度。 这是 IP 数据报的总长度（ 首部加上数据） ， <strong>单位是字节</strong>。 因为该字段长为 16 比特， 所以 IP数据报的理论最大长度为 65 535 字节。 然而， 数据报很少有超过 1500 字节的，该长度使得 IP 数据报能容纳最大长度以太网帧的载荷字段</li>
<li>标 识：占16位，是一个计数器，每产生一个数据报就加1，数据报分片时，每一个数据报片都复制一遍标识号。</li>
<li>标 志：占3位，最后一位MF=1是表示后面还有分片，MF=0时表示最后一个分片</li>
<li>片 偏 移。 以八个字节为偏移单位，除最后一个分片外，每个分片长度必须是8B的整数倍。</li>
<li>寿命。 寿命 ( Time- To- Uve , TTL ) 字段用来确保数据报不会永远 （ 如由于长时间的路由选择环路） 在网络中循环。 毎当一台路由器处理数据报时， 该字段的值减1。 若TTL字段减为0,则该数据报必须丢弃。</li>
<li>协议。 该字段通常仅当一个 IP 数据报到达其最终目的地时才会有用。 该字段值指示了 IP 数据报的数据部分应交给哪个特定的运输层协议。 例如， 值为 6 表明数据部分要交给 TCP, 而值为 17 表明数据要交给 UDP。</li>
<li>首部检验和。 首部检验和用于帮助路由器检测收到的 IP 数据报中的比特错误。 首部检验和是这样计算的： 将首部中的每 2 个字节当作一个数， 用反码算术对这些数求和。</li>
<li>源和目的 IP 地 址。 当某源生成一个数据报时， 它在源 IP 字段中插人它的 IP 地址， 在目的 IP 地址字段中插入其最终目的地的地址。 通常源主机通过 DNS 査找来决定目的地址</li>
<li>选 项。 选项字段允许 IP 首部被扩展。在 IPv6 首部中已去掉了 IP 选项</li>
<li>数据（ 有效载荷）。 我们来看看最后也是最重要的字段， 这是数据报存在的首要理由！ 在大多数情况下， IP 数据报中的数据字段包含要交付给目的地的运输层报文段（ TCP 或 UDP)。 然而， 该数据字段也可承载其他类型的数据， 如 ICMP 报文( 在 5.6 节中讨论）。</li>
</ul>
<h3 id="442-ipv4数据报分片"><a class="markdownIt-Anchor" href="#442-ipv4数据报分片"></a> 4.4.2 IPv4数据报分片</h3>
<p><img src="/posts/9d1d146e/image-20220605113500345.png" srcset="/img/loading.gif" lazyload alt="image-20220605113500345"></p>
<h3 id="443-ipv4编址"><a class="markdownIt-Anchor" href="#443-ipv4编址"></a> 4.4.3 IPv4编址</h3>
<p>互联这3个主机接口与 1 个路由器接口的网络形成一个子网</p>
<p>两级IP地址:</p>
<ul>
<li>
<p>子网部分，网络号，网络前缀(高阶比特)</p>
</li>
<li>
<p>主机部分，主机号(低阶比特)</p>
</li>
</ul>
<p>子网：</p>
<ul>
<li>
<p>IP地址具有相同的子网部分的设备接口（具有共同的IP地址前缀）</p>
</li>
<li>
<p>无需通过路由器就能够物理上互相到达</p>
</li>
</ul>
<p>IP 编址为这个子网分配一个地址 223.1.1.0/24, 其中的/24 记法， 有时称为<strong>子网掩码</strong>（ network mask ), 指示 32 比特中的最左侧 24 比特 定义了子网地址。 因此子网223.1.1.0/24 由 3 个主机接口（ 223.1.1.1 、 223.1.1.2和 223.1.1 . 3 ) 和 1 个 路 由 器 接 口(223.1.1.4 ) 组成。</p>
<p><img src="/posts/9d1d146e/image-20220605114842068.png" srcset="/img/loading.gif" lazyload alt="image-20220605114842068"></p>
<p><img src="/posts/9d1d146e/image-20220613134559429.png" srcset="/img/loading.gif" lazyload alt="image-20220613134559429"></p>
<p><img src="/posts/9d1d146e/image-20220613134813517.png" srcset="/img/loading.gif" lazyload alt="image-20220613134813517"></p>
<p>如何得到一个IP地址：</p>
<ol>
<li>
<p>获取一块地址</p>
<ul>
<li>从一个 ISP 获取一组地址</li>
<li>供 ISP 本身得到一块地址–一个全球性的权威机构:ICANN</li>
</ul>
</li>
<li>
<p>获取主机地址： 动态主机配置协议</p>
<p>DHCP 允许主机自动获取（ 被分配） 一个 IP 地址。 网络管理员能够配置 DHCP， 以使某给定主机每次与网络连接时能得到一个相同的 IP 地址， 或者某主机将被分配一个临时的 IP 地址（ temporary IP address)， 每次与网络连接时该地址也许是不同的。</p>
<p>除了主机 IP 地址分配外， DHCP 还允许一台主机得知其他信息， 例如它的子网掩码、 它的第一跳路由器地址 （ 常称为默认网关） 与它的本地DNS 服务器的地址。</p>
<p><strong>即插即用协议 （ plug-and- play protocol ) 或 零 配 置 （ zeroconf ) 协议</strong></p>
<p>DHCP 协议是一个 4 个步骤的过程</p>
<ul>
<li>
<p><strong>DHCP服务器发现</strong>： 0.0.0.0——&gt;255.255.255.255</p>
<p>一台新到达的主机的首要任务是发现一个要与其交互的 DHCP服务器。 这可通过使用 DHCP 发现报文 ( DHCP discover message) 来完成， 客户在UDP 分组中向端口 67 发送该发现报文。</p>
</li>
</ul>
</li>
</ol>
<p>DHCP 客户生成包含 DHCP 发现报文的IP 数据报， 其中使用广播目的地址 255.255. 255. 255 并且使用“ 本主机” 源 IP 地址0.0. 0.0。DHCP 客户将该 1P 数据报传递给链路层， 链路层然后将该帧广播到所有与该子网连接的节点。</p>
<ul>
<li>
<p><strong>DHCP服务器提供</strong>： a.b.c.d——&gt;255.255.255.255</p>
<p>DHCP 服务器收到一个 DHCP 发现报文时， 用 DHCP 提供报文 （ DHCP offer message) 向客户做出响应， 该报文向该子网的所有节点广播 ， 仍然使用 IP 广播地址 255.255.255.255</p>
</li>
<li>
<p><strong>DHCP请求</strong></p>
<p>新到达的客户从一个或多个服务器提供中选择一个， 并向选中的服务器提供用 DHCP 请求报文 （ DHCP request message ) 进行响应， 回显配置的参数</p>
</li>
<li>
<p><strong>DHCP ACK</strong></p>
<p>服务器用 DHCP ACK 报文 ( DHCP ACK message) 对 DHCP 请求报文进行响应， 证实所要求的参数</p>
</li>
</ul>
<p><img src="/posts/9d1d146e/image-20220605121832903.png" srcset="/img/loading.gif" lazyload alt="image-20220605121832903"></p>
<h3 id="444-网络地址转换nat"><a class="markdownIt-Anchor" href="#444-网络地址转换nat"></a> 4.4.4 网络地址转换NAT</h3>
<p>NAT技术（地址代理技术），提供内部私有地址与共有地址的转换，支持内网与公网的通信</p>
<p><img src="/posts/9d1d146e/image-20220605123503136.png" srcset="/img/loading.gif" lazyload alt="image-20220605123503136"></p>
<h3 id="455-互联网控制报文协议icmp"><a class="markdownIt-Anchor" href="#455-互联网控制报文协议icmp"></a> 4.5.5 互联网控制报文协议ICMP</h3>
<p>IP网络是尽力而为（不可靠）的，ICMP通过<strong>差错报文</strong>和<strong>询问报文</strong>来辅助IP网络的功能</p>
<p>与IP关系：</p>
<p>ICMP报文作为IP层数据报的数据，加上IP首部组成IP数据报发送出去。</p>
<p><img src="/posts/9d1d146e/image-20220613140250306.png" srcset="/img/loading.gif" lazyload alt="image-20220613140250306"></p>
<h3 id="446-ipv6"><a class="markdownIt-Anchor" href="#446-ipv6"></a> 4.4.6 IPv6</h3>
<p>特点：</p>
<ul>
<li>扩 大 的 地 址 容 量</li>
<li>简化高效的40字节首部</li>
<li>流标签</li>
</ul>
<p><img src="/posts/9d1d146e/image-20220605124448556.png" srcset="/img/loading.gif" lazyload alt="image-20220605124448556"></p>
<ul>
<li>版 本。 该 4 比特字段用于标识 IP 版本号。 毫不奇怪， IPv6 将该字段值设为 6。</li>
<li>流量类型。 该 8 比特字段与我们在 IPv4 中看到的 T0S 字段的含义相似。</li>
<li>流 标 签。 如上面讨论过的那样， 该 20 比特的字段用于标识一条数据报的流， 能够对一条流中的某些数据报给岀优先权， 或者它能够用来对来自某些应用（ 例如 IP话音） 的数据报给出更高的优先权， 以优于来自其他应用（ 例如 SMTP 电子邮件）的数据报。</li>
<li>有效载荷长度。 该 16 比特值作为一个无符号整数， 给出了 IPv6 数据报中跟在定长的 40 字节数据报首部后面的字节数量。</li>
<li>下一个首部。 该字段标识数据报中的内容（ 数据字段） 需要交付给哪个协议（ 如TCP 或 UDP)。 该字段使用与 IPv4 首部中协议字段相同的值。</li>
<li>跳限制。 转发数据报的每台路由器将对该字段的内容减 1。 如果跳限制计数达到0, 则该数据报将被丢弃。</li>
<li>源地址和目的地址。 IPv6 128 比特地址的各种格式在 RFC 4291 中进行了描述。</li>
<li>数据。 这是 IPv6 数据报的有效载荷部分。 当数据报到达目的地时， 该有效载荷就从 IP 数据报中移出， 并交给在下一个首部字段中指定的协议处理。</li>
</ul>
<p><strong>从 IPv4 到 IPv6 的迁移</strong></p>
<p><img src="/posts/9d1d146e/image-20220605125253185.png" srcset="/img/loading.gif" lazyload alt="image-20220605125253185"></p>
<h2 id="45-选路算法"><a class="markdownIt-Anchor" href="#45-选路算法"></a> 4.5 选路算法</h2>
<p><img src="/posts/9d1d146e/image-20220613141052311.png" srcset="/img/loading.gif" lazyload alt="image-20220613141052311"></p>
<h3 id="451-链路状态路由选择算法"><a class="markdownIt-Anchor" href="#451-链路状态路由选择算法"></a> 4.5.1 链路状态路由选择算法</h3>
<p><img src="/posts/9d1d146e/image-20220613142004033.png" srcset="/img/loading.gif" lazyload alt="image-20220613142004033"></p>
<p><img src="/posts/9d1d146e/image-20220613142215257.png" srcset="/img/loading.gif" lazyload alt="image-20220613142215257"></p>
<h3 id="452-距离向量路由选择算法"><a class="markdownIt-Anchor" href="#452-距离向量路由选择算法"></a> 4.5.2 距离向量路由选择算法</h3>
<p>Bellman-Ford方程 (动态规划)</p>
<p><img src="/posts/9d1d146e/image-20220613142400246.png" srcset="/img/loading.gif" lazyload alt="image-20220613142400246"></p>
<p><img src="/posts/9d1d146e/image-20220613142518942.png" srcset="/img/loading.gif" lazyload alt="image-20220613142518942"></p>
<p>基本思想:</p>
<p><img src="/posts/9d1d146e/image-20220613142707187.png" srcset="/img/loading.gif" lazyload alt="image-20220613142707187"></p>
<ul>
<li>每个节点周期性的发送它自己的距离矢量估计到其邻居</li>
<li>当节点x接收到来自邻居的新DV估计，它使用B-F方程更新其自己的DV</li>
<li>在规模较小、正常的条件下，估计值D<strong>x</strong>(y)收敛在实际最小费用 dx(y)</li>
</ul>
<p><img src="/posts/9d1d146e/image-20220613143549357.png" srcset="/img/loading.gif" lazyload alt="image-20220613143549357"></p>
<h2 id="46-互联网中选路"><a class="markdownIt-Anchor" href="#46-互联网中选路"></a> 4.6 互联网中选路</h2>
<p>用于自治系统内部的路由协议称为“<strong>内部网关协议</strong>”，简称 <strong>IGP</strong>(Interior Gateway Protocol)</p>
<ul>
<li>
<p>RIP</p>
</li>
<li>
<p>OSPF</p>
</li>
<li>
<p>EIGRP</p>
</li>
</ul>
<p>用于自治系统间接口上的路由协议称为“<strong>外部网关协议</strong>”，简称<strong>EGP</strong>(Exterior Gateway Protocol)</p>
<ul>
<li>BGP-4</li>
</ul>
<h3 id="461-路由信息协议rip"><a class="markdownIt-Anchor" href="#461-路由信息协议rip"></a> 4.6.1 路由信息协议RIP</h3>
<p>路由信息协议 RIP 是内部网关协议 IGP中最先得到广泛使用的协议。</p>
<p>RIP 是一种分布式的基于距离向量的路由选择协议。</p>
<blockquote>
<p>应用层协议，使用UDP传送数据，RIP报文作为UDP的数据部分</p>
</blockquote>
<p>距离的定义：</p>
<ul>
<li>
<p>从一路由器到直接连接的网络的距离定义为 1。</p>
</li>
<li>
<p>从一个路由器到非直接连接的网络的距离定义为所经过的路由器数加1。</p>
</li>
<li>
<p>RIP 协议中的“距离”也称为“跳数”(hop count)，因为每经过一个路由器，跳数就加 1。</p>
</li>
<li>
<p>RIP认为一个好的路由就是它通过的路由器的数目少，即“距离短”。</p>
</li>
<li>
<p>RIP允许一条路径最多只能包含 15 个路由器， “距离”的最大值为16 时即相当于不可达。</p>
</li>
</ul>
<p>RIP协议的三个要点 ：</p>
<ul>
<li>
<p>仅和相邻路由器交换信息。</p>
</li>
<li>
<p>交换的信息是当前本路由器所知道的全部信息，即自己的路由表。</p>
</li>
<li>
<p>按固定的时间间隔交换路由信息，例如，每隔 30 秒。</p>
</li>
</ul>
<p><img src="/posts/9d1d146e/image-20220613144427124.png" srcset="/img/loading.gif" lazyload alt="image-20220613144427124"></p>
<p><img src="/posts/9d1d146e/image-20220613145858068.png" srcset="/img/loading.gif" lazyload alt="image-20220613145858068"></p>
<p><strong>RIP协议的优缺点：</strong></p>
<ul>
<li>
<p>RIP 协议最大的优点就是实现简单，开销较小。</p>
</li>
<li>
<p>RIP 限制了网络的规模，它能使用的最大距离为 15（16 表示不可达）。</p>
</li>
<li>
<p>路由器之间交换的路由信息是路由器中的完整路由表，因而随着网络规模的扩大，开销也就增加。</p>
</li>
<li>
<p>RIP 存在的一个问题是当网络出现故障时，要经过比较长的时间才能将此信息传送到所有的路由器。</p>
</li>
</ul>
<p>开放最短路径优先OSPF协议是目前IGP中应用最广、性能最有的协议。</p>
<h3 id="462-ospf协议"><a class="markdownIt-Anchor" href="#462-ospf协议"></a> 4.6.2 OSPF协议</h3>
<ul>
<li>
<p>使用链路状态算法</p>
</li>
<li>
<p>可适应大规模网络-层次OSPF</p>
</li>
<li>
<p>路由变化收敛速度快</p>
</li>
<li>
<p>其他特征</p>
<ul>
<li>支持路由等级划分，支持组播，支持验证，支持（多路径）等值路由</li>
</ul>
</li>
</ul>
<p>OSPF工作过程：</p>
<ul>
<li>
<p>每个路由器通过“HELLO”与邻居节点形成和维持邻居关系</p>
</li>
<li>
<p>路由器节点在与邻居的交互中掌握了本区域网络拓扑 ，使用 Dijkstra算法完成本节点的路由计算</p>
</li>
<li>
<p>邻居或链路状态发生变化时，将信息通过洪泛法散布到整个区域。</p>
</li>
<li>
<p>携带在OSPF报文中直接封装在IP中(而不是TCP或UDP)</p>
</li>
</ul>
<blockquote>
<p>网络层协议，直接使用IP数据报传送，数据封装在IP数据报的数据部分</p>
</blockquote>
<h3 id="463-bgp协议"><a class="markdownIt-Anchor" href="#463-bgp协议"></a> 4.6.3 BGP协议</h3>
<blockquote>
<p>应用层协议，使用TCP传送数据</p>
</blockquote>
<p>BGP (边界网关协议): AS间路由协议事实上的标准</p>
<p>BGP为每个AS提供了一种手段 :</p>
<ol>
<li>
<p>从相邻AS获得子网可达性信息</p>
</li>
<li>
<p>向AS内部的所有路由器传播可达性信息</p>
</li>
<li>
<p>基于可达性信息和策略，决定到子网的“好”路由</p>
</li>
</ol>
<h2 id="47-广播和多播选路"><a class="markdownIt-Anchor" href="#47-广播和多播选路"></a> 4.7 广播和多播选路</h2>
<p><img src="/posts/9d1d146e/image-20220613152330140.png" srcset="/img/loading.gif" lazyload alt="image-20220613152330140"></p>
<h1 id="第5章-链路层和局域网"><a class="markdownIt-Anchor" href="#第5章-链路层和局域网"></a> 第5章 链路层和局域网</h1>
<h2 id="51-概述与服务"><a class="markdownIt-Anchor" href="#51-概述与服务"></a> 5.1 概述与服务</h2>
<ul>
<li>
<p>主机和路由器是<strong>节点</strong></p>
</li>
<li>
<p>连接沿通信路径的相邻节点的路径是<strong>链路</strong></p>
<ul>
<li>
<p>有线链路</p>
</li>
<li>
<p>无线链路</p>
</li>
<li>
<p>局域网</p>
</li>
</ul>
</li>
<li>
<p>第二层的分组叫<strong>帧</strong>,封装数据报</p>
</li>
</ul>
<p><strong>数据链路层具有经一条链路从一个节点传输数据到相邻节点的能力</strong></p>
<h4 id="链路层提供的服务"><a class="markdownIt-Anchor" href="#链路层提供的服务"></a> 链路层提供的服务</h4>
<ul>
<li>
<p><strong>成帧, 链路访问</strong>:</p>
<ul>
<li>将数据报封装进帧，加上首部和尾部</li>
<li>如果共享媒体，信道访问</li>
<li>位于帧首部的“MAC”地址标识源、目的地
<ul>
<li>不同于IP地址!</li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>相连节点间的可靠交付</strong></p>
</li>
<li>
<p>在比特差错低的链路很少使用 (光纤，某些双绞线)</p>
</li>
<li>
<p>无线链路: 高差错率</p>
</li>
</ul>
<p><span style="background:#FFDBBB;">问题: 为什么同时使用链路级和端到端可靠性?</span></p>
<p><strong style="color:#ff0000;">数据链路层是为物理层提供可靠服务的，因为物理层可能导致比特传输差错，数据链路层保证点到点的可靠传输，即保证其向上层提供的数据是无差错的；</strong></p>
<p><strong style="color:#ff0000;">传输层是为网络层提供可靠传输服务的，因为数据报在核心网传输过程中，可能会在路由器那里因负载过高导致丢弃，然后传输层重传，来保证可靠传输，传输层保证端到端的可靠传输，这样传输层能保证向上层(也就是应用层)提供的数据是无误且按序交付的。</strong></p>
<ul>
<li>
<p><strong>流量控制</strong>:</p>
<ul>
<li>相邻发送和接收节点间的步调一致</li>
</ul>
</li>
<li>
<p><strong>差错检测</strong>:</p>
<ul>
<li>差错由信号衰减、噪声所致</li>
<li>接收方检测差错的存在</li>
<li>信号发送方负责重传或丢弃帧</li>
</ul>
</li>
<li>
<p><strong>纠错</strong>:</p>
<ul>
<li>接收方识别<em>和纠正</em>比特差错，而不采取重传</li>
</ul>
</li>
<li>
<p><strong>半双工and全双工</strong></p>
<ul>
<li>使用半双工, 链路的两端节点能够传输，但不能同时</li>
</ul>
</li>
</ul>
<h2 id="52-差错检测和纠错"><a class="markdownIt-Anchor" href="#52-差错检测和纠错"></a> 5.2 差错检测和纠错</h2>
<h3 id="521-奇偶校验"><a class="markdownIt-Anchor" href="#521-奇偶校验"></a> 5.2.1 奇偶校验</h3>
<p><img src="/posts/9d1d146e/image-20220613154455027.png" srcset="/img/loading.gif" lazyload alt="image-20220613154455027"></p>
<h3 id="522-检验和方法"><a class="markdownIt-Anchor" href="#522-检验和方法"></a> 5.2.2 检验和方法</h3>
<p><img src="/posts/9d1d146e/image-20220613165706758.png" srcset="/img/loading.gif" lazyload alt="image-20220613165706758"></p>
<h3 id="523-循环冗余检测"><a class="markdownIt-Anchor" href="#523-循环冗余检测"></a> 5.2.3 循环冗余检测</h3>
<p><img src="/posts/9d1d146e/image-20220613165931601.png" srcset="/img/loading.gif" lazyload alt="image-20220613165931601"></p>
<h2 id="53-多路访问协议"><a class="markdownIt-Anchor" href="#53-多路访问协议"></a> 5.3 多路访问协议</h2>
<h3 id="631-信道划分协议"><a class="markdownIt-Anchor" href="#631-信道划分协议"></a> 6.3.1 信道划分协议</h3>
<h4 id="tdma-时分多路访问"><a class="markdownIt-Anchor" href="#tdma-时分多路访问"></a> TDMA: 时分多路访问</h4>
<ul>
<li>
<p>”循环“访问信道</p>
</li>
<li>
<p>每个站点在每个循环中获得固定长度时隙(长度=分组传输时间)</p>
</li>
<li>
<p>不使用的时隙空闲</p>
</li>
</ul>
<h4 id="fdma-频分多路访问"><a class="markdownIt-Anchor" href="#fdma-频分多路访问"></a> FDMA: 频分多路访问</h4>
<ul>
<li>
<p>信道频谱划分为频带</p>
</li>
<li>
<p>每个站点分配固定的频带</p>
</li>
<li>
<p>频带中未使用的传输时间空闲</p>
</li>
</ul>
<h3 id="632-随机访问协议"><a class="markdownIt-Anchor" href="#632-随机访问协议"></a> 6.3.2 随机访问协议</h3>
<p>当站点有分组要发送</p>
<ul>
<li>
<p>以信道全部速率R传输</p>
</li>
<li>
<p>节点间<em>无优先权</em>协调</p>
</li>
</ul>
<p>两个或更多传输节点➜ “碰撞”,</p>
<p>随即访问MAC协议 定义了:</p>
<ul>
<li>
<p>如何检测碰撞</p>
</li>
<li>
<p>如何从碰撞中恢复 (例如，经延迟的重新传输)</p>
</li>
</ul>
<p>随即访问MAC协议的例子:</p>
<ul>
<li>
<p>时隙ALOHA</p>
</li>
<li>
<p>ALOHA</p>
</li>
<li>
<p>CSMA, CSMA/CD, CSMA/CA</p>
</li>
</ul>
<h4 id="时隙aloha"><a class="markdownIt-Anchor" href="#时隙aloha"></a> 时隙ALOHA</h4>
<p><img src="/posts/9d1d146e/image-20220613170937523.png" srcset="/img/loading.gif" lazyload alt="image-20220613170937523"></p>
<p>优点</p>
<ul>
<li>
<p>单个活跃节点能够连续地以信道的全速传输</p>
</li>
<li>
<p>高速分散：仅节点中的时隙需要同步</p>
</li>
<li>
<p>简单</p>
</li>
</ul>
<p>缺点</p>
<ul>
<li>
<p>碰撞，浪费时隙</p>
</li>
<li>
<p>空闲时隙</p>
</li>
<li>
<p>节点可能能够以小于传输分组的时间检测到碰撞</p>
</li>
<li>
<p>时钟同步</p>
</li>
</ul>
<p>效率为1/e=0.37</p>
<h4 id="aloha"><a class="markdownIt-Anchor" href="#aloha"></a> ALOHA</h4>
<p><img src="/posts/9d1d146e/image-20220613171509912.png" srcset="/img/loading.gif" lazyload alt="image-20220613171509912"></p>
<h4 id="csma载波侦听多路访问"><a class="markdownIt-Anchor" href="#csma载波侦听多路访问"></a> CSMA(载波侦听多路访问)</h4>
<p><strong>CSMA</strong>: 在传输前侦听:</p>
<ul>
<li>
<p>如果侦听到信道空闲: 传输整个帧</p>
</li>
<li>
<p>如果侦听到信道忙, 推迟传输</p>
</li>
<li>
<p>检测到碰撞后，继续完整地传输它们的帧</p>
</li>
</ul>
<p><img src="/posts/9d1d146e/image-20220613172750269.png" srcset="/img/loading.gif" lazyload alt="image-20220613172750269"></p>
<h4 id="csmacd"><a class="markdownIt-Anchor" href="#csmacd"></a> CSMA/CD</h4>
<p>CSMA/CD协议原理</p>
<ul>
<li>
<p>载波侦听：先听再说</p>
<ul>
<li>适配器在发送前监听总线是否空闲，总线空闲则发送数据，不空闲则继续监听</li>
</ul>
</li>
<li>
<p>冲突检测：边说边听</p>
<ul>
<li>数据在发送的同时保持对总线的监听，发现冲突则停止发送</li>
</ul>
</li>
<li>
<p>随机延迟后重发</p>
<ul>
<li>冲突发生后，采用指数回退方法等待一段随机时间后，再进行监听和发送</li>
</ul>
</li>
</ul>
<p>检测到碰撞将立即停止传输</p>
<p><img src="/posts/9d1d146e/image-20220613172805578.png" srcset="/img/loading.gif" lazyload alt="image-20220613172805578"></p>
<h4 id="csmaca"><a class="markdownIt-Anchor" href="#csmaca"></a> CSMA/CA</h4>
<ul>
<li>
<p>CSMA/CD 用在以太网中</p>
</li>
<li>
<p>CSMA/CA 用在 802.11中</p>
</li>
</ul>
<h3 id="633-轮流协议"><a class="markdownIt-Anchor" href="#633-轮流协议"></a> 6.3.3 轮流协议</h3>
<p><strong>信道划分 MAC协议:</strong></p>
<ul>
<li>
<p>在高负载时高效、公平地共享信道</p>
</li>
<li>
<p>低负载时低效：信道访问中延时，当1个活跃节点时，甚至仅有分配了 1/N 带宽!</p>
</li>
</ul>
<p><strong>随机访问 MAC协议</strong></p>
<ul>
<li>
<p>低负载是有效：单个节点能够全面利用信道</p>
</li>
<li>
<p>高负载：碰撞开销</p>
</li>
</ul>
<p><strong>“轮流”协议</strong></p>
<ul>
<li>兼有这方面的优点!</li>
</ul>
<p><img src="/posts/9d1d146e/image-20220613173459293.png" srcset="/img/loading.gif" lazyload alt="image-20220613173459293"></p>
<h2 id="54-链路层编址"><a class="markdownIt-Anchor" href="#54-链路层编址"></a> 5.4 链路层编址</h2>
<p>MAC地址</p>
<p>32-bit IP地址:</p>
<ul>
<li>
<p>网络层地址</p>
</li>
<li>
<p>用于使数据报到达目的IP子网</p>
</li>
</ul>
<p>MAC(或LAN 或物理或以太网)地址:</p>
<ul>
<li>
<p>用于使数据报从一个接口到达另一个物理连接的接口(同一个网络内)</p>
</li>
<li>
<p>48 bit MAC地址(对多数LAN) 烧在了适配器ROM中</p>
</li>
</ul>
<h3 id="arp-地址解析协议"><a class="markdownIt-Anchor" href="#arp-地址解析协议"></a> ARP: 地址解析协议</h3>
<p>工作在网络层</p>
<p>ARP 将一个 IP 地址解析为一个 MAC 地址</p>
<p><img src="/posts/9d1d146e/image-20220613183202684.png" srcset="/img/loading.gif" lazyload alt="image-20220613183202684"></p>
<p>首先， 查询 ARP 报文是在广播帧中发送的， 而响应 ARP 报文在一个标准帧中发送。</p>
<p><img src="/posts/9d1d146e/image-20220613183659941.png" srcset="/img/loading.gif" lazyload alt="image-20220613183659941"></p>
<p><img src="/posts/9d1d146e/image-20220613183736774.png" srcset="/img/loading.gif" lazyload alt="image-20220613183736774"></p>
<h2 id="55-以太网"><a class="markdownIt-Anchor" href="#55-以太网"></a> 5.5 以太网</h2>
<p>以太网帧结构</p>
<p><img src="/posts/9d1d146e/image-20220613184124220.png" srcset="/img/loading.gif" lazyload alt="image-20220613184124220"></p>
<p><strong>数 据 字 段 （ 46 ~ 1500 字节）</strong>。 这个字段承载了 IP 数据报。 以太网的最大传输单元( MTU ) 是 1500 字节。 这意味着如果 1P 数据报超过了 1500 字节， 则主机必须将该数据报分片， 如 4.3.2 节所讨论。 数据字段的最小长度是 46 字节。 这意味着如果 IP 数据报小于 46 字节， 数据报必须被填充到 46 字节。</p>
<p><strong>目的地址（6 字节）</strong>。 这个字段包含目的适配器的 MAC 地址， 即 BB- BB- BB- BB-BB-BB。</p>
<p><strong>源地址（6字节）</strong>。 这个字段包含了传输该帧到局域网上的适配器的 MAC 地址，在本例中为 AA- AA- AA- AA- AA- AA.<br>
类 型 字 段（2 字节）。 类型字段允许以太网复用多种网络层协议。</p>
<p><strong>CRC (4 字节）</strong>。 如 6.2.3 节中讨论的那样， CRC ( 循环冗余检测） 字段的目的是使得接收适配器（ 适配器 B ) 检测帧中是否引入了差错。</p>
<p><strong>前同步码（8字节）</strong>。 以太网帧以一个 8 字节的前同步码 （ Preamble ) 字段开始。该前同步码的前 7 字节的值都是 10101010; 最后一个字节是 10101011。 前同步码字段的前7 字节用于 “ 唤醒” 接收适配器， 并且将它们的时钟和发送方的时钟同<br>
步。</p>
<p>以太网使用CSMA/CD协议</p>
<p><img src="/posts/9d1d146e/image-20220613184653677.png" srcset="/img/loading.gif" lazyload alt="image-20220613184653677"></p>
<p><img src="/posts/9d1d146e/image-20220613184706357.png" srcset="/img/loading.gif" lazyload alt="image-20220613184706357"></p>
<h2 id="56-链路层交换机"><a class="markdownIt-Anchor" href="#56-链路层交换机"></a> 5.6 链路层交换机</h2>
<h3 id="集线器"><a class="markdownIt-Anchor" href="#集线器"></a> 集线器</h3>
<p><img src="/posts/9d1d146e/image-20220613185140619.png" srcset="/img/loading.gif" lazyload alt="image-20220613185140619"></p>
<h3 id="交换机"><a class="markdownIt-Anchor" href="#交换机"></a> 交换机</h3>
<ul>
<li>
<p>工作在链路层</p>
</li>
<li>
<p>即插即用，自学习</p>
</li>
<li>
<p>线速转发</p>
</li>
</ul>
<h3 id="交换机-vs-路由器"><a class="markdownIt-Anchor" href="#交换机-vs-路由器"></a> 交换机 vs. 路由器</h3>
<ul>
<li>
<p>两者都是存储转发设备</p>
<ul>
<li>
<p>路由器: 网络层设备(检查网络层首部)</p>
</li>
<li>
<p>交换机是链路层设备</p>
</li>
</ul>
</li>
<li>
<p>路由器维护选路表，实现选路算法</p>
</li>
<li>
<p>交换机维护交换机表, 实现过滤、学习</p>
</li>
</ul>
<h2 id="57-ppp"><a class="markdownIt-Anchor" href="#57-ppp"></a> 5.7 PPP</h2>
<p><strong>概述</strong>：</p>
<ul>
<li>
<p>PPP（Point to Point Protocol）协议是在点对点链路上运行的数据链路层协议</p>
</li>
<li>
<p>用户使用拨号电话线接入Internet时，一般都是使用 PPP 协议</p>
</li>
<li>
<p>PPP协议支持用户的认证，是广域网接入使用最广泛的协议</p>
</li>
</ul>
<p><strong>PPP主要包括三个部分</strong>：</p>
<ul>
<li>
<p>在串行链路上封装上层数据报文的方法</p>
</li>
<li>
<p>采用LCP（Link-Control Protocol，链路控制协议）来建立、控制数据链路</p>
</li>
<li>
<p>采用NCP（Network-Control Protocol，网络控制协议）来支持多种网络协议</p>
</li>
</ul>
<p><img src="/posts/9d1d146e/image-20220613185805254.png" srcset="/img/loading.gif" lazyload alt="image-20220613185805254"></p>
<h2 id="58-链路虚拟化"><a class="markdownIt-Anchor" href="#58-链路虚拟化"></a> <strong>5.8</strong> 链路虚拟化</h2>
<p><img src="/posts/9d1d146e/image-20220613190145329.png" srcset="/img/loading.gif" lazyload alt="image-20220613190145329"></p>
<p>DNS：域名到IP的转换，应用层协议，基于UDP</p>
<p><strong style="color:#0070c0;">FTP：文件传输协议，端口21,20，应用层协议，基于TCP</strong></p>
<p><strong style="color:#0070c0;">SMTP、POP3：电子邮件系统，应用层协议，基于TCP</strong></p>
<p>RIP：路由信息协议，端口520，应用层协议，基于UDP</p>
<p><strong>OSPF：开放最短路径优先，网络层协议，直接使用IP数据报</strong></p>
<p><strong style="color:#0070c0;">BGP:边界网关协议，应用层协议，基于TCP</strong></p>
<p><strong>ARP：地址解析协议，IP地址到MAC地址的映射，工作在网络层</strong></p>
<p>DHCP：动态主机配置协议，应用层协议，基于UDP</p>
<p><strong>ICMP：网际控制报文协议，网络层协议</strong></p>
<blockquote>
<p><strong>为何要有 UDP协议?</strong>（优点）</p>
</blockquote>
<ul>
<li>
<p>无连接创建(它将增加时延)</p>
</li>
<li>
<p>简单：在发送方、接收方无连接状态</p>
</li>
<li>
<p>段首部小</p>
</li>
<li>
<p>无拥塞控制: UDP能够尽可能快地传输</p>
</li>
</ul>
<p>常用于流媒体应用程序</p>
<ul>
<li>
<p>丢包容忍</p>
</li>
<li>
<p>速率敏感</p>
</li>
</ul>
<p>其他UDP应用</p>
<ul>
<li>
<p>DNS</p>
</li>
<li>
<p>SNMP</p>
</li>
</ul>
<p>当应用程序<strong>对传输的可靠性要求不高</strong>，但是对<strong>传输速度和延迟要求较高</strong>时，可以用UDP协议来替代TCP协议在传输层控制数据的转发。</p>
<p>UDP适合于<strong>实时数据传输</strong>，如<strong>语音</strong>和<strong>视频通信</strong>，因为它们即使偶尔丢失一两个数据包，也不会对接收结果产生太大影响。例如：我们在看视频的时候偶尔丢一两个包也不影响体验。</p>
<p><span style="background:#FFDBBB;">问题: 为什么同时使用链路级和端到端可靠性?</span></p>
<p><strong style="color:#ff0000;">数据链路层是为物理层提供可靠服务的，因为物理层可能导致比特传输差错，数据链路层保证点到点的可靠传输，即保证其向上层提供的数据是无差错的；</strong></p>
<p><strong style="color:#ff0000;">传输层是为网络层提供可靠传输服务的，因为数据报在核心网传输过程中，可能会在路由器那里因负载过高导致丢弃，然后传输层重传，来保证可靠传输，传输层保证端到端的可靠传输，这样传输层能保证向上层(也就是应用层)提供的数据是无误且按序交付的。</strong></p>

            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                  <div class="post-meta mr-3">
                    <i class="iconfont icon-category"></i>
                    
                      <a class="hover-with-bg" href="/categories/Course-Study/">Course Study</a>
                    
                      <a class="hover-with-bg" href="/categories/Course-Study/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">计算机网络</a>
                    
                  </div>
                
                
                  <div class="post-meta">
                    <i class="iconfont icon-tags"></i>
                    
                      <a class="hover-with-bg" href="/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">学习笔记</a>
                    
                      <a class="hover-with-bg" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">计算机网络</a>
                    
                  </div>
                
              </div>
              
                <p class="note note-warning">
                  
                    本博客所有文章除特别声明外，著作权归作者所有，转载请注明出处！
                  
                </p>
              
              
                <div class="post-prevnext">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/posts/e99d01ee/">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">论文笔记：《Software Vulnerability Discovery via Learning Multi-Domain Knowledge Bases》</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/posts/76311f61/">
                        <span class="hidden-mobile">计算机网络Lab4-WiresharkLab:Ethernet-and-ARP-v7.0</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
              <!-- Comments -->
              <article class="comments" id="comments" lazyload>
                
                  
                
                
  <div class="disqus" style="width:100%">
    <div id="disqus_thread"></div>
    
      <script type="text/javascript">
        var disqus_config = function() {
          this.page.url = 'https://zino00.github.io/posts/9d1d146e/';
          this.page.identifier = '/posts/9d1d146e/';
        };
        Fluid.utils.loadComments('#disqus_thread', function() {
          var d = document, s = d.createElement('script');
          s.src = '//' + 'fluid' + '.disqus.com/embed.js';
          s.setAttribute('data-timestamp', new Date());
          (d.head || d.body).appendChild(s);
        });
      </script>
    
    <noscript>Please enable JavaScript to view the comments</noscript>
  </div>


              </article>
            
          </article>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    

    
      <a id="scroll-top-button" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
    

    
  </main>

  <footer class="text-center mt-5 py-3">
  <div class="footer-content">
     <a  rel="nofollow noopener"><span>Copyrights © 2021</span></a> <i class="iconfont icon-love"></i> <a  target="_blank" rel="nofollow noopener"><span>Zino</span></a> 
  </div>
  
  <div class="statistics">
    
    

    
      
        <!-- 不蒜子统计PV -->
        <span id="busuanzi_container_site_pv" style="display: none">
            总访问量 
            <span id="busuanzi_value_site_pv"></span>
             次
          </span>
      
      
        <!-- 不蒜子统计UV -->
        <span id="busuanzi_container_site_uv" style="display: none">
            总访客数 
            <span id="busuanzi_value_site_uv"></span>
             人
          </span>
      
    
  </div>


  

  
  <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?d1745c2e21adaa6ae90b93f4f4d22da9";
      var s = document.getElementsByTagName("script")[0]; 
      s.parentNode.insertBefore(hm, s);
    })();
    </script>
    
</footer>


  <!-- SCRIPTS -->
  
  <script  src="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" ></script>
<script  src="https://cdn.jsdelivr.net/npm/bootstrap@4.6.0/dist/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>

<!-- Plugins -->


  
    <script  src="/js/img-lazyload.js" ></script>
  



  



  <script  src="https://cdn.jsdelivr.net/npm/tocbot@4.12.3/dist/tocbot.min.js" ></script>



  <script  src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js" ></script>



  <script  src="https://cdn.jsdelivr.net/npm/anchor-js@4.3.1/anchor.min.js" ></script>



  <script defer src="https://cdn.jsdelivr.net/npm/clipboard@2.0.8/dist/clipboard.min.js" ></script>



  <script  src="/js/local-search.js" ></script>



  <script defer src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" ></script>




  <script  src="https://cdn.jsdelivr.net/npm/typed.js@2.0.12/lib/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var title = document.getElementById('subtitle').title;
      
      typing(title)
      
    })(window, document);
  </script>





  

  
    <!-- KaTeX -->
    <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.13.10/dist/katex.min.css" />
  








  
    <!-- Baidu Analytics -->
    <script defer>
      var _hmt = _hmt || [];
      (function () {
        var hm = document.createElement("script");
        hm.src = "https://hm.baidu.com/hm.js?f45dcd001d67e8f9d84f91248ea31abf";
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(hm, s);
      })();
    </script>
  

  

  

  

  

  





<!-- 主题的启动项 保持在最底部 -->
<script  src="/js/boot.js" ></script>


</body>
</html>
