

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=&#34;auto&#34;>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/favicon.jpg">
  <link rel="icon" href="/img/favicon.jpg">
  <meta name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="description" content="操作系统的学习笔记">
  <meta name="author" content="John Doe">
  <meta name="keywords" content="">
  
  <title>操作系统笔记 - Zino&#39;s Blog</title>

  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.6.0/dist/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/github-markdown-css@4.0.0/github-markdown.min.css" />
  <link  rel="stylesheet" href="/lib/hint/hint.min.css" />

  
    
    
      
      <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@10.7.2/styles/github-gist.min.css" />
    
  

  
    <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css" />
  



<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_kmeydafke9r.css">


<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->


  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    var CONFIG = {"hostname":"zino00.github.io","root":"/","version":"1.8.11","typing":{"enable":true,"typeSpeed":70,"cursorChar":"","loop":false},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"copy_btn":true,"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":1},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":true,"baidu":"f45dcd001d67e8f9d84f91248ea31abf","google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null}},"search_path":"/local-search.xml"};
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
<meta name="generator" content="Hexo 5.4.0"></head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand"
       href="/">&nbsp;<strong>Zino's Blog</strong>&nbsp;</a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" data-toggle="modal" data-target="#modalSearch">&nbsp;<i
                class="iconfont icon-search"></i>&nbsp;</a>
          </li>
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="banner" id="banner" parallax=true
         style="background: url('/img/post.jpg') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="page-header text-center fade-in-up">
            <span class="h2" id="subtitle" title="操作系统笔记">
              
            </span>

            
              <div class="mt-3">
  
  
    <span class="post-meta">
      <i class="iconfont icon-date-fill" aria-hidden="true"></i>
      <time datetime="2021-11-17 13:39" pubdate>
        2021年11月17日 下午
      </time>
    </span>
  
</div>

<div class="mt-1">
  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      57.6k 字
    </span>
  

  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      622
       分钟
    </span>
  

  
  
    
      <!-- 不蒜子统计文章PV -->
      <span id="busuanzi_container_page_pv" style="display: none">
        <i class="iconfont icon-eye" aria-hidden="true"></i>
        <span id="busuanzi_value_page_pv"></span> 次
      </span>
    
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">操作系统笔记</h1>
            
            <div class="markdown-body">
              <h1 id="第1章-导论"><a class="markdownIt-Anchor" href="#第1章-导论"></a> 第1章 导论</h1>
<h2 id="11-操作系统做什么"><a class="markdownIt-Anchor" href="#11-操作系统做什么"></a> 1.1 操作系统做什么</h2>
<p>计算机系统可以大致分为4个组成部分：计算机硬件、操作系统、系统程序与应用程序和用户。</p>
<p><img src="/posts/8ce3e425/image-20211114101353468.png" srcset="/img/loading.gif" lazyload alt="image-20211114101353468"></p>
<p><strong>定义操作系统</strong>：</p>
<p>操作系统是一直运行在计算机上的程序（通常称为内核），其他程序则为系统程序和应用程序。</p>
<h2 id="12-计算机系统组织"><a class="markdownIt-Anchor" href="#12-计算机系统组织"></a> 1.2 计算机系统组织</h2>
<p><strong>1.2.1 计算机系统操作</strong></p>
<p><strong>1.2.2 存储结构</strong></p>
<p><img src="/posts/8ce3e425/image-20211114104118324.png" srcset="/img/loading.gif" lazyload alt="image-20211114104118324"></p>
<p><strong>1.2.3 I/O结构</strong></p>
<h2 id="13-计算机系统体系结构"><a class="markdownIt-Anchor" href="#13-计算机系统体系结构"></a> 1.3 计算机系统体系结构</h2>
<p><strong>1.3.1 单处理器系统</strong></p>
<p><strong>1.3.2 多处理器系统</strong></p>
<p><strong>1.3.3 集群系统</strong></p>
<p>与多处理器系统一样， 集群系统将多个CPU集中起来完成计算任务。然而，集群系统与多处理器系统不同，它是由两个或多个独立的系统藕合起来的。</p>
<h2 id="14-操作系统结构"><a class="markdownIt-Anchor" href="#14-操作系统结构"></a> 1.4 操作系统结构</h2>
<h2 id="15-操作系统操作"><a class="markdownIt-Anchor" href="#15-操作系统操作"></a> 1.5 操作系统操作</h2>
<p>1.5.1 双重模式操作<br>
1.5.2 定时器</p>
<h2 id="16-进程管理"><a class="markdownIt-Anchor" href="#16-进程管理"></a> 1.6 进程管理</h2>
<h2 id="17-内存管理"><a class="markdownIt-Anchor" href="#17-内存管理"></a> 1.7 内存管理</h2>
<h2 id="18-存储管理"><a class="markdownIt-Anchor" href="#18-存储管理"></a> 1.8 存储管理</h2>
<p>1.8.1 文件系统管理<br>
1.8.2 大容量存储器管理<br>
1.8.3 高速缓存<br>
1.8.4 V/O系统</p>
<h2 id="19-保护和安全"><a class="markdownIt-Anchor" href="#19-保护和安全"></a> 1.9 保护和安全</h2>
<h2 id="110-分布式系统"><a class="markdownIt-Anchor" href="#110-分布式系统"></a> 1.10 分布式系统</h2>
<h2 id="111-专用系统"><a class="markdownIt-Anchor" href="#111-专用系统"></a> 1.11 专用系统</h2>
<p>1.111 实时嵌入式系统<br>
1.11.2 多媒体系统<br>
1.11.3 手持系统</p>
<h2 id="112-计算环境"><a class="markdownIt-Anchor" href="#112-计算环境"></a> 1.12 计算环境</h2>
<p>1.12.1 传统计算<br>
1.12.2 客户机服务器计算<br>
1.12.3 对等计算<br>
1.12.4 基于Web的计算</p>
<p><strong>用户态切换到内核态的3种方式</strong></p>
<ol>
<li>
<p><strong>系统调用</strong> 这是用户态进程主动要求切换到内核态的一种方式，用户态进程通过系统调用申请使用操作系统提供的服务程序完成工作。而系统调用的机制其核心还是使用了操作系统为用户特别开放的一个中断来实现，例如Linux的int 80h中断。</p>
</li>
<li>
<p><strong>异常</strong> 当CPU在执行运行在用户态下的程序时，发生了某些事先不可知的异常，这时会触发由当前运行进程切换到处理此异常的内核相关程序中，也就转到了内核态，比如缺页异常。</p>
</li>
<li>
<p><strong>外围设备的中断</strong> 当外围设备完成用户请求的操作后，会向CPU发出相应的中断信号，这时CPU会暂停执行下一条即将要执行的指令转而去执行与中断信号对应的处理程序，如果先前执行的指令是用户态下的程序，那么这个转换的过程自然也就发生了由用户态到内核态的切换。比如硬盘读写操作完成，系统会切换到硬盘读写的中断处理程序中执行后续操作等。</p>
</li>
</ol>
<h1 id="第2章-操作系统结构"><a class="markdownIt-Anchor" href="#第2章-操作系统结构"></a> 第2章 操作系统结构</h1>
<h2 id="21-操作系统服务"><a class="markdownIt-Anchor" href="#21-操作系统服务"></a> 2.1 操作系统服务</h2>
<ul>
<li>
<p><strong>用户界面</strong>：</p>
<ul>
<li>一种是命令行界面（command-line interface CLI）， 它采用文本命令， 并用一定的方法输入（即一种允许输入并编辑的命令〉。</li>
<li>另一种是批界面， 其中控制这些命令和命令的指令被输入文件中，通过执行文件来实现。</li>
<li>最为常用的是图形用户界面（graphical user interface,GUI)， 此时界面是一个视窗系统， 它具有定位设备来指挥I/O、从菜单来选择、选中部分并用键盘输入文本。有些系统还提供了两种甚至所有这三种界面。</li>
</ul>
</li>
<li>
<p><strong>程序执行</strong>： 系统必须能将程序装入内存并运行程序。程序必须能结束执行， 包括正常或不正常结束（指明错误）。</p>
</li>
<li>
<p><strong>I/O操作</strong>：运行程序可能需要I/O，这些I/O 可能涉及文件或设备。对于特定设备，需要特定的功能（如刻录CD或DVD驱动器，或清屏）。为了提高效率和进行保护， 用户通常不能直接控制νo设备。因此，操作系统必须提供进行I/O操作的方法。</p>
</li>
<li>
<p><strong>文件系统操作</strong>： 文件系统特别重要。很明显， 程序需要读写文件和目录， 也需要根据文件名来创建和删除文件、搜索一个给定的文件、列出文件信息。最后，有些程序还包括了基于文件所有权的允许或拒绝对文件或目录的访问管理。</p>
</li>
<li>
<p><strong>通信</strong>：在许多情况下，一个进程需要与另一个进程交换信息。这种通信有两种主要形式。一种是发生在同一台计算机运行的两个进程之间。另一种是运行在由网络连接起来<br>
的不同的计算机上的进程之间。通信可以通过共事冲序来实现，也可通过信息交换技术来实现（对于消息交换，消息包通过操作系统在进程之间移动）。</p>
</li>
<li>
<p><strong>错误检测</strong>：操作系统需要时刻知道可能出现的错误。</p>
</li>
<li>
<p><strong>资源分配</strong>：当多个用户或多个作业同时运行时，必须为每一个分配资源。</p>
</li>
<li>
<p><strong>统计</strong>：跟踪记录那些用户使用了多少资源和什么类型的资源。</p>
</li>
<li>
<p><strong>保护和安全</strong>：多进程并发执行时，一个进程不能干预另一个进程或操作系统本身。</p>
</li>
</ul>
<h2 id="22-操作系统的用户界面"><a class="markdownIt-Anchor" href="#22-操作系统的用户界面"></a> 2.2 操作系统的用户界面</h2>
<h3 id="221-命令解释程序"><a class="markdownIt-Anchor" href="#221-命令解释程序"></a> 2.2.1 命令解释程序</h3>
<p>具有多个命令解释程序选择的系统中， 解释程序被称为外壳(Shell）。例如，在UNIX 和Linux 系统中，有多种不同的Shell 可供用户选择，包括：Bourne Shell、C Shell、Bourne-Again Shell、Korn Shell 等。</p>
<h3 id="222-图形用户界面"><a class="markdownIt-Anchor" href="#222-图形用户界面"></a> 2.2.2 图形用户界面</h3>
<p>与用户通过命令行直接输入命令不同， GUI 允许提供基于鼠标的窗口和菜单系统作为接口。</p>
<h2 id="23-系统调用"><a class="markdownIt-Anchor" href="#23-系统调用"></a> 2.3 系统调用</h2>
<p>系统调用Csystem call）提供了操作系统提供的有效服务界面。</p>
<p>系统调用提供了进程与操作系统之间的接口</p>
<p><strong>系统调用</strong></p>
<p>操作系统服务的编程接口<br>
通常由高级语言编写（C或C++）<br>
程序访问通常通过高层次 的API接口（C标准库的库函数）而不是直接进行系统调用<br>
每个系统调用对应一个系统调用编号</p>
<h3 id="系统调用与函数调用的区别"><a class="markdownIt-Anchor" href="#系统调用与函数调用的区别"></a> <strong>！！！系统调用与函数调用的区别</strong></h3>
<p><strong>系统调用</strong></p>
<ol>
<li>
<p>使用INT和IRET指令，内核和应用程序使用的是不同的堆栈，因此存在堆栈的切换，从用户态切换到内核态，从而可以使用特权指令操控设备</p>
</li>
<li>
<p>依赖于内核，不保证移植性</p>
</li>
<li>
<p>在用户空间和内核上下文环境间切换，开销较大</p>
</li>
<li>
<p>是操作系统的一个入口点</p>
</li>
</ol>
<p><strong>函数调用</strong></p>
<ol>
<li>使用CALL和RET指令，调用时没有堆栈切换</li>
<li>平台移植性好</li>
<li>属于过程调用，调用开销较小</li>
<li>一个普通功能函数的调用</li>
</ol>
<h3 id="api与系统调用"><a class="markdownIt-Anchor" href="#api与系统调用"></a> API与系统调用</h3>
<p><strong>API</strong>是函数的定义，规定了这个函数的功能，跟内核无直接关系。</p>
<p><strong>系统调用</strong>是通过中断向内核发请求，实现内核提供的某些服务。</p>
<p><strong>联系</strong>：一个API可能会需要一个或多个系统调用来完成特定功能。通俗点说就是如果这个api需要跟内核打交道就需要系统调用，否则不需要。 程序员调用的是API（API函数），然后通过与系统调用共同完成函数的功能。</p>
<p>API是一个提供给应用程序的接口，一组函数，是与程序员进行直接交互的。 系统调用则不与程序员进行交互的，它根据API函数，通过一个软中断机制向内核提交请求，以获取内核服务的接口。</p>
<p>并不是所有的API函数都一一对应一个系统调用。一个API函数可能需要几个系统调用来共同完成函数的功能。一些API函数不需要调用相应的系统调用（因此它所完成的不是内核提供的服务）</p>
<p><img src="/posts/8ce3e425/image-20211114112604666.png" srcset="/img/loading.gif" lazyload alt="image-20211114112604666"></p>
<h2 id="24-系统调用类型"><a class="markdownIt-Anchor" href="#24-系统调用类型"></a> 2.4 系统调用类型</h2>
<h3 id="241-进程控制"><a class="markdownIt-Anchor" href="#241-进程控制"></a> 2.4.1 进程控制</h3>
<ul>
<li>结束， 放弃</li>
<li>装入， 执行</li>
<li>创建进程， 终止进程</li>
<li>取得进程属性， 设置进程属性</li>
<li>等待时间</li>
<li>等待事件， 唤醒事件</li>
<li>分配和释放内存</li>
</ul>
<h3 id="242-文件管理"><a class="markdownIt-Anchor" href="#242-文件管理"></a> 2.4.2 文件管理</h3>
<ul>
<li>创建文件， 删除文件</li>
<li>打开， 关闭</li>
<li>读、写、重定位</li>
<li>取得文件属性， 设置文件属性</li>
</ul>
<h3 id="243-设备管理"><a class="markdownIt-Anchor" href="#243-设备管理"></a> 2.4.3 设备管理</h3>
<ul>
<li>请求设备， 释放设备</li>
<li>读、写、重定位</li>
<li>取得设备属性， 设置设备属性</li>
<li>逻辑连接或断开设备</li>
</ul>
<h3 id="244-信息维护"><a class="markdownIt-Anchor" href="#244-信息维护"></a> 2.4.4 信息维护</h3>
<ul>
<li>读取时间或日期， 设置时间或日期</li>
<li>读取系统数据， 设置系统数据</li>
<li>读取进程， 文件或设备属性</li>
<li>设置进程， 文件或设备属性</li>
</ul>
<h3 id="245-通信"><a class="markdownIt-Anchor" href="#245-通信"></a> 2.4.5 通信</h3>
<ul>
<li>创建， 删除通信连接</li>
<li>发送， 接受消息</li>
<li>传递状态消息</li>
<li>连接或断开远程设备</li>
</ul>
<h2 id="25-系统程序"><a class="markdownIt-Anchor" href="#25-系统程序"></a> 2.5 系统程序</h2>
<p>系统程序提供了一个方便的环境， 以开发程序和执行程序。其中一小部分只是系统调用的简单接口， 其他的可能是相当复杂的。它们可分为如下几类：</p>
<ul>
<li><strong>文件管理</strong>：这些程序创建、删除、复制、重新命名、打印、转储、列出和操作文件和目录。</li>
<li><strong>状态信息</strong>：一些程序从系统那里得到日期、时间、可用内存或磁盘空间的数量、用户数或类似状态信息。另一些更为复杂， 能提供详细的性能、登录和调试信息。通常， 这些信息经格式化后，再打印到终端、输出设备或文件， 或在GUI的窗体上显示。有些系统还支持注册衰，它被用于存储和检索配置信息。</li>
<li><strong>文件修改</strong>：－ 有多个编辑器可以创建和修改位于磁盘或其他存储设备上的文件内容。也可能有特殊的命令被用于查找文件内容或完成文本的转换。</li>
<li><strong>程序语言支持</strong>： 常用程序设计语言（如C、C＋＋、Java、Visual Basic和Perl等〉的编译程序、汇编程序、调试程序和解释程序通常与操作系统一起提供给用户。</li>
<li><strong>程序装入和执行</strong>：一旦程序汇编或编译后， 它必须装入内存才能执行。系统可能要提供绝对加载程序、重定位加载程序、链接编辑器和覆盖式加载程序。系统还需要有高级语言或机器语言的调试程序。</li>
<li><strong>通信</strong>：这些程序提供了在进程、用户和计算机系统之间创建虚拟连接的机制。它们允许用户在互相的屏幕上发送消息， 浏览网页， 发送电子邮件， 远程登录， 从一台机器向另一台机器传送文件。</li>
</ul>
<h3 id="26-操作系统设计和实现"><a class="markdownIt-Anchor" href="#26-操作系统设计和实现"></a> 2.6 操作系统设计和实现</h3>
<h3 id="261-设计目标"><a class="markdownIt-Anchor" href="#261-设计目标"></a> 2.6.1 设计目标</h3>
<h3 id="262-机制与策略"><a class="markdownIt-Anchor" href="#262-机制与策略"></a> 2.6.2 机制与策略</h3>
<h3 id="263-实现"><a class="markdownIt-Anchor" href="#263-实现"></a> 2.6.3 实现</h3>
<h2 id="27-操作系统结构"><a class="markdownIt-Anchor" href="#27-操作系统结构"></a> 2.7 操作系统结构</h2>
<h4 id="271-简单结构"><a class="markdownIt-Anchor" href="#271-简单结构"></a> 2.7.1 简单结构</h4>
<p><img src="/posts/8ce3e425/image-20211114121729295.png" srcset="/img/loading.gif" lazyload alt="image-20211114121729295"></p>
<p><img src="/posts/8ce3e425/image-20211114121720130.png" srcset="/img/loading.gif" lazyload alt="image-20211114121720130"></p>
<h4 id="272-分层方法"><a class="markdownIt-Anchor" href="#272-分层方法"></a> 2.7.2 分层方法</h4>
<ul>
<li>
<p>操作系统被划分为若干层级，每一层都建立在较低层之上</p>
</li>
<li>
<p>模块化</p>
</li>
</ul>
<p><img src="/posts/8ce3e425/image-20211114122235688.png" srcset="/img/loading.gif" lazyload alt="image-20211114122235688"></p>
<ul>
<li>
<p>优点</p>
<ul>
<li>便于构造和调试  简化系统设计和实现</li>
</ul>
</li>
<li>
<p>不足</p>
<ul>
<li>定义和划分困难  效率相对要低一些</li>
</ul>
</li>
</ul>
<h4 id="273-微内核"><a class="markdownIt-Anchor" href="#273-微内核"></a> 2.7.3 微内核</h4>
<ul>
<li>
<p>这种方法将所有非基本部分从内核中移走，并将它们当做系统级程序和用户级程序来实现，用这种方法来构建操作系统</p>
</li>
<li>
<p>用户模块之间采用消息传递的方式进行通信</p>
</li>
<li>
<p>优点</p>
<ul>
<li>微内核易于扩展</li>
<li>易于提升OS至一个新的体系结构</li>
<li>更可靠（内核模式中运行的代码更少）</li>
<li>更安全</li>
</ul>
</li>
<li>
<p>缺点</p>
<ul>
<li>用户空间与内核空间的通信代价较高</li>
</ul>
</li>
</ul>
<h4 id="274-模块"><a class="markdownIt-Anchor" href="#274-模块"></a> 2.7.4 模块</h4>
<p>用面向对象编程技术来生成模块化的内核。这里， 内核有一组核心部件， 以及在启动或运行时对附加服务的动态链接。</p>
<ul>
<li>用面向对象的方法</li>
<li>内核的组成部分相互分离</li>
<li>任务之间的交互通过已知的接口来实现</li>
<li>每个模块在内核中是按照需要可装载的</li>
<li>比分层系统更为灵活</li>
<li>比微内核更高效（不需要调用消息传递来通信）</li>
</ul>
<p><img src="/posts/8ce3e425/image-20211114122827683.png" srcset="/img/loading.gif" lazyload alt="image-20211114122827683"></p>
<h2 id="28-虚拟机"><a class="markdownIt-Anchor" href="#28-虚拟机"></a> 2.8 虚拟机</h2>
<h3 id="281-实现"><a class="markdownIt-Anchor" href="#281-实现"></a> 2.8.1 实现</h3>
<p>虚拟机是.通过软件模拟的具有完整硬件系统功能的、运行在一个完全隔离环境中的完整计算机系统。</p>
<p>虚拟机的基本思想是单个计算机(CPU、 内存、 磁盘、 网卡等〉的硬件抽象为几个不同的执行部件， 从而造成一种 “ 幻觉，仿佛每个独立的执行环境都在自己的计算机上运行一样。</p>
<ul>
<li>虚拟机采用了分层的方法。它将物理硬件和OS内核统一看作为硬件</li>
<li>虚拟机提供了与基本硬件相同的接口</li>
<li>通过利用CPU调度和虚拟内存技术，操作系统能创建一种“幻觉”，以至于进程认为有自己的处理器和自己的（虚拟）内存。</li>
</ul>
<h3 id="282-优点"><a class="markdownIt-Anchor" href="#282-优点"></a> 2.8.2 优点</h3>
<ul>
<li>通过完全保护系统资源，虚拟机提供了一个坚实的安全层</li>
<li>虚拟机允许进行系统开发而不必中断正常的系统操作</li>
</ul>
<p>缺点</p>
<ul>
<li>虚拟机概念很难提供真实的硬件效果</li>
</ul>
<h3 id="283-实例"><a class="markdownIt-Anchor" href="#283-实例"></a> 2.8.3 实例</h3>
<h2 id="29-系统生成"><a class="markdownIt-Anchor" href="#29-系统生成"></a> 2.9 系统生成</h2>
<h2 id="210-系统启动"><a class="markdownIt-Anchor" href="#210-系统启动"></a> 2.10 系统启动</h2>
<h2 id="211-小结"><a class="markdownIt-Anchor" href="#211-小结"></a> 2.11 小结</h2>
<h2 id="212-习题"><a class="markdownIt-Anchor" href="#212-习题"></a> 2.12 习题</h2>
<p><strong>2.1 操作系统提供的服务和功能可以主要分为两大类。简要描述这两大类并讨论它们的区别。</strong></p>
<blockquote>
<p>第一种操作系统提供的服务是<strong>用来保护在系统中同时运行的不同进程</strong>。进程只被允许获得与它们地址空间有联系的内存位置。同样，进程不允许破坏和其他用户有关的文件。一个进程同样不允许在没有操作系统的干预<br>
下直接进入设备。</p>
<p>第二种服务由操作系统提供的服务是<strong>提供一种新的功能，而这种功能并不直接被底层的硬件支持</strong>。虚拟存储器和文件系统就是由操作系统提供的这种新服务的实例。</p>
</blockquote>
<p><strong>2.2 列出操作系统提供使用户更为方便地使用计算机系统的5个服务，并说明在哪些情况下用户级程序不能够提供这些服务。请解释为什么。</strong></p>
<blockquote>
<p>2.1操作系统服务</p>
</blockquote>
<p><strong>2.3 给出三种向操作系统传递参数的常用方法。</strong></p>
<blockquote>
<ol>
<li>通过寄存器来传递参数</li>
<li>寄存器传递参数块的首地址</li>
<li>参数通过程序存放或压进堆栈中， 并通过操作系统弹出堆栈。</li>
</ol>
</blockquote>
<p><strong>2.4 介绍一下如何获得一个程序在执行其不同部分的代码时所耗时间的统计简衰。讨论获得该统计简表的重要性。</strong></p>
<p><strong>2.5 操作系统关于文件管理的5个主要功能是什么？</strong></p>
<blockquote>
<p>2.4.2</p>
</blockquote>
<p><strong>2.6 操作文件和设备时，采用同样的系统调用界面有什么优点和缺点？</strong></p>
<p><strong>2.7 命令解释器的用途是什么？为什么它经常是与内核分开的？是否可能采用操作系统提供的系统调用接口为用户开发一个新的命令解释器？</strong></p>
<p><strong>！！！2.8 进程间通信的两个模式是什么？这两种方法有何长处和缺点？</strong></p>
<blockquote>
<p>共享内存系统</p>
<ul>
<li>
<p>优点</p>
<ul>
<li>最快的一种通信方式，多个进程可同时访问同一片内存空间，相对其他方式来说具有更少的数据拷贝，效率较高。</li>
<li>随内核持续，相比于随进程持续生命力更强。</li>
</ul>
</li>
<li>
<p>缺点</p>
<p>需要结合信号量</p>
<p>或其他方式来实现多个进程间同步，自身不具备同步机制。</p>
</li>
</ul>
<p>消息传递系统</p>
<ul>
<li>优点
<ul>
<li>可以实现通信进程间的同步</li>
</ul>
</li>
<li>缺点
<ul>
<li>效率较低</li>
</ul>
</li>
</ul>
</blockquote>
<p><strong>2.9 为什么要将机制和策略区分开来？</strong></p>
<p><strong>2.10 为什么Java提供从Java程序调用以C或C＋＋编写的本地方法？举出一个本地方法的例子。</strong></p>
<p><strong>2.11 如果操作系统的两个部件相互依赖，有时实现分层方法会很困难． 请区别两个功能紧密耦合的系统部件如何分层。</strong></p>
<p><strong>！！！2.12 系统设计采用微内核设计的主要优点是什么？用户程序和系统服务在微内核结构内如何相互影响？采用微内核设计的缺点又是什么？</strong></p>
<blockquote>
<p>优点主要包括以下几点：</p>
<ul>
<li>
<p><strong>灵活性高易拓展</strong>,增加一个新的服务不需要修改内核</p>
</li>
<li>
<p>在用户模式中中比在内核模式中<strong>更安全</strong>、更易操作</p>
</li>
<li>
<p>一个简单的内核设计和功能一般导致一个<strong>更可靠</strong>的操作系统</p>
</li>
<li>
<p><strong>可移植性强</strong></p>
</li>
<li>
<p>易于提升OS至一个新的体系结构</p>
</li>
</ul>
<p>用户程序和系统服务通过使用进程件的通信机制在微内核中相互作用，例如发送消息。这些消息由操作系统运送。</p>
<p>缺点是</p>
<ul>
<li>与进程间通信的过度联系和为了保证用户程序和系统服务相互作用而频繁使用操作系统的消息传递功能。使得<strong>效率较低</strong></li>
</ul>
</blockquote>
<p><strong>2.13 模块化内核方法和分层方法在哪些方面类似？哪些方面不同？</strong></p>
<blockquote>
<p>二者的相似之处在于实现了系统的模块化设计，每一部分都对外提供接口，便于对系统进行维护和修改。</p>
<p>二者的区别在于模块化内核方法比分层方法更为灵活，它的任一模块都能调用任何其他模块，提高了系统效率；而分层方法通过层层的系统调用实现上层与下层模块之间的通信，增加了系统开销。</p>
</blockquote>
<p><strong>2.14 操作系统设计员采用虚拟机结构的主要优点是什么？对用户来说主要有什么好处？</strong></p>
<p><strong>2.15 为什么说一个TIT (just-in-time）编译器对执行一个Java程序是有用的？</strong></p>
<p><strong>2.16 在VMware这样的系统中，客户操作系统与主操作系统有什么关系？选择主操作系统要考虑什么因素？</strong></p>
<h1 id="第3章-进程"><a class="markdownIt-Anchor" href="#第3章-进程"></a> 第3章 进程</h1>
<h2 id="31-进程概念"><a class="markdownIt-Anchor" href="#31-进程概念"></a> 3.1 进程概念</h2>
<h3 id="311-进程"><a class="markdownIt-Anchor" href="#311-进程"></a> 3.1.1 进程</h3>
<p><strong>进程</strong>：是一个可并发执行的具有独立功能的程序关于某个数据集合的一次执行过程，也是操作系统进行资源分配和保护的基本单位。</p>
<p><strong>进程和程序的区别</strong></p>
<ul>
<li>
<p><strong>进程</strong>反映的是一个动态概念，而<strong>程序</strong>是一个静态概念；程序是指令的有序集合，没有任何执行的含义，而进程则强调的是执行过程，它动态被创建、执行和消亡。</p>
</li>
<li>
<p><strong>进程</strong>是一个能独立运行的单位，能与其他进程并发执行，进程是作为资源申请和调度单位存在的。而<strong>程序</strong>则没有。因为程序不反映执行过程。</p>
</li>
<li>
<p>程序和进程并不一定具有一一对应的关系。不同的进程可以来自于同一程序，只要该程序所对应的数据集不同。</p>
</li>
</ul>
<p>进程包括文本段、堆栈段（包括临时数据，如函数参数、返回地址和局部变量）、数据段（包括全局变量）、堆（进程运行时动态分配的内存）</p>
<p><img src="/posts/8ce3e425/image-20210622073331434.png" srcset="/img/loading.gif" lazyload alt="image-20210622073331434"></p>
<p><img src="/posts/8ce3e425/image-20211024142834120.png" srcset="/img/loading.gif" lazyload alt="内存中的进程"></p>
<p><strong>进程的内存映像：</strong></p>
<p><img src="/posts/8ce3e425/image-20220109122113919.png" srcset="/img/loading.gif" lazyload alt="image-20220109122113919"></p>
<h3 id="312-进程状态"><a class="markdownIt-Anchor" href="#312-进程状态"></a> 3.1.2 进程状态</h3>
<p>进程在执行时会改变状态。进程状态在某种程度上是由当前活动所定义的。每个进程可能处于下列状态之一：</p>
<ul>
<li>新的：进程正在被创建。</li>
<li>运行： 指令正在被执行。</li>
<li>等待：进程等待某个事件的发生（如I/O完成或收到信号）。</li>
<li>就绪：进程等待分配处理器。</li>
<li>终止：进程完成执行。</li>
</ul>
<p><img src="/posts/8ce3e425/image-20211024144135058.png" srcset="/img/loading.gif" lazyload alt="image-20211024144135058"></p>
<h3 id="313-进程控制块"><a class="markdownIt-Anchor" href="#313-进程控制块"></a> 3.1.3 进程控制块</h3>
<p>每个进程在操作系统内用进程控制块（process control block, PCB ，也称为任务控制块）来表示。</p>
<p>图3.3 给出了一个PCB 的例子， 它包含许多与一个特定进程相关的信息。</p>
<p><img src="/posts/8ce3e425/image-20211024144308211.png" srcset="/img/loading.gif" lazyload alt="image-20211024144308211"></p>
<ul>
<li>进程状态：状态可包括新的、就绪、运行、等待、停止等。</li>
<li>程序计数器：计数器表示进程要执行的下个指令的地址。</li>
<li>CPU 寄存器：根据计算机体系结构的不同， 寄存器的数量和类型也不同。它们包括累加器、索引寄存器、堆钱指针、通用寄存器和其他条件码信息寄存器。与程序计数器一起，这些状态信息在出现中断时也需要保存， 以便进程以后能正确地继续执行（见图3.4)。</li>
<li>CPU 调度信息：这类信息包括进程优先级、调度队列的指针和其他调度参数（第5章讨论进程调度）。</li>
<li>内存管理信息： 根据操作系统所使用的内存系统， 这类信息包括基址和界限寄存器的值、页表或段表（见第8章）。</li>
<li>记账信息：这类信息包括CPU时间、实际使用时间、时间界限、记账数据、作业或进程数量等。</li>
<li>I/O状态信息：这类信息包括分配给进程的I/O设备列表、打开的文件列表等。</li>
</ul>
<p><img src="/posts/8ce3e425/image-20211024144700188.png" srcset="/img/loading.gif" lazyload alt="image-20211024144700188"></p>
<p><strong>PCB的作用</strong></p>
<ul>
<li>PCB可唯一标识一个进程</li>
<li>PCB中的信息为进程的控制提供依据</li>
<li>PCB将程序变成了进程</li>
<li>PCB是进程在系统中存在的唯一标志</li>
</ul>
<h3 id="314-线程"><a class="markdownIt-Anchor" href="#314-线程"></a> 3.1.4 线程</h3>
<p>迄今为止所讨论的进程模型暗示： 一个进程是一个只能进行单个执行线程的程序。例如， 如果一个进程运行一个字处理器程序， 那么只能执行单个线程指令。这种单一控制线程使得进程一次只能执行一个任务。例如， 用户不能在同一进程内， 同时输入字符和进行拼写检查。</p>
<p>许多现代操作系统扩展了进程概念以支持一次能执行多个线程。第4章将讨论多线程进程。</p>
<h2 id="32-进程调度"><a class="markdownIt-Anchor" href="#32-进程调度"></a> 3.2 进程调度</h2>
<p>多道程序设计的目的是无论何时都有进程在运行，从而使CPU利用率达到最大化。</p>
<p>分时系统的目的是在进程之间快速切换CPU以便用户在程序运行时能与其进行交互。</p>
<h3 id="321-调度队列"><a class="markdownIt-Anchor" href="#321-调度队列"></a> 3.2.1 调度队列</h3>
<p>讨论进程调度的常用表示方法是队列图， 如图3.7 所示。每个长方形表示一个队列。<br>
有两种队列： 就绪队列和一组设备队列。圆形表示为队列服务的资源， 箭头表示系统内进程的流向。</p>
<p>新进程开始处于就绪队列。它在就绪队列中等待直到被选中执行或被派遣。当进程分配到CPU 并执行时， 可能发生下面几种事件中的一种：</p>
<ul>
<li>进程可能发出一个I/O请求， 并被放到I/O队列中。</li>
<li>进程可能创建一个新的子进程， 并等待其结束。</li>
<li>进程可能会由于中断而强制释放CPU， 并被放回到就绪队列中。</li>
</ul>
<p>对于前两种情况， 进程最终从等待状态切换到就绪态， 并放回到就绪队列中。进程继续这一循环直到终止， 到时它将从所有队列中删除， 其PCB 和资源将得以释放。</p>
<p><img src="/posts/8ce3e425/image-20211025195355812.png" srcset="/img/loading.gif" lazyload alt="image-20211025195355812"></p>
<h3 id="322-调度程序"><a class="markdownIt-Anchor" href="#322-调度程序"></a> 3.2.2 调度程序</h3>
<p>进程在其生命周期中会在各种调度队列之间迁移。为了调度， 操作系统必须按某种方式从这些队列中选择进程。进程选择是由相应的<strong>调度程序</strong>（ scheduler ）来执行的。</p>
<p>通常对于批处理系统， 进程更多地是被提交， 而不是马上执行。这些进程被放到大容量存储设备（通常为磁盘〉的缓冲池中，保存在那里以便以后执行。</p>
<p><strong>长期调度程序</strong>（long-term scheduler ）或作业调度程序（job scheduler ） 从缓冲池中选择进程， 并装入内存以准备执行。</p>
<p><strong>短期调度程序</strong>（ short-term scheduler ）或CPU 调度程序从准备执行的进程中选择进程， 并为之分配CPU。</p>
<p>这两个调度程序的<strong>主要差别</strong>是它们执行的频率。</p>
<p><strong>中期调度程序</strong>的核心思想是能将进程从内存（或从CPU 竞争）中移出， 从而降低多道程序设计的程度。之后， 进程能被重新调入内存， 并从中断处继续执行。</p>
<p><img src="/posts/8ce3e425/image-20211025200346176.png" srcset="/img/loading.gif" lazyload alt="image-20211025200346176"></p>
<h3 id="323-上下文切换"><a class="markdownIt-Anchor" href="#323-上下文切换"></a> 3.2.3 上下文切换</h3>
<p>当发生一个中断时，系统需要保存当前运行在CPU 中进程的上下文， 从而在其处理完后能恢复上下文， 即先中断进程， 之后再继续。</p>
<p><strong>进程上下文</strong>用进程的PCB 表示， 它包括CPU 寄存器的值、进程状态（见图3.2） 和内存管理信息等。通常，通过执行一个<strong>状态保存</strong>（ state save） 来保存CPU当前状态（不管它是内核模式还是用户模式）， 之后执行一个<strong>状态恢复</strong>（ state restore）重新开始运行。</p>
<p>将CPU切换到另一个进程需要保存当前进程的状态并恢复另一个进程的状态，这一任务称为<strong>上下文切换</strong>（ context switch）。当发生上下文切换时， 内核会将旧进程的状态保存在其PCB中，然后装入经调度要执行的并己保存的新进程的上下文。</p>
<h2 id="33-进程操作"><a class="markdownIt-Anchor" href="#33-进程操作"></a> 3.3 进程操作</h2>
<h3 id="331-进程创建"><a class="markdownIt-Anchor" href="#331-进程创建"></a> 3.3.1 进程创建</h3>
<p>进程在其执行过程中， 能通过创建进程系统调用（ create-process system call） 创建多个新进程。创建进程称为父进程， 而新进程称为子进程。每个新进程可以再创建其他进程，从而形成了进程树。</p>
<p><strong>创建过程</strong></p>
<ul>
<li>
<p>申请空白PCB</p>
</li>
<li>
<p>分配资源</p>
</li>
<li>
<p>初始化PCB</p>
</li>
<li>
<p>插入就绪队列</p>
</li>
</ul>
<p>进程创建实质上是生成一个PCB</p>
<p><img src="/posts/8ce3e425/image-20211114152544023.png" srcset="/img/loading.gif" lazyload alt="image-20211114152544023"></p>
<p>当进程创建新进程时， 有两种执行可能：<br>
①父进程与子进程并发执行。<br>
②父进程等待， 直到某个或全部子进程执行完。</p>
<p>新进程的地址空间也有两种可能：<br>
①子进程是父进程的复制品（具有与父进程相同的程序和数据）。<br>
②子进程装入另一个新程序。</p>
<p><img src="/posts/8ce3e425/image-20211025201136927.png" srcset="/img/loading.gif" lazyload alt="image-20211025201136927"></p>
<p><strong>fork实例：</strong></p>
<p><img src="/posts/8ce3e425/image-20220109122155530.png" srcset="/img/loading.gif" lazyload alt="image-20220109122155530"></p>
<h3 id="332-进程终止"><a class="markdownIt-Anchor" href="#332-进程终止"></a> 3.3.2 进程终止</h3>
<p><strong>进程终止的过程</strong></p>
<ul>
<li>
<p>查找进程</p>
</li>
<li>
<p>查找该进程的PCB</p>
</li>
<li>
<p>中止执行</p>
</li>
<li>
<p>终止子进程</p>
</li>
<li>
<p>归还资源</p>
</li>
<li>
<p>将PCB从所在队列移出</p>
</li>
<li>
<p>释放PCB</p>
</li>
</ul>
<p><img src="/posts/8ce3e425/image-20211114152857377.png" srcset="/img/loading.gif" lazyload alt="image-20211114152857377"></p>
<p>当进程完成执行最后的语句并使用系统调用exit()请求操作系统删除自身时， 进程终止。这时， 进程可以返回状态值（通常为整数〉到父进程（通过系统调用wait（））。所有进程资源（包括物理和虚拟内存、打开文件和I/O缓冲〉会被操作系统释放。</p>
<p>在其他情况下也会出现终止。进程通过适当的系统调用（如Win32 中的TerminatePorcess（）） 能终止另一个进程。通常， 只有被终止进程的父进程才能执行这一系统调用。否则， 用户可以任意地终止彼此的作业。</p>
<h3 id="333-进程阻塞"><a class="markdownIt-Anchor" href="#333-进程阻塞"></a> 3.3.3 进程阻塞</h3>
<p><strong>阻塞过程</strong></p>
<ul>
<li>
<p>停止执行</p>
</li>
<li>
<p>更改PCB为阻塞</p>
</li>
<li>
<p>保留现场</p>
</li>
<li>
<p>PCB插入相应阻塞队列</p>
</li>
<li>
<p>提示重新调度</p>
</li>
</ul>
<p><strong>唤醒过程</strong></p>
<ul>
<li>根据释放条件寻找相应进程</li>
<li>改PCB状态为就绪</li>
<li>将PCB插入就绪队列</li>
</ul>
<h2 id="34-进程间通信"><a class="markdownIt-Anchor" href="#34-进程间通信"></a> 3.4 进程间通信</h2>
<p><strong>允许进程协作的理由</strong></p>
<ul>
<li>信息共享（information sharing）：由于多个用户可能对同样的信息感兴趣（例如共享的文件）， 所以必须提供环境以允许对这些信息进行并发访问。</li>
<li>提高运算速度（computation speedup）： 如果希望一个特定任务快速运行， 那么必须将它分成子任务，每个子任务可以与其他子任务并行执行。注意，如果要实现这样的加速，需要计算机有多个处理单元（例如CPU或I/0通道）。</li>
<li>模块化（modularity）：可能需要按模块化方式构造系统， 如第2章所讨论， 可将系统功能分成独立进程或线程。</li>
<li>方便（convenience）：单个用户也可能同时执行许多任务。例如，一个用户可以并行进行编辑、打印和编译操作。</li>
</ul>
<p>进程间通信有两种基本模式：</p>
<p><strong>(1) 共享内存</strong></p>
<p>在共享内存模式中， 建立起一块供协作进程共享的内存区域， 进程通过向此共享区域读或写入数据来交换信息。</p>
<p><strong>(2) 消息传递</strong></p>
<p>在消息传递模式中，通过在协作进程间交换消息来实现通信。</p>
<p>图3.13 给出了这两种模式的对比。</p>
<p><img src="/posts/8ce3e425/image-20211026154454752.png" srcset="/img/loading.gif" lazyload alt="image-20211026154454752"></p>
<h3 id="341-共享内存系统"><a class="markdownIt-Anchor" href="#341-共享内存系统"></a> 3.4.1 共享内存系统</h3>
<p>采用共享内存的进程间通信需要通信进程建立<strong>共享内存区域</strong>。通常， 一块共享内存区域驻留在生成共享内存段进程的地址空间。其他希望使用这个共享内存段进行通信的进程必须将此放到它们自己的地址空间上。</p>
<p>采用共享内存是解决生产者一消费者问题方法中的一种。为了允许生产者进程和消费进程能并发执行， 必须要有一个缓冲来被生产者填充并被消费者所使用。此缓冲驻留在生产者进程和消费者进程的共享内存区域内， 当消费者使用一项时， 生产者能产生另一项。生产者和消费者必须同步， 以免消费者消费一个没有生产出来的项。</p>
<p>可以使用两种缓冲。<strong>无限缓冲</strong>（unbounded-buffer）对缓冲大小没有限制。消费者可能不得不等待新的项， 但生产者总是可以产生新项。有限缓冲（ bounded-buffer）假设缓冲大小固定。对于这种情况， 如果缓冲为空， 那么消费者必须等待：如果缓冲为满， 那么生产者必须等待。</p>
<p>共享缓冲是通过循环数组和两个逻辑指针来实现的： in 和out。变量in 指向缓冲中下一个空位： out 指向缓冲中的第一个满位。当in==out 时， 缓冲为空： (in+1)%BUFFER_SIZE= out 时，缓冲为满。</p>
<p><img src="/posts/8ce3e425/image-20211026155644352.png" srcset="/img/loading.gif" lazyload alt="image-20211026155644352"></p>
<h3 id="342-消息传递系统"><a class="markdownIt-Anchor" href="#342-消息传递系统"></a> 3.4.2 消息传递系统</h3>
<p>消息传递提供一种机制以允许进程不必通过共享地址空间来实现通信和同步。</p>
<p>消息传递工具提供至少两种操作：发送（消息） 和接收（消息） 。</p>
<ol>
<li>
<p><strong>命名</strong></p>
<p><strong>直接通信</strong>:</p>
<p>对于<strong>直接通信</strong>， 需要通信的每个进程必须明确地命名通信的接收者或发送者。采用这种方案， 原语send()和receive()定义如下：</p>
<ul>
<li>send(P,message）：发送消息到进程P。</li>
<li>receive(Q, message）： 接收来自进程Q的消息。</li>
</ul>
<p>这种方案的通信线路具有如下属性：</p>
<ul>
<li>在需要通信的每对进程之间自动建立线路。进程仅需知道相互通信的标识符。</li>
<li>一个线路只与两个进程相关。</li>
<li>每对进程之间只有一个线路。</li>
</ul>
<p>这种方案展示了<strong>对称寻址</strong>， 即发送和接收进程必须命名对方以便通信。</p>
<p>这种方案一个变形采用<strong>非对称寻址</strong>， 即只要发送者命名接收者， 而接收者不需要命名发送者。采用这种方案， 原语send()和receive()定义如下：</p>
<ul>
<li>send(P,message）：发送消息到进程P。</li>
<li>receive(id, message）：接收来自任何进程的消息，变量id设置成与其通信的进程名称。</li>
</ul>
<p>对称和非对称寻址方案的<strong>缺点</strong></p>
<ul>
<li>是限制了进程定义的模块化。改变进程的名称可能必须检查所有其他进程定义。所有旧名称的引用都必须找到， 以便修改成为新名称。</li>
<li>有可能造成依赖于特定的操作系统，因为不同操作系统对进程的ID号的指定方式可能不一致；</li>
<li>每对进程间只能够建立一条链路是一个重大的缺陷。</li>
</ul>
<p><strong>间接通信</strong>:</p>
<p>在<strong>间接通信</strong>中， 通过邮箱或端口来发送和接收消息。邮箱可以抽象成一个对象， 进程可以向其中存放消息，也可从中删除消息，每个邮箱都有一个唯一的标识符。例如，POSIX消息队列采用一个整数值来标识一个邮箱。对于这种方案， 一个进程可能通过许多不同的邮箱与其他进程通信， 但两个进程仅在其共享至少一个邮箱时可相互通信。原语send()和receive()定义如下：</p>
<ul>
<li>send(A , message）：发送一个消息到邮箱A。</li>
<li>receive(A, message）： 接收来自邮箱A 的消息。</li>
</ul>
<p>对于这种方案， 通信线路具有如下属性：</p>
<ul>
<li>只有在两个进程共享一个邮箱时， 才能建立通信线路。</li>
<li>一个线路可以与两个或更多的进程相关联。</li>
<li>两个通信进程之间可有多个不同的线路， 每个线路对应于一个邮箱。</li>
</ul>
</li>
<li>
<p><strong>同步</strong></p>
<p>进程间的通信可以通过调用原语send（）和receiveO来进行。这些原语的实现有不同的设计选项。消息传递可以是阻塞或非阻塞一一一也称为同步或异步。</p>
<ul>
<li>阻塞send：发送进程阻塞，直到消息被接收进程或邮箱所接收。</li>
<li>非阻塞send：发送进程发送消息并再继续操作。</li>
<li>阻塞receive：接收者阻塞，直到有消息可用。</li>
<li>非阻塞receive：接收者收到一个有效消息或空消息。</li>
</ul>
<p>send（）和receive（）可以进行多种组合。当send（）和receive（）都阻塞时，则在发送者和接收者之间就有一个集合点（rendezvous）。当使用阻塞sendO和receive(）时，如何解决生产者－消费者问题就不再重要了。生产者仅需调用阻塞send（）调用并等待，直到消息被送到接收者或邮箱。同样地，当消费者调用receive（）时，发生阻塞直到有一个消息可用。</p>
</li>
<li>
<p><strong>缓冲</strong></p>
<p>不管通信是直接的或是间接的， 通信进程所交换的消息都驻留在临时队列中。简单地讲， 队列实现有三种方法：</p>
<ul>
<li>零容量：队列的最大长度为0：因此， 线路中不能有任何消息处于等待。对于这种<br>
情况， 必须阻塞发送， 直到接收者接收到消息。</li>
<li>有限容量：队列的长度为有限的n： 因此， 最多只能有n个消息驻留其中。如果在发送新消息时队列未满，那么该消息可以放在队列中（或者复制消息或者保存消息的指针），且发送者可继续执行而不必等待。不过， 线路容量有限。如果线路满， 必须阻塞发送者直到队列中的空间可用为止。</li>
<li>无限容量：队列长度可以无限，因此， 不管多少消息都可在其中等待， 从不阻塞发送者。</li>
</ul>
<p>零容量情况称为没有缓冲的消息系统， 其他情况称为自动缓冲。</p>
</li>
</ol>
<h2 id="35-客户机服务器系统通信"><a class="markdownIt-Anchor" href="#35-客户机服务器系统通信"></a> 3.5 客户机服务器系统通信</h2>
<h3 id="351-socket"><a class="markdownIt-Anchor" href="#351-socket"></a> 3.5.1 Socket</h3>
<p><strong>Socket</strong> （套接字〉可定义为通信的端点。一对通过网络通信的进程需要使用一对Socket一一即每个进程各有一个。</p>
<p>Socket 由IP 地址与一个端口号连接组成。通常， Socket采用客户机一服务器结构。服务器通过监昕指定端口来等待进来的客户请求。一旦收到请求，服务器就接受来自客户Socket 的连接， 从而完成连接。</p>
<p>Java提供了三种不同类型的Socket。</p>
<ul>
<li>面向连接（TCP) Socket是用Socket类实现的。</li>
<li>无连接（UDP) Socket 使用了DatagramSocket 类。</li>
<li>最后一种类型是多点传送Socket 类(MulticastSocket class）， 它是DatagramSocket类的子类。多点传送Socket允许数据发送给多个接收者。</li>
</ul>
<p><img src="/posts/8ce3e425/image-20211114161059376.png" srcset="/img/loading.gif" lazyload alt="image-20211114161059376"></p>
<p><img src="/posts/8ce3e425/image-20211114161112895.png" srcset="/img/loading.gif" lazyload alt="image-20211114161112895"></p>
<p>无论一个Socket通信程序的功能多么齐全、程序多么复杂，其基本结构都是一样的，都包括以下四个基本步骤：</p>
<ol>
<li>在客户方和服务器方创建Socket/ServerSocket实例。</li>
<li>打开连接到Socket的输入/输出流。</li>
<li>利用输入/输出流，按照一定的协议对Socket进行读/写操作。</li>
<li>关闭输入/输出流和Socket。//如果网络的一端已经关闭，另一端读到null</li>
</ol>
<p>通常，程序员的主要工作是针对所要完成的功能在第3步进行编程，第1、2、4步对所有的通信程序来说几乎都是一样的。</p>
<p>有连接：</p>
<p><img src="/posts/8ce3e425/image-20211114162712864.png" srcset="/img/loading.gif" lazyload alt="image-20211114162712864"></p>
<p>无连接：</p>
<p><img src="/posts/8ce3e425/image-20211114162726368.png" srcset="/img/loading.gif" lazyload alt="image-20211114162726368"></p>
<h3 id="352-远程过程调用"><a class="markdownIt-Anchor" href="#352-远程过程调用"></a> 3.5.2 远程过程调用</h3>
<p><img src="/posts/8ce3e425/image-20211114162954112.png" srcset="/img/loading.gif" lazyload alt="image-20211114162954112"></p>
<h3 id="353-远程方法调用"><a class="markdownIt-Anchor" href="#353-远程方法调用"></a> 3.5.3 远程方法调用</h3>
<p>远程方法调用（remote method invocation, RMI） 是一个类似于RPC 的Java 特性。RMI允许线程调用远程对象的方法。如果对象位于不同的JVM 上，那么就认为它是远程的。因此， 远程可能在同一计算机或通过网络连接的主机的不同JVM 上。这种情况如图3.22所示。</p>
<p><img src="/posts/8ce3e425/image-20211114163017447-16417053527271.png" srcset="/img/loading.gif" lazyload alt></p>
<h2 id="36-小结"><a class="markdownIt-Anchor" href="#36-小结"></a> 3.6 小结</h2>
<p>进程是执行中的程序。随着进程的执行， 它改变状态。进程状态由进程当前活动所定义。每个进程可处于： <strong>新的、就绪、运行、等待或终止</strong>等状态。每个进程在操作系统内通过自己的**进程控制块（PCB）**来表示。</p>
<p>当前不在执行的进程会放在某个等待队列中。操作系统有两种主要队列：<strong>I/O请求队列</strong>和<strong>就绪队列</strong>。就绪队列包括所有准备执行并等待CPU的进程。每个进程都有PCB , PCB链接起来就形成了就绪队列。长期（作业）调度通过选择进程来争用CPU。通常， <strong>长期调度</strong>会受资源分配考虑， 尤其是内存管理的影响。<strong>短期调度</strong>从就绪队列中选择进程。操作系统必须为父进程创建子进程提供一种机制。父进程在继续之前可以等待它的子进程终止， 也可以并发执行父进程和子进程。并发执行有许多优点， 例如信息共享、提高运算速度、模块化和便利性等。</p>
<p>操作系统的执行进程可以是独立进程或协作进程。协作进程需要进程间有互相通信的机制。主要有两种形式的通信： <strong>共享内存和消息系统</strong>。共享内存方法要求通信进程共享一些变量。进程通过使用这些共享变量来交换信息。对于<strong>共享内存系统</strong>， 主要由应用程序员提供通信， 操作系统只需要提供共享内存。<strong>消息系统方法</strong>允许进程交换信息。提供通信的主要责任在于操作系统本身。这两种方法并不互相排斥， 能在同一操作系统内同时实现。</p>
<p>客户机一服务器系统中的通信可能使用：</p>
<p>(1) <strong>Socket</strong>,(2) <strong>远程过程调用(RPC)</strong>,(3) <strong>Java的远程方法调用（RMI）</strong>。</p>
<p>Socket定义为通信的端点。一对应用程序间的连接由一对Socket组成，每端各有一个通信频道。RPC 是另一种形式的分布式通信。当一个进程（或线程） 调用一个远程应用的方法时， 就出现了RPC。RMI是RPC 的Java版。RMI允许线程如同调用本地对象一样来调用远程对象的方法。RPC 和RMI的主要区别是RPC传递给远程过程的数据是按普通数据结构形式的， 而RMI允许把对象传递给远程方法。</p>
<h2 id="37-习题"><a class="markdownIt-Anchor" href="#37-习题"></a> 3.7 习题</h2>
<p><strong>1.什么是多道程序的度（degree of multiprogramming），它的上限由哪些因素确定？</strong></p>
<blockquote>
<p>多道即计算机内存中同时存放几道相互独立的程序。多道程序的度就是操作系统将多少个进程放入了内存。上限的限制因素有CPU的核数、所采用的的调度算法、内存的大小等。</p>
</blockquote>
<p><strong>3.1 论述长期、中期、短期调度之间的区别。</strong></p>
<blockquote>
<p>a.<strong>短期调度</strong>：从准备执行的进程中选择进程， 并为之分配CPU。<br>
b.<strong>中期调度</strong>：作为一种中等程度的调度程序，尤其被用于分时系统，一个交换方案的实施，将部分运行程序移出内存，之后，从中断处继续执行。<br>
c.<strong>长期调度</strong>（作业调度程序）：通常对于批处理系统， 进程更多地是被提交， 而不是马上执行。这些进程被放到大容量存储设备（通常为磁盘）的缓冲池中，保存在那里以便以后执行。长期调度程序从缓冲池中选择进程， 并装入内存以准备执行。</p>
<p>它们主要的<strong>不同之处</strong>是它们的执行的频率。短期调度必须经常调用一个新进程，由于在系统中，长期调度处理移动的作业时，并不频繁被调用，可能在进程离开系统时才被唤起。</p>
</blockquote>
<p><strong>3.2 描述内核在两个进程间进行上下文切换的过程。</strong></p>
<blockquote>
<p>进程上下文是由进程的PCB来表示的，它包括CPU寄存器的值和内存管理信息等。</p>
<p>通常，通过执行一个状态保存（ state save） 来保存CPU当前状态（不管它是内核模式还是用户模式）， 之后执行一个状态恢复（ state restore）重新开始运行。</p>
<p>当发生上下文切换时， 内核会将旧进程的状态保存在其PCB中，然后装入经调度要执行的并己保存的新进程的上下文</p>
</blockquote>
<p><strong>3.5 下面设计的好处和坏处分别是什么？系统层次和用户层次都要考虑到</strong>．<br>
A，对称和非对称通信</p>
<p>B，自动和显式缓冲</p>
<p>C， 复制发送和引用发送</p>
<p>D，固定大小和可变大小消息</p>
<blockquote>
<p>a、 对称和非对称通信——对称通信的一个好处是它允许发送者和接收者之间会合。阻塞发送的一个缺点是可能不需要集合，并且消息可以异步传递；在发送方不感兴趣的点接收。因此，消息传递系统通常提供两种形式的同步<br>
b、 自动和显式缓冲自动缓冲提供了一个无限长的队列：因此确保发送方在等待复制消息时不必阻塞。没有关于如何提供自动缓冲的规范：一种方案可能会在浪费大量内存的地方保留足够大的内存。显式缓冲指定缓冲区的大小。在这种情况下，发送方在等待队列中的可用空间时可能会被阻止。但是，显式缓冲不太可能浪费内存<br>
c、 按副本发送和按引用发送按副本发送不允许接收方更改参数的状态；“通过引用发送”不允许这样做。通过引用senid的一个好处是，它允许程序员编写集中式应用程序的分布式版本。javasrmi提供了这两种方法，但是通过引用传递参数也需要将参数声明为远程对象。</p>
</blockquote>
<h1 id="第4章-线程"><a class="markdownIt-Anchor" href="#第4章-线程"></a> 第4章 线程</h1>
<h2 id="41-概述"><a class="markdownIt-Anchor" href="#41-概述"></a> 4.1 概述</h2>
<p>线程是CPU使用的基本单元， 它由<strong>线程ID、程序计数器、寄存器集合和栈</strong>组成。它与属于同一进程的其他线程<strong>共享代码段、数据段和其他操作系统资源</strong>，如打开文件和信号。</p>
<p>线程是CPU使用的基本单位。</p>
<p>一个传统重量级（ heavyweight ）的进程只有单个控制线程。如果进程有多个控制线程， 那么它能同时做多个任务。图4.1 说明了传统单线程进程和多线程进程的差别。</p>
<p><img src="/posts/8ce3e425/image-20211114231912641.png" srcset="/img/loading.gif" lazyload alt="image-20211114231912641"></p>
<p><img src="/posts/8ce3e425/image-20220109131221489.png" srcset="/img/loading.gif" lazyload alt="image-20220109131221489"></p>
<h3 id="411-动机"><a class="markdownIt-Anchor" href="#411-动机"></a> 4.1.1 动机</h3>
<h3 id="412-优点"><a class="markdownIt-Anchor" href="#412-优点"></a> 4.1.2 优点</h3>
<p>多线程编程具有如下4个优点：</p>
<p>①<strong>响应度高：</strong> 如果对一个交互程序采用多线程， 那么即使其部分阻塞或执行较冗长的操作，该程序仍能继续执行，从而增加了对用户的响应程度。例如，多线程Web浏览器在用一个线程装入图像时，能通过另一个线程与用户交互。</p>
<p>②<strong>资源共享：</strong> 线程默认共享它们所属进程的内存和资源。代码和数据共享的优点是它能允许一个应用程序在同一地址空间有多个不同的活动线程。</p>
<p>③<strong>经济：</strong> 进程创建所需要的内存和资源的分配比较昂贵。由于线程能共享它们所属进程的资源，所以创建和切换线程会更为经济。</p>
<p>④<strong>多处理器体系结构的利用：</strong> 多线程的优点之一是能充分使用多处理器体系结构，以便每个进程能并行运行在不同的处理器上。不管有多少CPU， 单线程进程只能运行在一个CPU上。在多CPU上使用多线程加强了并发功能。</p>
<h3 id="413-线程与进程的比较"><a class="markdownIt-Anchor" href="#413-线程与进程的比较"></a> 4.1.3 线程与进程的比较</h3>
<ol>
<li>调度
<ul>
<li>同一进程的多线程间调度时，不引起进程的切换</li>
<li>不同进程的线程间调度，需要进程切换
<ul>
<li>线程上下文切换和进程上下问切换一个<strong>最主要的区别</strong>是线程的切换虚拟内存空间依然是相同的，但是进程切换是不同的。因此，进程切换需要切换页目录以使用新的地址空间。而线程切换不需要，</li>
</ul>
</li>
</ul>
</li>
<li>并发性<br>
一个进程的多个线程之间可并发执行</li>
<li>资源的拥有<br>
线程不拥有系统资源，不拥有代码段、数据段。</li>
</ol>
<h3 id="414-线程状态图"><a class="markdownIt-Anchor" href="#414-线程状态图"></a> 4.1.4 线程状态图</h3>
<p><img src="/posts/8ce3e425/image-20220109131828395.png" srcset="/img/loading.gif" lazyload alt="image-20220109131828395"></p>
<h2 id="42-多线程模型"><a class="markdownIt-Anchor" href="#42-多线程模型"></a> 4.2 多线程模型</h2>
<p>有两种不同方法来提供线程支持： 用户层的<strong>用户线程</strong>或内核层的<strong>内核线程</strong>。</p>
<p>用户线程受内核支持， 而无须内核管理： 而内核线程由操作系统直接支持和管理。</p>
<h3 id="421-多对一模型"><a class="markdownIt-Anchor" href="#421-多对一模型"></a> 4.2.1 多对一模型</h3>
<p>多对一模型（见图4.2 ）将许多用户级线程映射到一个内核线程。</p>
<p><strong>优点</strong>：</p>
<ul>
<li>线程管理是由线程库在用户空间进行的， 因而效率比较高。</li>
</ul>
<p><strong>缺点</strong>：</p>
<ul>
<li>
<p>但是如果一个线程执行了阻塞系统调用，那么整个进程会阻塞。</p>
</li>
<li>
<p>而且， 因为任一时刻只有一个线程能访问内核， 多个线程不能并行运行在多处理器上。</p>
</li>
</ul>
<p><img src="/posts/8ce3e425/image-20211114232532605.png" srcset="/img/loading.gif" lazyload alt="image-20211114232532605"></p>
<h3 id="422-一对一模型"><a class="markdownIt-Anchor" href="#422-一对一模型"></a> 4.2.2 一对一模型</h3>
<p>一对一模型（见图4.3） 将每个用户线程映射到一个内核线程。</p>
<p><strong>优点</strong>：</p>
<ul>
<li>该模型在一个线程执行阻塞系统调用时， 能允许另一个线程继续执行， 所以它提供了比多对一模型更好的并发功能；</li>
<li>它也允许多个线程能并行地运行在多处理器系统上。</li>
</ul>
<p>这种模型的唯一<strong>缺点</strong>是：</p>
<ul>
<li>每创建一个用户线程就需要创建一个相应的内核线程。由于创建内核线程的开销会影响应用程序的性能， 所以这种模型的绝大多数实现限制了系统所支持的线程数</li>
</ul>
<p><img src="/posts/8ce3e425/image-20211114232838467.png" srcset="/img/loading.gif" lazyload alt="image-20211114232838467"></p>
<h3 id="423-多对多模型"><a class="markdownIt-Anchor" href="#423-多对多模型"></a> 4.2.3 多对多模型</h3>
<p>多对多模型（见图4.4） 多路复用了许多用户线程到同样数量或更小数量的内核线程上。内核线程的数量可能与特定应用程序或特定机器有关（位于多处理器上的应用程序可比单处理器上分配更多数量的内核线程）。</p>
<p>虽然多对一模型允许开发人员创建任意多的用户线程， 但是因为内核只能一次调度一个线程， 所以并没有增加并发性。一对一模型提供了更大的并发性， 但是开发人员必须小心， 不要在应用程序内创建太多的线程（有时可能会限制创建线程的数量）。</p>
<p>多对多模型没有这两者的缺点：</p>
<ul>
<li>
<p>开发人员可创建任意多的用户线程，并且相应内核线程能在多处理器系统上并发执行。</p>
</li>
<li>
<p>而且，当一个线程执行阻塞系统调用时，内核能调度另一个线程来执行。</p>
</li>
</ul>
<p>一个流行的多对多模型的变种仍然多路复用了许多用户线程到同样数量或更小数量的内核线程上， 但也允许将一个用户线程绑定到某个内核线程上。这个变种有时被称为二级模型（见图4.5）</p>
<p><img src="/posts/8ce3e425/image-20211114233616173.png" srcset="/img/loading.gif" lazyload alt="image-20211114233616173"></p>
<h2 id="43-线程库"><a class="markdownIt-Anchor" href="#43-线程库"></a> 4.3 线程库</h2>
<p>线程库为程序员提供创建和管理线程的API。</p>
<p>主要有两种方法来实现线程库。</p>
<ul>
<li>第一种方法是在用户空间中提供一个没有内核支持的库， 此库的所有代码和数据结构都存在于用户空间中。调用库中的一个函数只是导致了用户空间中的一个本地函数调用， 而不是系统调用。</li>
<li>第二种方法是执行一个由操作系统直接支持的内核级的库。此时，库的代码和数据结构存在于内核空间中。调用库中的一个API 函数通常会导致对内核的系统调用。</li>
</ul>
<h2 id="47-习题"><a class="markdownIt-Anchor" href="#47-习题"></a> 4.7 习题</h2>
<p><strong>4.1 举两个多线程程序设计的例子， 其中多线程的性能比单线程的性能差。</strong></p>
<p><strong>4.2 描述线程库进行用户级线程上下文切换的过程所采取的措施。</strong></p>
<blockquote>
<p>用户线程之间的上下文切换与内核线程之间的切换非常相似，尽管它取决于线程库以及它如何将用户线程映射到内核线程。一般来说，用户线程之间的上下文切换涉及获取其LWP的一个用户线程并用另一个线程替换它。此操作通常涉及保存和恢复寄存器的状态。</p>
</blockquote>
<p><strong>4.3 在什么环境中， 采用多内核线程的多线程方法比单处理器系统的单线程提供更好的性能？</strong></p>
<blockquote>
<p>当一个内核线程出现页面错误时，可以切换另一个内核线程，以一种有用的方式使用交织时间。</p>
<p>另一方面，当发生页面错误时，单线程进程将无法执行有用的工作。因此，在程序可能经常出现页面错误或必须等待其他系统事件的情况下，多线程解决方案甚至在单处理器系统上也会表现得更好</p>
</blockquote>
<p><strong>4.4 在多线程进程中， 下列哪些程序状态组成被共享？</strong><br>
<strong>a. 寄存器值</strong><br>
<strong>b. 堆内存</strong><br>
<strong>c. 全局变量</strong><br>
<strong>d. 栈内存</strong></p>
<blockquote>
<p>一个线程程序的线程共享<strong>堆内存</strong>和<strong>全局变量</strong>，但每个线程都有属于自己的一组<strong>寄存器值</strong>和<strong>栈内存</strong>。</p>
</blockquote>
<p><strong>4.5 使用多用户线程的多线程解决方案，在多处理器系统中可以比在单处理器系统中获得更好的性能吗？</strong></p>
<blockquote>
<p>一个包括多用户线程的多线程系统无法在多处理系统上同时使用不同的处理器。操作系统只能看到一个单一的进程且不会调度在不同处理器的不同进程的线程。<br>
因此， 多处理器系统执行多个用户线程是没有性能优势的。</p>
</blockquote>
<p><strong>4.6 如4.5.2小节所介绍，Linux并不区分进程和线程，而是将两者同样对待，将一个任务视为进程或线程， 这取决于传递给clone（）系统调用的标志集。然而， 许多操作系统， 如Windows XP和Solaris,对待进程和线程是不一样的。通常， 这类系统使用标记， 其中进程的数据结构中包含指向属于进程的不同线程。试在内核中比较这两种对进程和线程建模的方法。</strong></p>
<h1 id="第5章-cpu调度"><a class="markdownIt-Anchor" href="#第5章-cpu调度"></a> 第5章 CPU调度</h1>
<h2 id="51-基本概念"><a class="markdownIt-Anchor" href="#51-基本概念"></a> 5.1 基本概念</h2>
<p>多道程序的目标是在任何时候都有某些进程在运行，以使CPU使用率最大化。多道程序的思想较为简单。进程执行直到它必须等待， 通常等待某些I/O请求的完成。</p>
<p>当一个进程必须等待时， 操作系统会从该进程拿走CPU 的使用权，·而将CPU交给其他进程， 如此继续。在该进程必须等待的时间内，另一个进程就可以拿走CPU的使用权。</p>
<h3 id="511-cpu-io区间周期"><a class="markdownIt-Anchor" href="#511-cpu-io区间周期"></a> 5.1.1 CPU-I/O区间周期</h3>
<p>CPU的成功调度依赖于进程的如下属性：进程执行由CPU执行和I/O等待周期组成。进程在这两个状态之间切换。</p>
<h3 id="512-cpu调度程序"><a class="markdownIt-Anchor" href="#512-cpu调度程序"></a> 5.1.2 CPU调度程序</h3>
<p>每当CPU空闲时，操作系统就必须从就绪队列中选择一个进程来执行。进程选择由短期调度程序（ short-termscheduler）或CPU调度程序执行。调度程序从内存中选择一个能够执行的进程，并为之分配CPU。</p>
<h3 id="513-抢占调度"><a class="markdownIt-Anchor" href="#513-抢占调度"></a> 5.1.3 抢占调度</h3>
<p>CPU调度决策可在如下4种环境下发生：</p>
<ul>
<li>当一个进程从运行状态切换到等待状态（例如，I/O请求，或调用wait等待一个子进程的终止〉。</li>
<li>当一个进程从运行状态切换到就绪状态（例如， 当出现中断时）。</li>
<li>当一个进程从等待状态切换到就绪状态（例如，I/O完成）。</li>
<li>当一个进程终止时。</li>
</ul>
<p>对于第1 和第4 两种情况， 没有选择而只有调度。一个新进程（如果就绪队列中已有一个进程存在〉必须被选择执行。不过， 对于第2 和第3 两种情况， 可以进行选择。</p>
<p>当调度只能发生在第1 和第4 两种情况下时，称调度方案是<strong>非抢占的</strong>（ nonpreemptive)的或协作的（ cooperative）：否则， 称调度方案是<strong>抢占的</strong>（preemptive）。采用非抢占调度，一旦CPU 分配给一个进程，那么该进程会一直使用CPU 直到进程终止或切换到等待状态。</p>
<h3 id="514-分派程序"><a class="markdownIt-Anchor" href="#514-分派程序"></a> 5.1.4 分派程序</h3>
<p>分派程序是一个模块，用来将CPU 的控制交给由短期调度程序选择的进程。其功能包括：</p>
<ul>
<li>切换上下文。</li>
<li>切换到用户模式。</li>
<li>跳转到用户程序的合适位置， 以重新启动程序。</li>
</ul>
<p>分派程序应尽可能快， 因为在每次进程切换时都要使用。分派程序停止一个进程而启动另一个所要花的时间称为分派延迟（dispatch latency）。</p>
<h2 id="52-调度准则"><a class="markdownIt-Anchor" href="#52-调度准则"></a> 5.2 调度准则</h2>
<ul>
<li><strong>CPU 使用率</strong>： 需要使CPU 尽可能忙。从概念上讲， CPU 使用率从0%～100%。对于真实系统， 它应从40% C轻负荷系统）～90%（重负荷系统）。</li>
<li><strong>吞吐量</strong>：如果CPU 忙于执行进程，那么就有工作在完成。一种测量工作量的方法称为在吞吐量， 它指一个时间单元内所完成进程的数量。对于长进程，吞吐量可能为每小时一个进程：对于短进程， 吞吐量可能为每秒10 个进程。</li>
<li><strong>周转时间</strong>：从一个特定进程的角度来看， 一个重要准则是运行该进程需要多长时间。从进程提交到进程完成的时间段称为周转时间。周转时间为所有时间段之和， 包括等待进入内存、在就绪队列中等待、在CPU 上执行和I/O执行。</li>
<li><strong>等待时间</strong>： CPU 调度算法并不影响进程运行和执行I/O的时间： 它只影响进程在就绪队列中等待所花的时间。等待时间为在就绪队列中等待所花费时间之和。</li>
<li><strong>响应时间</strong>： 对于交互系统， 周转时间并不是最佳准则。通常， 进程能相当早就产生输出， 并继续计算新结果同时输出以前的结果给用户。因此， 另一时间是从提交请求到产生第一响应的时间。这种时间称为响应时间， 是开始响应所需要的时间， 而不是输出响应所需要的时间。周转时间通常受输出设备速度的限制。</li>
</ul>
<p>需要使CPU 使用率和吞吐量最大化，而使周转时间、等待时间和响应时间最小化。</p>
<h2 id="53-调度算法"><a class="markdownIt-Anchor" href="#53-调度算法"></a> 5.3 调度算法</h2>
<h3 id="531-先到先服务调度fcfs"><a class="markdownIt-Anchor" href="#531-先到先服务调度fcfs"></a> 5.3.1 先到先服务调度（FCFS）</h3>
<p><strong>first-come，first-served</strong></p>
<p>先请求CPU 的进程先分配到CPU。</p>
<p>FCFS是非抢占的</p>
<p><img src="/posts/8ce3e425/image-20211103111439645.png" srcset="/img/loading.gif" lazyload alt="image-20211103111439645"></p>
<h3 id="532-最短作业优先调度sjf"><a class="markdownIt-Anchor" href="#532-最短作业优先调度sjf"></a> 5.3.2 最短作业优先调度(SJF)</h3>
<p><strong>shortest job-first (SJF) scheduling algorithm</strong></p>
<p>这一算法将每个进程与其下一个CPU 区间段相关联。当CPU 为空闲时，它会赋给具有最短CPU 区间的进程。</p>
<p><img src="/posts/8ce3e425/image-20211103112112804.png" srcset="/img/loading.gif" lazyload alt="image-20211103112112804"></p>
<p>SJF 调度算法可证明为最佳的， 这是因为对于给定的一组进程， SJF 算法的平均等待时间最小。</p>
<p>SJF调度经常用于长期调度。</p>
<p>对于短期调度，一种方法是使用近似SJF调度，虽然不知道下一个CPU区间的长度，但是可以预测它。认为下一个CPU区间的长度与以前的相似。下一个CPU区间通常可预测为以前CPU区间的测量长度的指数平均。</p>
<p>SJF 算法可能是抢占的或非抢占的。</p>
<p>抢占SJF 调度有时称为<strong>最短剩余时间优先调度</strong>（shortest-remaining-time-first scheduling）。</p>
<p><img src="/posts/8ce3e425/image-20211103113129077.png" srcset="/img/loading.gif" lazyload alt="image-20211103113129077"></p>
<h3 id="533-优先级调度"><a class="markdownIt-Anchor" href="#533-优先级调度"></a> 5.3.3 优先级调度</h3>
<p><strong>priority scheduling algorithm</strong></p>
<p>每个进程都有一个优先级与其关联，具有最高优先级的进程会分配到CPU。具有相同优先级的进程按FCFS 顺序调度。SJF 算法属于简单优先级算法，其优先级（p） 为下一个（预测的） CPU 区间的倒数。</p>
<p><img src="/posts/8ce3e425/image-20211103113523515.png" srcset="/img/loading.gif" lazyload alt="image-20211103113523515"></p>
<p>优先调度可以是<strong>抢占的或者非抢占</strong>的。当一个进程到达就绪队列时， 其优先级与当前运行进程的优先级相比较。如果新到达进程的优先级高于当前运行进程的优先级，那么抢占优先级调度算法会抢占CPU。而非抢占优先级调度算法只是将新进程加到就绪队列的头部。</p>
<p>优先级调度算法的一个主要问题是<strong>无穷阻塞</strong>（indefinite blocking）或饥饿（ starvation）。可以运行但缺乏CPU 的进程可认为是阻塞的，它在等待CPU。优先级调度算法会使某个低优先级进程无穷等待CPU。</p>
<p>低优先级进程无穷等待问题的解决之一是<strong>老化</strong>（aging）。老化是一种技术，以逐渐增加在系统中等待很长时间的进程的优先级。</p>
<h3 id="534-轮转法调度rr"><a class="markdownIt-Anchor" href="#534-轮转法调度rr"></a> 5.3.4 轮转法调度(RR)</h3>
<p>轮转法（round-robin, RR） 调度算法是专门为分时系统设计的。它类似于FCFS 调度，但是增加了抢占以切换进程。定义一个较小时间单元称为时间片（ time quantun, or time slice)。时间片通常为10~100ms。将就绪队列作为循环队列。CPU调度程序循环就绪队列为每个进程分配不超过ー个时间片的CPU。</p>
<p><img src="/posts/8ce3e425/image-20211103114645373.png" srcset="/img/loading.gif" lazyload alt="image-20211103114645373"></p>
<p>RR算法的性能很大程度上依赖于时间片的大小。在极端情况下，如果时间片非常大，那么RR算法与FCFS算法一样，如果时间片很小(如1ms):那么RR算法称为处理器共享。</p>
<h3 id="535-多级队列调度"><a class="markdownIt-Anchor" href="#535-多级队列调度"></a> 5.3.5 多级队列调度</h3>
<p><strong>多级队列调度算法</strong>（multilevel queue scheduling algorithm）将就绪队列分成多个独立队列（见图5.6〕。根据进程的属性， 如内存大小、进程优先级、进程类型， 一个进程被永久地分配到一个队列。每个队列有自己的调度算法。例如， 前台进程和后台进程可处于不同队列。前台队列可能采用RR 算法调度， 而后台队列可能采用FCFS 算法调度。</p>
<p><img src="/posts/8ce3e425/image-20220109135201389.png" srcset="/img/loading.gif" lazyload alt="image-20220109135201389"></p>
<p>另外， 队列之间必须有调度， 通常采用固定优先级抢占调度。例如， 前台队列可以比后台队列具有绝对的优先级。且是抢占式的。</p>
<p>另一种可能是在队列之间划分时间片。每个队列都有一定的CPU时间，这可用于调度队列内的进程。例如， 对于前台－后台队列的例子， 前台队列可以有80%的CPU时间用于在进程之间进行RR调度， 而后台队列可以有20%的CPU时间采用FCFS算法调度进程。</p>
<p>优点是低调度开销， 缺点是不够灵活</p>
<h3 id="536-多级反馈队列调度"><a class="markdownIt-Anchor" href="#536-多级反馈队列调度"></a> 5.3.6 多级反馈队列调度</h3>
<p><strong>多级反馈队列调度算法</strong>（multilevelfeedback queue scheduling a lgorithm）允许进程在队列之间移动。主要思想是根据不同CPU区间的特点以区分进程。如果进程使用过多CPU时间， 那么它会被转移到更低优先级队列。这种方案将I/O约束和交互进程留在更高优先级队列。此外， 在较低优先级队列中等待时间过长的进程会被转移到更高优先级队列。这种形式的老化阻止饥饿的发生。</p>
<p><img src="/posts/8ce3e425/image-20220109135218552.png" srcset="/img/loading.gif" lazyload alt="image-20220109135218552"></p>
<h2 id="54-多处理器调度"><a class="markdownIt-Anchor" href="#54-多处理器调度"></a> 5.4 多处理器调度</h2>
<h3 id="541-多处理器调度的方法"><a class="markdownIt-Anchor" href="#541-多处理器调度的方法"></a> 5.4.1 多处理器调度的方法</h3>
<p>一种是种<strong>非对称多处理</strong>（asymmetric multiprocessing）方法。是让一个处理器（主服务器）处理所有的调度决定、I/O处理以及其他系统活动， 其他的处理器只执行用户代码。</p>
<p>另一种方法是使用<strong>对称多处理</strong>（ symmetric multiprocessing, <strong>SMP</strong>）方法， 即每个处理器自我调度。所有进程可能处于一个共同的就绪队列中， 或每个处理器都有它自己的私有就绪进程队列。无论如何，调度通过每个处理器检查共同就绪队列并选择一个进程来执行。</p>
<h3 id="542-处理器亲和性"><a class="markdownIt-Anchor" href="#542-处理器亲和性"></a> 5.4.2 处理器亲和性</h3>
<p>处理器亲和性有几种形式。当一个操作系统具有设法让一个进程保持在同一个处理器上运行的策略， 但不能做任何保证时， 则会出现<strong>软亲和性</strong>（ soft affinity ）。 此时， 进程可能在处理器之间移动。有些系统， 如Linux， 还提供一个支持<strong>硬亲和性</strong>（ hard affinity） 的系统调用， 从而允许进程指定它不允许移至其他处理器上。</p>
<h3 id="543-负载平衡"><a class="markdownIt-Anchor" href="#543-负载平衡"></a> 5.4.3 负载平衡</h3>
<h3 id="544-对称多线程"><a class="markdownIt-Anchor" href="#544-对称多线程"></a> 5.4.4 对称多线程</h3>
<h2 id="55-线程调度"><a class="markdownIt-Anchor" href="#55-线程调度"></a> 5.5 线程调度</h2>
<h3 id="551-竞争范国"><a class="markdownIt-Anchor" href="#551-竞争范国"></a> 5.5.1 竞争范国</h3>
<h3 id="552-pthread调度"><a class="markdownIt-Anchor" href="#552-pthread调度"></a> 5.5.2 Pthread调度</h3>
<h2 id="56-操作系统实例"><a class="markdownIt-Anchor" href="#56-操作系统实例"></a> 5.6 操作系统实例</h2>
<h3 id="561-实例solaris调度"><a class="markdownIt-Anchor" href="#561-实例solaris调度"></a> 5.6.1 实例：Solaris调度</h3>
<h3 id="562-实例windows-xp调度"><a class="markdownIt-Anchor" href="#562-实例windows-xp调度"></a> 5.6.2 实例：Windows XP调度</h3>
<h3 id="563-实例linux调度"><a class="markdownIt-Anchor" href="#563-实例linux调度"></a> 5.6.3 实例：Linux调度</h3>
<h2 id="57-算法评估"><a class="markdownIt-Anchor" href="#57-算法评估"></a> 5.7 算法评估</h2>
<h3 id="571-确定模型"><a class="markdownIt-Anchor" href="#571-确定模型"></a> 5.7.1 确定模型</h3>
<p>一种类型的分析评估是确定模型法（ deterministic modeling）。这种方法采用特殊预先确定的负荷， 计算在给定负荷下每个算法的性能。</p>
<p>确定模型不但简单而且快速。它给出了数字， 以允许人们对算法进行比较。然而， 它要求输入为精确数字， 而且其答案只适用于这些情况。确定模型的主要用途在于描述调度算法和提供例子。</p>
<h3 id="572-排队模型"><a class="markdownIt-Anchor" href="#572-排队模型"></a> 5.7.2 排队模型</h3>
<p>知道了到达率和服务率， 可计算使用率、平均队列长度、平均等待时间等。这种研究称为排队网络分析（queueing-network analysis）。</p>
<p>作为一个例子， 设n为平均队列长度（不包括正在服务的进程）， w 为队列的平均等待时间，A为新进程到达队列的平均到达率（如每秒三个进程）。那么，在进程等待的W时间内， 则有λ ×w个新进程到达队列。如果系统处于稳定状态， 那么离开队列的进程的数量必须等于到达进程的数量。</p>
<p>因此，<strong>n ＝ λ × W</strong><br>
这一公式称为Little公式。Little 公式特别有用， 因为它适用于任何调度算法和到达分布。</p>
<h3 id="573-模拟"><a class="markdownIt-Anchor" href="#573-模拟"></a> 5.7.3 模拟</h3>
<p>为了获得更为精确的调度算法评估， 可使用模拟（simulation）。模拟涉及对计算机系统进行建模。软件数据结构表示系统的主要组成部分。模拟程序有一个变量以表示时钟；当该变量的值增加时， 模拟程序会修改系统状态以反映设备、进程和调度程序的活动。随着模拟程序的执行， 用以表示算法性能的统计数字可以被收集并打印出来。</p>
<h3 id="574-实现"><a class="markdownIt-Anchor" href="#574-实现"></a> 5.7.4 实现</h3>
<p>针对评估调度算法， 唯一完全精确的方法是对它进行编程， 将它放在操作系统内， 并观测它如何工作。这一方法将真实算法放入操作系统，然后在真实操作系统内进行评估。</p>
<h2 id="58-小结"><a class="markdownIt-Anchor" href="#58-小结"></a> 5.8 小结</h2>
<p>CPU 调度的任务是从就绪队列中选择一个等待进程，并为其分配CPU。CPU由调度程序分配给所选中的进程。</p>
<p>先到先服务（FCFS）调度是最简单的调度算法，但是它会让短进程等待非常长的进程。</p>
<p>最短作业优先（ SJF ）调度可证明是最佳的，它提供了最短平均等待时间。实现SJF 调度比较困难，因为预测下一个CPU区间的长度有难度。SJF算法是通用优先级调度算法（将CPU 简单地分配给具有最高优先级的进程〉的特例。优先级和SJF调度会产生饥饿。老化技术可阻止饥饿。</p>
<p>轮转法（RR）调度对于分时（交互〉系统更为合适。RR调度让就绪队列的第一个进程使用CPU 的q个时间单元，这里q是时间片。在q时间单元之后，如果该进程还没有释放CPU，那么它被抢占并放到就绪队列的尾部。该算法的主要问题是选择时间片。如果时间片太大， 那么RR调度就成了FCFS调度；如果时间片太小， 那么因上下文切换而引起的调度开销就过大。</p>
<p>FCFS算法是非抢占的，而RR算法是抢占的。SJF和优先级算法可以是抢占的，也可以是非抢占的。</p>
<p>多级队列调度算法允许多个不同算法用于各种类型的进程。最为常用的模型包括使用眼调度的前台交互队列，以及使用FCFS 调度的后台批处理队列。多级反馈队列调度算法允许进程在队列之间迁移。</p>
<p>许多当前的计算机系统支持多处理器， 井允许每个处理器独立地调度它自己。通常，每个处理器维护自己的私有进程（或线程）队列， 它们都可以运行。与多处理器调度相关<br>
的问题包括处理器亲和性和负载平衡。</p>
<p>如果操作系统在内核级支持线程， 那么必须调度线程而不是进程来执行。Solaris和Windows XP就是这样的系统， 它们采用抢占的、基于优先级的调度算法， 并支持实时线程。Linux进程调度也使用基于优先级算法， 并提供实时支持。这三种操作系统通常偏爱交互进程而不是批处理进程或CPU约束进程。</p>
<p>因为有多种不同的调度算法可用， 所以需要某种方法来选择它们。分析方法使用数学分析以确定算法性能。模拟方法通过对代表性的进程采用调度算法模拟并计算其性能来确定优劣。不过， 模拟最多也只是提供对真实系统性能的近似， 评估调度算法唯一可靠的技术是在真实系统上的实现算法并在真实环境中进行性能跟踪。</p>
<h2 id="59-习题"><a class="markdownIt-Anchor" href="#59-习题"></a> 5.9 习题</h2>
<p><strong>5.1 为什么对调度程序来说，区分I/O限制的程序和CPU 限制的程序是重要的？</strong></p>
<blockquote>
<p>I/O限制的程序有在运行I/O操作前只运行很少数量的计算机操作的性质。这种程序一般来说不会使用很多的CPU。 但是 CPU 限制的程序会利用整个的时间片，且不做任何阻碍I/O操作的工作。</p>
<p>I/O约束程序通常具有很多短CPU区间。CPU约束程序可能有少量的长CPU区间。</p>
<p>因此，通过给I/O限制的程序优先权和允许在CPU 限制的程序之前运行， 可以很好的利用计算机资源</p>
</blockquote>
<p><strong>5.4</strong></p>
<p><img src="/posts/8ce3e425/image-20211103122937119.png" srcset="/img/loading.gif" lazyload alt="image-20211103122937119"></p>
<p><img src="/posts/8ce3e425/image-20211103122955012.png" srcset="/img/loading.gif" lazyload alt="image-20211103122955012"></p>
<blockquote>
<p><strong>a. Gantt图</strong></p>
<p><img src="/posts/8ce3e425/image-20211103130642240.png" srcset="/img/loading.gif" lazyload alt="image-20211103130642240"></p>
<p><strong>b. 周转时间</strong></p>
<table>
<thead>
<tr>
<th></th>
<th style="text-align:center">FCFS</th>
<th style="text-align:center">SJF</th>
<th style="text-align:center">非抢占优先级</th>
<th style="text-align:center">RR</th>
</tr>
</thead>
<tbody>
<tr>
<td>P<sub>1</sub></td>
<td style="text-align:center">10</td>
<td style="text-align:center">19</td>
<td style="text-align:center">16</td>
<td style="text-align:center">19</td>
</tr>
<tr>
<td>P<sub>2</sub></td>
<td style="text-align:center">11</td>
<td style="text-align:center">1</td>
<td style="text-align:center">1</td>
<td style="text-align:center">2</td>
</tr>
<tr>
<td>P<sub>3</sub></td>
<td style="text-align:center">13</td>
<td style="text-align:center">4</td>
<td style="text-align:center">18</td>
<td style="text-align:center">7</td>
</tr>
<tr>
<td>P<sub>4</sub></td>
<td style="text-align:center">14</td>
<td style="text-align:center">2</td>
<td style="text-align:center">19</td>
<td style="text-align:center">4</td>
</tr>
<tr>
<td>P<sub>5</sub></td>
<td style="text-align:center">19</td>
<td style="text-align:center">9</td>
<td style="text-align:center">6</td>
<td style="text-align:center">14</td>
</tr>
</tbody>
</table>
<p><strong>c. 等待时间</strong></p>
<table>
<thead>
<tr>
<th></th>
<th style="text-align:center">FCFS</th>
<th style="text-align:center">SJF</th>
<th style="text-align:center">非抢占优先级</th>
<th style="text-align:center">RR</th>
</tr>
</thead>
<tbody>
<tr>
<td>P<sub>1</sub></td>
<td style="text-align:center">0</td>
<td style="text-align:center">9</td>
<td style="text-align:center">6</td>
<td style="text-align:center">9</td>
</tr>
<tr>
<td>P<sub>2</sub></td>
<td style="text-align:center">10</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">1</td>
</tr>
<tr>
<td>P<sub>3</sub></td>
<td style="text-align:center">11</td>
<td style="text-align:center">2</td>
<td style="text-align:center">16</td>
<td style="text-align:center">5</td>
</tr>
<tr>
<td>P<sub>4</sub></td>
<td style="text-align:center">13</td>
<td style="text-align:center">1</td>
<td style="text-align:center">18</td>
<td style="text-align:center">3</td>
</tr>
<tr>
<td>P<sub>5</sub></td>
<td style="text-align:center">14</td>
<td style="text-align:center">4</td>
<td style="text-align:center">2</td>
<td style="text-align:center">9</td>
</tr>
</tbody>
</table>
<p><strong>d.</strong> <strong>平均等待时间</strong></p>
<p>​	FCFS=(0+10+11+13+14)/5=48/5=9.6</p>
<p>​	SJF=(9+0+2+1+4)/5=3.2</p>
<p>​	非抢占优先级=(6+0+16+18+2)/5=8.4</p>
<p>​	RR=(9+1+5+3+9)/5=5.4</p>
<p>​	平均等待时间最短的是SJF调度算法。</p>
</blockquote>
<p><strong>5.5</strong></p>
<p><img src="/posts/8ce3e425/image-20211103123014862.png" srcset="/img/loading.gif" lazyload alt="image-20211103123014862"></p>
<blockquote>
<p>b和d.    最短作业优先调度和优先级调度算法都会引起饥饿</p>
</blockquote>
<p><strong>5.7</strong></p>
<p><img src="/posts/8ce3e425/image-20211103123055446.png" srcset="/img/loading.gif" lazyload alt="image-20211103123055446"></p>
<blockquote>
<p><strong>a. 时间片是1ms：</strong></p>
<p>不论是哪个进程被调度，这个调度都会为每一次的上下文切换花费一个0.1ms的上下文切换。</p>
<p>CPU的利用率是1/1.1*100%=92%</p>
<p><strong>b. 时间片是10秒：</strong></p>
<p>这I/O限制任务会在使用完1ms时间片后进行一次上下文切换。这个时间片要求在所有的进程间都走一遍，因此，10*1.1+10.1(因为每个1/0限定任务执行为1毫秒，然后承担上下文切换的任务，而CPU限制任务的执行10毫秒在承担一个上下文切换之前）。</p>
<p>因此，CPU的利用率是20/21.1*100=94%</p>
</blockquote>
<p>5.9 考虑下面的动态改变优先级的抢占式优先级调度算法。 大的优先级数代表高优先级。 当一个进程在等待CPU时（在就绪队列中，但没执行）， 优先级以α速率改变： 当它运行时，优先级以β速率改<br>
变。 所有的进程在进入等待队列时指定优先级为0。 参数α和β可以进行设定得到许多不同的调度算法。<br>
a. β&gt;α&gt;0是什么算法？<br>
b. α&lt;β&lt;0是什么算法？</p>
<blockquote>
<p>a. FCFS</p>
<p>b. FIFO</p>
</blockquote>
<p><strong>5.11</strong></p>
<p><img src="/posts/8ce3e425/image-20211103123112891.png" srcset="/img/loading.gif" lazyload alt="image-20211103123112891"></p>
<blockquote>
<p>a: 26</p>
<p>b: 8</p>
<p>c: 14</p>
</blockquote>
<p><strong>5.10 解释下面调度算法对短进程偏好程度上的区别：</strong><br>
<strong>a. FCFS</strong><br>
<strong>b. RR</strong><br>
<strong>c. 多级反馈队列</strong></p>
<blockquote>
<p>a. FCFS一一区别短任务是因为任何在长任务之后到达的短任务部将会有很长的等待时间.<br>
b. RR一一对所有的任务都是能够相同的（给它们相同的CPU 时间区间），所以，短任务可以很快的离开系统， 只要它们可以先完成．<br>
c . 多级反馈队列和RR 调度算法相似一一它们不会先选择短任务。</p>
</blockquote>
<h1 id="第6章进程同步"><a class="markdownIt-Anchor" href="#第6章进程同步"></a> 第6章进程同步</h1>
<h2 id="61-背景"><a class="markdownIt-Anchor" href="#61-背景"></a> 6.1 背景</h2>
<p>允许两个进程并发操作变量counter会得到不正确的状态。</p>
<p>多个进程并发访问和操作同一数据且执行结果与访问发生的特定顺序有关， 称为竞争条件（race condition）。为了避免竞争条件， 需要确保一段时间内只有一个进程能操作变量counter。为了实现这种保证， 要求进行一定形式的进程同步。</p>
<h2 id="62-临界区问题"><a class="markdownIt-Anchor" href="#62-临界区问题"></a> 6.2 临界区问题</h2>
<p>每个进程有一个代码段称为<strong>临界区</strong>（critical section）， 在该区中进程可能改变共同变量、更新一个表、写一个文件等。</p>
<p>这种系统的<strong>重要特征</strong>是当一个进程进入临界区， 没有其他进程可被允许在临界区内执行， 即没有两个进程可同时在临界区内执行。</p>
<p><strong>临界区问题</strong>(critical-section problem ） 是设计一个以便进程协作的协议。每个进程必须请求允许进入其<strong>临界区</strong>。实现这一请求的代码段称为<strong>进入区</strong>（entry section）， 临界区之后可有<strong>退出区</strong>（exit section）， 其他代码为剩余区（remainder section）。</p>
<p><img src="/posts/8ce3e425/image-20211116161533895.png" srcset="/img/loading.gif" lazyload alt="image-20211116161533895"></p>
<p>临界区问题的解答必须满足如下三项要求：</p>
<ul>
<li>
<p><strong>互斥</strong>（mutual exclusion）： 如果进程P<sub>i</sub>在其临界区内执行， 那么其他进程都不能在其临界区内执行。</p>
</li>
<li>
<p><strong>有空让进</strong>（progress）： 如果没有进程在其临界区内执行，且有进程需进入临界区，那么只有那些不在剩余区内执行的进程可参加选择， 以确定谁能下一个进入临界区， 且这种选择不能无限推迟。</p>
<p>当没有进程在互斥区时，任何有权使用互斥区的进程可进入。</p>
</li>
<li>
<p><strong>有限等待</strong>(bounded waiting）：任何进入互斥区的要求应在有限的时间内得到满足.</p>
</li>
</ul>
<h2 id="63-peterson算法"><a class="markdownIt-Anchor" href="#63-peterson算法"></a> 6.3 Peterson算法</h2>
<p>变量 turn表示哪个进程可以进入其临界区。即如果 turn==i， 那么进程 P<sub>i</sub>允许在其临界区内执行。数组 flag 表示哪个进程想要进入其临界区。</p>
<p><img src="/posts/8ce3e425/image-20211116161739706.png" srcset="/img/loading.gif" lazyload alt="image-20211116161739706"></p>
<h2 id="630-面包师算法"><a class="markdownIt-Anchor" href="#630-面包师算法"></a> 6.3.0 面包师算法</h2>
<p>面包师算法是n个进程进入临界区问题的算法</p>
<ul>
<li>在进入临界区前，进程接收一个数字，最小数字的持有者进入临界区</li>
<li>如果Pi和Pj接收到了同样的数字，而且如果i &lt; j，那么Pi 先得到服务。</li>
</ul>
<p><img src="/posts/8ce3e425/image-20211116161850602.png" srcset="/img/loading.gif" lazyload alt="image-20211116161850602"></p>
<p><img src="/posts/8ce3e425/image-20211116161908057.png" srcset="/img/loading.gif" lazyload alt="image-20211116161908057"></p>
<h2 id="64-硬件同步"><a class="markdownIt-Anchor" href="#64-硬件同步"></a> 6.4 硬件同步</h2>
<p><strong>TestAndSet()</strong></p>
<p><img src="/posts/8ce3e425/image-20220109162023500.png" srcset="/img/loading.gif" lazyload alt="image-20220109162023500"></p>
<p>TS的逻辑：<br>
如果测试值为false，则返回false，并把测试值置为true。<br>
如果测试值为true，则返回true，测试值仍然为true。</p>
<p>Lock为FALSE，则马上结束空循环；如果Lock为TRUE，则一直空循环，直到别的进程把Lock改为FALSE</p>
<p><strong>Swap()</strong></p>
<p><img src="/posts/8ce3e425/image-20211116162152258.png" srcset="/img/loading.gif" lazyload alt="image-20211116162152258"></p>
<p>如果别的进程把lock设置为flase，则经过Swap交换之后，Key会等于false ，这意味着已经没有一个进程处于CS</p>
<p><strong>上面两种算法解决了互斥，未解决有限等待</strong></p>
<p>下面的算法满足临界区三个要求：</p>
<p>boolean waiting[n];<br>
boolean lock;</p>
<p>这些数据结构均初始化false。</p>
<p><img src="/posts/8ce3e425/image-20211116162305381.png" srcset="/img/loading.gif" lazyload alt="image-20211116162305381"></p>
<ul>
<li>
<p>互斥</p>
<p>为了证明满足互斥要求，注意，只有waiting[i]==false 或key==flase 时， 进程P<sub>i</sub> 才进入临界区。只有当TestAndSet执行时， key的值才变成false。执行TestAndSet的第一个进程会发现key==false；所有其他进程必须等待。只有其他进程离开其临界区时，变量waiting[i］的值才能变成false：每次只有一个waiting[i］被设置为false,以满足互斥要求。</p>
</li>
<li>
<p>有空让进</p>
<p>任何一个已经进入CS的进程在“exit section” 时，设置：lock =false 或 waiting[ j ]= false，确保了至少可以让一个进程进入CS</p>
</li>
<li>
<p>有限等待条件</p>
<p>任何一个已经进入CS的进程Pi在“exit section” 时， 将会依次扫描waiting 数组（i+1,i+2,…n-1,0,…i-1)，并仅将Pi后面最先找到的进程j的waiting[ j]设置为false</p>
<p>这就使进程能依此循环进入CS</p>
</li>
</ul>
<p><strong>硬件指令实现的缺点</strong></p>
<ul>
<li>硬件指令虽然可以有效地保证进程间互斥，但有一个缺点，就是当进程正在临界段中执行时，其它想进入临界段的进程必须不断地测试布尔变量lock的值，这就造成了处理机机时的浪费，我们常称这种情况为“忙等待”</li>
<li>可能“饥饿”<strong>：<strong>如果从等待进程中随机选择一个进入临界区</strong>，<strong>有的进程可能一直选不上</strong>。</strong></li>
</ul>
<h2 id="65-信号量"><a class="markdownIt-Anchor" href="#65-信号量"></a> 6.5 信号量</h2>
<p>信号量S是个整数变量，除了初始化外，它只能通过两个标准原子操作：wait()和signal()来访问。</p>
<p><img src="/posts/8ce3e425/image-20211116162927219.png" srcset="/img/loading.gif" lazyload alt="image-20211116162927219"></p>
<h3 id="651-用法"><a class="markdownIt-Anchor" href="#651-用法"></a> 6.5.1 用法</h3>
<p><img src="/posts/8ce3e425/image-20211116163758185.png" srcset="/img/loading.gif" lazyload alt="image-20211116163758185"></p>
<h3 id="652-实现"><a class="markdownIt-Anchor" href="#652-实现"></a> 6.5.2 实现</h3>
<p>信号量的主要缺点是都要求<strong>忙等待</strong>（busy waiting）。当一个进程位于其临界区内时， 任何其他试图进入其临界区的进程都必须在其进入代码中连续地循环。这种类型的信号量也称为<strong>自旋锁</strong>（spinlock）</p>
<p>为了克服忙等， 可以修改信号量操作wait()和signal()的定义。当一个进程执行wait()操作时， 发现信号量值不为正， 则它必须等待。然而， 该进程不是忙等而是阻塞自己。阻塞操作将一个进程放入到与信号量相关的等待队列中，井将该进程的状态切换成等待状态。接着， 控制转到CPU调度程序， 以选择另一个进程来执行。</p>
<p>一个被阻塞在等待信号量S上的进程，可以在其他进程执行signal()操作之后被重新执行。该进程的重新执行是通过wakeup()操作来进行的， 该操作将进程从等待状态切换到就绪状态。接着， 该进程被放入到就绪队列中（根据CPU调度算法的不同，CPU有可能会、也可能不会从正在运行的进程切换到刚刚就绪的进程）。</p>
<p><img src="/posts/8ce3e425/image-20211116164332005.png" srcset="/img/loading.gif" lazyload alt="image-20211116164332005"></p>
<p><img src="/posts/8ce3e425/image-20211116164343388.png" srcset="/img/loading.gif" lazyload alt="image-20211116164343388"></p>
<p><img src="/posts/8ce3e425/image-20211116165105798.png" srcset="/img/loading.gif" lazyload alt="image-20211116165105798"></p>
<h3 id="653-死锁与饥饿"><a class="markdownIt-Anchor" href="#653-死锁与饥饿"></a> 6.5.3 死锁与饥饿</h3>
<p><strong>死锁</strong>：两个或多个进程无限地等待一个事件，而该事件只能由这些等待进程之一来产生。这里的事件是signal()操作的执行。当出现这样的状态时， 这些进程就称为死锁（deadlocked）。</p>
<p><strong>无限期阻塞</strong>(indefinite blocking）或<strong>饥饿</strong>（starvation）：即进程在信号量内无限期等待。如果对与信号量相关的链表按LIFO顺序来增加和移动进程，<br>
那么可能会发生无限期阻塞。</p>
<h3 id="654-信号量小结"><a class="markdownIt-Anchor" href="#654-信号量小结"></a> 6.5.4 信号量小结</h3>
<ol>
<li>
<p><strong>信号量的物理含义：</strong></p>
<p>**S&gt;0：**表示有S个资源可用</p>
<p>**S=0：**表示无资源可用</p>
<p>**S&lt;0：**则|S|表示S等待队列中的进程个数</p>
<p>**P(S)：**表示申请一个资源</p>
<p>**V(S)：**表示释放一个资源。</p>
</li>
<li>
<p><strong>P.V操作必须成对出现，有一个P操作就一定有一个V操作</strong></p>
<p>当为<strong>互斥操作</strong>时，它们同处于同一进程</p>
<p>当为<strong>同步操作</strong>时，则不在同一进程中出现</p>
<p>如果P(S1)和P(S2)两个操作在一起，那么P操作的顺序至关重要,一个同步P操作与一个互斥P操作在一起时，同步P操作在互斥P操作前。</p>
<p>而两个V操作无关紧要</p>
</li>
<li>
<p><strong>P.V操作的优缺点</strong></p>
<ul>
<li>优点：简单，而且表达能力强（用P.V操作可解决任何同步互斥问题）</li>
<li>缺点：不够安全；P.V操作使用不当会出现死锁；遇到复杂同步互斥问题时实现复杂</li>
</ul>
</li>
</ol>
<p><strong>而两个V操作无关紧要</strong></p>
<h2 id="66-经典同步问题"><a class="markdownIt-Anchor" href="#66-经典同步问题"></a> 6.6 经典同步问题</h2>
<p>使用PV操作完成进程间的<strong>同步与互斥步骤</strong>：</p>
<ol>
<li>分析同步关系（制约关系）</li>
<li>设置信号量（一般情况下，有几项制约条件就应设置几个信号量）</li>
<li>选择并确定信号量的初值（初值和初始可用资源有关）</li>
<li>利用PV操作写出同步关系。</li>
</ol>
<h3 id="661-有限缓冲问题"><a class="markdownIt-Anchor" href="#661-有限缓冲问题"></a> 6.6.1 有限缓冲问题</h3>
<p><img src="/posts/8ce3e425/image-20211116164843159.png" srcset="/img/loading.gif" lazyload alt="image-20211116164843159"></p>
<p>下图会发生死锁，生产者一直等待</p>
<p><img src="/posts/8ce3e425/image-20211116165556108.png" srcset="/img/loading.gif" lazyload alt="image-20211116165556108"></p>
<h3 id="662-读者写者问题"><a class="markdownIt-Anchor" href="#662-读者写者问题"></a> 6.6.2 读者写者问题</h3>
<p><strong>制约条件分析：</strong></p>
<p>1、允许多个进程同时读文件（读－读允许）；<br>
2、不允许在进程读文件时让另外一进程去写文件；有进程在写文件时不让另外一个进程去读该文件（“读-写”互斥）；<br>
3、不允许多个写进程同时写同一文件（“写-写”互斥）。</p>
<h4 id="读者优先"><a class="markdownIt-Anchor" href="#读者优先"></a> <strong>读者优先：</strong></h4>
<p>只要不断的有读者来读，那么readcount就一直会大于0，那么永远不会触发signal(wrt)条件，从而导致写者饥饿。</p>
<p>该问题被称为第一读者优先问题</p>
<p><img src="/posts/8ce3e425/image-20211116170507558.png" srcset="/img/loading.gif" lazyload alt="image-20211116170507558"></p>
<h4 id="写者优先"><a class="markdownIt-Anchor" href="#写者优先"></a> <strong>写者优先:</strong></h4>
<p>1.写者线程的优先级高于读者线程。<br>
2.当写者到来时，只有那些已经获得授权的读进程才被允许完成它们的操作，写者之后到来的读者将被推迟，直到写者完成。<br>
3.当没有写者进程时读者进程应该能够同时读取文件。</p>
<p><strong>具体实现:</strong><br>
1.通过添加信号量<code>read</code>实现写者到来时能够阻止读者进程。<br>
2.设置信号量<code>fileSrc</code>实现读写者对临界资源的访问。<br>
3.设置计数器<code>writeCount</code>来统计当前阻塞的写者进程的数目，设置信号量<code>writeCountSignal</code>完成对<code>writeCount</code>计数器资源的互斥访问。<br>
4.设置计数器<code>readCount</code>来统计访问临界资源的读者数目，设置信号量<code>readCountSignal</code>完成对<code>readCount</code>计数器资源的互斥访问。</p>
<p><img src="/posts/8ce3e425/image-20211116170755343.png" srcset="/img/loading.gif" lazyload alt="image-20211116170755343"></p>
<h4 id="读者写者公平竞争"><a class="markdownIt-Anchor" href="#读者写者公平竞争"></a> 读者写者公平竞争：</h4>
<ol>
<li>优先级相同。</li>
<li>写者、读者互斥访问。</li>
<li>只能有一个写者访问临界区。</li>
<li>可以有多个读者同时访问临界资源。</li>
</ol>
<p><strong>具体实现:</strong></p>
<ol>
<li>设置<code>file</code>信号量实现对临界资源的互斥访问。</li>
<li>设置计数器<code>readCount</code>实现多个读者访问临界资源，通过设置信号量<code>readCountSignal</code>实现对<code>readCount</code>计数器的互斥访问。</li>
<li>设置信号量<code>keySignal</code>实现读者和写者的公平竞争（令牌）。</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter hljs hljs hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-comment">/* 读者队列初始值为0，其他资源初始值为1*/</span><br><span class="hljs-keyword">int</span> readCount = <span class="hljs-number">0</span>;<br>semaphore keySignal = <span class="hljs-number">1</span>;<br>semaphore fileSrc = <span class="hljs-number">1</span>;<br>semaphore readCountSignal = <span class="hljs-number">1</span>;<br><br><span class="hljs-built_in">reader</span>()<br>&#123;<br>    <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)<br>    &#123;<br>      <span class="hljs-built_in">wait</span>(keySignal);        <span class="hljs-comment">//申请令牌</span><br>      <span class="hljs-built_in">wait</span>(readCountSignal);  <span class="hljs-comment">//申请计数器资源</span><br>      <span class="hljs-keyword">if</span>(!readCount)          <span class="hljs-comment">//为零则申请文件资源</span><br>         <span class="hljs-built_in">wait</span>(fileSrc);<br>      readCount++;<br>      <span class="hljs-built_in">signal</span>(readCountSignal); <span class="hljs-comment">//释放计数器资源</span><br>      <span class="hljs-built_in">signal</span>(keySignal);      <span class="hljs-comment">//释放令牌</span><br> <br>      ...<br>      perform read operation  <span class="hljs-comment">//执行临界区代码</span><br>      ...<br>  <br>      <span class="hljs-built_in">wait</span>(readCountSignal);  <span class="hljs-comment">//申请计数器资源</span><br>      readCount--;<br>      <span class="hljs-keyword">if</span>(!readCount)                <span class="hljs-comment">//为零则释放文件资源</span><br>         <span class="hljs-built_in">signal</span>(fileSrc);<br>      <span class="hljs-built_in">signal</span>(readCountSignal); <span class="hljs-comment">//释放读者计数器资源</span><br>    &#125;<br>&#125;<br> <br><span class="hljs-built_in">writer</span>()<br>&#123;<br>     <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)<br>     &#123;<br>        <span class="hljs-built_in">wait</span>(keySignal);     <span class="hljs-comment">//申请令牌</span><br>        <span class="hljs-built_in">wait</span>(fileSrc);       <span class="hljs-comment">//申请文件资源</span><br> <br>        ...<br>        perform write operation <span class="hljs-comment">//执行临界区代码</span><br>        ...<br> <br>        <span class="hljs-built_in">signal</span>(fileSrc);   <span class="hljs-comment">//释放文件资源</span><br>        <span class="hljs-built_in">signal</span>(keysignal); <span class="hljs-comment">//释放令牌</span><br>     &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<h3 id="663-哲学家进餐回题"><a class="markdownIt-Anchor" href="#663-哲学家进餐回题"></a> 6.6.3 哲学家进餐回题</h3>
<p><img src="/posts/8ce3e425/image-20211116170946819.png" srcset="/img/loading.gif" lazyload alt="image-20211116170946819"></p>
<p><strong>死锁解决方法：</strong></p>
<ul>
<li>至多只允许四位哲学家同时去拿左边的筷子；</li>
<li>仅当哲学家左右两边的筷子均可用时才允许他拿起筷子；</li>
<li>规定奇数号哲学家先拿起他左边的筷子，而偶数号哲学家先拿起他右边的筷子。</li>
</ul>
<p><img src="/posts/8ce3e425/image-20211116171117548.png" srcset="/img/loading.gif" lazyload alt="image-20211116171117548"></p>
<p><img src="/posts/8ce3e425/image-20211116171127875.png" srcset="/img/loading.gif" lazyload alt="image-20211116171127875"></p>
<h2 id="611-习题"><a class="markdownIt-Anchor" href="#611-习题"></a> 6.11 习题</h2>
<p>**试解释为什么自旋锁对单处理器系统不合适而对多处理器系统合适。  **</p>
<blockquote>
<p>解答：<br>
自旋锁（进程在其等待锁时还在运行）的缺点是忙等待，当一个进程位于其临界区内时，任何其它试图进入其临界区的进程都必须在其进入代码中连续地循环。在单处理器系统中，忙等待浪费了CPU时钟（这些时钟本来可以有效地为其他进程所使用）。<br>
自旋锁的优点就是，进程在等待锁时不会进行上下文切换，而上下文切换可能需要花费相当长的时间。因此，如果锁的占用时间短，自旋锁就可以变得非常有用。它常常用于多处理器系统中，这样一个线程在一个处理器自旋时，另一线程可在另一处理器上在其临界区内执行。</p>
</blockquote>
<h3 id="信号量确定"><a class="markdownIt-Anchor" href="#信号量确定"></a> 信号量确定</h3>
<p><strong>设有N个进程共享一互斥段对如下两种情况</strong></p>
<ol>
<li><strong>每次只允许一个进程进入互斥段；</strong></li>
<li><strong>最多允许M个进程(M&lt;N)同时进入互斥段；所采用信号量是否相同？信号量值的初始值如何确定？变化范围如何？</strong></li>
</ol>
<blockquote>
<p>答：所采用的信号量相同，为mutex。<br>
第一种情况mutex初值为1，变化范围为－（N－1）&lt;mutex &lt;1<br>
的整数。<br>
第二种情况mutex初值为M，变化范围为 M–N &lt; mutex &lt; M的整<br>
数。</p>
</blockquote>
<h3 id="进程同步"><a class="markdownIt-Anchor" href="#进程同步"></a> 进程同步</h3>
<p><strong>试用信号量实现这三个进程的同步</strong></p>
<blockquote>
<p><img src="/posts/8ce3e425/image-20220109165911590.png" srcset="/img/loading.gif" lazyload alt="image-20220109165911590"></p>
</blockquote>
<p><strong>试用信号量实现这6个进程的同步。</strong></p>
<blockquote>
<p><img src="/posts/8ce3e425/image-20220109170141492.png" srcset="/img/loading.gif" lazyload alt="image-20220109170141492"></p>
</blockquote>
<h3 id="文件打印问题"><a class="markdownIt-Anchor" href="#文件打印问题"></a> 文件打印问题</h3>
<p><img src="/posts/8ce3e425/image-20220109170235648.png" srcset="/img/loading.gif" lazyload alt="image-20220109170235648"></p>
<blockquote>
<p><img src="/posts/8ce3e425/image-20220109170246580.png" srcset="/img/loading.gif" lazyload alt="image-20220109170246580"></p>
<p><img src="/posts/8ce3e425/image-20220109170253513.png" srcset="/img/loading.gif" lazyload alt="image-20220109170253513"></p>
</blockquote>
<h3 id="司机和售票员问题"><a class="markdownIt-Anchor" href="#司机和售票员问题"></a> 司机和售票员问题</h3>
<p><img src="/posts/8ce3e425/image-20220109170301130.png" srcset="/img/loading.gif" lazyload alt="image-20220109170301130"></p>
<blockquote>
<p><img src="/posts/8ce3e425/image-20220109170310637.png" srcset="/img/loading.gif" lazyload alt="image-20220109170310637"></p>
</blockquote>
<h3 id="阅览室问题"><a class="markdownIt-Anchor" href="#阅览室问题"></a> 阅览室问题</h3>
<p><img src="/posts/8ce3e425/image-20220109170320259.png" srcset="/img/loading.gif" lazyload alt="image-20220109170320259"></p>
<blockquote>
<p><img src="/posts/8ce3e425/image-20220109170330032.png" srcset="/img/loading.gif" lazyload alt="image-20220109170330032"><img src="/posts/8ce3e425/image-20220109170338052.png" srcset="/img/loading.gif" lazyload alt="image-20220109170338052"><img src="/posts/8ce3e425/image-20220109170431135.png" srcset="/img/loading.gif" lazyload alt="image-20220109170431135"></p>
</blockquote>
<h3 id="苹果橘子问题"><a class="markdownIt-Anchor" href="#苹果橘子问题"></a> 苹果橘子问题</h3>
<p><img src="/posts/8ce3e425/image-20220109170438876.png" srcset="/img/loading.gif" lazyload alt="image-20220109170438876"></p>
<blockquote>
<p><img src="/posts/8ce3e425/image-20220109170446193.png" srcset="/img/loading.gif" lazyload alt="image-20220109170446193"><img src="/posts/8ce3e425/image-20220109170455073.png" srcset="/img/loading.gif" lazyload alt="image-20220109170455073"></p>
</blockquote>
<h3 id="61"><a class="markdownIt-Anchor" href="#61"></a> <strong>6.1</strong></h3>
<blockquote>
<p>第一个著名的正确解决两个进程的临界区问题的软件方法是由Dekker设计的。两个进程P0和P1共享以下变量：</p>
<figure class="highlight c++"><table><tr><td class="gutter hljs hljs hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++">boolean flag[<span class="hljs-number">2</span>];<span class="hljs-comment">/*initially false*/</span><br><span class="hljs-keyword">int</span> turn;<br></code></pre></div></td></tr></table></figure>
<p>进程P<sub>i</sub> （i=0或1）的结构如下， 另一个进程为P<sub>j</sub> (j=0或1）。 试证明这个算法满足临界区问题的所有三个要求.</p>
<figure class="highlight c"><table><tr><td class="gutter hljs hljs hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-keyword">do</span> &#123; <br>	flag[i] = <span class="hljs-literal">true</span>; <br>	<span class="hljs-keyword">while</span> (flag[j]) &#123; <br>		<span class="hljs-keyword">if</span>(turn==j) &#123; <br>			flag[i] = <span class="hljs-literal">false</span>; <br>			<span class="hljs-keyword">while</span> (turn == j);<br>        <span class="hljs-comment">// do nothing </span><br>			flag[i] = <span class="hljs-literal">true</span>; <br>		&#125;<br>	&#125;<br>	<span class="hljs-comment">//critical section </span><br>	turn=j; <br>	flag[i] = <span class="hljs-literal">false</span>; <br>	<span class="hljs-comment">//remainder section</span><br>&#125;<span class="hljs-keyword">while</span> (TRUE); <br></code></pre></div></td></tr></table></figure>
</blockquote>
<p>满足三个条件：</p>
<p><strong>互斥</strong>:进程P<sub>i</sub>要进入临界区，必有flag[i]=true,flag[j]=false,此时进程P<sub>j</sub>无法进入临界区;如果flag[j]==true，且有turn==j,说明进程进程P<sub>j</sub>正在临界区内，那么P<sub>i</sub>则会进入自旋，直到进程P<sub>j</sub>运行完成，将flag[j]设置为false，然后轮到P<sub>i</sub>进入临界区。由此可知，互斥成立</p>
<p><strong>前进</strong>：和互斥的论证相同，如果flag[j]==true，且有turn==j,说明进程进程P<sub>j</sub>正在临界区内，那么P<sub>i</sub>则会进入自旋等待，直到进程P<sub>j</sub>运行完成，将turn设置为i,将flag[j]设置为false，然后P<sub>i</sub>就会结束自旋，进入临界区，满足前进。</p>
<p><strong>优先等待</strong>：当P<sub>j</sub>在临界区，而P<sub>i</sub>在等待时，之后P<sub>j</sub>退出临界区后，P<sub>i</sub>可以进入临界区，如果此时flag[j]再次变为true,即Pj和Pi企图竞争，我们就会发现因为此时的turn=i，所以Pj会进入自旋，并把flag[j]设置为false,这样Pi就可以进入临界区了，满足优先等待原则。</p>
<h3 id="62"><a class="markdownIt-Anchor" href="#62"></a> 6.2</h3>
<blockquote>
<p><img src="/posts/8ce3e425/image-20211113183219139.png" srcset="/img/loading.gif" lazyload alt="image-20211113183219139"></p>
<p><img src="/posts/8ce3e425/image-20211113183254084.png" srcset="/img/loading.gif" lazyload alt="image-20211113183254084"></p>
</blockquote>
<p>满足三个条件：</p>
<p><strong>互斥</strong>：注意到一个进程只有在下列条件满足时才能进入临界区域：没有其他进程在CS中有设置的标识变量，这是由于进程在CS中设置白身的标识变量之前要先检査其他进程的状态。我们保证没有两个进程将同时进入临界区。</p>
<p><strong>前进</strong>：考虑以下情況，当多进程同时在CS中设置它们的标识变量，然后检查是否有其他进程在s中设置标识变量。当这种情况发生时，所有的进程意识到这里存在进程争，在外层 while(1)的环下进入下一次送代，重置它们的标识变量到want中。现在只有唯一的进程将设置它的轮次受量到cs中，这个唯一的进程就是其序号是最接近轮次的。从这个角度来说，对于哪些序号次接近轮次的新的进程就能决定进入临界区域，而且能同时在CS中设置它们的标识。随后这些进程意识到这里存在竟争的进程，于是重新启动进入临界区域的进程。在每次送代中，进程在cs中设置的序号值将变得更加接近轮次，最后我们得出以下结论：只有进程k在cs中设置它的标识，而其他些序号在轮次和k之间不能在cs中设置它们的标识。这个进程仪能进入临界区域</p>
<p><strong>有限等待</strong>：有限等待需要满足以下事实：当进程k在打算进入临界区域时，它的标识不再置为空闲。任何序号不在轮次和k之间的进程不能进入临界区域。与此同时，所有序号落在轮次和k之回且又想要进入临界区域的进程能够进入临界区域（这是基于系统一直在进步的事实），这个轮次值变得越来越接近k。最后，要么轮次变为k,要么没有哪些序号在轮次和k之间的进程，这样进程k就进入临界区域了。</p>
<h3 id="63"><a class="markdownIt-Anchor" href="#63"></a> 6.3</h3>
<blockquote>
<p>术语忙等的含义是什么？</p>
<p>操作系统中其他类型的等待有哪些？</p>
<p>忙等能否完全避免？为什么？</p>
</blockquote>
<p>忙等：当一个进程位于其临界区内时， 任何其他试图进入其临界区的进程都必须在其进入代码中连续地循环。</p>
<p>操作系统里其他种类的等待有：等待I/O，等待信号被释放等等</p>
<p>忙等可以避免，可以采用将进程沉睡，在相应程序到达一定状态的时候再将其唤醒的方式来避免忙等。</p>
<h3 id="611-理发店问题"><a class="markdownIt-Anchor" href="#611-理发店问题"></a> 6.11 <strong>理发店问题</strong>。</h3>
<blockquote>
<p><strong>理发店问题</strong>。一家理发店有一间有n把椅子的等待室和一间有一把理发椅的理发室。如果没有顾客， 理发师就去睡觉。如果顾客来时所有的椅子都有人， 那么顾客将会离去。如果理发师在忙， 而又有空闲的椅子， 那么顾客会坐在其中一个空闲的椅子上。如果理发师在睡觉， 顾客会摇醒他。编写一个程序来协调理发师和顾客。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter hljs hljs hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c"><span class="hljs-keyword">int</span> waiting = <span class="hljs-number">0</span>; <span class="hljs-comment">// 等候理发师 顾客坐的椅子数</span><br><span class="hljs-keyword">int</span> CHAIRS = N;  <span class="hljs-comment">// 为顾客准备的椅子数</span><br>semaphore customers = <span class="hljs-number">0</span>; <span class="hljs-comment">// 等候的顾客数</span><br>semaphore barbers = <span class="hljs-number">0</span>;   <span class="hljs-comment">// 空闲的理发师数</span><br>semaphore mutex = <span class="hljs-number">1</span>;     <span class="hljs-comment">// 互斥信号量，保证waiting++操作完整进行</span><br><br><span class="hljs-function">cobegin</span><br><span class="hljs-function">process <span class="hljs-title">barber</span><span class="hljs-params">()</span> </span>&#123;  <span class="hljs-comment">// 理发师</span><br>    <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>) &#123;<br>        P(customers); <span class="hljs-comment">// 有顾客吗？若无顾客，理发师睡眠</span><br>        P(mutex);     <span class="hljs-comment">// 保证waiting--完整进行</span><br>        <span class="hljs-comment">// 若有顾客时，进入临界区</span><br>        waiting--;    <span class="hljs-comment">// 等候区顾客数减一</span><br>        V(barbers);   <span class="hljs-comment">// 理发师准备为顾客理发</span><br>        V(mutex);<br>        cut_hair();   <span class="hljs-comment">// 理发师正在理发（非临界区）</span><br>    &#125;<br>&#125;<br><br><span class="hljs-function">process <span class="hljs-title">customer_i</span><span class="hljs-params">()</span> </span>&#123;  <span class="hljs-comment">// 顾客</span><br>    P(mutex);     <span class="hljs-comment">// 进入临界区</span><br>    <span class="hljs-keyword">if</span>(waiting &lt; CHAIRS) &#123;  <span class="hljs-comment">// 有空椅子</span><br>        waiting++;    <span class="hljs-comment">// 等候顾客加一</span><br>        V(customers); <span class="hljs-comment">// 唤醒理发师</span><br>        V(mutex);     <span class="hljs-comment">// 退出临界区</span><br>        P(barbers);   <span class="hljs-comment">// 理发师忙，顾客坐下等待</span><br>        get_haircut();<span class="hljs-comment">// 否则顾客坐下理发</span><br>    &#125; <span class="hljs-keyword">else</span><br>        V(mutex);     <span class="hljs-comment">// 没椅子，顾客走人</span><br>&#125;<br>coend<br></code></pre></div></td></tr></table></figure>
<h3 id="无限缓冲的生产者和消费者"><a class="markdownIt-Anchor" href="#无限缓冲的生产者和消费者"></a> 无限缓冲的生产者和消费者</h3>
<blockquote>
<p>假设某生产者—消费者问题的缓冲区是无限的，试用信号量与PV操作给出该问题的解法</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter hljs hljs hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c">semaphore mutex;<br>mutex=<span class="hljs-number">1</span>;<span class="hljs-comment">//initial</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">consumer</span><span class="hljs-params">()</span></span>&#123;<br>	<span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)&#123;<br>        P(mutex);<br>		<span class="hljs-comment">//remove an item from buffer to nextc</span><br>        V(mutex);<br>        <span class="hljs-comment">//consume the item in nextc</span><br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">producer</span><span class="hljs-params">()</span></span>&#123;<br>	<span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)&#123;<br>		<span class="hljs-comment">//produce an item in nextp</span><br>        P(mutex);<br>        <span class="hljs-comment">//add nextp to buffer</span><br>        V(mutex);<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<h3 id="和尚喝水问题"><a class="markdownIt-Anchor" href="#和尚喝水问题"></a> 和尚喝水问题</h3>
<blockquote>
<p>某寺庙，有小和尚、老和尚若干．庙内有一水缸，由小和尚提水入缸，供老和尚饮用。水缸可容纳 30 桶水，每次入水、取水仅为1桶，不可同时进行。水取自同一井中，水井径窄，每次只能容纳一个水桶取水。设水桶个数为5个，试用信号灯和PV操作给出老和尚和小和尚的活动</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter hljs hljs hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++">semaphore mutex_well，mutex_tank，empty，full,bucket<br>mutex_well=<span class="hljs-number">1</span>;<span class="hljs-comment">//小和尚从水井提水进程互斥</span><br>mutex_tank=<span class="hljs-number">1</span>;<span class="hljs-comment">//水缸里小和尚入水、老和尚喝水进程互斥</span><br>empty=<span class="hljs-number">30</span>;<span class="hljs-comment">//表示水缸剩余容量</span><br>full=<span class="hljs-number">0</span>;<span class="hljs-comment">//表示水缸是否满</span><br>bucket=<span class="hljs-number">5</span>;<span class="hljs-comment">//水桶数量</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">young_monk</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)&#123;<br>        <span class="hljs-built_in">P</span>(empty);<span class="hljs-comment">//水缸容量是否为0，为0则等待</span><br>        <span class="hljs-built_in">P</span>(bucket);<span class="hljs-comment">//是否有水桶，没有则等待</span><br>        <span class="hljs-built_in">P</span>(mutex_well);<span class="hljs-comment">//保证取水进程互斥</span><br>        <span class="hljs-comment">//从水井取水；</span><br>        <span class="hljs-built_in">V</span>(mutex_well);<span class="hljs-comment">//释放</span><br>        <span class="hljs-built_in">P</span>(mutex_tank);<span class="hljs-comment">//保证入水进程互斥</span><br>        <span class="hljs-comment">//向水缸入水；</span><br>        <span class="hljs-built_in">V</span>(mutex_tank);<span class="hljs-comment">//释放</span><br>        <span class="hljs-built_in">V</span>(bucket);<span class="hljs-comment">//回复一个水桶的状态</span><br>        <span class="hljs-built_in">V</span>(full);<span class="hljs-comment">//缸内容量加一</span><br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">old_monk</span><span class="hljs-params">()</span></span>&#123;<br>	<span class="hljs-built_in">P</span>(full);<span class="hljs-comment">//缸内是否有水</span><br>    <span class="hljs-built_in">P</span>(bucket);<span class="hljs-comment">//是否有水桶</span><br>    <span class="hljs-built_in">P</span>(mutex_tank);<span class="hljs-comment">//保证喝水进程互斥</span><br>    <span class="hljs-comment">//从水缸喝水；</span><br>    <span class="hljs-built_in">V</span>(mutex_tank);<span class="hljs-comment">//释放</span><br>    <span class="hljs-built_in">V</span>(bucket);<span class="hljs-comment">//回复一个水桶的状态</span><br>    <span class="hljs-built_in">V</span>(empty);<span class="hljs-comment">//缸内容量减一</span><br>&#125;<br></code></pre></div></td></tr></table></figure>
<h3 id="过独木桥问题"><a class="markdownIt-Anchor" href="#过独木桥问题"></a> 过独木桥”问题</h3>
<blockquote>
<p>请用信号量解决以下的“过独木桥”问题：同一方向的行人可连续过桥，当某一方向有人过桥时，另一方向的行人必须等待；当某一方向无人过桥时，另一方向的行人可以过桥</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter hljs hljs hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c">semaphore leftCount=<span class="hljs-number">0</span>,rightCount=<span class="hljs-number">0</span>;<span class="hljs-comment">//左右过桥人数</span><br>semaphore keySignal = <span class="hljs-number">1</span>;<span class="hljs-comment">//实现左右两边公平过桥</span><br>semaphore bridge = <span class="hljs-number">1</span>;<span class="hljs-comment">//实现左右两边过桥互斥</span><br>semaphore leftCountSignal = <span class="hljs-number">1</span>,rightCountSignal=<span class="hljs-number">1</span>;<span class="hljs-comment">//过桥人数计数器资源</span><br><br>reader()<br>&#123;<br>    <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)<br>    &#123;      <br>      wait(leftCountSignal);  <span class="hljs-comment">//申请计数器资源</span><br>      <span class="hljs-keyword">if</span>(!leftCount)wait(bridge);<span class="hljs-comment">//为零则申请过桥资源</span><br>      leftCount++;<br>      signal(leftCountSignal); <span class="hljs-comment">//释放计数器资源</span><br>         <br>      ...<br>      过桥<br>      ...<br>  <br>      wait(leftCountSignal);  <span class="hljs-comment">//申请计数器资源</span><br>      leftCount--;<br>      <span class="hljs-keyword">if</span>(!leftCount)signal(bridge);<span class="hljs-comment">//为零则释放过桥资源</span><br>      signal(leftCountSignal); <span class="hljs-comment">//释放读者计数器资源</span><br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">right_people</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)<br>    &#123;      <br>      wait(rightCountSignal);  <span class="hljs-comment">//申请计数器资源</span><br>      <span class="hljs-keyword">if</span>(!rightCount)wait(bridge);<span class="hljs-comment">//为零则申请过桥资源</span><br>      rightCount++;<br>      signal(rightCountSignal); <span class="hljs-comment">//释放计数器资源</span><br>         <br>      ...<br>      过桥<br>      ...<br>  <br>      wait(rightCountSignal);  <span class="hljs-comment">//申请计数器资源</span><br>      rightCount--;<br>      <span class="hljs-keyword">if</span>(!rightCount)signal(bridge);<span class="hljs-comment">//为零则释放过桥资源</span><br>      signal(rightCountSignal); <span class="hljs-comment">//释放读者计数器资源</span><br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<h1 id="第7章-死锁"><a class="markdownIt-Anchor" href="#第7章-死锁"></a> 第7章 死锁</h1>
<h2 id="71-系统模型"><a class="markdownIt-Anchor" href="#71-系统模型"></a> 7.1 系统模型</h2>
<p>当一组进程中的每个进程都在等待一个事件， 而这一事件只能由这一组进程的另 一进程引起， 那么这组进程就处于死锁状态。</p>
<h2 id="72-死锁特征"><a class="markdownIt-Anchor" href="#72-死锁特征"></a> 7.2 死锁特征</h2>
<h3 id="721-必要条件"><a class="markdownIt-Anchor" href="#721-必要条件"></a> 7.2.1 必要条件</h3>
<p>如果在一个系统中下面4个条件同时满足，那么会引起<strong>死锁</strong>。</p>
<ol>
<li><strong>互斥：</strong> 至少有一个资源必须处于非共享模式，即一次只有一个进程使用。 如果另一进程申请该资源，那么申请进程必须等到该资源被释放为止。</li>
<li><strong>占有并等待：</strong> 一个进程必须占有至少一个资源，并等待另一资源， 而该资源为其他进程所占有。</li>
<li><strong>非抢占：</strong> 资源不能被抢占，即资源只能在进程完成任务后自动释放。</li>
<li><strong>循环等待：</strong> 有一组等待进程｛P0，P1， …，Pn}， P0等待的资源为P1所占有， P1等待的资源为P2所占有， ……，Pn-1等待的资源为Pn 所占有， Pn 等待的资源为P0所占有。</li>
</ol>
<p>在此， 强调所有4个条件必须同时满足才会出现死锁。</p>
<h3 id="722-资源分配图"><a class="markdownIt-Anchor" href="#722-资源分配图"></a> 7.2.2 资源分配图</h3>
<p><img src="/posts/8ce3e425/image-20220110122604071.png" srcset="/img/loading.gif" lazyload alt="image-20220110122604071"></p>
<p>根据资源分配图的定义，可以证明：如果分配图没有环，那么系统就没有进程死锁。如果分配图有环，那么可能存在死锁。</p>
<p><img src="/posts/8ce3e425/image-20220110122939209.png" srcset="/img/loading.gif" lazyload alt="image-20220110122939209"></p>
<h2 id="73-死锁处理方法"><a class="markdownIt-Anchor" href="#73-死锁处理方法"></a> 7.3 死锁处理方法</h2>
<p>从原理上来说， 有三种方法可处理死锁问题：</p>
<ul>
<li>可使用协议以预防或避免死锁，确保系统不会进入死锁状态。</li>
<li>可允许系统进入死锁状态，然后检测它，并加以恢复。</li>
<li>可忽视这个问题，认为死锁不可能在系统内发生。</li>
</ul>
<h2 id="74-死锁预防"><a class="markdownIt-Anchor" href="#74-死锁预防"></a> 7.4 死锁预防</h2>
<p>出现死锁有4个必要条件。 只要确保至少一个必要条件不成立，就能预防死锁发生。</p>
<h3 id="741-互斥"><a class="markdownIt-Anchor" href="#741-互斥"></a> 7.4.1 互斥</h3>
<p>对于<strong>非共享资源</strong>，必须要有互斥条件。</p>
<p>另一方面，<strong>共享资源</strong>不要求互斥访问，因此不会涉及死锁。</p>
<p>通常不能通过否定互斥条件来预防死锁：有的资源身就是非共享的。</p>
<h3 id="742-占有并等待"><a class="markdownIt-Anchor" href="#742-占有并等待"></a> 7.4.2 占有并等待</h3>
<p>为了确保占有并等待条件不会在系统内出现，必须保证：当 一个进程申请一个资源时，它不能占有其他资源。</p>
<ul>
<li>
<p>一种可以使用的协议是<strong>每个进程在执行前申请并获得所有资源</strong>。 可以实现通过要求申请资源的系统调用在所有其他系统调用之前进行。</p>
</li>
<li>
<p>另外一种协议允许<strong>进程在没有资源时才可申请资源</strong>。 一个进程可申请一些资源并使用它们。 然而， 在它申请更多其他资源之前， 它必须释放其现己分配的所有资源。</p>
</li>
</ul>
<p>这两种协议有两个主要缺点。</p>
<ul>
<li>第一， 资源利用率可能比较低，因为许多资源可能己分配， 但是很长时间没有被使用。</li>
<li>第二， 可能发生饥饿。 一个进程如需要多个常用资源， 可能会永久等待， 因为其所需要的资源中至少有一个己分配给其他进程。</li>
</ul>
<h3 id="743-非抢占"><a class="markdownIt-Anchor" href="#743-非抢占"></a> 7.4.3 非抢占</h3>
<p>第三个必要条件是对己分配的资源不能抢占。 为了确保这一条件不成立， 可以使用如下协议：如果一个进程占有资源并申请另一个不能立即分配的资源， 那么其现己分配的资源都可被抢占。 换句话说， 这些资源都被隐式地释放了。</p>
<p>这个协议通常应用于状态可以保存和恢复的资源，如CPU寄存器和内存。它一般不适用于其他资源， 如打印机和磁带驱动器。</p>
<h3 id="744-循环等待"><a class="markdownIt-Anchor" href="#744-循环等待"></a> 7.4.4 循环等待</h3>
<p>死锁的第4个也是最后一个条件是循环等待。</p>
<p>一个确保此条件不成立的方法是对所有资源类型进行完全排序，且要求每个进程按递增顺序来申请资源</p>
<h2 id="75-死锁避免"><a class="markdownIt-Anchor" href="#75-死锁避免"></a> 7.5 死锁避免</h2>
<p>死锁预防算法中，通过限制资源申请的方法来预防死锁。这种限制确保4个必要条件之一不会发生，因此死锁不成立。 然而，通过这种方法预防死锁的副作用是低设备使用率和系统吞吐率。</p>
<p><strong>死锁避免算法</strong>动态地检测资源分配状态以确保循环等待条件不可能成立。资源分配状态是由可用资源和己分配资源，及进程最大需求所决定的。</p>
<h3 id="751-安全状态"><a class="markdownIt-Anchor" href="#751-安全状态"></a> 7.5.1 安全状态</h3>
<p>如果系统能按某个顺序为每个进程分配资源（ 不超过其最大值）并能避免死锁， 那么系统状态就是安全的。 更为准确地说， 如果存在一个<strong>安全序列</strong>， 那么系统处于<strong>安全状态</strong>。</p>
<blockquote>
<p>安全序列：</p>
<p>进程顺序＜P1，P2，…，Pn＞，如果对于每个 Pi, Pi仍然可以申请的资源数小于当前可用资源加上所有进程Pj（其中j&lt;i） 所占有的资源， 那么这一顺序称为安全序列。</p>
</blockquote>
<p>在这种情况下，进程Pi所需要的资源即使不能立即可用，Pi也可等待直到所有Pj释放其资源。 当它们完成时，Pi可得到其所需要的所有资源， 完成其给定任务，返回其所分配的资源井终止。</p>
<p><img src="/posts/8ce3e425/image-20220110131605918.png" srcset="/img/loading.gif" lazyload alt="image-20220110131605918"></p>
<h3 id="752-资源分配图算法"><a class="markdownIt-Anchor" href="#752-资源分配图算法"></a> 7.5.2 资源分配图算法</h3>
<p>假设进程Pi申请资源Rj。只有在将申请边Pi→Rj 变成分配边Rj→Pi 而不会导致资源分配图形成环时，才允许申请。注意，通过采用环检测算法，检测安全性。检测图中是否有环的算法需要n<sup>2</sup>级的操作，其中n是系统的进程数量。</p>
<p>如果没有环存在， 那么资源分配会使得系统处于安全状态。如果有环存在， 那么分配会导致系统处于不安全状态。因此，进程Pi必须等待其资源申请被满足。</p>
<p><img src="/posts/8ce3e425/image-20220110132333116.png" srcset="/img/loading.gif" lazyload alt="image-20220110132333116"></p>
<h3 id="753-银行家算法"><a class="markdownIt-Anchor" href="#753-银行家算法"></a> 7.5.3 银行家算法</h3>
<h4 id="1算法原理"><a class="markdownIt-Anchor" href="#1算法原理"></a> 1）算法原理</h4>
<p><img src="/posts/8ce3e425/image-20220110134858471.png" srcset="/img/loading.gif" lazyload alt="image-20220110134858471"></p>
<ol>
<li>
<p>安全性算法</p>
<p><img src="/posts/8ce3e425/image-20220110134809173.png" srcset="/img/loading.gif" lazyload alt="image-20220110134809173"></p>
</li>
<li>
<p>资源请求算法</p>
<p><img src="/posts/8ce3e425/image-20220110134844887.png" srcset="/img/loading.gif" lazyload alt="image-20220110134844887"></p>
</li>
</ol>
<h4 id="2编程实现"><a class="markdownIt-Anchor" href="#2编程实现"></a> 2）编程实现</h4>
<figure class="highlight c++"><table><tr><td class="gutter hljs hljs hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> N 100</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> M 100</span><br><span class="hljs-keyword">int</span> Available[M],     <span class="hljs-comment">//每种资源现有的实例数量</span><br>    Max[N][M],        <span class="hljs-comment">//每个进程i的对资源j最大需求</span><br>    Allocation[N][M], <span class="hljs-comment">//每个进程现在所分配的每个资源的实例数量</span><br>    Need[N][M],       <span class="hljs-comment">//每个进程还需要的剩余的资源</span><br>    Request[N][M],    <span class="hljs-comment">//进程资源请求</span><br>    sign[N],          <span class="hljs-comment">//记录安全序列</span><br>    process_num,      <span class="hljs-comment">//进程数量</span><br>    recourse_num;     <span class="hljs-comment">//资源数量</span><br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span> <span class="hljs-comment">//初始化进程资源状况</span></span><br><span class="hljs-function"></span>&#123;<br>    cin &gt;&gt; process_num &gt;&gt; recourse_num;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; process_num; i++)<br>    &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; recourse_num; j++)<br>        &#123;<br>            cin &gt;&gt; Allocation[i][j];<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; process_num; i++)<br>    &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; recourse_num; j++)<br>        &#123;<br>            cin &gt;&gt; Max[i][j];<br>            Need[i][j] = Max[i][j] - Allocation[i][j];<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; recourse_num; j++)<br>    &#123;<br>        cin &gt;&gt; Available[j];<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">print_information</span><span class="hljs-params">()</span> <span class="hljs-comment">//打印进程资源表</span></span><br><span class="hljs-function"></span>&#123;<br>    cout &lt;&lt; <span class="hljs-string">&quot;-----------------------------------进程资源表------------------------------------&quot;</span> &lt;&lt; endl;<br>    cout &lt;&lt; <span class="hljs-string">&quot;|    进程名称   |   已占用资源  |    尚需资源   |  最大所需资源 |  资源剩余实例 |&quot;</span> &lt;&lt; endl;<br>    cout &lt;&lt; <span class="hljs-string">&quot;|&quot;</span> &lt;&lt; <span class="hljs-built_in">setw</span>(<span class="hljs-number">16</span>) &lt;&lt; <span class="hljs-string">&quot;|&quot;</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">4</span> * recourse_num; j++)<br>    &#123;<br><br>        cout &lt;&lt; <span class="hljs-built_in">setw</span>(<span class="hljs-number">4</span>) &lt;&lt; <span class="hljs-built_in"><span class="hljs-keyword">char</span></span>(j % recourse_num + <span class="hljs-string">&#x27;A&#x27;</span>);<br>        <span class="hljs-keyword">if</span> ((j + <span class="hljs-number">1</span>) % recourse_num == <span class="hljs-number">0</span>)<br>            cout &lt;&lt; <span class="hljs-string">&quot;   |&quot;</span>;<br>    &#125;<br>    cout &lt;&lt; endl;<br>    <span class="hljs-keyword">int</span> k = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; process_num; i++)<br>    &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;|&quot;</span> &lt;&lt; <span class="hljs-built_in">setw</span>(<span class="hljs-number">10</span>) &lt;&lt; <span class="hljs-string">&quot;P[&quot;</span> &lt;&lt; i &lt;&lt; <span class="hljs-string">&quot;]&quot;</span>; <span class="hljs-comment">//进程名称</span><br>        cout &lt;&lt; <span class="hljs-string">&quot;   |&quot;</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; recourse_num; j++)<br>        &#123;<br>            cout &lt;&lt; <span class="hljs-built_in">setw</span>(<span class="hljs-number">4</span>) &lt;&lt; Allocation[i][j]; <span class="hljs-comment">//已占用资源</span><br>        &#125;<br>        cout &lt;&lt; <span class="hljs-string">&quot;   |&quot;</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; recourse_num; j++)<br>        &#123;<br>            cout &lt;&lt; <span class="hljs-built_in">setw</span>(<span class="hljs-number">4</span>) &lt;&lt; Need[i][j]; <span class="hljs-comment">//尚需资源</span><br>        &#125;<br>        cout &lt;&lt; <span class="hljs-string">&quot;   |&quot;</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; recourse_num; j++)<br>        &#123;<br>            cout &lt;&lt; <span class="hljs-built_in">setw</span>(<span class="hljs-number">4</span>) &lt;&lt; Max[i][j]; <span class="hljs-comment">//最大所需资源</span><br>        &#125;<br>        <span class="hljs-keyword">if</span> (k == <span class="hljs-number">0</span>)<br>        &#123;<br>            cout &lt;&lt; <span class="hljs-string">&quot;   |&quot;</span>;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; recourse_num; j++)<br>            &#123;<br>                cout &lt;&lt; <span class="hljs-built_in">setw</span>(<span class="hljs-number">4</span>) &lt;&lt; Available[j]; <span class="hljs-comment">//资源剩余实例</span><br>            &#125;<br>            cout &lt;&lt; <span class="hljs-string">&quot;   |&quot;</span> &lt;&lt; endl;<br>            k = <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>            cout &lt;&lt; <span class="hljs-string">&quot;   |&quot;</span> &lt;&lt; <span class="hljs-built_in">setw</span>(<span class="hljs-number">16</span>) &lt;&lt; <span class="hljs-string">&quot;|&quot;</span> &lt;&lt; endl;<br>    &#125;<br>    cout &lt;&lt; <span class="hljs-string">&quot;---------------------------------------------------------------------------------&quot;</span> &lt;&lt; endl<br>         &lt;&lt; endl;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">security_test</span><span class="hljs-params">()</span> <span class="hljs-comment">//安全性检查</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> work[recourse_num];<br>    <span class="hljs-keyword">bool</span> finish[process_num];<br>    <span class="hljs-keyword">int</span> count, k = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; recourse_num; i++) <span class="hljs-comment">//初始化work</span><br>    &#123;<br>        work[i] = Available[i];<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; process_num; i++) <span class="hljs-comment">//设置false</span><br>    &#123;<br>        finish[i] = <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; process_num; i++) <span class="hljs-comment">////满足条件释放资源，并从头开始扫描进程集合</span><br>    &#123;<br>        count = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; recourse_num; j++)<br>            <span class="hljs-keyword">if</span> (finish[i] == <span class="hljs-literal">false</span> &amp;&amp; Need[i][j] &lt;= work[j])<br>                count++;<br>        <span class="hljs-keyword">if</span> (count == recourse_num) <span class="hljs-comment">//当进程各类资源都满足NEED&lt;=WORK时</span><br>        &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; recourse_num; j++)<br>                work[j] = work[j] + Allocation[i][j]; <span class="hljs-comment">//释放进程</span><br>            finish[i] = <span class="hljs-literal">true</span>;<br>            sign[k] = i; <span class="hljs-comment">//记录下满足条件的进程</span><br>            k++;<br>            i = <span class="hljs-number">-1</span>; <span class="hljs-comment">//从头开始扫描</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; process_num; i++)<br>        <span class="hljs-keyword">if</span> (finish[i] == <span class="hljs-literal">false</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">Banker_Algorithm</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i)</span> <span class="hljs-comment">//资源请求算法</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> m = <span class="hljs-number">0</span>; m &lt; recourse_num; m++)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (Request[i][m] &gt; Need[i][m])<br>        &#123;<br>            cout &lt;&lt; <span class="hljs-string">&quot;所需资源数超出其宣布的最大值!&quot;</span> &lt;&lt; endl;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (Request[i][m] &gt; Available[m])<br>        &#123;<br>            cout &lt;&lt; <span class="hljs-string">&quot;无足够资源，p[&quot;</span> &lt;&lt; i &lt;&lt; <span class="hljs-string">&quot;]需等待!&quot;</span> &lt;&lt; endl;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">//尝试为进程分配资源</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; recourse_num; j++)<br>    &#123;<br>        Available[j] = Available[j] - Request[i][j];<br>        Allocation[i][j] = Allocation[i][j] + Request[i][j];<br>        Need[i][j] = Need[i][j] - Request[i][j];<br>    &#125;<br>    cout &lt;&lt; <span class="hljs-string">&quot;尝试进行资源分配后的进程资源表: &quot;</span> &lt;&lt; endl;<br>    <span class="hljs-built_in">print_information</span>();<br>    <span class="hljs-comment">//执行安全性算法</span><br>    cout &lt;&lt; <span class="hljs-string">&quot;正在进行安全性检查&quot;</span> &lt;&lt; endl;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">security_test</span>())<br>    &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;经安全性检查，系统安全，本次分配成功&quot;</span> &lt;&lt; endl;<br>        cout &lt;&lt; <span class="hljs-string">&quot;安全进程序列为：&quot;</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> p = <span class="hljs-number">0</span>; p &lt; process_num - <span class="hljs-number">1</span>; p++)<br>        &#123;<br>            cout &lt;&lt; <span class="hljs-string">&quot;P[&quot;</span> &lt;&lt; sign[p] &lt;&lt; <span class="hljs-string">&quot;]---&gt;&quot;</span>; <span class="hljs-comment">//输出安全的进程序列</span><br>        &#125;<br>        cout &lt;&lt; <span class="hljs-string">&quot;P[&quot;</span> &lt;&lt; sign[process_num - <span class="hljs-number">1</span>] &lt;&lt; <span class="hljs-string">&quot;]&quot;</span>;<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;安全性检测失败!系统不安全!!!正在恢复资源分配------&quot;</span> &lt;&lt; endl;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; recourse_num; j++) <span class="hljs-comment">//恢复进程资源分配</span><br>        &#123;<br>            Available[j] = Available[j] + Request[i][j];<br>            Allocation[i][j] = Allocation[i][j] - Request[i][j];<br>            Need[i][j] = Need[i][j] + Request[i][j];<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">init</span>();<br>    cout &lt;&lt; <span class="hljs-string">&quot;初始化进程信息为：&quot;</span> &lt;&lt; endl;<br>    <span class="hljs-built_in">print_information</span>();<br>    <span class="hljs-keyword">int</span> i, tt = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (tt != <span class="hljs-number">999</span>)<br>    &#123;<br>        cout &lt;&lt; endl<br>             &lt;&lt; <span class="hljs-string">&quot;请输入请求资源Request[进程标号i][资源类型j]:&quot;</span> &lt;&lt; endl;<br>        cout &lt;&lt; <span class="hljs-string">&quot;进程i=：&quot;</span>;<br>        cin &gt;&gt; i;<br>        cout &lt;&lt; <span class="hljs-string">&quot;各类资源数量(A B C)=:  &quot;</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> m = <span class="hljs-number">0</span>; m &lt; recourse_num; m++)<br>            cin &gt;&gt; Request[i][m];<br>        cout &lt;&lt; endl;<br>        <span class="hljs-comment">//执行银行家算法</span><br>        <span class="hljs-built_in">Banker_Algorithm</span>(i);<br>        <span class="hljs-comment">//输出每次判断产生的执行序列</span><br>        cout &lt;&lt; endl<br>             &lt;&lt; <span class="hljs-string">&quot;当前资源分配表：&quot;</span> &lt;&lt; endl;<br>        <span class="hljs-built_in">print_information</span>();<br>        cout &lt;&lt; endl<br>             &lt;&lt; <span class="hljs-string">&quot;请输入N(当N=999退出)：&quot;</span> &lt;&lt; endl;<br>        cin &gt;&gt; tt;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<h4 id="3银行家算法缺点"><a class="markdownIt-Anchor" href="#3银行家算法缺点"></a> 3）银行家算法缺点</h4>
<ul>
<li>进程很难在运行前知道其所需资源的最大值。</li>
<li>系统中各进程之间必须是无关的，即没有同步要求，无法处理有同步关系的进程。</li>
<li>进程的数量和资源的数目是固定不变的，无法处理进程数量和资源数目动态变化的情况。</li>
</ul>
<h2 id="76-死锁检测"><a class="markdownIt-Anchor" href="#76-死锁检测"></a> 7.6 死锁检测</h2>
<h3 id="761-每种资源类型只有单个"><a class="markdownIt-Anchor" href="#761-每种资源类型只有单个"></a> 7.6.1 每种资源类型只有单个</h3>
<p>如果所有资源类型只有单个实例，那么可以定义这样一个死锁检测算法，该算法使用了资源分配图的一个变种，称为等待（wait-for）图。从资源分配图中，删除所有资源类型节点，合并适当边，就可以得到等待图。</p>
<p>当且仅当等待图中有一个环， 系统中存在死锁。 为了检测死锁， 系统需要维护等待图，并周期性地调用在图中进行搜索的算法。从图中检测环的算法需要n<sup>2</sup>级操作， 其中n为图中的节点数。</p>
<p><img src="/posts/8ce3e425/image-20220111113157466.png" srcset="/img/loading.gif" lazyload alt="image-20220111113157466"></p>
<h3 id="762-每种资源类型可有多个"><a class="markdownIt-Anchor" href="#762-每种资源类型可有多个"></a> 7.6.2 每种资源类型可有多个</h3>
<p><img src="/posts/8ce3e425/image-20220111114549547.png" srcset="/img/loading.gif" lazyload alt="image-20220111114549547"></p>
<p><img src="/posts/8ce3e425/image-20220111114535791.png" srcset="/img/loading.gif" lazyload alt="image-20220111114535791"></p>
<h2 id="77-死锁恢复"><a class="markdownIt-Anchor" href="#77-死锁恢复"></a> 7.7 死锁恢复</h2>
<p>打破死锁有两个方法。</p>
<ul>
<li>一个方法是简单地终止一个或多个进程以打破循环等待。</li>
<li>另一个方法是从一个或多个死锁进程那里抢占一个或多个资源。</li>
</ul>
<h3 id="771-进程终止"><a class="markdownIt-Anchor" href="#771-进程终止"></a> 7.7.1 进程终止</h3>
<p>有两种方法通过终止进程以取消死锁。 不管采用哪个方法，系统都会收回分配给被终止进程的所有资源。</p>
<ul>
<li>终止所有死锁进程。这种方法显然终止了死锁循环，但其代价也大。这些进程可能己计算了很长时间，这些部分计算结果必须放弃，以后可能还要重新计算。</li>
<li>一次只终止一个进程直到取消死锁循环为止。这种方法的开销会相当大，这是因为每次终止一个进程，都必须调用死锁检测算法以确定进程是否仍处于死锁。</li>
</ul>
<h3 id="772-资源抢占"><a class="markdownIt-Anchor" href="#772-资源抢占"></a> 7.7.2 资源抢占</h3>
<p>如果要求使用抢占来处理死锁， 那么有三个问题需要处理：</p>
<ol>
<li>选择一个牺牲品： 抢占哪些资源和哪个进程？与进程取消一样， 必须确定抢占顺序以便代价最小化。代价因素包括许多参数， 如死锁进程所拥有的资源数量，死锁进程到现在为止在其执行过程中所消耗的时间。</li>
<li>回滚：如果从一个进程那里抢占一个资源，那么该进程不能正常执行，它缺少所需要的资源。 必须将进程回液到某个安全状态，以便从该状态重启进程。 通常确定一个安全状态并不容易，所以最简单的方法是完全回滚：终止进程并重新执行。更为有效的方法是将进程回滚到足够打破死锁。 另一方面，这种方法要求系统维护有关运行进程状态的更多信息。</li>
<li>饥饿：如果一个系统是基于代价来选择牺牲进程， 那么同一进程可能总是被选为牺牲品。结果，这个进程永远不能完成其指定任务，任何实际系统都需要处理这种饥饿情况。显然，必须确保一个进程只能有限地被选择为牺牲品。最为常用的方法是在代价因素中加上回滚次数。</li>
</ol>
<h2 id="78-习题"><a class="markdownIt-Anchor" href="#78-习题"></a> 7.8 习题</h2>
<h3 id="74"><a class="markdownIt-Anchor" href="#74"></a> 7.4</h3>
<blockquote>
<p>根据如下两点， 比较循环等待方法与各种死锁避免方法（如银行家算法〉：<br>
a. 运行时开销。<br>
b. 系统吞吐量。</p>
</blockquote>
<p>由于跟踪当前资源分配的成本，死锁避免方案往往会增加运行时开销。然而，与静态防止死锁形成的方案相比，死锁避免方案允许更多的资源并发使用。从这个意义上讲，死锁避免方案可以提高系统吞吐量。</p>
<h3 id="75"><a class="markdownIt-Anchor" href="#75"></a> 7.5</h3>
<blockquote>
<p>在一个真实的计算机系统中 ， 可用的资源和进程对资源的要求都不会持续很久（几个月〉。资源会损坏和被替换， 新的进程会进入和离开系统， 新的资源会被购买和 加入系统。 如果用银行家算法控制<br>
死锁，下面哪些变化在什么情况下是安全的（不会导致死锁） ？</p>
<ul>
<li>a. 增加可用资源〈新的资源被加入系统）</li>
<li>b. 减少可用资源（资源被从系统中永久性地移出〉</li>
<li>c. 增加一个进程的Max （进程需要更多的资源， 超过所允许</li>
<li>的资源）</li>
<li>d. 减少一个进程的Max （进程不再需要那么多资源）</li>
<li>e. 增加进程的数量</li>
<li>t. 减少进程的数量</li>
</ul>
</blockquote>
<p>a，d，f安全</p>
<p>e需要在给进程分配资源时确保系统不会进入不安全状态</p>
<p>b,c可能会导致死锁，如果进入不安全状态的话</p>
<h3 id="78"><a class="markdownIt-Anchor" href="#78"></a> 7.8</h3>
<blockquote>
<p>考虑这样的哲学家就餐问题： 筷子放在桌子中央， 且一个哲学家可使用任两只筷子。假定一次只能请求一只筷子。设计一简单规则， 可以根据现有筷子分配来确定某个请求是否可满足而不会出现死锁。</p>
</blockquote>
<p>以下规则避免了死锁：当一个哲学家发出一个需要第一根筷子的请求时，如果没有别的哲学家有两根筷子或者只留有一根筷子时，这个请求就不被允许。</p>
<h3 id="711"><a class="markdownIt-Anchor" href="#711"></a> 7.11</h3>
<blockquote>
<p>考虑下面的一个系统在某一时刻的状态。</p>
<p><img src="/posts/8ce3e425/image-20211201232218325.png" srcset="/img/loading.gif" lazyload alt="image-20211201232218325"></p>
<p>使用银行家算法回答下面问题：<br>
a.Need 矩阵的内容是怎样的？<br>
b. 系统是否处于安全状态？<br>
c. 如果从进程Pi 发来一个请求(0，4，2,0）， 这个请求能否立刻被满足？</p>
</blockquote>
<p>a. Need矩阵的内容是</p>
<p>P<sub>0</sub>(0 0 0 0),</p>
<p>P<sub>1</sub>(0 7 5 0),</p>
<p>P<sub>2</sub>(1 0 0 2),</p>
<p>P<sub>3</sub>(0 0 2 0),</p>
<p>P<sub>4</sub>(0 6 4 0)。</p>
<p>b. 系统处于安全状态， 因为Available矩阵等于(1 5 2 0),进程P<sub>0</sub>和P<sub>3</sub>都可以运行，<br>
当进程P<sub>3</sub>运行完时，它释放它的资源，而允许其它进程运行。</p>
<p>c. 可以被满足，满足以后， Available矩阵等于(1 1 0 0) ，当以次序P<sub>0</sub>,P<sub>1</sub>,P<sub>2</sub>, P<sub>3</sub>,P<sub>4</sub>运行时<br>
，可以完成运行。</p>
<h1 id="第8章-内存管理"><a class="markdownIt-Anchor" href="#第8章-内存管理"></a> 第8章 内存管理</h1>
<h2 id="81-背景"><a class="markdownIt-Anchor" href="#81-背景"></a> 8.1 背景</h2>
<h3 id="811-基本硬件"><a class="markdownIt-Anchor" href="#811-基本硬件"></a> 8.1.1 基本硬件</h3>
<p>基地址寄存器含有最小的合法物理内存地址，</p>
<p>而界限地址寄存器决定了范围的大小。</p>
<p><img src="/posts/8ce3e425/image-20220110151139132.png" srcset="/img/loading.gif" lazyload alt="image-20220110151139132"></p>
<p><img src="/posts/8ce3e425/image-20220110151147020.png" srcset="/img/loading.gif" lazyload alt="image-20220110151147020"></p>
<h3 id="812-地址绑定"><a class="markdownIt-Anchor" href="#812-地址绑定"></a> 8.1.2 地址绑定</h3>
<p>将指令与数据绑定到内存地址有以下几种情况：</p>
<ul>
<li>编译时(compile time)：如果在编译时就知道进程将在内存中的驻留地址，那么就可以生成绝对代码（absolute code）。</li>
<li>加载时(load time）：如果在编译时并不知道进程将驻留在内存的什么地方，那么编译器就必须生成可重定位代码 （relocatable code）。</li>
<li>执行时(execution time）：如果进程在执行时可以从一个内存段移到另一个内存段，那么绑定必须延迟到执行时才进行。</li>
</ul>
<h3 id="813-逻辑地址空间与物理地址空间"><a class="markdownIt-Anchor" href="#813-逻辑地址空间与物理地址空间"></a> 8.1.3 逻辑地址空间与物理地址空间</h3>
<p>CPU所生成的地址通常称为<strong>逻辑地址</strong>（logical address），而内存单元所看到的地址（即加载到内存地址寄存器（memory-address register）中的地址） 通常称为<strong>物理地址</strong> （physical address）</p>
<p>运行时从虚拟地址到物理地址的映射是由被称为<strong>内存管理单元</strong>（ memory-managementunit, <strong>MMU</strong>） 的硬件设备来完成的。</p>
<p><img src="/posts/8ce3e425/image-20220111210939563.png" srcset="/img/loading.gif" lazyload alt="image-20220111210939563"></p>
<h3 id="814-动态加载"><a class="markdownIt-Anchor" href="#814-动态加载"></a> 8.1.4 动态加载</h3>
<p>动态加载：将加载延迟到运行时</p>
<p>采用<strong>动态加载</strong>时，一个子程序只有在调用时才被加载。所有子程序都以可重定位的形式保存在磁盘上。 主程序装入内存并执行。 当一个子程序需要调用另一个子程序时，调用子程序首先检查另一个子程序是否己加载。如果没有，可重定位的链接程序将用来加载所需要的子程序，并更新程序的地址表以反映这一变化。接着，控制传递给新加载的子程序。</p>
<p>动态加载的优点是不用的子程序决不会被加载。</p>
<h3 id="815-动态链接与共享库"><a class="markdownIt-Anchor" href="#815-动态链接与共享库"></a> 8.1.5 动态链接与共享库</h3>
<p>动态链接：将链接延迟到运行时。</p>
<p>优点：</p>
<ul>
<li>
<p>使用语言库的所有进程只需要一个库代码副本</p>
</li>
<li>
<p>可用于库更新（如修改漏洞〉。 一个库可以被新的版本所替代且使用该库的所有程序会自动使用新的版本。</p>
</li>
</ul>
<h2 id="82交换"><a class="markdownIt-Anchor" href="#82交换"></a> 8.2交换</h2>
<p>进程可以暂时从内存中交换（swap）到备份存储(backing store）上， 当需要再次执行时再调回到内存中。</p>
<p>这种交换策略的变种被用在基于优先级的调度算法中。 如果有一个更高优先级的进程且需要服务，内存管理器可以交换出低优先级的进程，以便可以装入和执行更高优先级的进程。 当更高优先级的进程执行完后，低优先级进程可以交换回内存以继续执行。 这种交换有时称为滚出(roll out)和滚入(roll in)。</p>
<h2 id="83-连续内存分配"><a class="markdownIt-Anchor" href="#83-连续内存分配"></a> 8.3 连续内存分配</h2>
<h3 id="831-内存映射与保护"><a class="markdownIt-Anchor" href="#831-内存映射与保护"></a> 8.3.1 内存映射与保护</h3>
<p>重定位寄存器含有最小的物理地址值：界限地址寄存器含有逻辑地址的范围值。</p>
<p>每个逻辑地址必须小于界限地址寄存器。 <strong>MMU</strong>动态描将逻辑地址加上重定位寄存器的值后映射成物理地址。 映射后的物理地址再送交内存单元（见图 8.6）。</p>
<p><img src="/posts/8ce3e425/image-20220110154530899.png" srcset="/img/loading.gif" lazyload alt="image-20220110154530899"></p>
<h3 id="832-内存分配"><a class="markdownIt-Anchor" href="#832-内存分配"></a> 8.3.2 内存分配</h3>
<p>在任意时候，有一组可用孔（块） 大小列表和输入队列。操作系统根据调度算法来对输入队列进行排序。内存不断地分配给进程， 直到下一个进程的内存需求不能满足为止，这时没有足够大的可用孔来装入进程。操作系统可以等到有足够大的空间，或者往下扫描输入队列以确定是否有其他内存需求较小的进程可以被满足。</p>
<p>从一组可用孔中选择一个空闲孔的最为常用方法有首次适应（firSt-fit）＇ 最佳适应（best-fit）、 最差适应（worst-fit）。</p>
<ul>
<li>**首次适应：**分配第一个足够大的孔。 查找可以从头开始，也可以从上次首次适应结束时开始。一旦找到足够大的空闲孔，就可以停止。
<ul>
<li>特点：优先分配内存中低地址部分</li>
<li>优点：简单</li>
<li>缺点：在低地址部分会积累大量外零头</li>
</ul>
</li>
<li>**最佳适应：**搜索整个序列，找到适合条件的最小的分区进行分配。 这种方法可以产生最小剩余孔。
<ul>
<li>优点：保证总有大分区可分配（排在后面）</li>
<li>缺点：
<ul>
<li>效率不高，排在前面的分区不断变小，能被分出去的概率也就越来越低</li>
<li>外零头形成速度快</li>
</ul>
</li>
</ul>
</li>
<li>**最差适应：**搜索整个序列，寻找最大的分区进行分配。这种方法可以产生最大剩余孔， 该孔可能比最佳适应方法产生的较小剩余孔更为有用。
<ul>
<li>优点：查找效率显著提高，一次就找到</li>
<li>缺点：大作业容纳能力会下降</li>
</ul>
</li>
</ul>
<h3 id="833-碎片"><a class="markdownIt-Anchor" href="#833-碎片"></a> 8.3.3 碎片</h3>
<p>首次适应方法和最佳适应方法算法都有外部碎片问题。</p>
<p>随着进程装入和移出内存，空闲内存空间被分为小片段。当所有总的可用内存之和可以满足请求，但并不连续时，这就出现了外部碎片问题。</p>
<ul>
<li>
<p>一种解决外部碎片问题的方法是紧缩。</p>
<p>紧缩的目的是移动内存内容， 以便所有空闲空间合并成一整块。</p>
</li>
<li>
<p>另一种可能解决外部碎片问题的方法是允许物理地址空间为非连续， 这样只要有物理内存就可为进程分配。 这种方案有两种互补的实现技术：分页（见8.4节)和分段（见8.7节）</p>
</li>
</ul>
<h2 id="84-分页"><a class="markdownIt-Anchor" href="#84-分页"></a> 8.4 分页</h2>
<h3 id="841-基本方法"><a class="markdownIt-Anchor" href="#841-基本方法"></a> 8.4.1 基本方法</h3>
<p>实现分页的基本方法涉及将物理内存分为固定大小的块，称为帧（frame）：而将逻辑内存也分为同样大小的块，称为页（page）。</p>
<p><img src="/posts/8ce3e425/image-20220110162401210.png" srcset="/img/loading.gif" lazyload alt="image-20220110162401210"></p>
<p><img src="/posts/8ce3e425/image-20220110163418739.png" srcset="/img/loading.gif" lazyload alt="image-20220110163418739"></p>
<p>由CPU生成的每个地址分为两个部分：页号（p）和页偏移（d）。页号作为页表中的索引。页表包含每页所在物理内存的基地址。</p>
<p>如果逻辑地址空间为2<sup>m</sup>，且页大小为2<sup>n</sup> 单元（字节或字〉， 那<br>
么逻辑地址的高 m-n 位表示页号，而低n位表示页偏移。 这样， 逻辑地址如下所示：</p>
<p><img src="/posts/8ce3e425/image-20220110162740496.png" srcset="/img/loading.gif" lazyload alt="image-20220110162740496"></p>
<p>设定页面大小为4 byte，物理内存是32 byte（8 页)。逻辑地址0 在第0页，页偏移为0。根据索引页表，我们发现第0页在第5帧。这样，逻辑地址0 映射到物理地址20 (= (5 × 4) + 0)。逻辑地址3（第0 页，页偏移为3）映射到物理地址23 (= (5 × 4) + 3)。逻辑地址4 在第1页，偏移量为0；根据页表，第1 页被映射到第6 帧。这样，逻辑地址4 映射到物理地址24 (= (6 × 4) + 0)。逻辑地址13映射到物理地址9。</p>
<p><img src="/posts/8ce3e425/image-20220110163340244.png" srcset="/img/loading.gif" lazyload alt="image-20220110163340244"></p>
<p><strong>分页机制的特点</strong></p>
<ul>
<li>分页机制不会产生外部碎片：任何空闲帧都被分配给所需的进程。</li>
<li>分页机制会产生内部碎片。</li>
</ul>
<p>实例：</p>
<blockquote>
<p>1.<img src="/posts/8ce3e425/image-20220110165126064.png" srcset="/img/loading.gif" lazyload alt="image-20220110165126064"></p>
<ol start="2">
<li></li>
</ol>
<p>存储器的用户空间共有 32 个页面，每页 1KB，内存16KB。假定某时刻系统为用户的第 0、1、2、3 页分别分配的物理块号为 5、10、4、7，试将逻辑地址 0A5C 和093C 变换为物理地址。</p>
<p><img src="/posts/8ce3e425/image-20220110165235908.png" srcset="/img/loading.gif" lazyload alt="image-20220110165235908"></p>
</blockquote>
<h3 id="842-硬件支持"><a class="markdownIt-Anchor" href="#842-硬件支持"></a> 8.4.2 硬件支持</h3>
<p>转换表缓冲区（translation look-aside buffer, TLB）。 TLB 是关联的快速内存。</p>
<p>TLB 条目由两部分组成： 键（标签） 和值。 当关联内存根据给定值查找时，它会同时与所有键进行比较。 如果找到条目，那么就得到相应的值域。</p>
<p>TLB 与页表一起按如下方法使用：</p>
<ul>
<li>TLB只包括页表中的一小部分条目。当CPU产生逻辑地址后，其页号提交给TLB。</li>
<li>如果找到页号，那么也就得到了帧号，并可用来访问内存。</li>
<li>如果页码不在 TLB 中（称为 TLB 失效），那么就需要访问页表。当得到帧号后，就可以用它来访问内存（如图 8.11 所示）。 同时，将页号和帧号增加到 TLB 中，这样下次再用时就可很快查找到。如果 TLB 中的条目己满，那么操作系统会选择一个来替换。</li>
</ul>
<p><img src="/posts/8ce3e425/image-20220110170044634.png" srcset="/img/loading.gif" lazyload alt="image-20220110170044634"></p>
<h3 id="843-保护"><a class="markdownIt-Anchor" href="#843-保护"></a> 8.4.3 保护</h3>
<p>在分页环境下，内存保护是通过与每个帧相关联的保护位来实现的。</p>
<p>可以用<strong>一个位来定义一个页是可读写还是只读的</strong>。每次地址引用都要通过页表来查找正确的帧码，在计算物理地址的同时，可以通过检查保护位来验证有没有对只读页进行写操作。对只读页进行写操作会向操作系统产生硬件陷阱〈或内存保护冲突〉</p>
<p>还有一个位通常与页表中的每一条目相关联：<strong>有效－无效位</strong>。当该位为有效时，表 示相关的页在进程的逻辑地址空间内，因此是合法（或有效）的页。当该位为无效时，表示相关的页不在进程的逻辑地址空间内。**通常是指该页的内容不在内存，在磁盘上。**通过使用有效一无效位可以捕捉到非法地址。操作系统通过对该位的设置可以允许或不允许对某页的访问。</p>
<h2 id="85-页表结构"><a class="markdownIt-Anchor" href="#85-页表结构"></a> 8.5 页表结构</h2>
<h3 id="851-层次页表"><a class="markdownIt-Anchor" href="#851-层次页表"></a> 8.5.1 层次页表</h3>
<p>两级分页算法：将页表再分页</p>
<p><img src="/posts/8ce3e425/image-20220110172004055.png" srcset="/img/loading.gif" lazyload alt="image-20220110172004055"></p>
<p><img src="/posts/8ce3e425/image-20220110172010959.png" srcset="/img/loading.gif" lazyload alt="image-20220110172010959"></p>
<p><img src="/posts/8ce3e425/image-20220110172019871.png" srcset="/img/loading.gif" lazyload alt="image-20220110172019871"></p>
<p>对于 64位体系结构，层次页表通常并不适合。</p>
<h3 id="852-哈希页表"><a class="markdownIt-Anchor" href="#852-哈希页表"></a> 8.5.2 哈希页表</h3>
<p>处理超过 32 位地址空间的常用方法是使用<strong>哈希页表</strong>（hashed page table），并以虚拟页码作为哈希值。哈希页表的每一条目都包括一个链表的元素，这些元素哈希成同一位置（要处理碰撞〉。 每个元素有 3 个域：</p>
<p>（1）虚拟页码，</p>
<p>（2）所映射的帧号，</p>
<p>（3）指向链表中下一个元素的指针。</p>
<p>该算法按如下方式工作： 虚拟地址中的虚拟页号转换到哈希表中， 用虚拟页号与链表中的每一个元素的第一个域相比较。如果匹配，那么 相应的帧号（第二个域）就用来形成物理地址：如果不匹配，那么就对链表中的下一个节点进行比较，以寻找一个匹配的页号。<br>
该方案如图 8.16 所示</p>
<p><img src="/posts/8ce3e425/image-20220110172339613.png" srcset="/img/loading.gif" lazyload alt="image-20220110172339613"></p>
<h3 id="853-反向页表"><a class="markdownIt-Anchor" href="#853-反向页表"></a> 8.5.3 反向页表</h3>
<p>反向页表对于每个真正的内存页或帧才有一个条目。 每个条目包含保存在真正内存位置的页的虚拟地址以及拥有该页的进程的信息。 因此， 整个系统只有一个页表， 对每个物理内存的页只有一条相应的条目。</p>
<p><img src="/posts/8ce3e425/image-20220110172931237.png" srcset="/img/loading.gif" lazyload alt="image-20220110172931237"></p>
<h2 id="86-分段"><a class="markdownIt-Anchor" href="#86-分段"></a> 8.6 分段</h2>
<h3 id="861-基本方法"><a class="markdownIt-Anchor" href="#861-基本方法"></a> 8.6.1 基本方法</h3>
<p>分段（segmentation）就是支持这种用户视角的内存管理方案。 逻辑地址空间是由一组段组成的。 每个段都有名称和长度。 地址指定了段名称和段内偏移。 因此用户通过两个量来指定地址：段名称和偏移（请将这一方案与分页相比较。在分页中，用户只指定一个地址，<br>
该地址通过硬件分为页码和偏移，对于这些，程序员是看不见的）</p>
<h3 id="862-硬件"><a class="markdownIt-Anchor" href="#862-硬件"></a> 8.6.2 硬件</h3>
<p>段表的使用如图 8.19 所示。 一个逻辑地址由两部分组成： 段号s和段内的偏移d。段号用做段表的索引， 逻辑地址的偏移d应位于0和段界限之间。</p>
<p><img src="/posts/8ce3e425/image-20220110174321311.png" srcset="/img/loading.gif" lazyload alt="image-20220110174321311"></p>
<p><img src="/posts/8ce3e425/image-20220110174328309.png" srcset="/img/loading.gif" lazyload alt="image-20220110174328309"></p>
<p><strong>分段式与分页式的区别</strong></p>
<ul>
<li>
<ol>
<li>可见与不可见</li>
</ol>
<ul>
<li>“分页”是系统活动，用户无法介入，页的大小固定</li>
<li>“分段”是用户可见的，段大小可变</li>
</ul>
</li>
<li>
<ol start="2">
<li>物理单位与逻辑单位</li>
</ol>
<ul>
<li>页是信息的物理单位，不是完整的逻辑单位</li>
<li>段是完整的逻辑信息单位</li>
</ul>
</li>
<li>
<ol start="3">
<li>地址空间</li>
</ol>
<ul>
<li>分页的作业空间是一维的，是单一线性空间</li>
<li>分段的作业空间是二维的。</li>
</ul>
</li>
</ul>
<h3 id="863-段页式存储管理"><a class="markdownIt-Anchor" href="#863-段页式存储管理"></a> 8.6.3 段页式存储管理</h3>
<p><strong>引入</strong></p>
<p>分页管理内存管理效率高</p>
<ul>
<li>没有外零头</li>
<li>内零头小</li>
</ul>
<p>分段管理符合模块化思想</p>
<ul>
<li>每个分段都具备完整的功能</li>
<li>方便代码共享、保护</li>
</ul>
<p><strong>段页式管理的基本思想</strong></p>
<ul>
<li>用户程序分段、段内分页</li>
<li>系统内存分块</li>
<li>每块装入一页，各块之间可以不连续</li>
<li>一个有效地址＝（段名，段内地址）＝（段名，段内页号+页内地址）</li>
</ul>
<p><img src="/posts/8ce3e425/image-20220110175110374.png" srcset="/img/loading.gif" lazyload alt="image-20220110175110374"></p>
<h2 id="88-习题"><a class="markdownIt-Anchor" href="#88-习题"></a> 8.8 习题</h2>
<h3 id="81"><a class="markdownIt-Anchor" href="#81"></a> 8.1</h3>
<blockquote>
<p>试说明内部碎片与外部碎片的区别，及解决方法</p>
</blockquote>
<p>内部碎片是某一区域或某一页中未被占据其位置的作业所使用的区域。直到作业完成， 释放页或区域 ， 这个空间才能被系统所利用。内部碎片一般无法避免</p>
<p>外部碎片随着进程装入和移出内存， 空闲内存空间被分为小片段。 当所有总的可用内存之和可以满足请求， 但并不连续时， 这就出现了外部碎片问题。外部碎片可通过紧缩来减少，即将空闲内存合并成大内存，也可以通过允许物理地址空间为非连续来避免， 这样只要有物理内存就可为进程分配</p>
<h3 id="83"><a class="markdownIt-Anchor" href="#83"></a> 8.3</h3>
<blockquote>
<p>如果有内存块100KB、500KB、200KB、300KB和600KB C按顺序〉，首次适应算法、 最佳适应算法、 最差适应算法各自将怎样放置大小分别为212KB、417KB、112KB和426KB（按顺序）的进程？哪一种算法的内存利用率最高？</p>
</blockquote>
<p>最先适应：</p>
<ul>
<li>212KB被放入500KB内存部分</li>
<li>417KB被放入600KB内存部分</li>
<li>112KB被放入288KB(500KB-212KB)内存部分</li>
<li>426KBz需要等待</li>
</ul>
<p>最佳适应：</p>
<ul>
<li>212KB被放入300KB内存部分</li>
<li>417KB被放入500KB内存部分</li>
<li>112KB被放入200KB内存部分</li>
<li>426KB被放入600KB内存部分</li>
</ul>
<p>最差适应：</p>
<ul>
<li>212KB被内存600KB放入部分</li>
<li>417KB被放入500KB内存部分</li>
<li>112KB被放入388KB内存部分</li>
<li>426KB需要等待</li>
</ul>
<p>最佳适应算法的内存利用率最高</p>
<h3 id="84"><a class="markdownIt-Anchor" href="#84"></a> 8.4</h3>
<blockquote>
<p>绝大多数系统允许程序在执行时分配更多的内存给它自己的地址空间。 程序的堆段中的数据分配就是这样一个内存分配实例。 在下面的方法中，支持动态内存分配需要什么？</p>
<p>a.连续内存分配</p>
<p>b.纯分段</p>
<p>c.纯分页</p>
</blockquote>
<p>a.连续内存分配：当没有足够的空间给程序去扩大它已分配的内存空间时，将要求重新分配整个程序。<br>
b.纯段式分配：当没有足够的空间给段去扩大它的己分配内存空回时，将要求重新分配整个段。<br>
c.纯页式分配：在没有要求程序地址空间再分配的方案下，新页增加的分配是可能的。</p>
<h3 id="85"><a class="markdownIt-Anchor" href="#85"></a> 8.5</h3>
<blockquote>
<p>对下列问题，试比较连续内存分配方案、纯分段方案和纯分页方案中的内存组织方法<br>
a.外部碎片<br>
b.内部碎片<br>
c.共享跨进程代码的能力</p>
</blockquote>
<p>连续内存分配方案</p>
<ul>
<li>会受到外部碎片的影响，因为地址空间是连续分配的，随着旧进程的消亡和新进程的启动，会出现空洞。</li>
<li>它还不允许进程共享代码，因为进程的虚拟内存段不会被分解成不连续的细粒度段。</li>
</ul>
<p>纯分段</p>
<ul>
<li>也会受到外部碎片的影响，因为进程的一段被连续地布置在物理内存中，而当死进程的段被新进程的段替换时，将会发生碎片。</li>
<li>然而，分段使进程能够共享代码，例如，两个不同的进程可以共享一个代码段，但具有不同的数据段。</li>
</ul>
<p>纯分页</p>
<ul>
<li>不会受到外部碎片的影响，而是会受到内部碎片的影响。进程是按页面粒度分配的，如果页面没有得到充分利用，就会导致内部碎片和相应的空间浪费。</li>
<li>分页还使进程能够在分页的粒度上共享代码。</li>
</ul>
<h3 id="89"><a class="markdownIt-Anchor" href="#89"></a> 8.9</h3>
<blockquote>
<p>8.9 假设一个将页表存放在内存的分页系统：<br>
a. 如果一次内存访问需 200ns， 访问一页内存要用多长间？<br>
b. 如果加入TLB，并且75%的页表引用发生在TLB，内存有效访问时间是多少？（假设在TLB中查找页表项占用零时间， 如果页表项在其中。)</p>
</blockquote>
<p>a：需要400ns,用200ns访问内存页表，再用200ns进入内存中的字</p>
<p>b：有效查询时间=0.75*200ns+0.25*400ns=250ms</p>
<h3 id="810"><a class="markdownIt-Anchor" href="#810"></a> 8.10</h3>
<blockquote>
<p>为什么时常将分页与分段在同一个方案中结合使用？</p>
</blockquote>
<p>分段和分页通常结合在一起，以便相互改进。</p>
<p>当页表变得非常大时，分段非常有用。页表中未使用的较大连续部分可以折叠成页表地址为零的单个段表条目。分页分段处理需要大量时间进行分配的很长分段的情况。通过分页分段，我们减少了由于外部碎片造成的内存浪费，同时简化了分配</p>
<h3 id="811"><a class="markdownIt-Anchor" href="#811"></a> 8.11</h3>
<blockquote>
<p>试说明为什么使用分段比使用纯分页更容易共享一个可重入模块。</p>
</blockquote>
<h3 id="812"><a class="markdownIt-Anchor" href="#812"></a> 8.12</h3>
<blockquote>
<p>假设有下面的段表</p>
<p><img src="/posts/8ce3e425/image-20211223170751628.png" srcset="/img/loading.gif" lazyload alt="image-20211223170751628"></p>
<p>下面逻辑地址的物理地址是多少？</p>
<p>a. 0430<br>
b. 110<br>
c. 2500<br>
d. 3400<br>
e. 4122</p>
</blockquote>
<p>根据逻辑地址分离出段号和段内偏移，首先需要根据段长度判断地址是否合法</p>
<p>a=430+219=649</p>
<p>b=10+2300=2310</p>
<p>c:段偏移500&gt;段长度100，越界，地址不合法</p>
<p>d=400+1327=1727</p>
<p>e:段偏移122&gt;段长度96,越界，不合法</p>
<h3 id="813"><a class="markdownIt-Anchor" href="#813"></a> 8.13</h3>
<blockquote>
<p>页表分页的目的是什么？</p>
</blockquote>
<p>分页（paging）内存管理方案允许进程的物理地址空间可以是非连续的。 分页避免了将不同大小的内存块匹配到交换空间上这样的麻烦。</p>
<p>在某些情况下，分页的页表可以变得足够大 ，可以简化内存分配问题（确保全部可以分配固定大小的页 ， 而不是可变大小的块）确保当前未使用的部分页表可以交换 。</p>
<h1 id="第9章-虚拟内存"><a class="markdownIt-Anchor" href="#第9章-虚拟内存"></a> 第9章 虚拟内存</h1>
<h2 id="91-背景"><a class="markdownIt-Anchor" href="#91-背景"></a> 9.1 背景</h2>
<p>虚拟内存（virtual memory）将用户逻辑内存与物理内存分开。这在现有物理内存有限的情况下， 为程序员提供了巨大的虚拟内存 。 虚拟内存使编程更加容易， 因为程序员不再需要担心可用的有限物理内存空间， 只需要关注所要解决的问题。</p>
<p><img src="/posts/8ce3e425/image-20220101142011629.png" srcset="/img/loading.gif" lazyload alt="image-20220101142011629"></p>
<p>除了将逻辑内存与物理内存分开， 虚拟内存也允许文件和内存通过共享页而为两个或多个进程所共享（见 8.4.4 小节）。 这带来了如下优点：</p>
<ul>
<li>通过将共享对象映射到虚拟地址空间， 系统库可为多个进程所共享。 虽然每个进程都认为共享库是其虚拟地址空间的一部分， 而共享库所用的物理内存的实际页是为所有进程所共享。</li>
<li>类似地， 虚拟内存允许进程共享内存。 如第3章所述， 两个或多个进程之间可以通过使用共享内存来通信。虚拟内存允许一个进程创建内存区域，以便与其他进程进行共享。共享该内存区域的进程认为它是其虚拟地址空间的一部分， 而事实上这部分是共享的， 如图 9.3 所示。</li>
<li>虚拟内存可允许在用系统调用fork()创建进程期间共享页， 从而加快进程创建。</li>
</ul>
<p><img src="/posts/8ce3e425/image-20220101142401380.png" srcset="/img/loading.gif" lazyload alt="image-20220101142401380"></p>
<h2 id="92-按需调页"><a class="markdownIt-Anchor" href="#92-按需调页"></a> 9.2 按需调页</h2>
<p>**按需调页（**demand paging）:</p>
<p>是在需要时才调入相应的页。 这种技术常为虚拟内存系统所采用。 对于按需调页虚拟内存，只有程序执行需要时才载入页，那些从未访问的页不会调入到物理内存。</p>
<h3 id="921-基本概念"><a class="markdownIt-Anchor" href="#921-基本概念"></a> 9.2.1 基本概念</h3>
<p>当换入进程时，调页程序推测在该进程再次换出之前会用到哪些页。调页程序不是调入整个进程，而是把那些必需的页调入内存。这样， 调页程序就避免了读入那些不使用的页，也减少了变换时间和所需的物理内存空间。</p>
<p>需要设置页表条目的<strong>有效-无效位</strong>来区分哪些页在内存里。</p>
<p><img src="/posts/8ce3e425/image-20220103132620930.png" srcset="/img/loading.gif" lazyload alt="image-20220103132620930"></p>
<p>对标记为无效的访问会产生<strong>页错误陷阱</strong>（page-fault trap）。 分页硬件，在通过页表转换地址时，将发现己设置了无效位，会陷入操作系统。</p>
<p><strong>处理这种页错误的程序的流程：</strong></p>
<ul>
<li>①检查进程的内部页表（通常与PCB一起保存），以确定该引用是合法还是非法的地址访问。</li>
<li>②如果引用非法，那么终止进程。 如果引用有效但是尚未调入页面， 那么现在应调入。</li>
<li>③找到一个空闲帧 （例如，从空闲帧链表中选取一个）。</li>
<li>④调度一个磁盘操作， 以便将所需要的页调入刚分配的帧。</li>
<li>⑤当磁盘读操作完成后， 修改进程的内部表和页表， 以表示该页己在内存中。</li>
<li>⑥重新开始因陷阱而中断的指令。 进程现在能访问所需的页， 就好像它似乎总在内存中。</li>
</ul>
<p><img src="/posts/8ce3e425/image-20220103133033220.png" srcset="/img/loading.gif" lazyload alt="image-20220103133033220"></p>
<p><strong>支持按需调页的硬件</strong>与分页和交换的硬件一样：</p>
<ul>
<li>页表： 该表能够通过有效－无效位或保护位的特定值， 将条目设为无效。</li>
<li>次级存储器：该次级存储器用来保存不在内存中的页。次级存储器通常为快速磁盘。它通常称为交换设备， 用于交换的这部分磁盘称为交换空间（ swap space）。</li>
</ul>
<h3 id="922-按需调页的性能"><a class="markdownIt-Anchor" href="#922-按需调页的性能"></a> 9.2.2 按需调页的性能</h3>
<p><strong>按需调页内存的有效访问时间：</strong></p>
<p>设p为页错误的概率（0≤p≤1）。 希望p接近于 0， 即页错误很少。</p>
<p>内存访问时间（用ma表示）的范围为10～200ns</p>
<p>那么有效访问时间为：</p>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">有</mi><mi mathvariant="normal">效</mi><mi mathvariant="normal">访</mi><mi mathvariant="normal">问</mi><mi mathvariant="normal">时</mi><mi mathvariant="normal">间</mi><mi mathvariant="normal">＝</mi><mo stretchy="false">(</mo><mn>1</mn><mo>−</mo><mi>p</mi><mo stretchy="false">)</mo><mo>×</mo><mi>m</mi><mi>a</mi><mo>+</mo><mi>p</mi><mo>×</mo><mi mathvariant="normal">页</mi><mi mathvariant="normal">错</mi><mi mathvariant="normal">误</mi><mi mathvariant="normal">时</mi><mi mathvariant="normal">间</mi></mrow><annotation encoding="application/x-tex">有效访问时间＝ (1-p)×ma+p ×页错误时间
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord cjk_fallback">有</span><span class="mord cjk_fallback">效</span><span class="mord cjk_fallback">访</span><span class="mord cjk_fallback">问</span><span class="mord cjk_fallback">时</span><span class="mord cjk_fallback">间</span><span class="mord cjk_fallback">＝</span><span class="mopen">(</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">p</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">a</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.7777700000000001em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">p</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0em;vertical-align:0em;"></span><span class="mord cjk_fallback">页</span><span class="mord cjk_fallback">错</span><span class="mord cjk_fallback">误</span><span class="mord cjk_fallback">时</span><span class="mord cjk_fallback">间</span></span></span></span></span></p>
<p>页错误会引起如下序列的动作产生：</p>
<ul>
<li>①陷入到操作系统。</li>
<li>②保存用户寄存器和进程状态。</li>
<li>③确定中断是否为页错误。</li>
<li>④检查页引用是否合法并确定页所在磁盘的位置。</li>
<li>⑤从磁盘读入页到空闲帧中。
<ul>
<li>a. 在该磁盘队列中等待， 直到处理完读请求。</li>
<li>b. 等待磁盘的寻道和/或延迟时间。</li>
<li>c. 开始将磁盘的页传到空闲帧。</li>
</ul>
</li>
<li>⑥在等待时， 将 CPU 分配给其他用户（ CPU 调度， 可选）。</li>
<li>⑦从 I/O 子系统接收到中断（以示I/O完成）。</li>
<li>③保存其他用户的寄存器和进程状态（如果执行了第 6 步）。</li>
<li>⑨确定中断是否来自磁盘。</li>
<li>⑩修正页表和其他表以表示所需页现已在内存中。</li>
<li>⑪等待 CPU 再次分配给本进程。</li>
<li>⑫恢复用户寄存器、 进程状态和新页表， 再重新执行中断的指令。</li>
</ul>
<p>以上步骤并不是在所有情况下都是必需的。</p>
<p>不管如何， 都有如下三个主要的页错误处理时间：</p>
<ul>
<li>①处理页错误中断。</li>
<li>②读入页。</li>
<li>③重新启动进程。</li>
</ul>
<p>有效访问时间与页错误率直接有关。</p>
<p>按需调页的；另一个重要方面是<strong>交换空间的处理和使用</strong>。磁盘I/O到交换空间通常比到文件系统要快。 这是因为交换空间是按大块来分配的，并不使用文件查找和间接分配方法（第 12 章〉。因此，如果在进程开始时将整个文件镜像复制到交换空间，并从交换空间执行按页调度， 那么有可能获得更好的调页效果。 另一选择是开始时从文件系统中进行按需调页， 但是当出现页置换时则将页写入交换空间， 这种方法确保只有所需的页才从文件系统中调入，而以后出现的调页是从交换空间中读入的。</p>
<h2 id="93-写时复制"><a class="markdownIt-Anchor" href="#93-写时复制"></a> 9.3 写时复制</h2>
<p>传统上，fork()为子进程创建一个父进程地址空间的副本， 复制属于父进程的页。然而，由于许多子进程在创建之后通常马上会执行系统调用exec()，所以父进程地址空间的复制可能没有必要。</p>
<p>因此， 可以使用一 种称为<strong>写时复制</strong>（copy-on-write ）的技术。 这种方法允许父进程与子进程开始时共享同一页面。 这些页面标记为写时复制页， 即如果任何一个进程需要对页进行写操作，那么就创建一个共享页的副本。 写时复制如图 9.7 和图 9.8 所示;这两个图反映了进程 l修改页C前后的物理内存的情况。</p>
<p><img src="/posts/8ce3e425/image-20220103135108349.png" srcset="/img/loading.gif" lazyload alt="image-20220103135108349"></p>
<p>只有可能修改的页才需要标记为写时复制。 不能修改的页（即包含可执行代码的页）可以为父进程和子进程所共享。</p>
<h2 id="94-页面置换"><a class="markdownIt-Anchor" href="#94-页面置换"></a> 9.4 页面置换</h2>
<p>内存的过度分配会出现以下问题。当一个用户进程执行时， 一个页错误发生。操作系统会确定所需页在磁盘上的位置， 但是却发现空闲帧列表上并没有空闲帧，所有内存都在使用。这时候就需要页置换算法。</p>
<h3 id="941-基本页置换"><a class="markdownIt-Anchor" href="#941-基本页置换"></a> 9.4.1 基本页置换</h3>
<p><strong>修改页错误处理程序</strong>以包括页置换：</p>
<ul>
<li>①查找所需页在磁盘上的位置。</li>
<li>②查找一个空闲帧：
<ul>
<li>a. 如果有空闲帧， 那么就使用它。</li>
<li>b. 如果没有空闲帧， 那么就使用页置换算法以选择一个 “ 牺牲 ” 帧、。</li>
<li>c. 将 “ 牺牲 ” 帧的内容写到磁盘上， 改变页表和帧表。</li>
</ul>
</li>
<li>③将所需页读入(新)空闲帧， 改变页表和帧表。</li>
<li>④重启用户进程</li>
</ul>
<p>如果没有帧空闲，那么需要采用两个页传输（一个换出，一个换入）。这种情况实际上把页错误处理时间加倍了， 且也相应地增加了有效访问时间。  可以通过使用<strong>修改位</strong>（modify bit） 或脏位（dirty bit）以降低额外开销。每页或帧可以有一个修改位， 通过硬件与之相关联。每当页内的任何字或字节被写入时， 硬件就会设置该页的修改位以表示该页己修改。 如果修改位已设置， 那么就可以知道自从磁盘读入后该页己发生了修改。在这种情况下， 如果该页被选择为替换页， 就必须要把该页写到磁盘上去。然而， 如果修改位 没有设置， 那么也就知道自从磁盘读入后该页井没有发生修改。 因此， 磁盘上页的副本的内容没有必要（例如用其他页〉重写， 因此就避免了将内存页写回磁盘上。</p>
<p>为实现按需调页， 必须解决两个主要问题：必须开发帧分配算法和页置换算法。如果在内存中有多个进程， 那么必须决定为每个进程各分配多少帧。而且，当需要页置换时，必须选择要置换的帧。</p>
<h3 id="942-fifo页置换"><a class="markdownIt-Anchor" href="#942-fifo页置换"></a> 9.4.2 FIFO页置换</h3>
<p>最简单的页置换算法是<strong>FIFO算法</strong>。FIFO页置换算法为每个页记录着该页调入内存的时间。 当必须置换一页时， 将选择最旧的页。 注意并不需要记录调入一页的确切时间。可以创建一个FIFO队列来管理内存中的所有页。队列中的首页将被置换。当需要调入页时，将它加到队列的尾部。</p>
<p><img src="/posts/8ce3e425/image-20220103142955088.png" srcset="/img/loading.gif" lazyload alt="image-20220103142955088"></p>
<h3 id="943-最优置换"><a class="markdownIt-Anchor" href="#943-最优置换"></a> 9.4.3 最优置换</h3>
<p><strong>最优页置换算法</strong>是所有算法中产生页错误率最低的，且绝没有Belady 异常的问题。这种算法确实存在， 它被称为 <strong>OPT 或 MIN</strong>。 它会置换最长时间不会使用的页。 使用这种页置换算法确保对于给定数量的帧会产生最低可能的页错误率。</p>
<p><img src="/posts/8ce3e425/image-20220103143129400.png" srcset="/img/loading.gif" lazyload alt="image-20220103143129400"></p>
<p>然而，最优置换算法难以实现，因为需要引用串的未来知识（在 5.3.2小节讨论SJF CPU调度时，碰到过一个类似问题）。</p>
<h3 id="944-lru页置换"><a class="markdownIt-Anchor" href="#944-lru页置换"></a> 9.4.4 LRU页置换</h3>
<p>如果使用离过去最近作为不远将来的近似， 那么可置换最长时间没有使用的页（见图 9.15），这种方法称为<strong>最近最少使用算法</strong>（least-recently-used(<strong>LRU</strong>) algorithm）。</p>
<p><img src="/posts/8ce3e425/image-20220103143347226.png" srcset="/img/loading.gif" lazyload alt="image-20220103143347226"></p>
<p><strong>栈</strong>：实现LRU置换的 一个方法是采用页码栈。每当引用一个页，该页就从栈中删除并放在顶部。 这样， 栈顶部总是最近使用的页， 栈底部总是LRU页（图9.16）。由于必须从栈中部删除项， 所以该栈可实现为具有头指针和尾指针的双向链表。 这样， 删除 一页并放在栈顶部在最坏情况下需要改变6个指针。 虽说每个更新有点费时，但是置换不需要搜索；尾指针指向栈底部，就是LRU页。 对于用软件或微代码的LRU置换的实现， 这种方法十分合适。</p>
<p><img src="/posts/8ce3e425/image-20220103143738632.png" srcset="/img/loading.gif" lazyload alt="image-20220103143738632"></p>
<h3 id="945-近似lru页置换"><a class="markdownIt-Anchor" href="#945-近似lru页置换"></a> 9.4.5  近似LRU页置换</h3>
<p>很少有计算机系统能提供足够的硬件来支持真正的LRU页置换。有的系统不提供任何支持，因此必须使用其他置换算法（如FIFO算法）。</p>
<p>然而， 许多系统都通过<strong>引用位</strong>方式提供一定的支持。页表内的每项都关联着一个引用位（reference bit）。每当引用一个页时（无论是对页的字节进行读或写）， 相应页表的引用位就被硬件置位。开始， 操作系统会将所有引用位都清零。 随着用户进程的执行， 与引用页相关联的引用位被硬件置 位（置为 1）。之后，通过检查引用位，能够确定哪些页 使用过而哪些页未使用过。虽然不知道 使用顺序，但是知道哪些页 用过而哪些页未用过。这信息是许多近似LRU页置换算法的基础。</p>
<ol>
<li>
<p><strong>附加引用位算法</strong><br>
通过在规定时间间隔里记录引用位，可以获得额外顺序信息。 可以为位于内存内的每个表中的页保留一个8位的字节。在规定时间间隔（如， 每100 ms） 内，时钟定时器产生中断并将控制转交给操作系统。 操作系统把每个页的引用位转移到其8位字节的高位，而将 其他位向右移一位，并抛弃最低位。 这些8位移位寄存器包含着该页在最近8个时间周期内的使用情况。 例如，如果移位寄存器含有00000000，那么该页在8个时间周期内没有使用：如果移位寄存器的值为11111111， 那么该页在过去每个周期内都至少使用过 一次。具有值为11000100 的移位寄存器的页要比值为01110111 的页更为最近使用。 如果将这8位字节作为无符号整数，那么具有最小值的页为LRU页，且可以被置换。</p>
</li>
<li>
<p><strong>二次机会算法</strong></p>
<p>二次机会置换的基本算法是 FIFO 置换算法。 当要选择一个页时，检查其引用位。如果其值为0，那么就直接置换该页。如果引用位为1，那么就给该页第二次机会，并选择下一个FIFO 页。当一个页获得第二次机会时，其引用位清零，且其到达时间设为当前时间。因此，获得第二次机会的页在所有其他页置换（或获得第二次机会）之前，是不会被置换的。 另外，如果一 个页经常使用以致其引用位总是被设置， 那么它就不会被置换。</p>
<p>一种实现二次机会算法（有时称为<strong>时钟算法</strong>）的方法是采用循环队列。 用一个指针表示下次要置换哪一页。 当需要一个帧时，指针向前移动直到找到一个引用位为0的页。在向前移动时，它将清除引用位（见图 9.17）。一旦找到牺牲页，就置换该页，新页就插入到循环队列的该位置。注意：在最坏情况下，所有位均己设置，指针会遍历整个循环队列，以便给每个页第二次机会。 它将清除所有引用位后再选择页来置换。 这样，如果所有位均已设置，那么二次机会置换就变成了FIFO 置换。</p>
<p><img src="/posts/8ce3e425/image-20220103144540004.png" srcset="/img/loading.gif" lazyload alt="image-20220103144540004"></p>
</li>
<li>
<p><strong>增强型二次机会算法</strong><br>
通过将引用位和修改位（将在 9.4.1 小节中介绍〉作为一有序对来考虑，可以改进二次机会算法。 采用这两个位，有下面四种可能类型：<br>
①（0, 0）最近没有使用且也没有修改一一 用于置换的最佳页。</p>
<p>②（0, 1）最近没有使用 但修改过一一不是很好，因为在置换之前需要将页写出到磁盘。</p>
<p>③ (1, 0）最近使用过但没有修改一一它有可能很快又要被使用。</p>
<p>④（1, 1）最近使用过且修改过一一它有可能很快又要被使用， 且置换之前需要将页写出到磁盘。</p>
</li>
</ol>
<h3 id="946-基于计数的页置换"><a class="markdownIt-Anchor" href="#946-基于计数的页置换"></a> 9.4.6 基于计数的页置换</h3>
<p>还有许多其他算法可用于页置换。 例如， 可以为每个页保留一个用于记录其引用次数的计数器， 并可形成如下两个方案。</p>
<ul>
<li>
<p><strong>最不经常使用页置换算法</strong>（ least frequently used (<strong>LFU</strong>) page-replacement algorithm）要求置换计数最小的页。 这种选择的理由是活动页应该有更大的引用次数。 这种算法会产生如下问题： 一个页在进程开始时使用很多， 但以后就不再使用。 由于其使用过很多， 所以它有较大次数， 所以即使不再使用仍然会在内存中。 解决方法之一是定期地将次数寄存器右移一位， 以形成指数衰减的平均使用次数。</p>
</li>
<li>
<p><strong>最常使用页置换算法</strong>（ most frequently used (<strong>MFU</strong>) page-replacement algorithm） 是基于如下理论： 具有最小次数的页可能刚刚调进来， 且还没有使用。可以想象，MFU 和 LFU 置换都不常用。 这两种算法的实现都很费时， 且并不能很好地近似OPT置换算法。</p>
</li>
</ul>
<h3 id="947-页缓冲算法"><a class="markdownIt-Anchor" href="#947-页缓冲算法"></a> 9.4.7 页缓冲算法</h3>
<p>除了特定页置换算法外， 还经常采用其他措施。 例如，系统通常保留一个空闲帧缓冲池。 当出现页错误时， 会像以前一样选择一个牺牲帧。 然而， 在牺牲帧写出之前，所需要的页就从缓冲池中读到空闲内存。 这种方法允许进程尽可能快地重启，而无须等待牺牲帧页的写出。 当在牺牲帧以后写出时， 它再加入到空闲帧池。</p>
<p>另 一种修改是保留一个空闲帧池， 但要记住哪些页在哪些帧中。 由于当帧写到磁盘上时其内容并没有修改， 所以在该帧被重用之前如果需要使用原来页， 那么原来页可直接从空闲帧池中取出来使用。 这时并不需要1/0。 当一个页错误发生时， 先检查所需要页是否在空闲帧池中。 如果不在， 那么才必须选择一个空闲帧来读入所需页。</p>
<h2 id="95-帧分配"><a class="markdownIt-Anchor" href="#95-帧分配"></a> 9.5 帧分配</h2>
<h3 id="951-帧的最少数量"><a class="markdownIt-Anchor" href="#951-帧的最少数量"></a> 9.5.1 帧的最少数量</h3>
<p>每个进程帧的最少数量是由体系结构决定的，而最大数量是由可用物理内存的数量来决定。在这两者之间，关于帧分配还是有很多选择的。</p>
<h3 id="952-分配算法"><a class="markdownIt-Anchor" href="#952-分配算法"></a> 9.5.2 分配算法</h3>
<p><strong>平均分配</strong></p>
<p>在n个进程之间分配 m个帧的最为容易的方法是给每个一个平均值，即 m/n 帧</p>
<p><strong>比例分配</strong></p>
<p>根据进程大小，而将可用内存分配给每个进程。设进程 Pt的虚拟内存大小为S<sub>i</sub>且定义</p>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>S</mi><mo>=</mo><mo>∑</mo><msub><mi>s</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">S=\sum s_i
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.6000100000000002em;vertical-align:-0.55001em;"></span><span class="mop op-symbol large-op" style="position:relative;top:-0.000004999999999977245em;">∑</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></span></p>
<p>这样， 如果可用帧的总数为m，那么进程 P<sub>i</sub> 可分配到 a~i个帧， 这里a；近似为</p>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>a</mi><mi>i</mi></msub><mo>=</mo><msub><mi>s</mi><mi>i</mi></msub><mi mathvariant="normal">/</mi><mi>S</mi><mo>×</mo><mi>m</mi></mrow><annotation encoding="application/x-tex">a_i=s_i/S×m
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord">/</span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">m</span></span></span></span></span></p>
<h3 id="953-全局分配与局部分配"><a class="markdownIt-Anchor" href="#953-全局分配与局部分配"></a> 9.5.3 全局分配与局部分配</h3>
<p>各个进程分配帧的另 一个重要因素是页置换。 当有多个进程竞争帧时， 可将页置换算法分为两大类： <strong>全局置换</strong>（global replacement）和<strong>局部置换</strong>（local replacement）。</p>
<ul>
<li><strong>全局置换</strong>允许一个进程从所有帧集合中选择一个置换帧， 而不管该帧是否已分配给其他进程， 即一个进程可以从另一个进程中拿到帧。</li>
<li><strong>局部置换</strong>要求每个进程仅从其自己的分配帧中进行选择。</li>
</ul>
<p>局部置换不能使用其他进程的不常用的内存， 所以会阻碍一个进<br>
程。因此， 全局置换通常会有更好的系统吞吐量， 且更为常用。</p>
<h2 id="96-系统颠簸"><a class="markdownIt-Anchor" href="#96-系统颠簸"></a> 9.6 系统颠簸</h2>
<p>频繁的页调度行为称为颠簸（thrashing）。如果一个进程在换页上用的时间要多于执行时间， 那么这个进程就在颠簸。</p>
<h3 id="961-系统颠簸的原因"><a class="markdownIt-Anchor" href="#961-系统颠簸的原因"></a> 9.6.1 系统颠簸的原因</h3>
<p>操作系统在监视CPU的使用率。 如果CPU使用率太低， 那么向系统中引入新进程，以增加多道程序的程度。采用全局置换算法，它会置换页而不管这些页是属于哪个进程的。现在假设一个进程进入一个新执行阶段， 需要更多的帧。 它开始出现页错误， 并从其他进程中拿到帧。 然而， 这些进程也需要这些页， 所以它们也会出现页错误， 从而从其他进程中拿到帧。 这些页错误进程必须使用调页设备以换进和换出页。 随着它们排队等待换页设备， 就绪队列会变空， 而进程等待调页设备，CPU使用率就会降低。</p>
<p>CPU调度程序发现CPU使用率降低，因此会增加多道程序的程度。 新进程试图从其他运行进程中拿到帧，从而引起更多页错误， 形成更长的调页设备的队列。 因此，CPU使用率进一步降低，CPU调度程序试图再增加多道程序的程度。 这样就出现了系统颠簸， 系统吞吐量陡降， 页错误显著增加。 因此， 有效内存访问时间增加。 最终因为进程主要忙于调页， 系统不能完成一件工作。</p>
<p><img src="/posts/8ce3e425/image-20220103150630462.png" srcset="/img/loading.gif" lazyload alt="image-20220103150630462"></p>
<h3 id="962-工作集合模型"><a class="markdownIt-Anchor" href="#962-工作集合模型"></a> 9.6.2 工作集合模型</h3>
<p>工作集合模型（working-set model) 是基于局部性假设的。该模型使用参数<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">Δ</mi></mrow><annotation encoding="application/x-tex">\Delta</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord">Δ</span></span></span></span> 定义工作集合窗口（working-set window）。其思想是检查最近<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">Δ</mi></mrow><annotation encoding="application/x-tex">\Delta</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord">Δ</span></span></span></span>个页的引用。 这最近<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">Δ</mi></mrow><annotation encoding="application/x-tex">\Delta</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord">Δ</span></span></span></span>个引用的页集合称为工作集合（working set) （如图 9.20 所示）。如果一个页正在使用中，<br>
那么它就在工作集合内。如果它不再使用，那么它会在其上次引用的A时间单位后从工作集合中删除。 因此，工作集合是程序局部的近似。</p>
<p><img src="/posts/8ce3e425/image-20220103184407266.png" srcset="/img/loading.gif" lazyload alt="image-20220103184407266"></p>
<h3 id="963-页错误频率"><a class="markdownIt-Anchor" href="#963-页错误频率"></a> 9.6.3 页错误频率</h3>
<p>颠簸具有高的页错误率。因此，需要控制页错误率。当页错误率太高时， 进程需要更多帧。类似地，如果页错误率太低，那么进程可能有太多的帧。 可以为所期望的页错误率设置上限和下限（见图 9.21 ）。 如果实际页错误率超过上限，那么为进程分配更多的帧：如果实际页错误率低于下限，那么可从该进程中移走帧。因此，可以直接测量 和控制页错误率以防止颠簸。与工作集合策略一样， 也可能必须暂停一个进程。 如果页错误增加且没有可用帧， 那么必须选择一个进程暂停。 接着， 可将释放的帧分配给那些具有高页错误率的进程。</p>
<h2 id="97-内存映射文件"><a class="markdownIt-Anchor" href="#97-内存映射文件"></a> 9.7 内存映射文件</h2>
<h3 id="971-基本机制"><a class="markdownIt-Anchor" href="#971-基本机制"></a> 9.7.1 基本机制</h3>
<p>文件的内存映射可将一磁盘块映射成内存的一页（或多页）。 开始的文件访问按普通请求页面调度来进行， 会产生页错误。这样， 一页大小的部分文件从文件系统读入物理页（有的系统会一次读入多个一页大小的内容〉。以后文件的读写就按通常的内存访问来处理，由于是通过内存操作文件而不是使用系统调用 read()和 write()， 从而简化了文件访问和使用。</p>
<p><img src="/posts/8ce3e425/image-20220103194041972.png" srcset="/img/loading.gif" lazyload alt="image-20220103194041972"></p>
<h3 id="972-win32-api中的共享内存"><a class="markdownIt-Anchor" href="#972-win32-api中的共享内存"></a> 9.7.2 Win32 API中的共享内存</h3>
<h3 id="973-内存映射io"><a class="markdownIt-Anchor" href="#973-内存映射io"></a> 9.7.3 内存映射I/O</h3>
<h2 id="98-内核内存的分配"><a class="markdownIt-Anchor" href="#98-内核内存的分配"></a> 9.8 内核内存的分配</h2>
<h3 id="981-buddy系统"><a class="markdownIt-Anchor" href="#981-buddy系统"></a> 9.8.1 Buddy系统</h3>
<p>“Buddy系统 ” 从物理上连续的大小固定的段上进行分配。内存按2幂的大小来进行分配， 即 4 KB、 8 KB、 16 KB等。 如果请求大小不为 2 的事， 那么需要调整到下一个更大的 2 的幂。 例如， 请求大小为 11KB， 那么会按 16 KB 来请求。</p>
<p><img src="/posts/8ce3e425/image-20220103194814856.png" srcset="/img/loading.gif" lazyload alt="image-20220103194814856"></p>
<p>Buddy 系统的一个<strong>优点</strong>是可通过合并而快速地形成更大的段。 例如，如果图 9.27 中的CL 被释放，那么CL 和CR 可合并成 64KB 的段。而这个段BL 又可同BR 合并而得到 128KB的段。 最终， 得到了原来的大小为 256KB 的段。<br>
Buddy 系统的一个明显<strong>缺点</strong>是由于调整到下一个 2 的事容易产生碎片。 例如， 33KB的内存请求只能用 64KB 的段来满足。 事实上，可能有 50%的内存会因碎片而浪费。 下面讨论另一种没有碎片损失的内存分配。</p>
<h3 id="982-slab分配"><a class="markdownIt-Anchor" href="#982-slab分配"></a> 9.8.2 slab分配</h3>
<p>内核分配的另 一种方案是 slab 分配。 slab 是由一个或多个物理上连续的页组成的。 高速缓存（ cache ）含有一个或多个 slab。 每个内核数据结构都有一个 cache， 如进程描述符、文件对象、 信号量等。 每个 cache 含有内核数据结构的对象实例。 例如， 信号量 cache 存储着信号量对象，进程描述符 cache 存储着进程描述符对象。 图 9.28 描述 slab、 cache 及对象三者之间的关系。 该图中有两个 3KB 大小的内核对象和三个 7KB 大小的内核对象。 它<br>
们分别位于各自的 cache 上。</p>
<p><img src="/posts/8ce3e425/image-20220103195716302.png" srcset="/img/loading.gif" lazyload alt="image-20220103195716302"></p>
<p>slab分配器有两个主要优点：</p>
<p>①没有因碎片而引起的内存浪费。 碎片不是问题， 这是因为每个内核数据结构都有相应的cache， 而每个cache 都由若干slab组成， 而每个slab又分为若干个与对象大小相  同的部分。 因此， 当内核请求对象内存时， slab 分配器可以返回刚好可以表示对象所需的内存。</p>
<p>②内存请求可以快速满足。slab 分配器对于需要经常不断分配内存、释放内存来说特别有效， 而操作系统经常这样做。 内存分配与释放可能费时。 然而， 由于对象预先创建，所以可从 cache 上快速分配。另外，当用完对象并释放时，只需要标记为空闲并 返回给 cache,以便下次再用。</p>
<h2 id="99-其他考虑"><a class="markdownIt-Anchor" href="#99-其他考虑"></a> 9.9 其他考虑</h2>
<h3 id="991-预调页"><a class="markdownIt-Anchor" href="#991-预调页"></a> 9.9.1 预调页</h3>
<h3 id="992-页大小"><a class="markdownIt-Anchor" href="#992-页大小"></a> 9.9.2 页大小</h3>
<h3 id="993-tlb范围"><a class="markdownIt-Anchor" href="#993-tlb范围"></a> 9.9.3 TLB范围</h3>
<h3 id="994-反向页表"><a class="markdownIt-Anchor" href="#994-反向页表"></a> 9.9.4 反向页表</h3>
<h3 id="995-程序结构"><a class="markdownIt-Anchor" href="#995-程序结构"></a> 9.9.5 程序结构</h3>
<h3 id="996-io互锁"><a class="markdownIt-Anchor" href="#996-io互锁"></a> 9.9.6 I/O互锁</h3>
<h2 id="910-操作系统实例"><a class="markdownIt-Anchor" href="#910-操作系统实例"></a> 9.10 操作系统实例</h2>
<h3 id="9101-windows-xp"><a class="markdownIt-Anchor" href="#9101-windows-xp"></a> 9.10.1 Windows XP</h3>
<h3 id="9102-solaris"><a class="markdownIt-Anchor" href="#9102-solaris"></a> 9.10.2 Solaris</h3>
<h2 id="911-习题"><a class="markdownIt-Anchor" href="#911-习题"></a> 9.11 习题</h2>
<blockquote>
<p>9.2 讨论按需调页所需的硬件支持。</p>
</blockquote>
<p>页表、TLB、次级存储器</p>
<blockquote>
<p>9.3 什么是写时复制？何时这种特点有效？实现这种特点需要什么硬件支持？</p>
</blockquote>
<p><strong>写时复制</strong>（copy-on-write ）允许父进程与子进程开始时共享同一页面。 这些页面标记为写时复制页， 即如果任何一个进程需要对页进行写操作，那么就创建一个共享页的副本。以允许两个程序分别访问不同的副本，而不会相互干扰。</p>
<p>实现所需的<strong>硬件支持</strong>简单如下：在每次内存访问时，需要查阅页表以检查页是否具有写保护。如果它确实是写保护的，则会出现陷阱，操作系统可以解决此问题</p>
<blockquote>
<p>9.4 某台计算机给它的用户提供了2<sup>32</sup> B 的虚拟地址空间。计算机有2<sup>18</sup>B 的物理内存。虚拟内存使用页面大小为 4096B的分页机制实现。一个用户进程产生虚拟地址 11123456，现在说明一下系统怎样建立相应的物理地址。 区分一下软件操作和硬件操作。</p>
</blockquote>
<blockquote>
<p>9.5 假设有一个按需调页存储器， 页表放在寄存器中。 处理一个页错误， 当有空的帧可用或被置换的帧没有被修改过时要用8 ms， 当被置换的帧被修改过时用20ms。存储器存取时间为lOOns。假设被置换的页中有70%被修改过， 有效存取时间不超过200ns 时最大可以接受的页错误率是多少？</p>
</blockquote>
<p><img src="/posts/8ce3e425/image-20220112085440155.png" srcset="/img/loading.gif" lazyload alt="image-20220112085440155"></p>
<blockquote>
<p>9.6 假定要监视时钟算法的指针移动速度（可用来表示页替换的速度）。 根据下面现象， 可得到什么结论？<br>
a. 指针移动快<br>
b. 指针移动慢</p>
</blockquote>
<p>如果指针移动得很快，那么程序会同时访问大量页面。最有可能的是，在与页面对应的位被清除和再次检查之间的时间段内，页面被再次访问，因此无法被替换。这会导致在找到受害者页面之前对页面进行更多扫描。如果指针移动缓慢，那么虚拟内存系统将极其高效地查找替换的候选页，这表明许多驻留页没有被访问</p>
<blockquote>
<p>9.7 讨论在何种情况下最少经常使用页替换算法要比最近最少使用页置换算法要好。 并讨论相反情况。</p>
</blockquote>
<p>偶发性的、周期性的批量查询操作（包含冷数据）会淘汰掉大量的热点数据，导致 LRU 命中率急剧下降，缓存污染情况比较严重。这种情况下LFU算法更优。</p>
<p>相反情况：一个页在进程开始时使用很多， 但以后就不再使用。 由于其使用过很多， 所以它有较大次数， LFU不会将其替换，所以即使不再使用仍然会在内存中。这种情况下比LRU差。</p>
<p>举例：</p>
<p>考虑下面的页串：1 1 2 3 4 5 1，内存可容纳4页，当访问5时，LFU算法将会替换除了1以外的任意一页，这样接下来访问1时，可以不用替换。</p>
<p>相反情况，如果考虑下面的页串： 1 2 3 4 5 2，LRU算法的性能更好。</p>
<blockquote>
<p>9.8 讨论在何种情况下最多经常使用页置换算法要比最少近来使用算法要好。 并讨论相反情况。</p>
</blockquote>
<p>MFU基于以下原理具有最小次数的页可能刚刚调进来， 且还没有使用。</p>
<p>考虑可容纳 4 页的内存 1 2 3 4 4 4 5 1 ,MFU 算法会用 5 替换 4 ， 而 LRU 则用5替换1，这种情况LRU更优。</p>
<p>在实践中很少使用MFU</p>
<blockquote>
<p>9.9 VAXNMS 系统采用 FIFO 置换算法来处理常驻页和经常使用页的空闲帧池。 假定空闲帧池采用最近最少使用置换算法。 试回答下列问题：<br>
a如果出现页错误而所需页不在空闲帧池中， 那么新请求页如何从空闲中分配？<br>
b.如果出现页错误且所需页在空闲帧池中，那么新请求页如何由常驻页和经常使用页的空闲池<br>
来满足？<br>
c.如果常驻页的数量为l， 那么这样方法会退化成什么？<br>
d.如果空闲帧池的页数量为0 ， 那么这样方法会退化成什么？</p>
</blockquote>
<blockquote>
<p>9.10 假设一个具有下面时间利用率的按需调页系统：</p>
<p>CPU利用率   20%<br>
分页磁盘    97.7%<br>
其他IO设备   5%</p>
<p>试说明下面哪一项可能提高CPU的利用率， 为什么？<br>
a.安装一个更快的CPU<br>
b.安装一个更大的分页磁盘<br>
c.提高多道程序的程度<br>
d.降低多道程序的程度<br>
e.安装更多内存<br>
f.安装个更快的硬盘， 或对多个硬盘用多个控制器<br>
g.加入预约式页面调度算法预取页<br>
h.增加页面大小</p>
</blockquote>
<p>abc不行</p>
<p>其他可以</p>
<p>h可能加可能减</p>
<blockquote>
<p>一个页置换算法应使发生页面错误的次数最小化。 可以通过将使用频率高的页平均分配到整个内存， 而不是只使用少数几个帧来达到这种最小化。 可以对每个帧设置一个计数器来记录与帧相关的页数。 那么当置换一个页时就可以查找页数最少的帧来置换。</p>
<p>a. 基于这个基本思想定义一个页置换算法。 特别注意的问题：</p>
<p>①计数器初始化值是多少？</p>
<p>②什么时候计数增加？</p>
<p>③什么时候计数减少？</p>
<p>④怎样选择被置换的页？</p>
<p>b. 设有 4 个帧， 对于下面的页引用序列， 你的算法会发生多少次页错误？</p>
<p>1,2,3,4,5,3,4, 1,6,7,8, 7, 8,9,7,8,9, 5, 4, 5, 4, 2<br>
c. 最优页置换算法对于 4 帧的 b 中的页引用序列最小页错误数为多少？</p>
</blockquote>
<p>a.定义一 个页面置换算法解决 问题 ：</p>
<p>①计数器初始值——0 ;</p>
<p>②计数器值增加——每当新的一页与此帧相关联 ；</p>
<p>③计数器值减少——每当与此帧相关联的一个页不再需要 ；</p>
<p>④怎样选择要被置换的页一一找到带有最小计数器值的帧。使用先进先出算法解除其关系</p>
<p>b. 14个页错误</p>
<p>c. 11个页错误</p>
<blockquote>
<p>9.14 假设一个请求调页系统具有一个平均访问和传输时间为 20ms 的分页磁盘。 地址转换是通过在主存中的页表来进行的， 每次内存访问时间为1闷。 这样， 每个通过页表进行的内存访问都要访问内存两次。 为了提高性能， 加入一个相关存储器， 当页表项在相关存储器中时， 可以减少对内存的访问次数。 假设 80%的访问发生在相关存储器中， 而且剩下中的 10%（或总的 2%） 会导致页错误。内存的有效访问时间是多少？</p>
</blockquote>
<blockquote>
<p>！！！9.15 颠簸的原因是什么？系统怎样检测颠簸？－旦系统检测到颠簸， 系统怎样来消除这个问题？</p>
</blockquote>
<p>分配的页数少于进程所需的最小页数时发生颠簸，并迫使它不断地发生页错误。</p>
<p>该系统可通过对比多道程序的程度和CPU利用率的程度，以此来检测颠簸。<br>
降低多道程序的程度可以消除颠簸。</p>
<blockquote>
<p>9.16 一个进程是否可有两个工作集合， 一个用于数据， 另一用于代码？试解释之。</p>
</blockquote>
<blockquote>
<p>9.17 在工作集合模型中， 参数A 用来定义工作集合窗口的大小。当为A 设置一个小值时， 对页错误频率及正在系统中执行进程的数量有何影响？当为A设置一个大值时， 又如何？</p>
</blockquote>
<blockquote>
<p>9.20 假设有一个系统允许为进程分配不同大小的页。这样的请求页系统有什么优点？如何修改虚拟内存系统以提供这种功能？</p>
</blockquote>
<h1 id="第10章-文件系统接口"><a class="markdownIt-Anchor" href="#第10章-文件系统接口"></a> 第10章 文件系统接口</h1>
<h2 id="101-文件概念"><a class="markdownIt-Anchor" href="#101-文件概念"></a> 10.1 文件概念</h2>
<p>从用户角度而言，文件是逻辑外存的最小分配单元 ，即数据除非在文件中，否则不能写到外存。 通常， 文件表示程序（源形式和目标形式）和数据。</p>
<h3 id="1011-文件属性"><a class="markdownIt-Anchor" href="#1011-文件属性"></a> 10.1.1 文件属性</h3>
<p>文件有一定的属性， 这根据系统而有所不同， 但是通常都包括如下属性：</p>
<ul>
<li>名称：文件符号名称是唯一的、 按照人们容易读取的形式 保存。</li>
<li>标识符：标识文件系统内文件的 唯一标签， 通常为数字；对人而言这是不可读的文件名称。</li>
<li>类型：被支持不同类型的文件系统所使用。</li>
<li>位置： 该信息为指向设备和设备上文件位置的指针。</li>
<li>大小：文件当前大小（以字节、字或块来统计〉，该属性也可包括文件允许的最大容量值。</li>
<li>保护： 决定谁能读、写、 执行等的访问控制信息。</li>
<li>时间、 日期和用户标识：文件创建、 上次修改和上次访问的相关信息。 这些数据用于保护、 安全和使用跟踪。</li>
</ul>
<h3 id="1012-文件操作"><a class="markdownIt-Anchor" href="#1012-文件操作"></a> 10.1.2 文件操作</h3>
<p><strong>基本文件操作：</strong></p>
<ul>
<li>
<p><strong>创建文件</strong>：创建文件有两个必要步骤。第一，必须在文件系统中为文件找到空间。在第11章中将会讨论如何为 文件分配空间。 第二，在目录中为 新文件创建一个条目。</p>
</li>
<li>
<p><strong>写文件</strong>： 为了写文件，执行一个系统调用，其指明文件名称和要写入文件的内容。对于给定的文件名称，系统会搜索目录以查找该文件位置。 系统必须为该文件维护一个军位置的指针。每当发生写操作时，必须更新写指针。</p>
</li>
<li>
<p><strong>读文件</strong>： 为了读文件，使用一个系统调用，并指明文件名称和要读入文件块的内存位置。 同样，需要搜索目录以找到相关目录项，系统要为该文件维护一个读位置的指针。每当发生读操作时，必须更新尉旨针。 一个进程通常只对一个文件读或写，所以当前操作位置可作为每个进程当前文件位置指针。由于 读和写操作都使用同一指针，这既节省了空间也降低系统复杂度。</p>
</li>
<li>
<p><strong>在文件内重定位</strong>： 搜索目录相应条目，设置当前文件位置指针为给定值。 在文件内重定位不需要包含真正的 I/0。该文件操作也称为主佯罩在世（seek）。</p>
</li>
<li>
<p><strong>删除文件</strong>： 为了删除文件，在目录中搜索给定名称的文件。 找到相关目录条目后，释放所有的文件空间以便其他文件使用，并删除相应目录条目。</p>
</li>
<li>
<p><strong>截短文件</strong>： 用户可能只需要删除文件内容而保留其属性，而不是强制删除文件再创建文件。该函数将不改变所有文件属性，而只是将其长度设为0并释放其空间。</p>
</li>
</ul>
<h3 id="1013-文件类型"><a class="markdownIt-Anchor" href="#1013-文件类型"></a> 10.1.3 文件类型</h3>
<p><img src="/posts/8ce3e425/image-20220108122633760.png" srcset="/img/loading.gif" lazyload alt="image-20220108122633760"></p>
<h3 id="1014-文件结构"><a class="markdownIt-Anchor" href="#1014-文件结构"></a> 10.1.4 文件结构</h3>
<h3 id="1015-内部文件结构"><a class="markdownIt-Anchor" href="#1015-内部文件结构"></a> 10.1.5 内部文件结构</h3>
<h2 id="102-访问方法"><a class="markdownIt-Anchor" href="#102-访问方法"></a> 10.2 访问方法</h2>
<h3 id="1021-顺序访问"><a class="markdownIt-Anchor" href="#1021-顺序访问"></a> 10.2.1 顺序访问</h3>
<p>最为简单的访问方式是<strong>顺序访问</strong>。 文件信息按顺序， 一个记录接着一个记录地加以处理。 这种访问模式最为常用， 例如， 编辑器和编译器通常按这种方式访问文件。</p>
<p>大量的文件操作是读和写。 读操作读取下 一文件部分，并自动前移文件指针，以跟踪I/O位置。类似地， 写操作会向文件尾部增加内容，相应的文件指针移到新增数据之后（ 新文件结尾）。 文件也可重新设置到开始位置， 有的系统允许向前或向后跳过n个（这里n为整数， 有时只能为I)记录。 顺序访问如图 10.3 所示。 顺序访问基于文件的磁带模型，不仅适用于顺序访问设备， 也适用于随机访问设备。</p>
<p><img src="/posts/8ce3e425/image-20220108123600713.png" srcset="/img/loading.gif" lazyload alt="image-20220108123600713"></p>
<h3 id="1022-直接访问"><a class="markdownIt-Anchor" href="#1022-直接访问"></a> 10.2.2 直接访问</h3>
<p>另一方式是<strong>直接访问</strong> （或相对访问〉。 文件由固定长度的逻辑记录组成， 以允许程序按任意顺序进行快速读和写。 直接访问方式是基于文件的磁盘模型， 这是因为磁盘允许对任意文件块进行随机读和写。 对直接访问， 文件可作为块或记录的编号序列。 因此， 可先读取块14， 再读块53， 最后再写块7。 对于直接访问文件， 读写顺序是没有限制的。</p>
<p>由用户向操作系统所提供的块号通常为<strong>相对块号</strong>。 相对块号是相对于文件开始的索引。</p>
<h3 id="1023-其他访问方式"><a class="markdownIt-Anchor" href="#1023-其他访问方式"></a> 10.2.3 其他访问方式</h3>
<p>其他访问方式可建立在直接访问方式之上。 这些访问通常涉及创建文件索引。 索引包括各块的指针。 为了查找文件中的记录， 首先搜索索引， 再根据指针直接访问文件， 以查找所需要的记录。</p>
<p><img src="/posts/8ce3e425/image-20220108124050544.png" srcset="/img/loading.gif" lazyload alt="image-20220108124050544"></p>
<h2 id="103-目录结构"><a class="markdownIt-Anchor" href="#103-目录结构"></a> 10.3 目录结构</h2>
<h3 id="1031-存储结构"><a class="markdownIt-Anchor" href="#1031-存储结构"></a> 10.3.1 存储结构</h3>
<p>有时需要在一个磁盘上装多种文件系统， 或一部分用于文件系统而另 一部分用于其他地方， 如交换空间或非格式化的磁盘空间。 这些部分称为<strong>分区</strong>或片， 或称为小型磁盘（IBM的说法）。</p>
<p>将存储文件系统的一大块存储空间作为<strong>卷</strong>。 卷可以存放多个操作系统， 使系统启动和运行多个操作系统。</p>
<p><img src="/posts/8ce3e425/image-20220108124227507.png" srcset="/img/loading.gif" lazyload alt="image-20220108124227507"></p>
<h3 id="1032-目录概述"><a class="markdownIt-Anchor" href="#1032-目录概述"></a> 10.3.2 目录概述</h3>
<p><strong>目录相关操作：</strong></p>
<ul>
<li>**搜索文件：**需要能够搜索目录结构以查找特定文件的条目。因为文件具有符号名称，且类似的名称可能表示文件之间的关系， 所以要能查找文件名和某个模式相匹配的所有文件。</li>
<li><strong>创建文件：</strong> 可以创建新文件并增加到目录中。</li>
<li><strong>删除文件：</strong> 当不再需要文件时， 可以从目录中删除它。</li>
<li><strong>遍历目录：</strong> 需要能遍历目录内的所有文件以及其目录中每个文件条目的内容。</li>
<li><strong>重命名文件：</strong> 因为文件名称可向用户表示其内容， 当文件内容和用途改变时名称必须改变。 重新命名文件也允许改变该文件在目录结构中的位置。</li>
<li><strong>跟踪文件系统：</strong> 用户可能希望访问每个目录和每个目录的每个文件。 为了可靠， 定期备份整个文件系统的内容和结构是个不错的方法。 这种备份通常将所有文件复制到磁带上。 这种技术提供了备份副本以防止系统出错。 除此之外， 当文件不再使用时候， 这个文件被复制到磁带上， 该文件的原来占用磁盘空间可以释放以供其他文件所用。</li>
</ul>
<h3 id="1033-单层结构目录"><a class="markdownIt-Anchor" href="#1033-单层结构目录"></a> 10.3.3 单层结构目录</h3>
<p>最简单的目录结构是单层结构目录。 所有文件都包含在同一目录中， 其特点是便于理解和支持。</p>
<p><img src="/posts/8ce3e425/image-20220108125045812.png" srcset="/img/loading.gif" lazyload alt="image-20220108125045812"></p>
<h3 id="1034-双层结构目录"><a class="markdownIt-Anchor" href="#1034-双层结构目录"></a> 10.3.4 双层结构目录</h3>
<p>对于<strong>双层结构目录</strong>的结构， 每个用户都有自己的用户文件目录（ user file directory,UFD）。 每个UFD 都有相似的结构， 但只列出了单个用户的文件。 当一个用户作业开始执行或一个用户注册时， 就搜索系统的主文件目录（ master file directory, MFD）。 通过用户名或账号可索引MFD， 每个条目指向用户的UFD（见图10.8）。</p>
<p><img src="/posts/8ce3e425/image-20220108125126077.png" srcset="/img/loading.gif" lazyload alt="image-20220108125126077"></p>
<p>虽然双层结构目录解决了名称冲突问题， 但是它仍有缺点。 这种结构有效地对用户加以隔离。 这种隔离在用户需要完全独立时是优点， 但是在用户需要在某个任务上进行合作和访问其他文件时却是个缺点。 有的系统简单地不允许本地用户文件被其他用户所访问。</p>
<h3 id="1035-树状结构目录"><a class="markdownIt-Anchor" href="#1035-树状结构目录"></a> 10.3.5 树状结构目录</h3>
<p>将两层目录结构扩展为任意高度的树，这种推广允许用户创建自己的子目录，相应地组织文件。事实上，树是最为常用的目录结构。树有根目录，系统内的每个文件都有唯一路径名。</p>
<p><img src="/posts/8ce3e425/image-20220108125717434.png" srcset="/img/loading.gif" lazyload alt="image-20220108125717434"></p>
<h3 id="1036-无环图目录"><a class="markdownIt-Anchor" href="#1036-无环图目录"></a> 10.3.6 无环图目录</h3>
<p>树状结构禁止共享文件和目录。 <strong>无环图</strong>（acyclic graph）允许目录含有共享子目录和文件（见图10.10）。 用一文件或子目录可出现在两个不同目录中。 无环图是树状结构目录方案的扩展。</p>
<p><img src="/posts/8ce3e425/image-20220108130216854.png" srcset="/img/loading.gif" lazyload alt="image-20220108130216854"></p>
<h3 id="1037-通用图目录"><a class="markdownIt-Anchor" href="#1037-通用图目录"></a> 10.3.7 通用图目录</h3>
<p>当对己存在的树状结构目录增加链接时， 树状结构就被破坏了， 产生了简单的图结构  。</p>
<p><img src="/posts/8ce3e425/image-20220108130627493.png" srcset="/img/loading.gif" lazyload alt="image-20220108130627493"></p>
<h2 id="104-文件系统安装"><a class="markdownIt-Anchor" href="#104-文件系统安装"></a> 10.4 文件系统安装</h2>
<p>如同文件使用前必须要扩开，文件系统在被系统上的进程使用之前必须安装（ mount）。具体地说， 目录结构可以建立在多个卷上， 这些卷必须被安装以使它们在文件系统命名空间中可用。</p>
<p><img src="/posts/8ce3e425/image-20220108131017823.png" srcset="/img/loading.gif" lazyload alt="image-20220108131017823"></p>
<h2 id="105-文件共享"><a class="markdownIt-Anchor" href="#105-文件共享"></a> 10.5 文件共享</h2>
<h3 id="1051-多用户"><a class="markdownIt-Anchor" href="#1051-多用户"></a> 10.5.1 多用户</h3>
<h3 id="1052-远程文件系统"><a class="markdownIt-Anchor" href="#1052-远程文件系统"></a> 10.5.2 远程文件系统</h3>
<h3 id="1053-一致性语义"><a class="markdownIt-Anchor" href="#1053-一致性语义"></a> 10.5.3 一致性语义</h3>
<h2 id="106-保护"><a class="markdownIt-Anchor" href="#106-保护"></a> 10.6 保护</h2>
<h3 id="1061-访回类型"><a class="markdownIt-Anchor" href="#1061-访回类型"></a> 10.6.1 访回类型</h3>
<h3 id="1062-访问控制"><a class="markdownIt-Anchor" href="#1062-访问控制"></a> 10.6.2 访问控制</h3>
<h3 id="1063-其他保护方式"><a class="markdownIt-Anchor" href="#1063-其他保护方式"></a> 10.6.3 其他保护方式</h3>
<h2 id="107-小结"><a class="markdownIt-Anchor" href="#107-小结"></a> 10.7 小结</h2>
<h2 id="习题"><a class="markdownIt-Anchor" href="#习题"></a> 习题</h2>
<h1 id="第11章-文件系统实现"><a class="markdownIt-Anchor" href="#第11章-文件系统实现"></a> 第11章 文件系统实现</h1>
<h2 id="111-文件系统结构"><a class="markdownIt-Anchor" href="#111-文件系统结构"></a> 11.1 文件系统结构</h2>
<p>磁盘提供大量的外存空间来维持文件系统。<strong>磁盘</strong>的下述两个<strong>特点</strong>，使其成为存储多个文件的方便介质：</p>
<ul>
<li>
<p>①可以原地重写，可以从磁盘上读一块，修改该块，并将它写回到原来的位置。</p>
</li>
<li>
<p>②可以直接访问磁盘上的任意一块信息。因此，可以方便地按顺序或随机地访问文件，从一个文件切换到另 一个文件只需要简单地移动读写磁头并等待磁盘转动即可以完成。</p>
</li>
</ul>
<p><img src="/posts/8ce3e425/image-20220108133306308.png" srcset="/img/loading.gif" lazyload alt="image-20220108133306308"></p>
<p>设计中的每层利用较低层的功能创建新的功能来为更高层服务。</p>
<p><strong>I/O控制</strong>为最底层， 由设备驱动程序和中断处理程序组成， 实现内存与 磁盘之间的信息传输。 设备驱动程序可以作为翻译器。 其输入由高层命令组成， 如 “ retrieve block 123”  。其输出由底层的 、硬件特定的命令组成， 这些命令用于控制硬件控制器， 通过硬件控制器可以使VO 设备与系统其他部分相连。</p>
<p><strong>基本文件系统</strong>只需要向合适的设备驱动程序发送一般命令就可对磁盘上的物理块进行读写。每个块由其数值磁盘地址来标识（例如，驱动器1，柱面（ cylinder) 73，磁道（ track)3， 扇区（sector) 10）。</p>
<p><strong>文件组织模块</strong>知道文件及其逻辑块和物理块。 由于知道所使用的文件分配类型和文件的位置， 文件组织模块可以将逻辑块地址转换成基本文件系统所用的物理块地址。 每个文件的逻辑块按从0 或1到N来编号， 而包含数据的物理块并不与逻辑号匹配， 因此需要通过翻译来定位块。 文件组织模块也包括空闲空间 管理器， 用来跟踪未分配的块并根据要求提供给文件组织模块。</p>
<p><strong>逻辑文件系统</strong>管理元数据。元数据包括文件系统的所有结构数据， 而不包括实际数据（或文件内容）。逻辑文件系统根据给定符号文件名来 管理目录结构，并提供给文件组织模块所需要的信息。逻辑文件系统通过文件控制块来维护文件结构。文件控制块（file control block, FCB） 包含文件的信息， 如拥有者、权限、文件内容的位置。 逻辑文件系统也负责保护和安全（参见第10章和第14章）。</p>
<p>UNIX使用UNIX文件系统（<strong>UFS</strong>），它是基于伯克利快速文件系统（FFS） 的。</p>
<p>WindowsNT、Windows2000、WindowsXP支持 磁盘文件系统 <strong>FAT</strong>、<strong>FAT32</strong>和<strong>NTFS</strong></p>
<h2 id="112-文件系统实现"><a class="markdownIt-Anchor" href="#112-文件系统实现"></a> 11.2 文件系统实现</h2>
<h3 id="1121-概述"><a class="markdownIt-Anchor" href="#1121-概述"></a> 11.2.1 概述</h3>
<p><strong>磁盘结构</strong></p>
<p>在磁盘上，文件系统可能包括如下信息：</p>
<ul>
<li>如何启动所存储的操作系统</li>
<li>总的块数</li>
<li>空闲块的数目和位置</li>
<li>目录结构以及各个具体文件等</li>
</ul>
<p>磁盘结构包括</p>
<ul>
<li><strong>引导控制块</strong>（boot control block）：通常为分区的第一块。如果该分区没有OS，则为空。（其他名称：引导块（Linux）、分区引导扇区（WindowsNT））</li>
<li><strong>分区控制块</strong>（partition control block）：包括分区详细信息，如分区的块数、块的大小、空闲块的数量和指针、空闲FCB的数量和指针等（亦称为超级块（Linux）、主控文件表（WindowsNT））</li>
<li>**目录结构：**用来组织文件</li>
<li>**文件控制块（FCB）：**包括很多文件信息，如文件许可、拥有者、大小和数据块的位置等</li>
</ul>
<p><strong>内存中与文件相关的结构</strong></p>
<ul>
<li>
<p>内存分区表：包含所有安装分区的信息</p>
</li>
<li>
<p>内存目录结构：保存近来访问过的目录信息（对安装分区的目录，可以包括一个指向分区表的指针）</p>
</li>
<li>
<p>系统范围的打开文件表：包括每个打开文件的FCB拷贝和其他信息</p>
</li>
<li>
<p>单个进程的打开文件表：包括一个指向系统范围内已打开文件表中合适条目和其他信息的指针</p>
<ul>
<li>
<p>文件描述符（file descriptor, Linux/UNIX）</p>
<p>文件描述符在形式上是一个非负整数。当程序打开一个现有文件或者创建一个新文件时，内核向进程返回一个文件描述符。文件进程控制块中都有一份文件描述符表（可以把它看成是一个数组，里面的元素是指向file结构体指针类型），这个数组的下标就是文件描述符。文件描述符是Linux/unix下的概念</p>
</li>
<li>
<p>文件句柄（file handle, Windows）</p>
<p>Windows下的概念。句柄是Windows下各种对象的标识符。文件句柄和文件描述符类似，它也是一个非负整数，也用于定位文件数据在内存中的位置。</p>
</li>
</ul>
</li>
</ul>
<h3 id="1122-分区与安装"><a class="markdownIt-Anchor" href="#1122-分区与安装"></a> 11.2.2 分区与安装</h3>
<h3 id="1123-虚拟文件系统"><a class="markdownIt-Anchor" href="#1123-虚拟文件系统"></a> 11.2.3 虚拟文件系统</h3>
<p>虚拟文件系统(VFS)提供了一种面向对象的方法来实现文件系统</p>
<p>VFS允许在不同类型的文件系统上采用同样的系统调用接口（API）</p>
<ul>
<li>API是针对VFS的接口，而非对任何特定类型的文件系统</li>
</ul>
<p>虚拟文件系统实现的目标是：</p>
<ul>
<li>同时支持多种文件系统，系统中安装多个文件系统时，对用户而言没有区别，他们都表现为一致的接口。</li>
</ul>
<h2 id="113-目录实现"><a class="markdownIt-Anchor" href="#113-目录实现"></a> 11.3 目录实现</h2>
<h3 id="1131-线性列表"><a class="markdownIt-Anchor" href="#1131-线性列表"></a> 11.3.1 线性列表</h3>
<p>最为简单的目录实现方法是使用存储文件名和数据块指针的线性列表。</p>
<p>这种方法编程简单但运行时较为费时。</p>
<p>要创建新文件，必须首先搜索目录以确定没有同样名称的文件存在。接着，在目录后增加一个新条目。要删除文件时，根据给定文件名搜索目录，接着释放分配给它的空间。</p>
<h3 id="1132-哈希表"><a class="markdownIt-Anchor" href="#1132-哈希表"></a> 11.3.2 哈希表</h3>
<p>用于文件目录的另一个数据结构是哈希表。采用这种方法时，除了使用线性列表存储目录条目外， 还使用了哈希数据结构。 哈希表根据文件名得到一个值， 井返回一个指向线性列表中元素的指针。</p>
<p>因此， 它大大地减少目录搜索时间。 插入和删除也较简单， 不过需要一些预备措施来避免冲突（collision) （两个文件名哈希到相同的位置〉。</p>
<h2 id="114-分配方法"><a class="markdownIt-Anchor" href="#114-分配方法"></a> 11.4 分配方法</h2>
<p>常用的主要磁盘空间分配方法有三个： 连续、链接和索引。每种方法都有其优点和缺点。</p>
<h3 id="1141-连续分配"><a class="markdownIt-Anchor" href="#1141-连续分配"></a> 11.4.1 连续分配</h3>
<p><strong>连续分配</strong>（contiguous allocation） 方法要求每个文件在磁盘上占有一组连续的块。</p>
<p>文件的连续分配可以用第一块的磁盘地址和连续块的数量来定义。 如果文件有n块长并从位置b开始， 那么该文件将占有块b,b+I,b+2 …，b+n一 1。 一个文件的目录条目包括开始块的地址和该文件所分配区域的长度， 参见图11.5。</p>
<p><img src="/posts/8ce3e425/image-20220108140304356.png" srcset="/img/loading.gif" lazyload alt="image-20220108140304356"></p>
<p><strong>优点：</strong></p>
<ul>
<li>采用这种序列，假设只有一个作业访问磁盘，在访问块b后访问块b+1通常不需要移动磁头。当需要磁头移动（从一个柱面的最后扇区到下 一个柱面的第一扇区），只需要移动一个磁道。因此，用于访问连续分配文件所需要的寻道数最小，在确实需要寻道时所需要的寻道时间也最小。</li>
<li>连续分配支持顺序访问和直接访问</li>
<li>简单 － 只需要记录文件的起始位置（块号）及长度。</li>
</ul>
<p><strong>缺点：</strong></p>
<ul>
<li>为新文件找到空间比较困难。 有外部碎片（external fragmentation）问题。</li>
<li>连续分配的另一个问题是确定一个文件需要多少空间。</li>
</ul>
<h3 id="1142-链接分配"><a class="markdownIt-Anchor" href="#1142-链接分配"></a> 11.4.2 链接分配</h3>
<p><strong>链接分配</strong>（linked allocation） 解决了连续分配的所有问题。 采用链接分配， 每个文件是磁盘块的链表： 磁盘块分布在磁盘的任何地方。 目录包括文件第一块的指针和最后一块的指针。 例如， 一个有 5 块的文件可能从块 9 开始，然而是块 16、 块 1 、 块 10，最后是块25 （见图 11.6）。每块都有一个指向下一块的指针。用户不能使用这些指针。因此，如果每块有 512B， 磁盘地址为 4B， 那么用户可以使用 508B。</p>
<p><img src="/posts/8ce3e425/image-20220108140920356.png" srcset="/img/loading.gif" lazyload alt="image-20220108140920356"></p>
<p><strong>优点：</strong></p>
<ul>
<li>采用链接分配没有外部碎片，空闲空间列表上的任何块可以用来满足请求。</li>
<li>文件创建与增长容易，当创建文件时，并不需要说明文件大小。 只要有空闲块，文件就可以增大。 因此，无需合并磁盘空间。</li>
</ul>
<p><strong>缺点：</strong></p>
<ul>
<li>主要问题是它只能有效地用于文件的顺序访问。 要找到文件的第i块，必须从文件的开始起，跟着指针，找到第i块。 对指针的每次访问都需要读磁盘，有时需要进行磁盘寻道。 因此，链接分配不能有效地支持文件的直接访问。</li>
<li>链接分配的另一缺点是指针需要空间。如果指针需要使用 512B 块中的4B，那么0.78%的磁盘空间将会用于指针，而不是其他信息。 因而，每个文件也需要比原来更多的空间。</li>
<li>链接分配存在可靠性问题。会有指针损坏或丢失问题。</li>
</ul>
<p>一 个采用 链接分配方法的变种是**文件分配表（FAT）**的使用 。 这一简单但有效的磁盘空间分配用于MS-DOS和OS/2操作系统。</p>
<p>FAT的使用与链表相似。 目录条目含有文件首块的块号码。根据块号码索引的FAT条目包含 文件下一块的块号码。 这条链会一直继续到最后一块，该块对应FAT条目的值为文件结束值。未使用的块用0值来表示。</p>
<p><img src="/posts/8ce3e425/image-20220108141639269.png" srcset="/img/loading.gif" lazyload alt="image-20220108141639269"></p>
<h3 id="1143-索引分配"><a class="markdownIt-Anchor" href="#1143-索引分配"></a> 11.4.3 索引分配</h3>
<p><strong>索引分配</strong>（indexed allocation）通过把所有指针放在一起， 即通过索引块解决了这个问题。</p>
<p>当创建文件时， 索引块的所有指针都设为 null。 当首次写入第i块时， 先从空闲空间管理器中得到一块， 再将其地址写到索引块的第i个条目。</p>
<p><img src="/posts/8ce3e425/image-20220108151724583.png" srcset="/img/loading.gif" lazyload alt="image-20220108151724583"></p>
<p><strong>优点：</strong></p>
<ul>
<li>索引分配支持直接访问， 且没有外部碎片问题， 这是因为磁盘上的任一块都可满足更多空间的要求。</li>
<li>保持了链接结构的优点，又解决了其缺点：</li>
<li>即能顺序存取，又能随机存取</li>
<li>满足了文件动态增长、插入删除的要求</li>
<li>能充分利用外存空间</li>
</ul>
<p><strong>缺点：</strong></p>
<ul>
<li>索引分配会浪费空间。索引块指针的开销通常要比链接分配指针的开销大。设想一下在一般情况下， 每个文件只有一块或两块长。 采用链接分配， 每块只浪费一个指针。 采用索引分配， 尽管只有一个或两个指针为非空， 也必须分配一个完整的索引块。</li>
<li>索引分配方案与链接分配一样在性能方面有所欠缺。 特别是， 虽然索引块可以缓存在内存中，但是数据块可能分布在整个分区上。</li>
</ul>
<p><strong>确定索引块大小的机制：</strong></p>
<ul>
<li>链接方案：一个索引块通常为一个磁盘块。 因此， 它本身能直接读写。 为了处理大文件， 可以将多个索引块链接起来。 例如， 一个索引块可以包括一个含有文件名的头部和一组头100个磁盘块的地址。 下一个地址（索引块的最后一个词）为 nil （对于小文件〉或指向另 一个索引块（大文件）。</li>
<li>多层索引：链接表示的一种变种是用第一层索引块指向一组第二层的索引块， 第二层索引块再指向文件块。 为了访问一块， 操作系统通过第一层索引查找第二层索引， 再用第二层索引查找所需的数据块。 这种方法根据最大文件大小的要求， 可以继续到第三或第四层。 对于有 4 096 B 的块， 可以在索引块中存入 1 024 个4B的指针。 两层索引允许1048576个数据块， 这允许最大文件为 4GB。</li>
<li>组合方案：在 UFS 中使用的另 一方案是将索引块的头 15 个指针存在文件的 inode中。 这其中的头 12 个指针指向直接块：即它们包括了能存储文件数据的块的地址。 因此，（不超过 12 块的〉小文件不需要其他的索引块。 如果块大小为 4 KB ， 那么不超过 48 KB的数据可以直接访问。其他3个指针指向间接块。第一个间接块指针为一级间接块的地址。一级间接块为索引块， 它包含的不是数据， 而是那些包含数据的块的地址。 接着是一个二级间接块指针， 它包含了 一个块的地址， 而这个块中的地址指向了一些块， 这些块中又包含了指向真实数据块的指针。 最后一个指针为三级间接块指针。 采用这种方法，一个文件的块数可以超过许多操作系统所使用的 4B 的文件指针所能访问的空间。 32 位指针只能访问 2<sup>32</sup> B， 即4GB。 许多 UNIX 如 Solaris 和 IBM AIX 现在支持高达 64 位的文件指针。 这样的指针允许文件和文件系统为数太字节。 图 11.9 显示了一个 UNIX 的inode。</li>
</ul>
<p><img src="/posts/8ce3e425/image-20220108152148247.png" srcset="/img/loading.gif" lazyload alt="image-20220108152148247"></p>
<h3 id="1144-性能"><a class="markdownIt-Anchor" href="#1144-性能"></a> 11.4.4 性能</h3>
<h2 id="115-空闲空间管理"><a class="markdownIt-Anchor" href="#115-空闲空间管理"></a> 11.5 空闲空间管理</h2>
<p>为了记录空闲磁盘空间，系统需要维护一个空闲空间链表。 空闲空间链表记录了所有空闲磁盘空间， 即未分配给文件或目录的空间。 当创建文件时， 搜索空闲空间链表以得到所需要的空间， 并分配给新文件。 这些空间会从空闲空间链表中删除。 当删除文件时， 其磁盘空间会增加到空闲空间表上。 空闲空间链表虽然称为链表， 但不一定表现为链表。</p>
<h3 id="1151-位向量"><a class="markdownIt-Anchor" href="#1151-位向量"></a> 11.5.1 位向量</h3>
<p>空闲空间表实现为位图（bit map） 或位向量（bit vector）。 每块用一位表示。 如果一块为空闲， 那么其位为1：如果一块己分配， 那么其位为0。</p>
<p>例如， 假设有一个磁盘，其块 2 、 3、 4、 5、 8、9、 10、 11、 12、 13、 17、 18 、 25、 26、<br>
27 为空闲， 其他块为己分配。 那么， 空闲空间位图如下：<br>
001111001111110001100000011100000···</p>
<h3 id="1152-链表"><a class="markdownIt-Anchor" href="#1152-链表"></a> 11.5.2 链表</h3>
<p>空闲空间管理的另一种方法是将所有空闲磁盘块用链表连接起来， 并将指向第一空闲块的指针保存在磁盘的特殊位置， 同时也缓存在内存中。 第一块包含一个下一空闲磁盘块的指针， 如此继续下去。</p>
<p><img src="/posts/8ce3e425/image-20220108152927671.png" srcset="/img/loading.gif" lazyload alt="image-20220108152927671"></p>
<h3 id="1153-组"><a class="markdownIt-Anchor" href="#1153-组"></a> 11.5.3 组</h3>
<p>对空闲链表的一个改进是将n个空闲块的地址存在第一个空闲块中。这些块中的前 n-1个确实为空， 而最后一块包含另外n个空闲块的地址， 如此继续。 大量空闲块的地址可以很快地找到， 这一点有别于标准链表方法。</p>
<h3 id="1154-计数"><a class="markdownIt-Anchor" href="#1154-计数"></a> 11.5.4 计数</h3>
<p>另外一种方法是利用这样一个事实： 通常， 有多个连续块需要同时分配或释放， 尤其是在使用连续分配和采用簇时更是如此。 因此， 不是记录n个空闲块的地址， 而是可以记录第一块的地址和紧跟第一块的连续的空闲块的数量 n。 这样， 空闲空间表的每个条目包括磁盘地址和数量。 虽然每个条目会比原来需要更多空间， 但是表的总长度会更短， 这是因为连续块的数量常常大于1。</p>
<h2 id="116-效率与性能"><a class="markdownIt-Anchor" href="#116-效率与性能"></a> 11.6 效率与性能</h2>
<h3 id="1161-效率"><a class="markdownIt-Anchor" href="#1161-效率"></a> 11.6.1 效率</h3>
<p>磁盘空间的有效使用主要取决于所使用的磁盘分配和目录管理算法。</p>
<h3 id="1162-性能"><a class="markdownIt-Anchor" href="#1162-性能"></a> 11.6.2 性能</h3>
<h2 id="习题-2"><a class="markdownIt-Anchor" href="#习题-2"></a> 习题</h2>
<h2 id="112"><a class="markdownIt-Anchor" href="#112"></a> 11.2</h2>
<blockquote>
<p>链接分配的一种变种中， 使用 FAT 把文件的所有块链接起来， 它的优点和缺点是什么？</p>
</blockquote>
<p>优点：改善了随机访问时间，因为通过读入 FAT 信息，磁头能找到任何块的位置。在访问存储在文件中间的块时，可以通过追踪存储在FATA中的指针来确定其位置，而不是以顺序方式访问文件的所有单个块以找到指向目标块的指针。通常，大部分FAT都可以缓存在内存中，因此指针可以通过内存访问来确定，而不必访问磁盘块。</p>
<p>缺点：如果不对 FAT 采用缓存，FAT 分配方案可能导致大量的磁头寻道时间。磁头必须移到卷的开头以便读入 FAT，寻找所需要块的位置，接着移到块本身的位置。在最坏的情况下，每块都需要两次移动。</p>
<h2 id="114"><a class="markdownIt-Anchor" href="#114"></a> 11.4</h2>
<blockquote>
<p>有一些文件系统允许磁盘空间在不同的粒度级别分配。 比如， 文件系统可以把 4KB的磁盘空间分配为一个 4KB 的块， 或者 8 个 512 B 的块。 可以怎样利用这种特性来改进性能？要支持这种特性需要对空闲空间管理机制做什么修改？</p>
</blockquote>
<p>这样的方案将减少内部碎片。如果一个文件是5KB，那么它可能位于一个4KB块和两个连续的512字节块。除了维护空闲块的位图外，还必须维护关于块内当前正在使用的子块的额外状态。定位器随后必须检查该额外状态以分配子块，并在所有子块空闲时合并子块以获得较大的块</p>
<h2 id="116"><a class="markdownIt-Anchor" href="#116"></a> 11.6</h2>
<blockquote>
<p>设想一个在磁盘上的系统的逻辑块和物理块的大小都为 512 B。假设每个文件的信息已经在内存中。 针对三种分配方法（连续分配、 链接分配和索引分配）， 分别回答下面的问题。<br>
a. 逻辑地址到物理地址的映射是怎样进行的（对索引分配， 假设文件总是小于 512 块)？</p>
<p>b. 假设当前处在逻辑块 10 (最后访问的块是块 10）， 现在想访问逻辑块 4， 那么必须从磁盘上读多少个物理块？</p>
</blockquote>
<p>设Z为起始文件地址（块号）</p>
<p><strong>连续分配：</strong></p>
<p>a. 将逻辑地址除以512，X和Y为所得商和余数。将X添加到Z以获得物理块编号。Y是到那个块的位移</p>
<p>b. 1个物理块</p>
<p><strong>链接分配：</strong></p>
<p>a. 将逻辑物理地址除以511，X和Y为所得的商和余数，向下搜索链接列表（获得X+1个块）。Y+1是到最后一个物理块的位移。</p>
<p>b. 4个物理块</p>
<p><strong>索引分配：</strong></p>
<p>a. 将逻辑地址除以512，X和Y为所得商和余数。将索引块存储到内存中。物理块地址包含在位置X.Y处的索引块是所需物理块的位移</p>
<p>b. 2个物理块</p>
<h1 id="第12章-大容量存储器的结构"><a class="markdownIt-Anchor" href="#第12章-大容量存储器的结构"></a> 第12章 大容量存储器的结构</h1>
<h2 id="121-大容量存储器结构简介"><a class="markdownIt-Anchor" href="#121-大容量存储器结构简介"></a> 12.1 大容量存储器结构简介</h2>
<h3 id="1211-磁盘"><a class="markdownIt-Anchor" href="#1211-磁盘"></a> 12.1.1 磁盘</h3>
<p><img src="/posts/8ce3e425/image-20220108155656247.png" srcset="/img/loading.gif" lazyload alt="image-20220108155656247"></p>
<p><strong>磁盘访问时间=</strong> <strong>寻道时间</strong> <strong>+</strong> <strong>旋转时间</strong> <strong>+</strong> <strong>传输时间</strong> <strong>+</strong> <strong>控制器开销</strong></p>
<h3 id="1212-磁带"><a class="markdownIt-Anchor" href="#1212-磁带"></a> 12.1.2 磁带</h3>
<h2 id="122-磁盘结构"><a class="markdownIt-Anchor" href="#122-磁盘结构"></a> 12.2 磁盘结构</h2>
<h2 id="123-磁盘附属"><a class="markdownIt-Anchor" href="#123-磁盘附属"></a> 12.3 磁盘附属</h2>
<h3 id="1231-主机附属存储"><a class="markdownIt-Anchor" href="#1231-主机附属存储"></a> 12.3.1 主机附属存储</h3>
<h3 id="1232-网络附属存储"><a class="markdownIt-Anchor" href="#1232-网络附属存储"></a> 12.3.2 网络附属存储</h3>
<h3 id="1233-存储区域网络"><a class="markdownIt-Anchor" href="#1233-存储区域网络"></a> 12.3.3 存储区域网络</h3>
<h2 id="124-磁盘调度"><a class="markdownIt-Anchor" href="#124-磁盘调度"></a> 12.4 磁盘调度</h2>
<p>操作系统的任务之一就是有效地使用硬件。 对磁盘驱动器来说， 满足这一要求意味着<br>
要有较快的<strong>访问速度</strong>和较宽的<strong>磁盘带宽</strong>。</p>
<ul>
<li><strong>访问时间</strong>包括两个主要部分（参见12.1.1小节〉：寻道时间和旋转延迟。
<ul>
<li><strong>寻道时间</strong>是磁臂将磁头移动到包含目标扇区的柱面的时间。</li>
<li><strong>旋转延迟</strong>是磁盘需要将目标扇区转动到磁头下的时间。</li>
</ul>
</li>
<li><strong>磁盘带宽</strong>是所传递的总的字节数除以从服务请求开始到最后传递结束时的总时间。 可以通过使用适当的访问顺序来调度磁盘I/O请求， 提高访问速度和带宽。</li>
</ul>
<h3 id="1241-fcfs调度"><a class="markdownIt-Anchor" href="#1241-fcfs调度"></a> 12.4.1 FCFS调度</h3>
<p>最简单的磁盘调度形式当然是<strong>先来先服务算法</strong> （<strong>FCFS</strong> ）。</p>
<p>如果磁头开始位于 53， 那么它将从 53 移到98， 接着再到 183、 37、 122、 14、 124、 65, 最后到 67， 总的磁头移动为640柱面</p>
<p><img src="/posts/8ce3e425/image-20220108160611838.png" srcset="/img/loading.gif" lazyload alt="image-20220108160611838"></p>
<ul>
<li>**优点：**简单，公平；</li>
<li>**缺点：**效率不高，相邻两次请求可能会造成最内到最外的柱面寻道，使磁头反复移动，增加了服务时间，对机械也不利</li>
</ul>
<h3 id="1242-sstf调度"><a class="markdownIt-Anchor" href="#1242-sstf调度"></a> 12.4.2 SSTF调度</h3>
<p><strong>最短寻道时间优先算法</strong>（ shortest-seek-time-first <strong>SSTF</strong> ）：先处理靠近当前磁头位置的请求可能较为合理。</p>
<p>对于前面请求队列的例子， 与开始磁头位置（53） 最近的请求是位于柱面 65。 当位于柱面 65， 下个最近请求位于柱面 67。 从柱面 67， 由于柱面 37 比 98 还要近， 所以下次处理 37。 如此继续进行， 会处理位于柱面 14， 接着 98 、 122、 124， 最后处理 183 上的请求（参见图 12.5）。 这种调度算法所产生的磁头移动为 236 柱面， 约为 FCFS 调度算法所产生的磁头移动数量的三分之一 。</p>
<p><img src="/posts/8ce3e425/image-20220108160943048.png" srcset="/img/loading.gif" lazyload alt="image-20220108160943048"></p>
<ul>
<li>**优点：**改善了磁盘平均服务时间；</li>
<li>**缺点：**造成某些访问请求长期等待得不到服务</li>
</ul>
<h3 id="1243-scan调度"><a class="markdownIt-Anchor" href="#1243-scan调度"></a> 12.4.3 SCAN调度</h3>
<p><strong>SCAN 算法</strong>， 磁臂从磁盘的一端向另一端移动，同时当磁头移过每个柱面时， 处理位于该柱面上的服务请求。 当到达另 一端时， 磁头改变移动方向， 处理继续。SCAN算法有时被称为<strong>电梯算法</strong>（elevator algorithm）， 因为磁头的行为就像大楼里面的电梯，先处理所有向上请求， 然后再处理相反方向请求。</p>
<p><img src="/posts/8ce3e425/image-20220108161631672.png" srcset="/img/loading.gif" lazyload alt="image-20220108161631672"></p>
<ul>
<li>**优点：**克服了最短寻道优先的缺点，既考虑了距离，同时又考虑了方向</li>
</ul>
<h3 id="1244-c-scan调度"><a class="markdownIt-Anchor" href="#1244-c-scan调度"></a> 12.4.4 C-SCAN调度</h3>
<p><strong>C-SCAN</strong> （circular SCAN, C-SCAN）调度是SCAN调度的变种， 主要提供一个更为均匀的等待时间。与SCAN 一样，C-SCAN将磁头从磁盘一端移到磁盘的另一端， 随着移动不断地处理请求。不过，当磁头移到另 一端时， 它会马上返回到磁盘开始，返回时并不处理请求（参见图12.7）。C-SCAN调度算法基本上将柱面当做一个环链，以将最后的柱面和第一个柱面相连。</p>
<p><img src="/posts/8ce3e425/image-20220108161725922.png" srcset="/img/loading.gif" lazyload alt="image-20220108161725922"></p>
<h3 id="1245-look调度"><a class="markdownIt-Anchor" href="#1245-look调度"></a> 12.4.5 LOOK调度</h3>
<p>通常，磁头只移动到一个方向上最远的请求为止。 接着， 它马上回头，而不是继续到磁盘的尽头。这种形式的SCAN和C-SCAN称为<strong>LOOK</strong>和<strong>C-LOOK调度</strong>， 这是因为它们在朝一个方向移动会看（look） 是否有请求（见图12.8）。</p>
<p><img src="/posts/8ce3e425/image-20220108161853784.png" srcset="/img/loading.gif" lazyload alt="image-20220108161853784"></p>
<h3 id="1246-磁盘调度算法的选择"><a class="markdownIt-Anchor" href="#1246-磁盘调度算法的选择"></a> 12.4.6 磁盘调度算法的选择</h3>
<ul>
<li>SSTF较为普通且很有吸引力</li>
<li>SCAN和C-SCAN对磁盘负荷较大的系统会执行得更好，这是因为它不可能产生饥饿问题。</li>
<li>对于任何调度算法，性能依赖于请求的类型与数量</li>
<li>磁盘服务请求很大程度上受文件分配方法所影响（文件连续分配时磁头移动距离一般更短）</li>
<li>磁盘调度算法应作为一个操作系统的独立模块，这样如果有必要，它可以替换成另一个不同的算法。</li>
<li>SSTF或LOOK是比较合理的缺省算法。</li>
</ul>
<h2 id="125-磁盘管理"><a class="markdownIt-Anchor" href="#125-磁盘管理"></a> 12.5 磁盘管理</h2>
<h3 id="1251-磁盘格式化"><a class="markdownIt-Anchor" href="#1251-磁盘格式化"></a> 12.5.1 磁盘格式化</h3>
<p><strong>低级格式化</strong> (或物理格式化)：在磁盘能存储数据之前， 它必须分成扇区以便磁盘控制器能读和写。 低级格式化为磁盘的每个扇区采用特别的数据结构。</p>
<ul>
<li>每个扇区的数据结构通常由头、数据区域（通常为 512 B 大小）和尾部 组成。 头部和尾部包含了一些磁盘控制器所使用的信息， 如扇区号码和纠错代码（error-correcting code, ECC）。</li>
</ul>
<p>为了使用磁盘存储文件， 操作系统还需要将自己的数据结构记录在磁盘上。 这分为两步。</p>
<ul>
<li>第一步是将磁盘分为由一个或多个柱面组成的分区。操作系统可以将每个分区作为一个独立的磁盘。例如， 一个分区可以用来存储操作系统的可执行代码， 而其他分区用来存储用户数据。</li>
<li>在分区之后， 第二步是<strong>逻辑格式化</strong>（创建文件系统）。在这一步，操作系统将初始的文件系统数据结构存储到磁盘上。 这些数据结构包括空闲和己分配 的空间（FAT或者 inode）和一个初始为空的目录。</li>
</ul>
<p><img src="/posts/8ce3e425/image-20220108171332679.png" srcset="/img/loading.gif" lazyload alt="image-20220108171332679"></p>
<h3 id="1252-引导块"><a class="markdownIt-Anchor" href="#1252-引导块"></a> 12.5.2 引导块</h3>
<p>初始化自举 程序很简单。 它初始化系统的各个方面， 从CPU寄存器到设备控制器和内存， 接着启动操作系统 。 为此， 自举程序应找到磁盘上的操作系统内核， 装入内存， 并转到起始地址， 从而开始操作系统的执行。</p>
<p>绝大多数系统只在启动 ROM中 保留一个很小的自举加载程序， 其作用是进一步从磁盘上调入 更为完整的自举程序。 这一 更为完整的自举程序可以容易地进行修改：新版本可写到磁盘上。 这个完整的自举程序保存在磁盘的启动块 上， 启动块位于磁盘的固定位置 。拥有启动分区的磁盘称为启动磁盘（boot disk），或系统磁盘（systemdisk）。</p>
<h3 id="1253-坏块"><a class="markdownIt-Anchor" href="#1253-坏块"></a> 12.5.3 坏块</h3>
<h2 id="126-交换空间管理"><a class="markdownIt-Anchor" href="#126-交换空间管理"></a> 12.6 交换空间管理</h2>
<h3 id="1261-交换空间的使用"><a class="markdownIt-Anchor" href="#1261-交换空间的使用"></a> 12.6.1 交换空间的使用</h3>
<p>实现交换的系统可以将交换空间用于保存整个进程映像， 包括代码段和数据段。</p>
<p>换页系统也可能只用交换空间以存储换出内存的页。</p>
<p>系统所需交换空间的量因此会受以下因素影响：物理内存的多少、 所支持虚拟内存的多少、 内存使用方式等。 它可以是数MB到数GB的磁盘空间。</p>
<h3 id="1262-交换空间位置"><a class="markdownIt-Anchor" href="#1262-交换空间位置"></a> 12.6.2 交换空间位置</h3>
<p>交换空间可有两个位置： 交换空间在普通文件系统上加以创建**（外部碎片）<strong>， 或者是在一个独立的磁盘分区上进行</strong>（内部碎片）**。</p>
<h3 id="1263-实例交换空间管理"><a class="markdownIt-Anchor" href="#1263-实例交换空间管理"></a> 12.6.3 实例：交换空间管理</h3>
<ul>
<li>4.3 BSD在进程启动的时候分配交换空间，用来保存文本段（代码段）和数据段内核使用交换映射来跟踪交换空间的使用</li>
<li>Solaris 2当页被强制换出内存的时候分配交换空间。</li>
</ul>
<h2 id="127-raid结构"><a class="markdownIt-Anchor" href="#127-raid结构"></a> 12.7 RAID结构</h2>
<p>多种磁盘组织技术， 通常统称为**磁盘冗余阵列（RAID）**技术， 通常用于提高性能和可靠性。</p>
<h3 id="1271-通过冗余改善可靠性"><a class="markdownIt-Anchor" href="#1271-通过冗余改善可靠性"></a> 12.7.1 通过冗余改善可靠性</h3>
<ul>
<li>
<p>如果只存储数据的一个拷贝，只要n个磁盘中的一个磁盘出错，数据就出现错误。因此n个磁盘的出错率大于1个磁盘的出错率。</p>
</li>
<li>
<p>可靠性问题的解决方法是引入冗余。</p>
<ul>
<li>最为简单（但最为昂贵） 的引入冗余的方法是复制每个磁盘。 这种技术称为镜像(mirroring）。 因此每个逻辑磁盘由两个物理磁盘组成， 每次写都要在两个磁盘上进行。 如果一个磁盘损坏， 那么可从另一磁盘中恢复。 只有在第一个损坏磁盘没有替换之前而第二个磁盘又出错， 那么数据才会丢失。</li>
</ul>
</li>
</ul>
<h3 id="1272-通过并行处理改善性能"><a class="markdownIt-Anchor" href="#1272-通过并行处理改善性能"></a> 12.7.2 通过并行处理改善性能</h3>
<p>对于多个磁盘， 通过在多个磁盘上分散数据， 可以改善传输率。最简单形式是， 数据分散是在多个磁盘上分散每个字节的各个位， 这种分散称为位级分散。</p>
<p>总之， 磁盘系统并行访问有两个主要目的：</p>
<ul>
<li>①通过负荷平衡， 增加了多个小访问（即页访问）的吞吐量。</li>
<li>②降低大访问的响应时间</li>
</ul>
<h3 id="1273-raid级别"><a class="markdownIt-Anchor" href="#1273-raid级别"></a> 12.7.3 RAID级别</h3>
<p>通过磁盘分散和 “ 奇偶 ” 位（下面将要讨论）可以提供多种方案以在低代价环境下提供冗余。 这<br>
些方案有不同的性价折中，可分成不同级别，称为<strong>RAID级别</strong>。</p>
<p><img src="/posts/8ce3e425/image-20220108200057196.png" srcset="/img/loading.gif" lazyload alt="image-20220108200057196"></p>
<ul>
<li>
<p><strong>RAID级别0</strong>：</p>
<ul>
<li>数据分块，即把数据分布在多个盘上，写性能好。</li>
<li>非冗余阵列、无冗余信息。</li>
<li>严格地说，它不属于RAID系列。</li>
</ul>
<p><img src="/posts/8ce3e425/image-20220108200332672.png" srcset="/img/loading.gif" lazyload alt="image-20220108200332672"></p>
</li>
<li>
<p><strong>RAID级别1:</strong></p>
<ul>
<li>RAID级别1指磁盘镜像。</li>
<li>每当数据写入一个磁盘时，将该数据也写到另一个冗余盘，形成信息的两份复制品。</li>
</ul>
<p><img src="/posts/8ce3e425/image-20220108200532205.png" srcset="/img/loading.gif" lazyload alt="image-20220108200532205"></p>
<ul>
<li><strong>RAID1特点：</strong>
<ul>
<li>读性能好。</li>
<li>可靠性很高。</li>
<li>最昂贵的解决方法，物理磁盘空间是逻辑磁盘空间的两倍。</li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>RAID0+1</strong></p>
<ul>
<li><strong>先分块后镜像</strong></li>
<li>先做两个RAID0，然后再做RAID1，因此RAID0+1允许坏多个盘，但只能在坏在同一个RAID0中，不允许两个RAID0都有坏盘</li>
</ul>
<p><img src="/posts/8ce3e425/image-20220108203505969.png" srcset="/img/loading.gif" lazyload alt="image-20220108203505969"></p>
</li>
<li>
<p><strong>RAID1+0</strong></p>
<ul>
<li><strong>先镜像后分块</strong></li>
<li>先做RAID1，然后再做RAID0，因此RAID1+0允许坏多个盘，只要不是一对磁盘坏就可以。</li>
</ul>
<p><img src="/posts/8ce3e425/image-20220108203604834.png" srcset="/img/loading.gif" lazyload alt="image-20220108203604834"></p>
</li>
<li>
<p><strong>Raid0+1和Raid1+0比较</strong></p>
<p>在RAID 1+0的情况下，当一块独立的物理磁盘故障后，由于有一块对应镜像磁盘保护数据（除非对应的特定镜像硬盘也同时发生故障），因此不会对性能带来影响，从而显著高于RAID 0+1的容错性。磁盘故障后的恢复成本RAID 1+0技术也远低于RAID 0+1。在RAID 1+0技术中只需要重建一块物理磁盘，而RAID 0+1技术必须重建由块中所有物理磁盘组成的虚拟磁盘，从这点也能够体现出RAID 1+0相对RAID 0+1的优势。</p>
</li>
<li>
<p><strong>RAID级别2:</strong></p>
<p><img src="/posts/8ce3e425/image-20220108201500262.png" srcset="/img/loading.gif" lazyload alt="image-20220108201500262"></p>
<ul>
<li><strong>RAID2特点：</strong>
<ul>
<li>RAID级别2也称为内存方式的差错纠正代码结构。</li>
<li>并行存取，各个驱动器同步工作。</li>
<li>使用海明编码来进行错误检测和纠正，数据传输率高。</li>
<li>需要多个磁盘来存放海明校验码信息，冗余磁盘数量与数据磁盘数量的对数成正比。</li>
<li>是一种在多磁盘易出错环境中的有效选择。</li>
<li>并未被广泛应用，目前还没有商业化产品</li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>RAID级别3:</strong></p>
<ul>
<li>R位交叉奇偶校验盘阵列。</li>
<li>单盘容错并行传输：数据以位或字节交叉存储，奇偶校验信息存储在一台专用盘上。</li>
</ul>
<p><img src="/posts/8ce3e425/image-20220108201934015.png" srcset="/img/loading.gif" lazyload alt="image-20220108201934015"></p>
<ul>
<li>
<p>RAID3读写特点：</p>
<ul>
<li>假定有4个数据盘和一个冗余盘。</li>
<li>读出数据，一共需要5次磁盘读操作。</li>
<li>写数据需要3次磁盘读和2次磁盘写操作。</li>
</ul>
<p><img src="/posts/8ce3e425/image-20220108202309032.png" srcset="/img/loading.gif" lazyload alt="image-20220108202309032"></p>
</li>
<li>
<p><strong>RAID3特点：</strong></p>
<ul>
<li>将磁盘分组，读写要访问组中所有盘，每组中有一个盘作为校验盘。</li>
<li>校验盘一般采用奇偶校验。</li>
<li>简单理解：先将分布在各个数据盘上的一组数据加起来，将和存放在冗余盘上。一旦某一个盘出错，只要将冗余盘上的和减去所有正确盘上的数据，得到的差就是出错的盘上的数据。</li>
<li>缺点：恢复时间较长。</li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>RAID级别4:</strong></p>
<ul>
<li>专用奇偶校验独立存取盘阵列。</li>
<li>数据以块（块大小可变）交叉的方式存于各盘，奇偶校验信息存在一台专用盘上。</li>
</ul>
<p><img src="/posts/8ce3e425/image-20220108202537741.png" srcset="/img/loading.gif" lazyload alt="image-20220108202537741"></p>
<ul>
<li><strong>RAID4特点：</strong>
<ul>
<li>冗余代价与RAID3相同。</li>
<li>访问数据的方法与RAID3不同。
<ul>
<li>RAID4对数据的访问是按数据块（一般是一个扇区）进行的，也就是按磁盘进行的，每次是一个盘。 RAID3是一次一横条，而RAID4一次一竖条。所以RAID3常须访问阵列中所有的硬盘驱动器，而RAID4只须访问有用的硬盘驱动器。</li>
<li>这样读数据的速度大大提高了，但在写数据方面，需将从数据硬盘驱动器和校验硬盘驱动器中恢复出的旧数据与新数据通过异或运算，然后再将更新后的数据和检验位写入硬盘驱动器。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>RAID级别5</strong></p>
<ul>
<li>块交叉分布式奇偶校验盘阵列。</li>
<li>数据以块交叉的方式存于各盘，无专用冗余盘，奇偶校验信息均匀分布在所有磁盘上。</li>
</ul>
<p><img src="/posts/8ce3e425/image-20220108202759467.png" srcset="/img/loading.gif" lazyload alt="image-20220108202759467"></p>
<ul>
<li><strong>RAID5特点：</strong>
<ul>
<li><strong>RAID5</strong>的读出效率很高，写入效率一般，块式的集体访问效率不错。因为奇偶校验码在不同的磁盘上，所以提高了可靠性，允许单个磁盘出错。</li>
</ul>
</li>
</ul>
<p><img src="/posts/8ce3e425/image-20220108202836430.png" srcset="/img/loading.gif" lazyload alt="image-20220108202836430"></p>
</li>
<li>
<p><strong>RAID级别6：</strong></p>
<ul>
<li>双维奇偶校验独立存取盘阵列。</li>
</ul>
<p><img src="/posts/8ce3e425/image-20220108203118196.png" srcset="/img/loading.gif" lazyload alt="image-20220108203118196"></p>
<ul>
<li><strong>RAID6特点：</strong>
<ul>
<li>可容忍双盘出错。</li>
<li>RAID5的扩展，主要是用于要求数据绝对不能出错的场合。由于引入了第二种奇偶校验值，所以需要N+2个磁盘，同时对控制器的设计变得十分复杂，写入速度也不好，用于计算奇偶校验值和验证数据正确性所花费的时间比较多，造成了不必须的负载</li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>RAID级别7：</strong></p>
<ul>
<li>RAID7是在RAID6的基础上，采用了cache技术，它使得传输率和响应速度都有较大的提高。</li>
<li>一般采用cache分块大小和磁盘阵列中数据分块大小相同，即一块cache分块对应一块磁盘分块。</li>
<li>在写入时将数据分别写入两个独立的cache，这样即使其中有一个cache出故障，数据也不会丢失。写操作将直接在cache级响应，然后再转到磁盘阵列。</li>
<li>数据从cache写到磁盘阵列时，同一磁道的数据将在一次操作中完成，避免了不少块数据多次写的问题，提高了速度。在读出时，主机也是直接从cache中读出，而不是从阵列盘上读取，减少与磁盘读操作次数，这样比较充分地利用了磁盘带宽。</li>
</ul>
</li>
</ul>
<h2 id="习题-3"><a class="markdownIt-Anchor" href="#习题-3"></a> 习题</h2>
<h3 id="122"><a class="markdownIt-Anchor" href="#122"></a> 12.2</h3>
<blockquote>
<p>假设一个磁盘驱动器有5 000个柱面， 从0～4 999 。 驱动器正在为柱面143 的一个请求提供服务，且前面的一个服务请求是在柱面125 。 按FIFO顺序，即将到来的服务队列是86, 1470, 913, 1774, 948, 1509, 1022, 1750, 130<br>
从现在磁头位置开始，按照下面的磁盘调度算法， 要满足队列中的服务要求磁头总的移动距离是多少？<br>
a. FCFS<br>
b. SSTF<br>
c. SCAN<br>
d. LOOK<br>
e. C-SCAN<br>
f. C-LOOK</p>
</blockquote>
<p>a. FCFS 的调度是143、 86、1470、913、1774、948、1509、1022、1750、130。总移动距离是 7081 。</p>
<p>b. SSTF 的调度是 143、130 、86、913、948、1022、1470、1509、1750， 1774。总移动距离是 1745。</p>
<p>c. SCAN 的调度是143 ， 913 , 948 , 1022, 1470, 1509， 1750, 1774 , 4999 ,130 , 86 。总移动距离是 9769 。</p>
<p>d. LOOK 的调度是 143 ， 913 , 948 , 1022, 1470, 1509，1750， 1774, 130 ,86 。 总移动距离是 3319 。</p>
<p>e. C-SCAN 的调度是 143 ，913 , 948 , 1022 ， 1470 ， 1509 , 1750 , 1774 ,4999 , 0,86 ，130。总移动距离是9813 。</p>
<p>f. C-LOOK 的调度是 143，913 , 948 , 1022，1470 , 1509 , 1750 , 1774 ,86，130 。总移动距离是3363 。</p>
<h3 id="128"><a class="markdownIt-Anchor" href="#128"></a> 12.8</h3>
<blockquote>
<p>对于读请求， RAID级别1是否有可能比RAID级别0性能好(没有冗余分散数据)？若有，试具体说明。</p>
</blockquote>
<p>是的，RAID级别1组织可以实现更好的读请求性能。当执行读取操作时，RAID级别1系统可以决定应访问块的两个副本中的哪一个以满足请求。此选择可能基于磁头的当前位置，因此，通过选择更接近目标的磁头，可以实现性能优化</p>
<h3 id="129"><a class="markdownIt-Anchor" href="#129"></a> 12.9</h3>
<blockquote>
<p>考虑RAID级别5包含5个磁盘， 4个磁盘的奇偶校验存储在第5个磁盘中。 按下面的执行需要访问多少个块？<br>
a. 写1性能好<br>
b. 写7个连续块数据</p>
</blockquote>
<p>a.写入一个数据块需要如下操作：读取奇偶校验块，读取存储在目标块中的旧数据，根据目标块的新旧内容之间的差异计算新的奇偶校验，以及奇偶校验块和目标块的写入。</p>
<p>b.假设七个连续的块从一个四个块的边界开始。通过写入7个连续的块，写入前4个块的奇偶块，读取8个块计算下4个块的奇偶，并将相应的奇偶块写入磁盘，可以执行7个连续的数据块的写入。</p>
<h1 id="第13章-io输入系统"><a class="markdownIt-Anchor" href="#第13章-io输入系统"></a> 第13章 I/O输入系统</h1>
<h2 id="131-概述"><a class="markdownIt-Anchor" href="#131-概述"></a> 13.1 概述</h2>
<p>I/O与计算</p>
<ul>
<li>在不同应用场景下 各有侧重 （上网 游戏 文本 聊天）</li>
</ul>
<p>I/O子系统的核心</p>
<ul>
<li>统一管理复杂且差异化的各类IO设备</li>
</ul>
<p>I/O设备技术发展的两个矛盾趋势</p>
<ul>
<li>标准化和多样性</li>
</ul>
<p>设备驱动程序</p>
<ul>
<li>为应用程序与操作系统提供同意的标准接口</li>
</ul>
<h2 id="132-io硬件"><a class="markdownIt-Anchor" href="#132-io硬件"></a> 13.2 I/O硬件</h2>
<h3 id="1330-基本概念"><a class="markdownIt-Anchor" href="#1330-基本概念"></a> 13.3.0 <strong>基本概念</strong></h3>
<ul>
<li>
<p><strong>总线</strong> (daisy chain or shared direct access)</p>
<ul>
<li>是一组线和一组严格定义的可以描述在线上传输信息的协议</li>
</ul>
</li>
<li>
<p><strong>端口</strong></p>
<ul>
<li>设备通过系统总线上的接口与CPU相连，接口电路中含有多种寄存器，CPU向设备读写数据实际上是向接口上的寄存器读写数据，这些寄存器称为I/O端口</li>
<li>I/O端口通常有4种寄存器，即状态寄存器、控制寄存器、数据输入寄存器与数据输出寄存器。
<ul>
<li><strong>数据输入寄存器</strong>被主机读出以获取数据。</li>
<li><strong>数据输出寄存器</strong>被主机写入以发送数据。</li>
<li><strong>状态寄存器</strong>包含一些主机可读取的位（bit)。这些位指示各种状态， 例如，当前任务是否完成，数据输入寄存器中是否有数据可以读取，是否出现设备故障等。</li>
<li><strong>控制寄存器</strong>可以被主机用来向设备发送命令或改变设备状态。</li>
</ul>
</li>
<li>端口的<strong>编址方式</strong>有两种：统一编址和独立编址
<ul>
<li>**统一编址：**外设端口地址占用内存空间，也被称为内存映射方式。</li>
<li>**独立编址：**外设端口地址不占用内存空间，有自己的I/O地址空间。CPU通过专门的指令来访问I/O地址空间。</li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>控制器</strong> (host adapter)</p>
<ul>
<li>用于操作端口、总线或设备的一组电子器件（如：硬盘 ，移动硬盘）</li>
</ul>
</li>
</ul>
<h3 id="1321-轮询"><a class="markdownIt-Anchor" href="#1321-轮询"></a> 13.2.1 轮询</h3>
<p>主机通过端口写出数据时，<strong>主机与控制器之间的交互过程</strong>：</p>
<ol>
<li>主机不断地读取忙位，直到该位被清除 (这个过程称为轮询，亦称忙等待-busy waiting)</li>
<li>主机设置命令寄存器中的写位并向数据输出寄存器中写入一个字节。</li>
<li>主机设置命令就绪位</li>
<li>当控制器注意到命令就绪位已被设置，则设置忙位。</li>
<li>控制器读取命令寄存器，并看到写入命令。它从数据输出寄存器中读取一个字节，并向设备执行I/O操作。</li>
<li>控制器清除命令就绪位，清除状态寄存器的故障位以表示设备I/O成功，清除忙位以表示完成。</li>
</ol>
<h3 id="1322-中断"><a class="markdownIt-Anchor" href="#1322-中断"></a> 13.2.2 中断</h3>
<p>CPU硬件有一条<strong>中断请求线</strong>（interrupt-request line, IRL），由I/O设备触发</p>
<ul>
<li>设备控制器通过中断请求线发送信号而引起中断，</li>
<li>CPU捕获中断并派遣到中断处理程序
<ul>
<li>CPU执行完每条指令都将判断IRL</li>
</ul>
</li>
<li>中断处理程序通过处理设备来清除中断。</li>
</ul>
<p><strong>中断控制器</strong></p>
<ul>
<li>中断延迟处理(当系统进行关键处理时)</li>
<li>中断派遣</li>
<li>多级中断（中断具有优先级）</li>
</ul>
<p><strong>两种中断请求</strong>（ cup一般设置两根中断请求输入线来完成该功能）</p>
<ul>
<li>非屏蔽中断：不可拒绝的，主要用来处理如不可恢复内存错误等事件</li>
<li>可屏蔽中断：cpu可以响应，也可以不响应中断（例如：打印机）</li>
</ul>
<p><strong>中断优先级：</strong></p>
<ul>
<li>能够使CPU延迟处理低优先级中断而不屏蔽所有中断，这也可以让高优先级中断抢占低优先级中断处理。</li>
</ul>
<p><strong>中断的用途</strong></p>
<ul>
<li>中断机制用于处理各种异常，如被零除，访问一个受保护的或不存在的内存地址</li>
<li>系统调用的实现需要用到中断（软中断）</li>
<li>中断也可以用来管理内核的控制流</li>
</ul>
<h3 id="1323-直接内存访问"><a class="markdownIt-Anchor" href="#1323-直接内存访问"></a> 13.2.3 直接内存访问</h3>
<p><strong>用处：</strong></p>
<ul>
<li>用来避免处理大量数据移动时按字节来向控制器送入数据的问题
<ul>
<li>以PIO（Programmed I/O）方式进行大数据量传输，效率过低</li>
</ul>
</li>
<li>进一步降低CPU负担，任务下放给专用处理器
<ul>
<li>DMA（direct memory access）控制器</li>
</ul>
</li>
<li>绕过CPU直接在内存与I/O设备之间进行数据传输
<ul>
<li>DMA-request
<ul>
<li>请求信号 获取总线 设置地址 发送acknowledge信号</li>
</ul>
</li>
<li>DMA-acknowledge
<ul>
<li>接收信号 传输数据 清除request请求</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><img src="/posts/8ce3e425/image-20220110181813926.png" srcset="/img/loading.gif" lazyload alt="image-20220110181813926"></p>
<p>为实现在主机与控制器之间成块数据的直接交换，必须在DMA控制器中设置如下四类寄存器：</p>
<ol>
<li>**命令/状态寄存器(CR)：**用于接收从CPU发来的I/O命令或有关控制信息，或设备的状态。</li>
<li>**内存地址寄存器(MAR)：**在输入时，它存放把数据从设备传送到内存的起始目标地址；在输出时，它存放由内存到设备的内存源地址。</li>
<li>**数据寄存器(DR)：**用于暂存从设备到内存，或从内存到设备的数据。</li>
<li>**数据计数器(DC)：**存放本次CPU要读或写的字（节）数。</li>
</ol>
<p>DMA控制方式与中断驱动方式的<strong>主要区别</strong>是</p>
<ul>
<li>中断驱动方式在每个数据需要传输时中断CPU，而DMA控制方式则是在所要求传送的一批数据全部传送结束时才中断CPU；</li>
<li>此外，中断驱动方式数据传送是在中断处理时由CPU控制完成的，而DMA控制方式则是在DMA控制器的控制下完成的。</li>
</ul>
<h2 id="133-io应用接口"><a class="markdownIt-Anchor" href="#133-io应用接口"></a> 13.3 I/O应用接口</h2>
<h3 id="1331-块与字符设备"><a class="markdownIt-Anchor" href="#1331-块与字符设备"></a> 13.3.1 块与字符设备</h3>
<ul>
<li><strong>块设备</strong>包括磁盘驱动器
<ul>
<li>read，write，seek描述了块存储设备的基本特点，这样应用程序就不必关注这些设备的低层差别。</li>
<li>RAW I/O或文件系统访问</li>
<li>内存映射文件访问是建立在块设备驱动程序之上的。内存映射接口不是提供read和write操作，而是提供通过内存中的字节数组来访问磁盘存储。</li>
</ul>
</li>
<li><strong>字符设备</strong>包括键盘、鼠标、串行口
<ul>
<li>应用程序可以get或put字符。在此基础上，可以构造库以提供具有缓冲和编辑功能的按行访问。</li>
</ul>
</li>
</ul>
<h3 id="1332-网络设备"><a class="markdownIt-Anchor" href="#1332-网络设备"></a> 13.3.2 网络设备</h3>
<ul>
<li>网络I/O的性能与访问特点与磁盘I/O相比有很大差别，绝大多数操作系统所提供的网络I/O接口也不同于磁盘的read-write-seek接口。许多OS所提供的是网络套接字接口。</li>
<li>套接字接口还提供了select函数，以管理一组套接字。调用select可以得知哪个套接字已有接收数据需要处理，哪个套接字已有空间可以接收数据以便发送。</li>
</ul>
<h3 id="1333-时钟与定时器"><a class="markdownIt-Anchor" href="#1333-时钟与定时器"></a> 13.3.3 时钟与定时器</h3>
<ul>
<li>提供以下三个基本函数
<ul>
<li>获取当前时间</li>
<li>获取已经逝去的时间</li>
<li>设置定时器以在T时触发操作X</li>
</ul>
</li>
<li>测量逝去时间和触发器操作的硬件称为可编程间隔定时器（programmable interval timer）
<ul>
<li>可被设置为等待一定的时间，然后触发中断</li>
<li>也可设置成做一次或重复多次以产生定时中断</li>
</ul>
</li>
</ul>
<h3 id="1334-阻塞与非阻塞io"><a class="markdownIt-Anchor" href="#1334-阻塞与非阻塞io"></a> 13.3.4 阻塞与非阻塞I/O</h3>
<ul>
<li>阻塞 － 进程悬挂直到I/O完成为止
<ul>
<li>容易使用与理解</li>
<li>对某些需求难以满足</li>
</ul>
</li>
<li>非阻塞 － I/O调用立刻返回
<ul>
<li>用户接口，数据复制（缓冲I/O)</li>
<li>通过多线程实现</li>
<li>立刻返回读或写的字节数</li>
</ul>
</li>
<li>异步 － 进程与I/O同时运行
<ul>
<li>难以使用</li>
<li>当I/O完成时，I/O系统发送信号通知进程</li>
</ul>
</li>
<li>非阻塞与异步系统调用的差别
<ul>
<li>非阻塞read调用会马上返回，其所读取的数据可以等于或少于所要求的，或为零。</li>
<li>异步read调用所要求的传输应完整地执行，其具体执行可以是将来某个特定时间。</li>
</ul>
</li>
</ul>
<p>1.同步与异步</p>
<ul>
<li>
<p>同步和异步关注的是消息通信机制</p>
</li>
<li>
<p>同步，就是在发出一个调用时，在没有得到结果之前，该调用就不返回。但是一旦调用返回，就得到返回值了</p>
</li>
<li>
<p>异步则是相反，调用在发出之后，这个调用就直接返回了，所以没有返回结果</p>
</li>
</ul>
<p>2.阻塞与非阻塞</p>
<ul>
<li>阻塞和非阻塞关注的是程序在等待调用结果（消息，返回值）时的状态.</li>
<li>阻塞调用是指调用结果返回之前，当前线程会被挂起。调用线程只有在得到结果之后才会返回。</li>
<li>非阻塞调用指在不能立刻得到结果之前，该调用不会阻塞当前线程。</li>
</ul>
<h2 id="134-io内核子系统"><a class="markdownIt-Anchor" href="#134-io内核子系统"></a> 13.4 I/O内核子系统</h2>
<ul>
<li>
<p>I/O设备种类繁多，功能和传输速率差异巨大，需要多种方法来进行设备控制。这些方法共同组成了操作系统内核的I/O子系统，它将内核的其他方面从繁重的I/O设备管理中解放出来。</p>
</li>
<li>
<p>I/O核心子系统提供的服务主要有I/O调度、缓冲与高速缓存、设备分配与回收、假脱机、设备保护和差错处理等</p>
</li>
</ul>
<h3 id="1341-io调度"><a class="markdownIt-Anchor" href="#1341-io调度"></a> 13.4.1 I/O调度</h3>
<ul>
<li>
<p>调度一组I/O请求就是确定一个好的顺序来执行这些请求。</p>
<ul>
<li>假设磁头位于磁盘开始处，三个应用程序向该磁盘发布阻塞读调用。应用程序1需要磁盘结束部分的块，应用程序2需要磁盘开始部分的块，应用程序3需要磁盘中间部分的块。OS如果按2、3、1的顺序处理，则可以减低磁头所需移动的距离。按这种方法来重新安排服务顺序就是I/O调度的核心。</li>
<li>重新安排队列顺序以改善总体效率和平均响应时间</li>
</ul>
</li>
<li>
<p>实现</p>
<ul>
<li>OS通过为每个设备维护一个请求队列来实现调度。</li>
<li>可以试图公平，也可以根据不同的优先级进行I/O调度。</li>
<li>其他方法：缓冲、高速缓冲、假脱机</li>
</ul>
</li>
</ul>
<h3 id="1342-缓冲"><a class="markdownIt-Anchor" href="#1342-缓冲"></a> 13.4.2 缓冲</h3>
<p>采用缓冲有三个理由。</p>
<ul>
<li>一个理由是处理数据流的生产者与消费者之间的速度差异</li>
<li>协调传输数据大小不一致的设备</li>
<li>支持应用程序I/O的复制语义</li>
</ul>
<p>在设备管理子系统中，引入缓冲区的目的主要有：（解决速度慢和快的交接问题，一般不需要支持随机读写）</p>
<ul>
<li>
<p>缓和CPU与I/O设备间速度不匹配的矛盾。</p>
</li>
<li>
<p>减少对CPU的中断频率，放宽对CPU中断响应时间的限制。</p>
</li>
<li>
<p>解决基本数据单元大小（即数据粒度）不匹配的问题。</p>
</li>
<li>
<p>提高CPU和I/O设备之间的并行性。</p>
</li>
<li>
<p>实现方法有：</p>
<ul>
<li>釆用硬件缓冲器，但由于成本太高，除一些关键部位外，一般不釆用硬件缓冲器</li>
<li>釆用缓冲区（位于内存区域）。</li>
</ul>
</li>
</ul>
<h3 id="1343-高速缓存"><a class="markdownIt-Anchor" href="#1343-高速缓存"></a> 13.4.3 高速缓存</h3>
<p>高速缓存（ cache ）是可以保留数据副本的高速存储器。 高速缓冲区副本的访问要比原始数据访问要更为高效。</p>
<ul>
<li>磁盘高速缓存(Disk Cache)（主要用于实现数据的重复使用，支持随机读写）</li>
<li>操作系统中使用磁盘高速缓存技术来提高磁盘的I/O速度，对高速缓存复制的访问要比原始数据访问更为高效。例如，正在运行的进程的指令既存储在磁盘上，也存储在物理内存上，也被复制到CPU的二级和一级高速缓存中。</li>
<li>磁盘高速缓存是指利用内存中的存储空间来暂存从磁盘中读出的一系列盘块中的信息。因此，磁盘高速缓存在逻辑上属于磁盘，物理上则是驻留在内存中的盘块。</li>
<li>高速缓存在内存中分为两种形式：
<ul>
<li>一种是在内存中开辟一个单独的存储空间作为磁速缓存，大小固定；</li>
<li>另一种是把未利用的内存空间作为一个缓沖池，供请求分页系统和磁盘I/O时共享。</li>
</ul>
</li>
</ul>
<h3 id="1344-假脱机与设备预留"><a class="markdownIt-Anchor" href="#1344-假脱机与设备预留"></a> 13.4.4 假脱机与设备预留</h3>
<p>假脱机（spool） －为了缓和CPU的高速性与I/O设备低速性之间的矛盾而引入了脱机输入/输出技术。该技术是利用专门的外围控制机，将低速I/O设备上的数据传送到高速磁盘上；或者相反。 SPOOLing的意思是外部设备同时联机操作，又称为假脱机输入/输出操作，是操作系统中釆用的一项将独占设备改造成共享设备的技术。</p>
<h3 id="1345-错误处理"><a class="markdownIt-Anchor" href="#1345-错误处理"></a> 13.4.5 错误处理</h3>
<ul>
<li>OS可以对短暂出错进行弥补。
<ul>
<li>例如：磁盘read出错可以导致read重试，网络send出错可以导致resend（如果协议允许）。但是如果某个重要系统组件出现了永久错误，那么OS就不可能从中恢复。</li>
</ul>
</li>
<li>当I/O请求失败后，多数返回一个错误号或错误码</li>
<li>系统错误日志保存问题的详细报告</li>
</ul>
<h3 id="1346-io保护"><a class="markdownIt-Anchor" href="#1346-io保护"></a> 13.4.6 I/O保护</h3>
<h3 id="1347-内核数据结构"><a class="markdownIt-Anchor" href="#1347-内核数据结构"></a> 13.4.7 内核数据结构</h3>
<ul>
<li>内核需要保存留I/O组件使用的状态信息，包括打开文件表，网络连接，字符设备状态等</li>
<li>许多复杂的数据结构用来跟踪缓冲，内存分配，及“脏”块</li>
<li>某些OS用面向对象的方法和消息传递的方法来实现I/O</li>
</ul>
<h3 id="1348-内核io子系统小结"><a class="markdownIt-Anchor" href="#1348-内核io子系统小结"></a> 13.4.8 内核I/O子系统小结</h3>
<h2 id="135-把io操作转换成硬件操作"><a class="markdownIt-Anchor" href="#135-把io操作转换成硬件操作"></a> 13.5 把I/O操作转换成硬件操作</h2>
<ul>
<li>从磁盘读文件到进程的过程
<ul>
<li>找到包含文件的设备</li>
<li>将文件名转换成设备实现</li>
<li>从磁盘上读数据至缓冲区</li>
<li>通知进程数据可用</li>
<li>将控制返回给进程</li>
</ul>
</li>
</ul>
<h2 id="136-流"><a class="markdownIt-Anchor" href="#136-流"></a> 13.6 流</h2>
<ul>
<li>STREAM － 用户级进程与设备之间完全双方的通信通道</li>
<li>STREAM包括
<ul>
<li>STREAM至用户进程的接口</li>
<li>驱动器至设备的接口</li>
<li>两者之间零或多个STREAM模块</li>
</ul>
</li>
<li>每个模块包含一个读队列和一个写队列</li>
<li>队列之间通过消息传递进行通信</li>
</ul>
<h2 id="137-性能"><a class="markdownIt-Anchor" href="#137-性能"></a> 13.7 性能</h2>
<p>I/O是影响系统性能的重要因素之一</p>
<ul>
<li>执行设备驱动程序代码以及随着进程阻塞变化而公平且高效地调度进程都增加了CPU的负荷。</li>
<li>由于中断而产生的上下文切换也增加了CPU及其硬件高速缓存的负担。</li>
<li>用于控制器和物理内存之间的数据拷贝以及内核缓冲和应用程序数据空间之间有数据拷贝时的内存总线的负荷过重。</li>
<li>网络交通也能导致更高的关联切换率。</li>
</ul>
<p><strong>提高性能：</strong></p>
<ul>
<li>减少上下文切换（context switch）的次数</li>
<li>减少设备和应用程序之间传递数据时在内存中的数据拷贝次数<br>
使用大传输、智能控制器及轮流检测来减少中断频率。</li>
<li>通过采用DMA智能控制器和通道来为主CPU承担简单数据拷贝，以增加并发。</li>
<li>将处理原语移入硬件，允许控制器内的操作与CPU和总线内的操作并发。</li>
<li>平衡CPU，内存子系统，总线和I/O的性能，因为任何一处的过载都会引起其他部分空闲。</li>
</ul>
<h2 id="138-小结"><a class="markdownIt-Anchor" href="#138-小结"></a> 13.8 小结</h2>
<h3 id="习题-4"><a class="markdownIt-Anchor" href="#习题-4"></a> 习题</h3>

            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                  <div class="post-meta mr-3">
                    <i class="iconfont icon-category"></i>
                    
                      <a class="hover-with-bg" href="/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">操作系统</a>
                    
                  </div>
                
                
                  <div class="post-meta">
                    <i class="iconfont icon-tags"></i>
                    
                      <a class="hover-with-bg" href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">操作系统</a>
                    
                  </div>
                
              </div>
              
                <p class="note note-warning">
                  
                    本博客所有文章除特别声明外，著作权归作者所有，转载请注明出处！
                  
                </p>
              
              
                <div class="post-prevnext">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/posts/1326caf9/">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">虚拟机网络托管消失的问题</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/posts/3f961b4f/">
                        <span class="hidden-mobile">操作系统实验四-调度算法</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
              <!-- Comments -->
              <article class="comments" id="comments" lazyload>
                
                  
                
                
  <div class="disqus" style="width:100%">
    <div id="disqus_thread"></div>
    
      <script type="text/javascript">
        var disqus_config = function() {
          this.page.url = 'https://zino00.github.io/posts/8ce3e425/';
          this.page.identifier = '/posts/8ce3e425/';
        };
        Fluid.utils.loadComments('#disqus_thread', function() {
          var d = document, s = d.createElement('script');
          s.src = '//' + 'fluid' + '.disqus.com/embed.js';
          s.setAttribute('data-timestamp', new Date());
          (d.head || d.body).appendChild(s);
        });
      </script>
    
    <noscript>Please enable JavaScript to view the comments</noscript>
  </div>


              </article>
            
          </article>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    

    
      <a id="scroll-top-button" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
    

    
  </main>

  <footer class="text-center mt-5 py-3">
  <div class="footer-content">
     <a  rel="nofollow noopener"><span>Copyrights © 2021</span></a> <i class="iconfont icon-love"></i> <a  target="_blank" rel="nofollow noopener"><span>Zino</span></a> 
  </div>
  
  <div class="statistics">
    
    

    
      
        <!-- 不蒜子统计PV -->
        <span id="busuanzi_container_site_pv" style="display: none">
            总访问量 
            <span id="busuanzi_value_site_pv"></span>
             次
          </span>
      
      
        <!-- 不蒜子统计UV -->
        <span id="busuanzi_container_site_uv" style="display: none">
            总访客数 
            <span id="busuanzi_value_site_uv"></span>
             人
          </span>
      
    
  </div>


  

  
  <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?d1745c2e21adaa6ae90b93f4f4d22da9";
      var s = document.getElementsByTagName("script")[0]; 
      s.parentNode.insertBefore(hm, s);
    })();
    </script>
    
</footer>


  <!-- SCRIPTS -->
  
  <script  src="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" ></script>
<script  src="https://cdn.jsdelivr.net/npm/bootstrap@4.6.0/dist/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>

<!-- Plugins -->


  
    <script  src="/js/img-lazyload.js" ></script>
  



  



  <script  src="https://cdn.jsdelivr.net/npm/tocbot@4.12.3/dist/tocbot.min.js" ></script>



  <script  src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js" ></script>



  <script  src="https://cdn.jsdelivr.net/npm/anchor-js@4.3.1/anchor.min.js" ></script>



  <script defer src="https://cdn.jsdelivr.net/npm/clipboard@2.0.8/dist/clipboard.min.js" ></script>



  <script  src="/js/local-search.js" ></script>



  <script defer src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" ></script>




  <script  src="https://cdn.jsdelivr.net/npm/typed.js@2.0.12/lib/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var title = document.getElementById('subtitle').title;
      
      typing(title)
      
    })(window, document);
  </script>





  

  
    <!-- KaTeX -->
    <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.13.10/dist/katex.min.css" />
  








  
    <!-- Baidu Analytics -->
    <script defer>
      var _hmt = _hmt || [];
      (function () {
        var hm = document.createElement("script");
        hm.src = "https://hm.baidu.com/hm.js?f45dcd001d67e8f9d84f91248ea31abf";
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(hm, s);
      })();
    </script>
  

  

  

  

  

  





<!-- 主题的启动项 保持在最底部 -->
<script  src="/js/boot.js" ></script>


</body>
</html>
