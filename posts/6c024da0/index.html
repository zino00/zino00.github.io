

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=&#34;auto&#34;>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/favicon.jpg">
  <link rel="icon" href="/img/favicon.jpg">
  <meta name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="description" content="内存页面置换算法的设计、主存储器空间的分配和回收">
  <meta name="author" content="John Doe">
  <meta name="keywords" content="">
  
  <title>操作系统实验七-内存页面置换算法的设计和主存储器空间的分配和回收 - Zino&#39;s Blog</title>

  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.6.0/dist/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/github-markdown-css@4.0.0/github-markdown.min.css" />
  <link  rel="stylesheet" href="/lib/hint/hint.min.css" />

  
    
    
      
      <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@10.7.2/styles/rainbow.min.css" />
    
  

  
    <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css" />
  



<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_kmeydafke9r.css">


<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->


  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    var CONFIG = {"hostname":"zino00.github.io","root":"/","version":"1.8.11","typing":{"enable":true,"typeSpeed":70,"cursorChar":"","loop":false},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"copy_btn":true,"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":1},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":true,"baidu":"f45dcd001d67e8f9d84f91248ea31abf","google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null}},"search_path":"/local-search.xml"};
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
<meta name="generator" content="Hexo 5.4.0"></head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand"
       href="/">&nbsp;<strong>Zino's Blog</strong>&nbsp;</a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" data-toggle="modal" data-target="#modalSearch">&nbsp;<i
                class="iconfont icon-search"></i>&nbsp;</a>
          </li>
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="banner" id="banner" parallax=true
         style="background: url('/img/post.jpg') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="page-header text-center fade-in-up">
            <span class="h2" id="subtitle" title="操作系统实验七-内存页面置换算法的设计和主存储器空间的分配和回收">
              
            </span>

            
              <div class="mt-3">
  
  
    <span class="post-meta">
      <i class="iconfont icon-date-fill" aria-hidden="true"></i>
      <time datetime="2021-12-22 08:00" pubdate>
        2021年12月22日 早上
      </time>
    </span>
  
</div>

<div class="mt-1">
  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      6.5k 字
    </span>
  

  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      89
       分钟
    </span>
  

  
  
    
      <!-- 不蒜子统计文章PV -->
      <span id="busuanzi_container_page_pv" style="display: none">
        <i class="iconfont icon-eye" aria-hidden="true"></i>
        <span id="busuanzi_value_page_pv"></span> 次
      </span>
    
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">操作系统实验七-内存页面置换算法的设计和主存储器空间的分配和回收</h1>
            
            <div class="markdown-body">
              <h1 id="实验1内存页面置换算法的设计"><a class="markdownIt-Anchor" href="#实验1内存页面置换算法的设计"></a> 实验1：内存页面置换算法的设计</h1>
<h2 id="一-实验内容"><a class="markdownIt-Anchor" href="#一-实验内容"></a> 一、实验内容</h2>
<ul>
<li>实现最近最久未使用(LRU)置换算法</li>
</ul>
<h2 id="二-实验目的"><a class="markdownIt-Anchor" href="#二-实验目的"></a> 二、实验目的</h2>
<ul>
<li>LINUX中，为了提高内存利用率，提供了内外存进程对换机制，内存空间的分配和回收均以页为单位进行，一个进程只需将其一部分调入内存便可运行，还支持请求调页的存储管理方<br>
式。</li>
<li>本实验要求学生通过请求页式存储管理中页面置换算法模拟设计，了解虚拟存储技术的特点，掌握请求页式存储管理的页面置换算法。</li>
</ul>
<h2 id="三-实验题目"><a class="markdownIt-Anchor" href="#三-实验题目"></a> 三、实验题目</h2>
<ul>
<li>
<p>最近最久未使用（LRU）置换算法原理就是：当需要淘汰某页面时，选择当前一段时间内最久未使用过的页先淘汰，即淘汰距当前最远的上次使用的页。</p>
</li>
<li>
<p>假定分配给该进程的页块数为3，页面访问序列长度为20。本实验可以采用数组结构实现，首先随机产生页面序列，当发生请求调页时，若内存已满，则需要利用LRU算法，将当前一段时间内最久未使用过的页替换出去。</p>
</li>
<li>
<p>模拟程序的算法如下图：</p>
<p><img src="/posts/6c024da0/image-20211212154524278.png" srcset="/img/loading.gif" lazyload alt="image-20211212154524278"></p>
</li>
</ul>
<p><strong>思考题</strong></p>
<ul>
<li>比较LRU和其他置换算法各自的优缺点，能够实现其他置换算法模拟设计，分析内存页面数的变化对各种置换算法命中率的影响</li>
</ul>
<h2 id="四-实验设计与过程"><a class="markdownIt-Anchor" href="#四-实验设计与过程"></a> 四、实验设计与过程</h2>
<p>LRU算法实现并不难，但需考虑如何高效实现，本实验中我采用了哈希表和双向链表的结合来高效实现其中的插入、删除、查找，均可在O(1)时间内完成插入、删除、查找，利用空间换时间的思想，实现LRU算法。</p>
<h4 id="数据结构和符号说明"><a class="markdownIt-Anchor" href="#数据结构和符号说明"></a> 数据结构和符号说明</h4>
<div class="code-wrapper"><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">struct Node
    &#123;
        int key;
        int value;
        Node(int x, int y) : key(x), value(y) &#123;&#125;
    &#125;;
    int capacity;&#x2F;&#x2F;内存页面容量
    int missing &#x3D; 0;&#x2F;&#x2F;是否缺页
    list&lt;Node&gt; cacheList;&#x2F;&#x2F;双向链表
    unordered_map&lt;int, list&lt;Node&gt;::iterator&gt; 		cacheMap; &#x2F;&#x2F;哈希表<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div>
<h4 id="函数说明"><a class="markdownIt-Anchor" href="#函数说明"></a> 函数说明</h4>
<p>首先在哈希表中查找</p>
<ul>
<li>
<p>若没找到，说明当前页不在页面内存中，需要进行页面替换</p>
<ul>
<li>然后再看是否有空闲页，即判断双向链表容量是否已满，若满则要删除链表尾部元素，即最久未访问的页面，然后将新页面加到双向链表头部，同时更新哈希表</li>
</ul>
</li>
<li>
<p>若找到，则将该页放到链表头部，表示刚刚访问过，同时更新哈希表。</p>
</li>
</ul>
<div class="code-wrapper"><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">void set(int key, int val)
    &#123;
        if (cacheMap.find(key) &#x3D;&#x3D; cacheMap.end())
        &#123;
            missing &#x3D; 1; &#x2F;&#x2F;表示缺页
            &#x2F;&#x2F;淘汰最后一个，然后将其加到第一个位置
            if (cacheList.size() &#x3D;&#x3D; capacity)
            &#123;
                cacheMap.erase(cacheList.back().key);
                cacheList.pop_back();
            &#125;
            cacheList.push_front(Node(key, val));
            cacheMap[key] &#x3D; cacheList.begin();
        &#125;
        else
        &#123;
            missing &#x3D; 0; &#x2F;&#x2F;表示未缺页
            &#x2F;&#x2F;更新节点的值，并将其加到第一个位置,map和list均要更新
            cacheMap[key]-&gt;value &#x3D; val;
            cacheList.splice(cacheList.begin(), cacheList, cacheMap[key]);
            cacheMap[key] &#x3D; cacheList.begin();
        &#125;
    &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div>
<h4 id="完整源代码"><a class="markdownIt-Anchor" href="#完整源代码"></a> 完整源代码</h4>
<div class="code-wrapper"><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;bits&#x2F;stdc++.h&gt;
#include &lt;iostream&gt;
#include &lt;list&gt;
#include &lt;unordered_map&gt;

using namespace std;
int pagelist[20];
void buildpage() &#x2F;&#x2F;内存页初始化函数
&#123;
    for (int i &#x3D; 0; i &lt; 20; i++)
    &#123;
        &#x2F;&#x2F; cin &gt;&gt; pagelist[i];
        pagelist[i] &#x3D; rand() % 6;
    &#125;
&#125;
class LRUCache
&#123;
public:
    LRUCache(int c) : capacity(c) &#123;&#125; &#x2F;&#x2F;页面数量初始化
    int get(int key)                 &#x2F;&#x2F;查找
    &#123;
        if (cacheMap.find(key) &#x3D;&#x3D; cacheMap.end())
            return -1;

        &#x2F;&#x2F;将key移到第一个，并更新cacheMap
        cacheMap[key] &#x3D; cacheList.begin();
        cacheList.splice(cacheList.begin(), cacheList, cacheMap[key]);
        return cacheMap[key]-&gt;value;
    &#125;
    void set(int key, int val)
    &#123;
        if (cacheMap.find(key) &#x3D;&#x3D; cacheMap.end())
        &#123;
            missing &#x3D; 1; &#x2F;&#x2F;表示缺页
            &#x2F;&#x2F;淘汰最后一个，然后将其加到第一个位置
            if (cacheList.size() &#x3D;&#x3D; capacity)
            &#123;
                cacheMap.erase(cacheList.back().key);
                cacheList.pop_back();
            &#125;
            cacheList.push_front(Node(key, val));
            cacheMap[key] &#x3D; cacheList.begin();
        &#125;
        else
        &#123;
            missing &#x3D; 0; &#x2F;&#x2F;表示未缺页
            &#x2F;&#x2F;更新节点的值，并将其加到第一个位置,map和list均要更新
            cacheMap[key]-&gt;value &#x3D; val;
            cacheList.splice(cacheList.begin(), cacheList, cacheMap[key]);
            cacheMap[key] &#x3D; cacheList.begin();
        &#125;
    &#125;
    int show()
    &#123;
        int t &#x3D; 0;
        for (auto i &#x3D; cacheList.rbegin(); i !&#x3D; cacheList.rend(); i++)
        &#123;
            printf(&quot;%2d&quot;, i-&gt;key);
            t++;
        &#125;
        while (t++ &lt; 3)
        &#123;
            printf(&quot;%2c&quot;, &#39; &#39;);
        &#125;
        return missing;
    &#125;

private:
    struct Node
    &#123;
        int key;
        int value;
        Node(int x, int y) : key(x), value(y) &#123;&#125;
    &#125;;
    int capacity;&#x2F;&#x2F;内存页面容量
    int missing &#x3D; 0;&#x2F;&#x2F;是否缺页
    list&lt;Node&gt; cacheList;                              &#x2F;&#x2F;双向链表
    unordered_map&lt;int, list&lt;Node&gt;::iterator&gt; cacheMap; &#x2F;&#x2F;哈希表
&#125;;
int main()
&#123;
    srand((int)time(0));
    LRUCache lru(3); &#x2F;&#x2F;背包容量初始化
    buildpage();     &#x2F;&#x2F;页面初始化
    double m &#x3D; 0;
    printf(&quot;|--------------------------------|\n&quot;);
    printf(&quot;|---------------LRU--------------|\n&quot;);
    printf(&quot;|--------------------------------|\n&quot;);
    printf(&quot;| 页面序列 | 当前页块 | 是否缺页 |\n&quot;);
    for (int i &#x3D; 0; i &lt; 20; i++)
    &#123;
        lru.set(pagelist[i], pagelist[i]);
        printf(&quot;|    %d     |  &quot;, pagelist[i]);
        if (lru.show())
            printf(&quot;  |   缺页   |\n&quot;), m++;
        else
            printf(&quot;  |          |\n&quot;);
    &#125;
    printf(&quot;|--------------------------------|\n&quot;);
    printf(&quot;缺页次数为：%.0f\n缺页率为: %.2f%%&quot;, m, m &#x2F; 20 * 100);
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div>
<h4 id="程序初值和运行结果"><a class="markdownIt-Anchor" href="#程序初值和运行结果"></a> 程序初值和运行结果</h4>
<p>初值</p>
<div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">1 2 5 6 0 3 6 5 3 6 5 6 0 4 2 7 0 4 3 5<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div>
<p>测试样例结果：</p>
<p><img src="/posts/6c024da0/image-20211212155603938.png" srcset="/img/loading.gif" lazyload alt="image-20211212155603938"></p>
<p>页面序列随机生成结果：</p>
<p><img src="/posts/6c024da0/image-20211212155623913.png" srcset="/img/loading.gif" lazyload alt="image-20211212155623913"></p>
<p><img src="/posts/6c024da0/image-20211212155651385.png" srcset="/img/loading.gif" lazyload alt="image-20211212155651385"></p>
<h4 id="思考题"><a class="markdownIt-Anchor" href="#思考题"></a> 思考题</h4>
<p><strong>页面置换算法各自的优缺点</strong></p>
<ul>
<li>
<p>LRU（最近最久未使用）：</p>
<ul>
<li>优点：由于考虑程序访问的时间局部性，一般能有较好的性能；实际应用多</li>
<li>缺点：实现需要较多的硬件支持，会增加硬件成本</li>
</ul>
</li>
<li>
<p>FIFO（先进先出）：</p>
<ul>
<li>优点：先进先出算法实现简单，是最直观的一个算法</li>
<li>缺点：先进先出的性能最差，因为与通常页面的使用规则不符合，所以实际应用少</li>
</ul>
</li>
<li>
<p>OPT（最佳置换）：</p>
<ul>
<li>
<p>缺点：最佳置换算法是一种理想化算法，具有较好的性能，但是实际上无法实现（无法预知一个进程中的若干页面哪一个最长时间不被访问）；</p>
</li>
<li>
<p>优点：最佳置换算法可以保证获得最低的缺页率</p>
</li>
</ul>
</li>
</ul>
<h3 id="五-实验总结"><a class="markdownIt-Anchor" href="#五-实验总结"></a> 五、实验总结</h3>
<p>LRU算法本身比较简单，关键在于时间复杂度的控制，使其能够高效实现，哈希表可以在O(1)时间内查找，双向链表可以在O(1)时间内插入和删除，所以两者结合可以高效的实现LRU，本次实验过程是我重新回顾了list和map的用法，结合这两者，成功完成了实验。</p>
<h1 id="实验2主存储器空间的分配和回收"><a class="markdownIt-Anchor" href="#实验2主存储器空间的分配和回收"></a> 实验2：主存储器空间的分配和回收</h1>
<h2 id="一-实验内容-2"><a class="markdownIt-Anchor" href="#一-实验内容-2"></a> 一、实验内容</h2>
<ul>
<li>主存储器空间的分配和回收</li>
</ul>
<h2 id="二-实验目的-2"><a class="markdownIt-Anchor" href="#二-实验目的-2"></a> 二、实验目的</h2>
<ul>
<li>通过本实验帮助学生理解在不同的存储管理方式下应怎样实现主存空间的分配和回收</li>
</ul>
<h2 id="三-实验题目-2"><a class="markdownIt-Anchor" href="#三-实验题目-2"></a> 三、实验题目</h2>
<p>本实验模拟在两种存储管理方式下的主存分配和回收。</p>
<h3 id="第一题"><a class="markdownIt-Anchor" href="#第一题"></a> 第一题：</h3>
<p>在可变分区管理方式下采用<strong>最先适应算法</strong>实现主存分配和实现主存回收。</p>
<p>[提示]：</p>
<ol>
<li>
<p>可变分区方式是按作业需要的主存空间大小来分割分区的。当要装入一个作业时，根据作业需要的主存量查看是否有足够的空闲空间，若有，则按需要量分割一个分区分配给该作业；若无，则作业不能装入。随着作业的装入、撤离，主存空间被分成许多个分区，有的分区被作业占用，而有的分区是空闲的。例如：</p>
<p><img src="/posts/6c024da0/image-20211213172512213.png" srcset="/img/loading.gif" lazyload alt="image-20211213172512213"></p>
<p>为了说明哪些区是空闲的，可以用来装入新作业，必须要有一张空闲区说明表，格式如下：</p>
<p><img src="/posts/6c024da0/image-20211213172536343.png" srcset="/img/loading.gif" lazyload alt="image-20211213172536343"></p>
</li>
<li>
<p>当有一个新作业要求装入主存时，必须查空闲区说明表，从中找出一个足够大的空闲区。有时找到的空闲区可能大于作业需要量，这时应把原来的空闲区变成两部分：一部分分给作业占用；另一部分又成为一个较小的空闲区。为了尽量减少由于分割造成的空闲区，而尽量保存高地址部分有较大的连续空闲区域，以利于大型作业的装入。为此，在空闲区说明表中，把每个空闲区按其地址顺序登记，即每个后继的空闲区其起始地址总是比前者大。为了方便查找还可使表格“紧缩”，总是让“空表目”栏集中在表格的后部。</p>
</li>
<li>
<p>采用最先适应算法（顺序分配算法）分配主存空间。按照作业的需要量，查空闲区说明表，顺序查看登记栏，找到第一个能满足要求的空闲区。当空闲区大于需要量时，一部分用来装入作业，另一部分仍为空闲区登记在空闲区说明表中。由于本实验是模拟主存的分配，所以把主存区分配给作业后并不实际启动装入程序装入作业，而用输出“分配情况”来代替。最先适应分配算法如图。</p>
<p><img src="/posts/6c024da0/image-20211213172909092.png" srcset="/img/loading.gif" lazyload alt="image-20211213172909092"></p>
</li>
<li>
<p>当一个作业执行结束撤离时，作业所占的区域应该归还，归还的区域如果与其它空闲区相邻，则应合成一个较大的空闲区，登记在空闲区说明表中。例如，在提示(1)中列举的情况下，如果作业2撤离，归还所占主存区域时，应与上、下相邻的空闲区一起合成一个大的空闲区登记在空闲区说明表中。归还主存时的回收算法如图。</p>
<p><img src="/posts/6c024da0/image-20211213172948727.png" srcset="/img/loading.gif" lazyload alt="image-20211213172948727"></p>
</li>
<li>
<p>请按最先适应算法设计主存分配和回收的程序。然后按（1）中假设主存中已装入三个作业，且形成两个空闲区，确定空闲区说明表的初值。现有一个需要主存量为6K的作业4申请装入主存；然后作业3撤离；再作业2撤离。请你为它们进行主存分配和回收，把空闲区说明表的初值以及每次分配或回收后的变化显示出来或打印出来。</p>
</li>
</ol>
<h3 id="第二题"><a class="markdownIt-Anchor" href="#第二题"></a> 第二题：</h3>
<p><strong>在分页式管理方式下采用位示图来表示主存分配情况，实现主存空间的分配和回收。</strong></p>
<p>[提示]：</p>
<ol>
<li>
<p>分页式存储器把主存分成大小相等的若干块，作业的信息也按块的大小分页，作业装入主存时可把作业的信息按页分散存放在主存的空闲块中，为了说明主存中哪些块已经被占用，哪些块是尚未分配的空闲块，可用一张位示图来指出。位示图可由若干存储单元来构成，其中每一位与一个物理块对应，用0/1表示对应块为空闲/已占用。</p>
</li>
<li>
<p>假设某系统的主存被分成大小相等的64块，则位示图可用8个字节来构成，另用一单元记录当前空闲块数。如果已有第0，1，4，5，6，9，11，13，24，31，共10个主存块被占用了，那么位示图情况如下</p>
<p><img src="/posts/6c024da0/image-20211213173805545.png" srcset="/img/loading.gif" lazyload alt="image-20211213173805545"></p>
</li>
<li>
<p>当要装入一个作业时，根据作业对主存的需要量，先查当前空闲块数是否能满足作业要求，若不能满足则输出分配不成功。若能满足，则查位示图，找出为“0”的一些位，置上占用标志“1”，从“当前空闲块数”中减去本次占用块数。按找到的计算出对应的块号，其计算公式为：块号=j 8+I其中，j表示找到的是第n个字节，i表示对应的是第n位。根据分配给作业的块号，为作业建立一张页表，页表<br>
格式：</p>
<p><img src="/posts/6c024da0/image-20211213173822803.png" srcset="/img/loading.gif" lazyload alt="image-20211213173822803"></p>
</li>
<li>
<p>当一个作业执行结束，归还主存时，根据该作业的页表可以知道应归还的块号，由块号可计算出在位示图中的对应位置，把对应位的占用标志清成“0”，表示对应的块已成为空闲块。归还的块数加入到当前空闲块数中。由块号计算在位示图中的位置的公式如下：字节号 j=[块号/8] （[ ]表示取整）位数 i={块号/8} （{ }表示取余）</p>
</li>
<li>
<p>设计实现主存分配和回收的程序。假定位示图的初始状态如（2）所述，现有一信息量为5页的作业要装入，运行你所设计的分配程序，为作业分配主存且建立页表（格式如（3）所述）。然后假定有另一作业执行结束，它占用的块号为第4，5，6和31块，运行你所设计的回收程序，收回作业归还的主存块。要求能显示和打印分配或回收前后的位示图和当前空闲<br>
块数，对完成一次分配后还要显示或打印为作业建立的页表</p>
</li>
</ol>
<h3 id="思考题-2"><a class="markdownIt-Anchor" href="#思考题-2"></a> 思考题：</h3>
<p>结合实际情况，参考书本，仔细考虑各种主存分配算法的优缺点。把主存分成大小相等的若干块，作业的信息也按块的大小分页，作业装入主存时把作业的信息按页分散存放在主存的空闲块中，这样很可能导致每个作业按页装入主存中时，某一页还存在一定的空闲空间，思考如何才能有效的利用这些空闲区域。</p>
<h2 id="四-实验设计与过程-2"><a class="markdownIt-Anchor" href="#四-实验设计与过程-2"></a> 四、实验设计与过程</h2>
<h3 id="第一题最先适应"><a class="markdownIt-Anchor" href="#第一题最先适应"></a> 第一题：最先适应</h3>
<h4 id="数据结构和符号说明-2"><a class="markdownIt-Anchor" href="#数据结构和符号说明-2"></a> 数据结构和符号说明</h4>
<div class="code-wrapper"><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">struct table
&#123;
    string name; &#x2F;&#x2F;主存分配信息
    int address; &#x2F;&#x2F;主存起始地址
    int length;  &#x2F;&#x2F;主存分配长度
    int state;   &#x2F;&#x2F;主存状态信息，1为已分配，0为未分配
&#125;;
vector&lt;table&gt; alloc_table;   &#x2F;&#x2F;主存表<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div>
<h4 id="函数说明-2"><a class="markdownIt-Anchor" href="#函数说明-2"></a> 函数说明</h4>
<p>一共三个主要函数</p>
<ul>
<li>未分配主存的合并函数</li>
<li>主存回收函数</li>
<li>主存分配函数</li>
</ul>
<p>根据流程图，函数思路均很清晰。</p>
<div class="code-wrapper"><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">void merge() &#x2F;&#x2F;未分配主存的合并函数
&#123;
    for (int i &#x3D; 0; i &lt; alloc_table.size() - 1; i++)
    &#123;

        if (alloc_table[i].address + alloc_table[i].length &#x3D;&#x3D; alloc_table[i + 1].address &amp;&amp; alloc_table[i].state &#x3D;&#x3D; 0 &amp;&amp; alloc_table[i + 1].state &#x3D;&#x3D; 0)
        &#123; &#x2F;&#x2F;相邻则合并，并删掉后者
            alloc_table[i].length +&#x3D; alloc_table[i + 1].length;
            alloc_table.erase(alloc_table.begin() + i + 1);
            break;
        &#125;
    &#125;
&#125;
int recovery(string name) &#x2F;&#x2F;主存回收函数
&#123;
    for (int i &#x3D; 0; i &lt; alloc_table.size(); i++)
    &#123;
        if (alloc_table[i].name &#x3D;&#x3D; name)
        &#123;
            alloc_table[i].name &#x3D; &quot;未分配&quot;;
            alloc_table[i].state &#x3D; 0;
            return alloc_table[i].length;
        &#125;
    &#125;
&#125;
void allocation(string name, int length) &#x2F;&#x2F;主存分配函数
&#123;
    for (int i &#x3D; 0; i &lt; alloc_table.size(); i++)
    &#123;

        if (alloc_table[i].length &gt; length &amp;&amp; alloc_table[i].state &#x3D;&#x3D; 0) &#x2F;&#x2F;剩余空间比需求大
        &#123;
            table t;
            t.name &#x3D; name;
            t.address &#x3D; alloc_table[i].address;
            t.length &#x3D; length;
            t.state &#x3D; 1;
            alloc_table.push_back(t);

            alloc_table[i].address +&#x3D; length;
            alloc_table[i].length -&#x3D; length;
            break;
        &#125;
        else if (alloc_table[i].length &#x3D;&#x3D; length &amp;&amp; alloc_table[i].state &#x3D;&#x3D; 0) &#x2F;&#x2F;剩余空间和需求一样
        &#123;
            alloc_table[i].name &#x3D; name;
            alloc_table[i].state &#x3D; 1;
            break;
        &#125;
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div>
<h4 id="完整源代码-2"><a class="markdownIt-Anchor" href="#完整源代码-2"></a> 完整源代码</h4>
<div class="code-wrapper"><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;bits&#x2F;stdc++.h&gt;
using namespace std;
struct table
&#123;
    string name; &#x2F;&#x2F;主存分配信息
    int address; &#x2F;&#x2F;主存起始地址
    int length;  &#x2F;&#x2F;主存分配长度
    int state;   &#x2F;&#x2F;主存状态信息，1为已分配，0位未分配
&#125;;
vector&lt;table&gt; alloc_table;   &#x2F;&#x2F;主存表
bool cmp(table &amp;a, table &amp;b) &#x2F;&#x2F;排序比较函数
&#123;
    return a.address &lt; b.address;
&#125;
void merge() &#x2F;&#x2F;未分配主存的合并函数
&#123;
    for (int i &#x3D; 0; i &lt; alloc_table.size() - 1; i++)
    &#123;

        if (alloc_table[i].address + alloc_table[i].length &#x3D;&#x3D; alloc_table[i + 1].address &amp;&amp; alloc_table[i].state &#x3D;&#x3D; 0 &amp;&amp; alloc_table[i + 1].state &#x3D;&#x3D; 0)
        &#123; &#x2F;&#x2F;相邻则合并，并删掉后者
            alloc_table[i].length +&#x3D; alloc_table[i + 1].length;
            alloc_table.erase(alloc_table.begin() + i + 1);
            break;
        &#125;
    &#125;
&#125;
int recovery(string name) &#x2F;&#x2F;主存回收函数
&#123;
    for (int i &#x3D; 0; i &lt; alloc_table.size(); i++)
    &#123;
        if (alloc_table[i].name &#x3D;&#x3D; name)
        &#123;
            alloc_table[i].name &#x3D; &quot;未分配&quot;;
            alloc_table[i].state &#x3D; 0;
            return alloc_table[i].length;
        &#125;
    &#125;
&#125;
void allocation(string name, int length) &#x2F;&#x2F;主存分配函数
&#123;
    for (int i &#x3D; 0; i &lt; alloc_table.size(); i++)
    &#123;

        if (alloc_table[i].length &gt; length &amp;&amp; alloc_table[i].state &#x3D;&#x3D; 0) &#x2F;&#x2F;剩余空间比需求大
        &#123;
            table t;
            t.name &#x3D; name;
            t.address &#x3D; alloc_table[i].address;
            t.length &#x3D; length;
            t.state &#x3D; 1;
            alloc_table.push_back(t);

            alloc_table[i].address +&#x3D; length;
            alloc_table[i].length -&#x3D; length;
            break;
        &#125;
        else if (alloc_table[i].length &#x3D;&#x3D; length &amp;&amp; alloc_table[i].state &#x3D;&#x3D; 0) &#x2F;&#x2F;剩余空间和需求一样
        &#123;
            alloc_table[i].name &#x3D; name;
            alloc_table[i].state &#x3D; 1;
            break;
        &#125;
    &#125;
&#125;
void init() &#x2F;&#x2F;状态初始化
&#123;
    table a;
    a.name &#x3D; &quot;操作系统&quot;;
    a.address &#x3D; 0;
    a.length &#x3D; 5;
    a.state &#x3D; 1;
    alloc_table.push_back(a);

    a.name &#x3D; &quot;1&quot;;
    a.address &#x3D; 5;
    a.length &#x3D; 5;
    a.state &#x3D; 1;
    alloc_table.push_back(a);

    a.name &#x3D; &quot;3&quot;;
    a.address &#x3D; 10;
    a.length &#x3D; 4;
    a.state &#x3D; 1;
    alloc_table.push_back(a);

    a.name &#x3D; &quot;2&quot;;
    a.address &#x3D; 26;
    a.length &#x3D; 6;
    a.state &#x3D; 1;
    alloc_table.push_back(a);

    a.name &#x3D; &quot;未分配&quot;;
    a.address &#x3D; 14;
    a.length &#x3D; 12;
    a.state &#x3D; 0;
    alloc_table.push_back(a);

    a.name &#x3D; &quot;未分配&quot;;
    a.address &#x3D; 32;
    a.length &#x3D; 96;
    a.state &#x3D; 0;
    alloc_table.push_back(a);
&#125;
void print() &#x2F;&#x2F;信息打印
&#123;
    printf(&quot;\n|----------------空闲分区表------------------|\n&quot;);
    printf(&quot;|  起 址  |  长 度  |  状 态  |     名称     |\n&quot;);
    for (int i &#x3D; 0; i &lt; alloc_table.size(); i++)
    &#123;
        if (alloc_table[i].state &#x3D;&#x3D; 0)
        &#123;
            printf(&quot;|   %3d   |   %3d   |   %3d   |  %9s   |\n&quot;, alloc_table[i].address, alloc_table[i].length, alloc_table[i].state, alloc_table[i].name.c_str());
        &#125;
    &#125;
    printf(&quot;|--------------------------------------------|\n&quot;);
    printf(&quot;\n|----------------主存分配表------------------|\n&quot;);
    printf(&quot;|  起 址  |  长 度  |  状 态  |     名称     |\n&quot;);
    for (int i &#x3D; 0; i &lt; alloc_table.size(); i++)
    &#123;
        if (alloc_table[i].state &#x3D;&#x3D; 1)
        &#123;
            printf(&quot;|   %3d   |   %3d   |   %3d   |  %9s   |\n&quot;, alloc_table[i].address, alloc_table[i].length, alloc_table[i].state, alloc_table[i].name.c_str());
        &#125;
    &#125;
    printf(&quot;|--------------------------------------------|\n&quot;);
&#125;
int main()
&#123;
    printf(&quot;\n~~~~~~~~~~~~~~~~~~初始状态~~~~~~~~~~~~~~~~~~~~\n&quot;);
    init();
    sort(alloc_table.begin(), alloc_table.end(), cmp); &#x2F;&#x2F;排序
    merge();                                           &#x2F;&#x2F;合并
    print();                                           &#x2F;&#x2F;打印信息

    printf(&quot;\n~~~~~~~~~~~~~~~~~~加入工作4~~~~~~~~~~~~~~~~~~~\n&quot;);
    printf(&quot;\n------------------申请内存4-------------------\n&quot;);
    allocation(&quot;4&quot;, 6); &#x2F;&#x2F;分配
    sort(alloc_table.begin(), alloc_table.end(), cmp);
    merge();
    print();

    printf(&quot;\n~~~~~~~~~~~~~~~~~~回收工作3~~~~~~~~~~~~~~~~~~~\n&quot;);
    int a &#x3D; recovery(&quot;3&quot;); &#x2F;&#x2F;回收
    printf(&quot;\n------------------释放内存%d-------------------\n&quot;, a);
    sort(alloc_table.begin(), alloc_table.end(), cmp);
    merge();
    print();

    printf(&quot;\n~~~~~~~~~~~~~~~~~~回收工作2~~~~~~~~~~~~~~~~~~~\n&quot;);
    a &#x3D; recovery(&quot;2&quot;);
    printf(&quot;\n------------------释放内存%d-------------------\n&quot;, a);
    sort(alloc_table.begin(), alloc_table.end(), cmp);
    merge();
    print();
    return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div>
<h4 id="程序初值和运行结果-2"><a class="markdownIt-Anchor" href="#程序初值和运行结果-2"></a> 程序初值和运行结果</h4>
<p>初始状态：</p>
<p><img src="/posts/6c024da0/image-20211213174019843.png" srcset="/img/loading.gif" lazyload alt="image-20211213174019843"></p>
<p>加入工作4：</p>
<p><img src="/posts/6c024da0/image-20211213174056801.png" srcset="/img/loading.gif" lazyload alt="image-20211213174056801"></p>
<p>回收工作3：</p>
<p><img src="/posts/6c024da0/image-20211213174118960.png" srcset="/img/loading.gif" lazyload alt="image-20211213174118960"></p>
<p>回收工作2：</p>
<p><img src="/posts/6c024da0/image-20211213174145295.png" srcset="/img/loading.gif" lazyload alt="image-20211213174145295"></p>
<h3 id="第二题位示图"><a class="markdownIt-Anchor" href="#第二题位示图"></a> 第二题：位示图</h3>
<h4 id="数据结构和符号说明-3"><a class="markdownIt-Anchor" href="#数据结构和符号说明-3"></a> 数据结构和符号说明</h4>
<div class="code-wrapper"><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int table[8][8];&#x2F;&#x2F;位示图
int free_num &#x3D; 64;&#x2F;&#x2F;当前位示图空闲块
struct work
&#123;
    string name;&#x2F;&#x2F;作业名称
    int mem_num;&#x2F;&#x2F;作业页表数量
    int page_table[64];&#x2F;&#x2F;页表
&#125;;
vector&lt;work&gt; w;&#x2F;&#x2F;作业数量<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div>
<h4 id="函数说明-3"><a class="markdownIt-Anchor" href="#函数说明-3"></a> 函数说明</h4>
<p>一共两个主要函数</p>
<ul>
<li>作业分配函数allocation()</li>
<li>作业回收函数recovery()</li>
</ul>
<p>函数思路如下，均相当好理解</p>
<div class="code-wrapper"><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">void allocation()&#x2F;&#x2F;作业分配函数
&#123;
    work a;
    int t &#x3D; 0;
    while (1)&#x2F;&#x2F;输入作业名并判断是否已经存在
    &#123;
        printf(&quot;请输入要分配的作业名:&quot;);
        cin &gt;&gt; a.name;
        int kk &#x3D; 0;
        for (int i &#x3D; 0; i &lt; w.size(); i++)
        &#123;
            if (a.name &#x3D;&#x3D; w[i].name)
                kk &#x3D; 1;
        &#125;
        if (kk &#x3D;&#x3D; 1)
            printf(&quot;当前作业已存在，请重新输入\n&quot;);
        else
            break;
    &#125;
    printf(&quot;请输入作业内存申请量:&quot;);
    scanf(&quot;%d&quot;, &amp;a.mem_num);
    if (free_num &gt;&#x3D; a.mem_num)&#x2F;&#x2F;如果内存空间大于作业内存申请数量
    &#123;
        for (int i &#x3D; 0; i &lt; 8; i++)
        &#123;
            for (int j &#x3D; 0; j &lt; 8; j++)
            &#123;
                if (!table[i][j])&#x2F;&#x2F;修改未分配的位示图
                &#123;
                    table[i][j] &#x3D; 1;
                    free_num--;
                    a.page_table[t++] &#x3D; i * 8 + j;
                    if (t &#x3D;&#x3D; a.mem_num)
                        break;
                &#125;
            &#125;
            if (t &#x3D;&#x3D; a.mem_num)
                break;
        &#125;
        w.push_back(a);&#x2F;&#x2F;加入作业列表
        printf(&quot;\n作业内存分配成功\n&quot;);
        print();
    &#125;
    else
        printf(&quot;\n内存空闲块不足\n&quot;);
&#125;
void recovery()
&#123;
    string name;
    printf(&quot;请输入要释放的作业名:&quot;);
    cin &gt;&gt; name;
    for (int i &#x3D; 0; i &lt; w.size(); i++)
    &#123;
        if (w[i].name &#x3D;&#x3D; name)
        &#123;
            printf(&quot;\n当前作业归还的块号：&quot;);
            for (int k &#x3D; 0; k &lt; w[i].mem_num; k++)&#x2F;&#x2F;逐个释放内存块
            &#123;
                printf(&quot;%d  &quot;, w[i].page_table[k]);
                table[w[i].page_table[k] &#x2F; 8][w[i].page_table[k] % 8] &#x3D; 0;
                free_num++;
            &#125;
            w.erase(w.begin() + i);
            printf(&quot;\n作业回收成功\n&quot;);
            print();
            return;
        &#125;
    &#125;
    printf(&quot;\n未找到当前作业\n&quot;);
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div>
<h4 id="完整源代码-3"><a class="markdownIt-Anchor" href="#完整源代码-3"></a> 完整源代码</h4>
<div class="code-wrapper"><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;bits&#x2F;stdc++.h&gt;
using namespace std;
int table[8][8];&#x2F;&#x2F;位示图
int free_num &#x3D; 64;&#x2F;&#x2F;当前位示图空闲块
struct work
&#123;
    string name;&#x2F;&#x2F;作业名称
    int mem_num;&#x2F;&#x2F;作业页表数量
    int page_table[64];&#x2F;&#x2F;页表
&#125;;
vector&lt;work&gt; w;&#x2F;&#x2F;作业数量
void menu()
&#123;
    printf(&quot;1.分配作业\n&quot;);
    printf(&quot;2.回收作业\n&quot;);
    printf(&quot;3.退出\n&quot;);
&#125;
void init()&#x2F;&#x2F;位示图初始化函数
&#123;
    memset(table, 0, sizeof(table));
    table[0][0] &#x3D; 1;
    table[0][1] &#x3D; 1;
    table[0][4] &#x3D; 1;
    table[0][5] &#x3D; 1;
    table[0][6] &#x3D; 1;
    table[1][1] &#x3D; 1;
    table[1][3] &#x3D; 1;
    table[1][5] &#x3D; 1;
    table[3][0] &#x3D; 1;
    table[3][7] &#x3D; 1;
    free_num -&#x3D; 10;
    work a;
    a.name &#x3D; &quot;w1&quot;;&#x2F;&#x2F;作业1
    a.mem_num &#x3D; 4;
    a.page_table[0] &#x3D; 4;
    a.page_table[1] &#x3D; 5;
    a.page_table[2] &#x3D; 6;
    a.page_table[3] &#x3D; 31;
    w.push_back(a);

    a.name &#x3D; &quot;w2&quot;;&#x2F;&#x2F;作业2
    a.mem_num &#x3D; 6;
    a.page_table[0] &#x3D; 0;
    a.page_table[1] &#x3D; 1;
    a.page_table[2] &#x3D; 9;
    a.page_table[3] &#x3D; 11;
    a.page_table[4] &#x3D; 13;
    a.page_table[5] &#x3D; 24;
    w.push_back(a);
    printf(&quot;初始化完成\n&quot;);
&#125;
void print()&#x2F;&#x2F;信息打印函数
&#123;
    printf(&quot;当前位示图和作业页表:\n&quot;);
    printf(&quot;\n|--------------位示图---------------|\n&quot;);
    printf(&quot;|-----------------------------------|\n&quot;);
    printf(&quot;|  位数  |&quot;);
    for (int i &#x3D; 0; i &lt; 8; i++)
    &#123;
        printf(&quot;%3d&quot;, i);
    &#125;
    printf(&quot;  |\n| 字节数 |%24c  |\n&quot;, &#39; &#39;);
    printf(&quot;|        ___________________________|\n&quot;);
    for (int i &#x3D; 0; i &lt; 8; i++)
    &#123;
        printf(&quot;| %6d |&quot;, i);
        for (int j &#x3D; 0; j &lt; 8; j++)
        &#123;
            printf(&quot;%3d&quot;, table[i][j]);
        &#125;
        printf(&quot;  |\n&quot;);
    &#125;
    printf(&quot;|-----------------------------------|\n&quot;);
    printf(&quot;\n当前空闲块数：%d\n&quot;, free_num);
    printf(&quot;\n|-----作业页表----|\n&quot;);
    for (int i &#x3D; 0; i &lt; w.size(); i++)
    &#123;
        printf(&quot;|-----------------|\n&quot;);
        printf(&quot;|      作业%s     |\n&quot;, w[i].name.c_str());
        printf(&quot;|  页号  |  块号  |\n&quot;);
        for (int j &#x3D; 0; j &lt; w[i].mem_num; j++)
        &#123;
            printf(&quot;|  %4d  |  %4d  |\n&quot;, j, w[i].page_table[j]);
        &#125;
    &#125;
    printf(&quot;|-----------------|\n\n&quot;);
&#125;
void allocation()&#x2F;&#x2F;作业分配函数
&#123;
    work a;
    int t &#x3D; 0;
    while (1)&#x2F;&#x2F;输入作业名并判断是否已经存在
    &#123;
        printf(&quot;请输入要分配的作业名:&quot;);
        cin &gt;&gt; a.name;
        int kk &#x3D; 0;
        for (int i &#x3D; 0; i &lt; w.size(); i++)
        &#123;
            if (a.name &#x3D;&#x3D; w[i].name)
                kk &#x3D; 1;
        &#125;
        if (kk &#x3D;&#x3D; 1)
            printf(&quot;当前作业已存在，请重新输入\n&quot;);
        else
            break;
    &#125;
    printf(&quot;请输入作业内存申请量:&quot;);
    scanf(&quot;%d&quot;, &amp;a.mem_num);
    if (free_num &gt;&#x3D; a.mem_num)&#x2F;&#x2F;如果内存空间大于作业内存申请数量
    &#123;
        for (int i &#x3D; 0; i &lt; 8; i++)
        &#123;
            for (int j &#x3D; 0; j &lt; 8; j++)
            &#123;
                if (!table[i][j])&#x2F;&#x2F;修改未分配的位示图
                &#123;
                    table[i][j] &#x3D; 1;
                    free_num--;
                    a.page_table[t++] &#x3D; i * 8 + j;
                    if (t &#x3D;&#x3D; a.mem_num)
                        break;
                &#125;
            &#125;
            if (t &#x3D;&#x3D; a.mem_num)
                break;
        &#125;
        w.push_back(a);&#x2F;&#x2F;加入作业列表
        printf(&quot;\n作业内存分配成功\n&quot;);
        print();
    &#125;
    else
        printf(&quot;\n内存空闲块不足\n&quot;);
&#125;
void recovery()
&#123;
    string name;
    printf(&quot;请输入要释放的作业名:&quot;);
    cin &gt;&gt; name;
    for (int i &#x3D; 0; i &lt; w.size(); i++)
    &#123;
        if (w[i].name &#x3D;&#x3D; name)
        &#123;
            printf(&quot;\n当前作业归还的块号：&quot;);
            for (int k &#x3D; 0; k &lt; w[i].mem_num; k++)&#x2F;&#x2F;逐个释放内存块
            &#123;
                printf(&quot;%d  &quot;, w[i].page_table[k]);
                table[w[i].page_table[k] &#x2F; 8][w[i].page_table[k] % 8] &#x3D; 0;
                free_num++;
            &#125;
            w.erase(w.begin() + i);
            printf(&quot;\n作业回收成功\n&quot;);
            print();
            return;
        &#125;
    &#125;
    printf(&quot;\n未找到当前作业\n&quot;);
&#125;

int main()
&#123;
    int q;
    init();
    print();
    while (1)
    &#123;
        menu();
        printf(&quot;请输入选择:&quot;);
        scanf(&quot;%d&quot;, &amp;q);
        switch (q)
        &#123;
        case 1:
            allocation();
            break;
        case 2:
            recovery();
            break;
        case 3:
            exit(0);
            break;
        &#125;
    &#125;
    return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div>
<h4 id="程序初值和运行结果-3"><a class="markdownIt-Anchor" href="#程序初值和运行结果-3"></a> 程序初值和运行结果</h4>
<p>初始状态：</p>
<p><img src="/posts/6c024da0/image-20211214144921135.png" srcset="/img/loading.gif" lazyload alt="image-20211214144921135"></p>
<p>加入工作3，申请量为5：</p>
<p><img src="/posts/6c024da0/image-20211214145013435.png" srcset="/img/loading.gif" lazyload alt="image-20211214145013435"></p>
<p><img src="/posts/6c024da0/image-20211214145032075.png" srcset="/img/loading.gif" lazyload alt="image-20211214145032075"></p>
<p>回收工作1：</p>
<p><img src="/posts/6c024da0/image-20211214145333974.png" srcset="/img/loading.gif" lazyload alt="image-20211214145333974"></p>
<p><img src="/posts/6c024da0/image-20211214145129469.png" srcset="/img/loading.gif" lazyload alt="image-20211214145129469"></p>
<p>全部回收：</p>
<p><img src="/posts/6c024da0/image-20211214145241609.png" srcset="/img/loading.gif" lazyload alt="image-20211214145241609"></p>
<h4 id="思考题-3"><a class="markdownIt-Anchor" href="#思考题-3"></a> 思考题</h4>
<p><strong>各种主存分配算法的优缺点</strong></p>
<ul>
<li>
<p>首次适应算法：</p>
<ul>
<li>
<p>优点： 该算法倾向于使用内存中低地址部分的空闲区，在高地址部分的空闲区很少被利用，从而保留了高地址部分的大空闲 区。显然为以后到达的大作业分配大的内存空间创造了条件</p>
</li>
<li>
<p>缺点：低地址部分不断被划分，留下许多难以利用、很小的空闲区，而每次查找又都从低地址部分开始，会增加查找的开销</p>
</li>
</ul>
</li>
<li>
<p>最佳适应算法：</p>
<ul>
<li>
<p>优点：每次分配给文件的都是最合适该文件大小的分区。</p>
</li>
<li>
<p>缺点：内存中留下许多难以利用的小的空闲区。</p>
</li>
</ul>
</li>
<li>
<p>最差适应算法：</p>
<ul>
<li>优点：给文件分配分区后剩下的空闲区不至于太小，产生碎片的几率最小，对中小型文件分配分区操作有利。</li>
<li>缺点：使存储器中缺乏大的空闲区，对大型文件的分区分配不利。</li>
</ul>
</li>
</ul>
<p><strong>如何利用空闲分区</strong></p>
<p>采用可变内存管理，合并小的空闲区。</p>
<h3 id="五-实验总结-2"><a class="markdownIt-Anchor" href="#五-实验总结-2"></a> 五、实验总结</h3>
<p>本次实验要我对不同的存储管理方式下应怎样实现主存空间的分配和回收有了更深的理解，对页面置换算法、主存分配回收算法、最先适应算法和位示图方法有了一定的了解，实验算法思路总体上较为简单，只要理解了具体的内存的分配和释放规则就比较容易写出算法。</p>

            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                  <div class="post-meta mr-3">
                    <i class="iconfont icon-category"></i>
                    
                      <a class="hover-with-bg" href="/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">操作系统</a>
                    
                  </div>
                
                
                  <div class="post-meta">
                    <i class="iconfont icon-tags"></i>
                    
                      <a class="hover-with-bg" href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">操作系统</a>
                    
                  </div>
                
              </div>
              
                <p class="note note-warning">
                  
                    本博客所有文章除特别声明外，著作权归作者所有，转载请注明出处！
                  
                </p>
              
              
                <div class="post-prevnext">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/posts/6255939a/">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">操作系统实验八-文件结构</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/posts/7e08c437/">
                        <span class="hidden-mobile">AFL源码注释（待完成）</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
              <!-- Comments -->
              <article class="comments" id="comments" lazyload>
                
                  
                
                
  <div class="disqus" style="width:100%">
    <div id="disqus_thread"></div>
    
      <script type="text/javascript">
        var disqus_config = function() {
          this.page.url = 'https://zino00.github.io/posts/6c024da0/';
          this.page.identifier = '/posts/6c024da0/';
        };
        Fluid.utils.loadComments('#disqus_thread', function() {
          var d = document, s = d.createElement('script');
          s.src = '//' + 'fluid' + '.disqus.com/embed.js';
          s.setAttribute('data-timestamp', new Date());
          (d.head || d.body).appendChild(s);
        });
      </script>
    
    <noscript>Please enable JavaScript to view the comments</noscript>
  </div>


              </article>
            
          </article>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    

    
      <a id="scroll-top-button" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
    

    
  </main>

  <footer class="text-center mt-5 py-3">
  <div class="footer-content">
     <a  rel="nofollow noopener"><span>Copyrights © 2021</span></a> <i class="iconfont icon-love"></i> <a  target="_blank" rel="nofollow noopener"><span>Zino</span></a> 
  </div>
  
  <div class="statistics">
    
    

    
      
        <!-- 不蒜子统计PV -->
        <span id="busuanzi_container_site_pv" style="display: none">
            总访问量 
            <span id="busuanzi_value_site_pv"></span>
             次
          </span>
      
      
        <!-- 不蒜子统计UV -->
        <span id="busuanzi_container_site_uv" style="display: none">
            总访客数 
            <span id="busuanzi_value_site_uv"></span>
             人
          </span>
      
    
  </div>


  

  
  <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?d1745c2e21adaa6ae90b93f4f4d22da9";
      var s = document.getElementsByTagName("script")[0]; 
      s.parentNode.insertBefore(hm, s);
    })();
    </script>
    
</footer>


  <!-- SCRIPTS -->
  
  <script  src="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" ></script>
<script  src="https://cdn.jsdelivr.net/npm/bootstrap@4.6.0/dist/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>

<!-- Plugins -->


  
    <script  src="/js/img-lazyload.js" ></script>
  



  



  <script  src="https://cdn.jsdelivr.net/npm/tocbot@4.12.3/dist/tocbot.min.js" ></script>



  <script  src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js" ></script>



  <script  src="https://cdn.jsdelivr.net/npm/anchor-js@4.3.1/anchor.min.js" ></script>



  <script defer src="https://cdn.jsdelivr.net/npm/clipboard@2.0.8/dist/clipboard.min.js" ></script>



  <script  src="/js/local-search.js" ></script>



  <script defer src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" ></script>




  <script  src="https://cdn.jsdelivr.net/npm/typed.js@2.0.12/lib/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var title = document.getElementById('subtitle').title;
      
      typing(title)
      
    })(window, document);
  </script>





  

  
    <!-- KaTeX -->
    <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.13.10/dist/katex.min.css" />
  








  
    <!-- Baidu Analytics -->
    <script defer>
      var _hmt = _hmt || [];
      (function () {
        var hm = document.createElement("script");
        hm.src = "https://hm.baidu.com/hm.js?f45dcd001d67e8f9d84f91248ea31abf";
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(hm, s);
      })();
    </script>
  

  

  

  

  

  





<!-- 主题的启动项 保持在最底部 -->
<script  src="/js/boot.js" ></script>


</body>
</html>
