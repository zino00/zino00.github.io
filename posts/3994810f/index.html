

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=&#34;auto&#34;>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/favicon.jpg">
  <link rel="icon" href="/img/favicon.jpg">
  <meta name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="description" content="模拟操作系统中进程同步和互斥">
  <meta name="author" content="John Doe">
  <meta name="keywords" content="">
  
  <title>操作系统实验六-生产者消费者问题 - Zino&#39;s Blog</title>

  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.6.0/dist/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/github-markdown-css@4.0.0/github-markdown.min.css" />
  <link  rel="stylesheet" href="/lib/hint/hint.min.css" />

  
    
    
      
      
        
          
          
          
        
        <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/prismjs@1.23.0/themes/prism-okaidia.min.css" />
      
      
        <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/prismjs@1.23.0/plugins/line-numbers/prism-line-numbers.min.css" />
      
    
  

  
    <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css" />
  



<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_kmeydafke9r.css">


<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->


  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    var CONFIG = {"hostname":"zino00.github.io","root":"/","version":"1.8.11","typing":{"enable":true,"typeSpeed":70,"cursorChar":"","loop":false},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"copy_btn":true,"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":1},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":true,"baidu":"f45dcd001d67e8f9d84f91248ea31abf","google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null}},"search_path":"/local-search.xml"};
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
<meta name="generator" content="Hexo 5.4.0"></head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand"
       href="/">&nbsp;<strong>Zino's Blog</strong>&nbsp;</a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" data-toggle="modal" data-target="#modalSearch">&nbsp;<i
                class="iconfont icon-search"></i>&nbsp;</a>
          </li>
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="banner" id="banner" parallax=true
         style="background: url('/img/post.jpg') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="page-header text-center fade-in-up">
            <span class="h2" id="subtitle" title="操作系统实验六-生产者消费者问题">
              
            </span>

            
              <div class="mt-3">
  
  
    <span class="post-meta">
      <i class="iconfont icon-date-fill" aria-hidden="true"></i>
      <time datetime="2021-11-30 00:00" pubdate>
        2021年11月30日 凌晨
      </time>
    </span>
  
</div>

<div class="mt-1">
  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      5.8k 字
    </span>
  

  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      79
       分钟
    </span>
  

  
  
    
      <!-- 不蒜子统计文章PV -->
      <span id="busuanzi_container_page_pv" style="display: none">
        <i class="iconfont icon-eye" aria-hidden="true"></i>
        <span id="busuanzi_value_page_pv"></span> 次
      </span>
    
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">操作系统实验六-生产者消费者问题</h1>
            
            <div class="markdown-body">
              <h2 id="一-实验内容"><a class="markdownIt-Anchor" href="#一-实验内容"></a> 一、实验内容</h2>
<ul>
<li>模拟操作系统中进程同步和互斥。</li>
</ul>
<h2 id="二-实验目的"><a class="markdownIt-Anchor" href="#二-实验目的"></a> 二、实验目的</h2>
<ul>
<li>熟悉临界资源、信号量及PV操作的定义与物理意义</li>
<li>了解进程通信的方法</li>
<li>掌握进程互斥与进程同步的相关知识</li>
<li>掌握用信号量机制解决进程之间的同步与互斥问题</li>
<li>实现生产者－消费者问题，深刻理解进程同步问题</li>
</ul>
<h2 id="三-实验题目"><a class="markdownIt-Anchor" href="#三-实验题目"></a> 三、实验题目</h2>
<h3 id="进程实现"><a class="markdownIt-Anchor" href="#进程实现"></a> 进程实现</h3>
<p>在Linux操作系统下用C实现经典同步问题：生产者—消费者，具体要求如下：</p>
<ol>
<li>一个大小为10的缓冲区，初始状态为空。</li>
<li>2个生产者，随机等待一段时间，往缓冲区中添加数据，若缓冲区已满，等待消费者取走数据之后再添加，重复10次。</li>
<li>2个消费者，随机等待一段时间，从缓冲区中读取数据，若缓冲区为空，等待生产者添加数据之后再读取，重复10次。</li>
</ol>
<p><strong>提示</strong><br>
本实验的主要目的是模拟操作系统中进程同步和互斥。在系统进程并发执行异步推进的过程中，由于资源共享和进程间合作而造成进程间相互制约。进程间的相互制约有两种不同的方式。</p>
<ol>
<li>间接制约。这是由于多个进程共享同一资源（如CPU、共享输入/输出设备）而引起的，即共享资源的多个进程因系统协调使用资源而相互制约。</li>
<li>直接制约。只是由于进程合作中各个进程为完成同一任务而造成的，即并发进程各自的执行结果互为对方的执行条件，从而限制各个进程的执行速度。</li>
</ol>
<p>生产者和消费者是经典的进程同步问题，在这个问题中，生产者不断的向缓冲区中写入数据，而消费者则从缓冲区中读取数据。生产者进程和消费者对缓冲区的操作是互斥，即当前只能有一个进程对这个缓冲区进行操作，生产者进入操作缓冲区之前，先要看缓冲区是否已满，如果缓冲区已满，则它必须等待消费者进程将数据取出才能写入数据，同样的，消费者进程从缓冲区读取数据之前，也要判断缓冲区是否为空，如果为空，则必须等待生产者进程写入数据才能读取数据。</p>
<p>在这个问题当中，我们采用信号量机制进行进程之间的通信，设置两个信号量，空的信号量和满的信号量。在Linux系统中，一个或多个信号量构成一个信号量集合。使用信号量机制可以实现进程之间的同步和互斥，允许并发进程一次对一组信号量进行相同或不同的操作。每个P、V操作不限于减1或加1，而是可以加减任何整数。在进程终止时，系统可根据需要自动消除所有被进程操作过的信号量的影响</p>
<ol>
<li>
<p>缓冲区采用循环队列表示，利用头、尾指针来存放、读取数据，以及判断队列是否为空。缓冲区中数组大小为10；</p>
</li>
<li>
<p>利用随机函数rand()得到A～Z的一个随机字符，作为生产者每次生产的数据，存放到缓冲区中；</p>
</li>
<li>
<p>使用shmget()系统调用实现共享主存段的创建，shmget()返回共享内存区的ID。对于已经申请到的共享段，进程需把它附加到自己的虚拟空间中才能对其进行读写。</p>
</li>
<li>
<p>信号量的建立采用semget()函数，同时建立信号量的数量。在信号量建立后，调用semctl()对信号量进行初始化，例如本实验中，可以建立两个信号量SEM_EMPTY、SEM_FULL，初始化时设置SEM_EMPTY为10，SEM_FULL为0。使用操作信号的函数semop()做排除式操作，使用这个函数防止对共享内存的同时操作。对共享内存操作完毕后采用shmctl()函数撤销共享内存段。</p>
</li>
<li>
<p>使用循环，创建2个生产者以及2个消费者，采用函数fork()创建一个新的进程。</p>
</li>
<li>
<p>一个进程的一次操作完成后，采用函数fflush()刷新缓冲区。</p>
</li>
<li>
<p>程序最后使用semctl()函数释放内存。</p>
</li>
</ol>
<ul>
<li>主程序流程图：</li>
</ul>
<p><img src="/posts/3994810f/image-20211130105214487.png" srcset="/img/loading.gif" lazyload alt="image-20211130105214487"></p>
<ul>
<li>生产者进程流程图</li>
</ul>
<p><img src="/posts/3994810f/image-20211130105238309.png" srcset="/img/loading.gif" lazyload alt="image-20211130105238309"></p>
<ul>
<li>消费者进程流程图</li>
</ul>
<p><img src="/posts/3994810f/image-20211130105350695.png" srcset="/img/loading.gif" lazyload alt="image-20211130105350695"></p>
<ul>
<li>P操作流程图</li>
</ul>
<p><img src="/posts/3994810f/image-20211130105635105.png" srcset="/img/loading.gif" lazyload alt="image-20211130105635105"></p>
<ul>
<li>V操作流程图</li>
</ul>
<p><img src="/posts/3994810f/image-20211130105654202.png" srcset="/img/loading.gif" lazyload alt="image-20211130105654202"></p>
<h3 id="思考题-线程实现"><a class="markdownIt-Anchor" href="#思考题-线程实现"></a> 思考题 线程实现</h3>
<p>采用线程来实现</p>
<h2 id="四-实验设计与过程"><a class="markdownIt-Anchor" href="#四-实验设计与过程"></a> 四、实验设计与过程</h2>
<h3 id="进程实现-2"><a class="markdownIt-Anchor" href="#进程实现-2"></a> 进程实现</h3>
<h4 id="预备知识"><a class="markdownIt-Anchor" href="#预备知识"></a> 预备知识</h4>
<p>与信号量一样，在Linux中也提供了一组函数接口用于使用共享内存，而且使用共享共存的接口还与信号量的非常相似，而且比使用信号量的接口来得简单。它们声明在头文件 sys/shm.h 中。</p>
<h5 id="1-shmget函数"><a class="markdownIt-Anchor" href="#1-shmget函数"></a> 1、shmget()函数</h5>
<p>该函数用来创建共享内存，它的原型为：</p>
<div class="code-wrapper"><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">shmget</span><span class="token punctuation">(</span><span class="token class-name">key_t</span> key<span class="token punctuation">,</span> <span class="token class-name">size_t</span> size<span class="token punctuation">,</span> <span class="token keyword">int</span> shmflg<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div>
<ul>
<li>
<p>第一个参数，与信号量的semget函数一样，程序需要提供一个参数key（非0整数），它有效地为共享内存段命名，shmget()函数成功时返回一个与key相关的共享内存标识符（非负整数），用于后续的共享内存函数。调用失败返回-1.</p>
<p>不相关的进程可以通过该函数的返回值访问同一共享内存，它代表程序可能要使用的某个资源，程序对所有共享内存的访问都是间接的，程序先通过调用shmget()函数并提供一个键，再由系统生成一个相应的共享内存标识符（shmget()函数的返回值），只有shmget()函数才直接使用信号量键，所有其他的信号量函数使用由semget函数返回的信号量标识符。</p>
</li>
<li>
<p>第二个参数，size以字节为单位指定需要共享的内存容量</p>
</li>
<li>
<p>第三个参数，shmflg是权限标志，它的作用与open函数的mode参数一样，如果要想在key标识的共享内存不存在时，创建它的话，可以与IPC_CREAT做或操作。共享内存的权限标志与文件的读写权限一样，举例来说，0644,它表示允许一个进程创建的共享内存被内存创建者所拥有的进程向共享内存读取和写入数据，同时其他用户创建的进程只能读取共享内存。</p>
</li>
</ul>
<h5 id="2-shmat函数"><a class="markdownIt-Anchor" href="#2-shmat函数"></a> 2、shmat()函数</h5>
<p>– at：attach</p>
<p>第一次创建完共享内存时，它还不能被任何进程访问，shmat()函数的作用就是用来启动对该共享内存的访问，并把共享内存连接到当前进程的地址空间。它的原型如下：</p>
<div class="code-wrapper"><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token operator">*</span><span class="token function">shmat</span><span class="token punctuation">(</span><span class="token keyword">int</span> shm_id<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">void</span> <span class="token operator">*</span>shm_addr<span class="token punctuation">,</span> <span class="token keyword">int</span> shmflg<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div>
<ul>
<li>
<p>第一个参数，shm_id是由shmget()函数返回的共享内存标识。</p>
</li>
<li>
<p>第二个参数，shm_addr指定共享内存连接到当前进程中的地址位置，通常为空，表示让系统来选择共享内存的地址。</p>
</li>
<li>
<p>第三个参数，shm_flg是一组标志位，通常为0。</p>
</li>
</ul>
<p>调用成功时返回一个指向共享内存第一个字节的指针，如果调用失败返回-1.</p>
<h5 id="3-shmdt函数"><a class="markdownIt-Anchor" href="#3-shmdt函数"></a> 3、shmdt()函数</h5>
<p>– dt：detach</p>
<p>该函数用于将共享内存从当前进程中分离。注意，将共享内存分离并不是删除它，只是使该共享内存对当前进程不再可用。它的原型如下：</p>
<div class="code-wrapper"><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">shmdt</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">void</span> <span class="token operator">*</span>shmaddr<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div>
<p>参数shmaddr是shmat()函数返回的地址指针，调用成功时返回0，失败时返回-1.</p>
<h5 id="4-shmctl函数"><a class="markdownIt-Anchor" href="#4-shmctl函数"></a> 4、shmctl()函数</h5>
<p>– ctl：control</p>
<p>与信号量的semctl()函数一样，用来控制共享内存，它的原型如下：</p>
<div class="code-wrapper"><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">shmctl</span><span class="token punctuation">(</span><span class="token keyword">int</span> shm_id<span class="token punctuation">,</span> <span class="token keyword">int</span> command<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">shmid_ds</span> <span class="token operator">*</span>buf<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div>
<ul>
<li>
<p>第一个参数，shm_id是shmget()函数返回的共享内存标识符。</p>
</li>
<li>
<p>第二个参数，command是要采取的操作，它可以取下面的三个值 ：</p>
<ul>
<li>IPC_STAT：把shmid_ds结构中的数据设置为共享内存的当前关联值，即用共享内存的当前关联值覆盖shmid_ds的值。</li>
<li>IPC_SET：如果进程有足够的权限，就把共享内存的当前关联值设置为shmid_ds结构中给出的值</li>
<li>IPC_RMID：删除共享内存段</li>
</ul>
</li>
<li>
<p>第三个参数，buf是一个结构指针，它指向共享内存模式和访问权限的结构。</p>
<p>shmid_ds结构 至少包括以下成员：</p>
<div class="code-wrapper"><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">struct</span> <span class="token class-name">shmid_ds</span>
<span class="token punctuation">&#123;</span>
    <span class="token class-name">uid_t</span> shm_perm<span class="token punctuation">.</span>uid<span class="token punctuation">;</span>
    <span class="token class-name">uid_t</span> shm_perm<span class="token punctuation">.</span>gid<span class="token punctuation">;</span>
    <span class="token class-name">mode_t</span> shm_perm<span class="token punctuation">.</span>mode<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div>
</li>
</ul>
<h4 id="数据结构和符号说明"><a class="markdownIt-Anchor" href="#数据结构和符号说明"></a> <strong>数据结构</strong>和符号说明</h4>
<div class="code-wrapper"><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;信号集合内的每个信号量的索引,
#define SEM_FULL 0
#define SEM_EMPTY 1
#define MUTEX 2
&#x2F;&#x2F;缓冲区结构
struct my_buffer
&#123;
	int out;
	int in;
	char str[MAX_BUFFER_SIZE];
	int num; &#x2F;&#x2F;缓冲区里字母数量
	int is_empty;
&#125;;

const int N_CONSUMER &#x3D; 2;  &#x2F;&#x2F;消费者数量
const int N_PRODUCER &#x3D; 2;  &#x2F;&#x2F;生产者数量
const int N_BUFFER &#x3D; 10;   &#x2F;&#x2F;缓冲区容量
const int N_WORKTIME &#x3D; 10; &#x2F;&#x2F;工作次数

int shm_id &#x3D; -1;&#x2F;&#x2F;信号量id

int sem_id &#x3D; -1;&#x2F;&#x2F;共享内存id
&#x2F;&#x2F;子进程的id
pid_t consumer_id;
pid_t producer_id;
&#x2F;&#x2F;得到10以内的一个随机数
int get_random()
    
&#x2F;&#x2F;sem_id 表示信号量集合的 id
&#x2F;&#x2F;sem_num 表示要处理的信号量在信号量集合中的索引
&#x2F;&#x2F;P操作
void waitSem(int sem_id, int sem_num)
&#x2F;&#x2F;V操作
void signalSem(int sem_id, int sem_num)
&#x2F;&#x2F;打印进程运行时间
void printTime()
&#x2F;&#x2F;消费者进程的消费和信息打印
void consume_print(int i, struct my_buffer *shmptr)
&#x2F;&#x2F;消费者进程的消费和信息打印
void consume_print(int i, struct my_buffer *shmptr)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div>
<h4 id="源代码"><a class="markdownIt-Anchor" href="#源代码"></a> 源代码</h4>
<p>在main函数中，首先初始化信号量（mutex表示缓冲区的互斥访问，设为1；SEM_FULL表示缓冲区满的数量，设为0；SEM_EMPTY表示缓冲区空的数量，设为10），分配共享内存，初始化缓冲区，创建生产者与消费者，释放内存再退出。</p>
<div class="code-wrapper"><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;unistd.h&gt;
#include &lt;time.h&gt;
#include &lt;sys&#x2F;ipc.h&gt;
#include &lt;sys&#x2F;shm.h&gt;
#include &lt;sys&#x2F;sem.h&gt;
#include &lt;sys&#x2F;types.h&gt;
#include &lt;sys&#x2F;wait.h&gt;

#define MAX_BUFFER_SIZE 10
#define SHM_MODE 0600
#define SEM_MODE 0600
&#x2F;&#x2F;信号集合内的每个信号量的索引,
#define SEM_FULL 0
#define SEM_EMPTY 1
#define MUTEX 2
&#x2F;&#x2F;缓冲区结构
struct my_buffer
&#123;
	int out;
	int in;
	char str[MAX_BUFFER_SIZE];
	int num; &#x2F;&#x2F;缓冲区里字母数量
	int is_empty;
&#125;;

const int N_CONSUMER &#x3D; 2;  &#x2F;&#x2F;消费者数量
const int N_PRODUCER &#x3D; 2;  &#x2F;&#x2F;生产者数量
const int N_BUFFER &#x3D; 10;   &#x2F;&#x2F;缓冲区容量
const int N_WORKTIME &#x3D; 10; &#x2F;&#x2F;工作次数
&#x2F;&#x2F;信号量id
int shm_id &#x3D; -1;
&#x2F;&#x2F;共享内存id
int sem_id &#x3D; -1;
&#x2F;&#x2F;子进程的id
pid_t consumer_id;
pid_t producer_id;
&#x2F;&#x2F;得到10以内的一个随机数
int get_random()
&#123;
	int digit;
	digit &#x3D; rand() % 3;
	return digit;
&#125;

&#x2F;&#x2F;得到A～Z的一个随机字母
char getRandChar()
&#123;
	char letter;
	letter &#x3D; (char)((rand() % 26) + &#39;A&#39;);
	return letter;
&#125;

&#x2F;&#x2F;sem_id 表示信号量集合的 id
&#x2F;&#x2F;sem_num 表示要处理的信号量在信号量集合中的索引
&#x2F;&#x2F;P操作
void waitSem(int sem_id, int sem_num)
&#123;
	struct sembuf sb;
	sb.sem_num &#x3D; sem_num;
	sb.sem_op &#x3D; -1; &#x2F;&#x2F;表示要把信号量减一
	sb.sem_flg &#x3D; 0; &#x2F;&#x2F;
	&#x2F;&#x2F;第二个参数是 sembuf [] 类型的，表示数组
	&#x2F;&#x2F;第三个参数表示 第二个参数代表的数组的大小
	if (semop(sem_id, &amp;sb, 1) &lt; 0)
	&#123;
		perror(&quot;waitSem failed&quot;);
		exit(1);
	&#125;
&#125;

&#x2F;&#x2F;V操作
void signalSem(int sem_id, int sem_num)
&#123;
	struct sembuf sb;
	sb.sem_num &#x3D; sem_num;
	sb.sem_op &#x3D; 1;
	sb.sem_flg &#x3D; 0;
	&#x2F;&#x2F;第二个参数是 sembuf [] 类型的，表示数组
	&#x2F;&#x2F;第三个参数表示 第二个参数代表的数组的大小
	if (semop(sem_id, &amp;sb, 1) &lt; 0)
	&#123;
		perror(&quot;signalSem failed&quot;);
		exit(1);
	&#125;
&#125;

&#x2F;&#x2F;打印进程运行时间
void printTime()
&#123;
	&#x2F;&#x2F;打印时间
	time_t now;
	struct tm *timenow; &#x2F;&#x2F;实例化tm结构指针
	time(&amp;now);
	timenow &#x3D; localtime(&amp;now);
	printf(&quot;|   %02d:%02d:%02d   |  &quot;, timenow-&gt;tm_hour, timenow-&gt;tm_min, timenow-&gt;tm_sec);
&#125;
&#x2F;&#x2F;生产者进程的生产和信息打印
void produce_print(int i, struct my_buffer *shmptr)
&#123;
	&#x2F;&#x2F;sleep(get_random()); &#x2F;&#x2F;随机睡眠一段时间，相当于人为扩大进程执行操作时间
	printTime(); &#x2F;&#x2F;程序运行时间
	&#x2F;&#x2F;生产产品
	char c &#x3D; getRandChar(); &#x2F;&#x2F;随机获取字母
	shmptr-&gt;str[shmptr-&gt;in] &#x3D; c;
	shmptr-&gt;in &#x3D; (shmptr-&gt;in + 1) % MAX_BUFFER_SIZE;
	shmptr-&gt;is_empty &#x3D; 0; &#x2F;&#x2F;写入新产品
	shmptr-&gt;num++;
	&#x2F;&#x2F;打印缓冲区
	int p &#x3D; (shmptr-&gt;in - 1 &gt;&#x3D; shmptr-&gt;out) ? (shmptr-&gt;in - 1) : (shmptr-&gt;in - 1 + MAX_BUFFER_SIZE);
	for (p; !(shmptr-&gt;is_empty) &amp;&amp; p &gt;&#x3D; shmptr-&gt;out; p--)
	&#123;
		printf(&quot;%c&quot;, shmptr-&gt;str[p % MAX_BUFFER_SIZE]);
	&#125;
	for (int j &#x3D; 0; j &lt; 10 - shmptr-&gt;num; j++)
	&#123;
		printf(&quot;%c&quot;, &#39;-&#39;);
	&#125;
	printf(&quot;   |   &quot;);					  &#x2F;&#x2F;控制输出格式
	printf(&quot;producer_%d   |    &quot;, i + 1); &#x2F;&#x2F;进程id信息

	printf(&quot;+ %c    |\n&quot;, c); &#x2F;&#x2F;进程操作
	fflush(stdout);
&#125;
&#x2F;&#x2F;消费者进程的消费和信息打印
void consume_print(int i, struct my_buffer *shmptr)
&#123;
	&#x2F;&#x2F;sleep(get_random());
	printTime(); &#x2F;&#x2F;程序运行时间
	&#x2F;*生产产品*&#x2F;
	char lt &#x3D; shmptr-&gt;str[shmptr-&gt;out];
	shmptr-&gt;out &#x3D; (shmptr-&gt;out + 1) % MAX_BUFFER_SIZE;
	shmptr-&gt;is_empty &#x3D; (shmptr-&gt;out &#x3D;&#x3D; shmptr-&gt;in); &#x2F;&#x2F;
	shmptr-&gt;num--;
	&#x2F;&#x2F;打印缓冲区
	int p &#x3D; (shmptr-&gt;in - 1 &gt;&#x3D; shmptr-&gt;out) ? (shmptr-&gt;in - 1) : (shmptr-&gt;in - 1 + MAX_BUFFER_SIZE);
	for (p; !(shmptr-&gt;is_empty) &amp;&amp; p &gt;&#x3D; shmptr-&gt;out; p--)
	&#123;
		printf(&quot;%c&quot;, shmptr-&gt;str[p % MAX_BUFFER_SIZE]);
	&#125;
	for (int j &#x3D; 0; j &lt; 10 - shmptr-&gt;num; j++)
	&#123;
		printf(&quot;%c&quot;, &#39;-&#39;);
	&#125;
	printf(&quot;   |   &quot;);					  &#x2F;&#x2F;控制输出格式
	printf(&quot;consumer_%d   |    &quot;, i + 1); &#x2F;&#x2F;进程id信息

	printf(&quot;- %c    |\n&quot;, lt); &#x2F;&#x2F;进程操作
	fflush(stdout);
&#125;
int main(int argc, char **argv)
&#123;
	srand((unsigned)(getpid() + time(NULL)));
	shm_id &#x3D; shmget(IPC_PRIVATE, MAX_BUFFER_SIZE, SHM_MODE); &#x2F;&#x2F;申请共享内存
	if (shm_id &lt; 0)
	&#123;
		perror(&quot;create shared memory failed&quot;);
		exit(1);
	&#125;

	struct my_buffer *shmptr;
	shmptr &#x3D; shmat(shm_id, 0, 0); &#x2F;&#x2F;将申请的共享内存附加到申请通信的进程空间
	if (shmptr &#x3D;&#x3D; (void *)-1)
	&#123;
		perror(&quot;add buffer to using process space failed！\n&quot;);
		exit(1);
	&#125;

	if ((sem_id &#x3D; semget(IPC_PRIVATE, 3, SEM_MODE)) &lt; 0)
	&#123; &#x2F;&#x2F;创建三个信号量，SEM_EMPTY,SEM_FULL和MUTEX
		perror(&quot;create semaphore failed! \n&quot;);
		exit(1);
	&#125;

	if (semctl(sem_id, SEM_FULL, SETVAL, 0) &#x3D;&#x3D; -1)
	&#123; &#x2F;&#x2F;将索引为0的信号量设置为0--&gt;SEM_FULL
		perror(&quot;sem set value error! \n&quot;);
		exit(1);
	&#125;

	if (semctl(sem_id, SEM_EMPTY, SETVAL, 10) &#x3D;&#x3D; -1)
	&#123; &#x2F;&#x2F;将索引为1的信号量设置为10--&gt;SEM_EMPTY
		perror(&quot;sem set value error! \n&quot;);
		exit(1);
	&#125;
	if (semctl(sem_id, MUTEX, SETVAL, 1) &#x3D;&#x3D; -1)
	&#123; &#x2F;&#x2F;将索引为3的信号量设置为1--&gt;MUTEX
		perror(&quot;sem set value error! \n&quot;);
		exit(1);
	&#125;
	&#x2F;&#x2F;初始化缓冲区
	shmptr-&gt;out &#x3D; 0;
	shmptr-&gt;in &#x3D; 0;
	shmptr-&gt;is_empty &#x3D; 1;
	shmptr-&gt;num &#x3D; 0;

	printf(&quot;---------------------Process Execution Table-----------------\n&quot;);
	printf(&quot;-------------------------------------------------------------\n&quot;);
	printf(&quot;|     time     |  buffer data  |current  process| operation |\n&quot;);
	printf(&quot;-------------------------------------------------------------\n&quot;);
	for (int i &#x3D; 0; i &lt; N_PRODUCER; i++)
	&#123;
		sleep(get_random());
		producer_id &#x3D; fork();

		if (producer_id &lt; 0)
		&#123;
			perror(&quot;the fork failed&quot;);
			exit(1);
		&#125;
		else if (producer_id &#x3D;&#x3D; 0) &#x2F;&#x2F;是子进程则执行生产操作
		&#123;

			for (int j &#x3D; 0; j &lt; N_WORKTIME; j++)
			&#123;
				sleep(get_random());

				waitSem(sem_id, SEM_EMPTY);
				waitSem(sem_id, MUTEX);

				produce_print(i, shmptr);

				signalSem(sem_id, MUTEX);
				signalSem(sem_id, SEM_FULL);
			&#125;
			exit(0);
		&#125;
	&#125;

	for (int i &#x3D; 0; i &lt; N_CONSUMER; i++)&#x2F;&#x2F;
	&#123;
		sleep(get_random());
		consumer_id &#x3D; fork();

		if (consumer_id &lt; 0) &#x2F;&#x2F;调用fork失败
		&#123;
			perror(&quot;the fork failed&quot;);
			exit(1);
		&#125;
		else if (consumer_id &#x3D;&#x3D; 0) &#x2F;&#x2F;是子进程则执行消费操作
		&#123;
			for (int j &#x3D; 0; j &lt; N_WORKTIME; j++)
			&#123;
				sleep(get_random());

				waitSem(sem_id, SEM_FULL);
				waitSem(sem_id, MUTEX);

				consume_print(i, shmptr);

				signalSem(sem_id, MUTEX);
				signalSem(sem_id, SEM_EMPTY);
			&#125;
			exit(0);
		&#125;
	&#125;

	&#x2F;&#x2F;主进程最后退出
	while (wait(0) !&#x3D; -1)
		;
	&#x2F;&#x2F;将共享段与进程之间解除连接
	shmdt(shmptr);
	&#x2F;&#x2F;对共享内存区执行控制操作
	shmctl(shm_id, IPC_RMID, 0); &#x2F;&#x2F;当cmd为IPC_RMID时，删除该共享段
	printf(&quot;-------------------------------------------------------------\n&quot;);
	printf(&quot;主进程运行结束！\n&quot;);

	fflush(stdout);
	exit(0);
	return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div>
<h4 id="程序初值和运行结果"><a class="markdownIt-Anchor" href="#程序初值和运行结果"></a> 程序初值和运行结果</h4>
<p>进程</p>
<p><img src="/posts/3994810f/image-20211130090602101.png" srcset="/img/loading.gif" lazyload alt="image-20211130090602101"></p>
<p><img src="/posts/3994810f/image-20211130090745719.png" srcset="/img/loading.gif" lazyload alt="image-20211130090745719"></p>
<h3 id="线程实现"><a class="markdownIt-Anchor" href="#线程实现"></a> 线程实现</h3>
<h4 id="预备知识-2"><a class="markdownIt-Anchor" href="#预备知识-2"></a> 预备知识</h4>
<h5 id="pthread_create"><a class="markdownIt-Anchor" href="#pthread_create"></a> pthread_create</h5>
<p>pthread_create是UNIX环境创建线程函数</p>
<p><strong>头文件：</strong></p>
<div class="code-wrapper"><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;pthread.h></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div>
<p><strong>函数声明：</strong></p>
<div class="code-wrapper"><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">pthread_create</span><span class="token punctuation">(</span><span class="token class-name">pthread_t</span> <span class="token operator">*</span>restrict tidp<span class="token punctuation">,</span><span class="token keyword">const</span> <span class="token class-name">pthread_attr_t</span> <span class="token operator">*</span>restrict_attr<span class="token punctuation">,</span><span class="token keyword">void</span><span class="token operator">*</span>（<span class="token operator">*</span>start_rtn<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token keyword">void</span> <span class="token operator">*</span>restrict arg<span class="token punctuation">)</span><span class="token punctuation">;</span>
参数：<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></div>
<ul>
<li>第一个参数为指向线程标识符的指针，可用如下方式定义 pthread_t thread1;</li>
<li>第二个参数用来设置线程属性。</li>
<li>第三个参数是线程运行函数的地址，即函数名，函数内包括循环。</li>
<li>最后一个参数是运行函数的参数。</li>
</ul>
<p><strong>返回值：</strong></p>
<p>若成功则返回0，否则返回出错编号</p>
<p><strong>注意：</strong></p>
<p>在编译时注意加上-l pthread参数，以调用静态链接库。因为pthread并非Linux系统的默认库。</p>
<h5 id="pthread_join"><a class="markdownIt-Anchor" href="#pthread_join"></a> <strong>pthread_join</strong></h5>
<p><strong>函数简介：</strong></p>
<p>函数pthread_join用来等待一个线程的结束。pthread_join()函数，以阻塞的方式等待thread指定的线程结束。当函数返回时，被等待线程的资源被收回。如果线程已经结束，那么该函数会立即返回。并且thread指定的线程必须是joinable的。<br>
　　<br>
<strong>头文件：</strong></p>
<div class="code-wrapper"><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;pthread.h></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div>
<p><strong>函数声明：</strong></p>
<div class="code-wrapper"><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">pthread_join</span><span class="token punctuation">(</span><span class="token class-name">pthread_t</span> thread<span class="token punctuation">,</span> <span class="token keyword">void</span> <span class="token operator">*</span><span class="token operator">*</span>retval<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div>
<p><strong>参数：</strong></p>
<ul>
<li>
<p>thread: 线程标识符，即线程ID，标识唯一线程，为被等待的线程标识符。</p>
</li>
<li>
<p>retval: 用户定义的指针，用来存储被等待线程的返回值。</p>
</li>
</ul>
<p><strong>返回值：</strong></p>
<p>如果执行成功，将返回0，如果失败则返回一个错误号。</p>
<h4 id="数据结构和符号说明-2"><a class="markdownIt-Anchor" href="#数据结构和符号说明-2"></a> <strong>数据结构</strong>和符号说明</h4>
<div class="code-wrapper"><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">const int N_WORKTIME &#x3D; 10; &#x2F;&#x2F;工作次数
&#x2F;&#x2F;三个信号量
pthread_mutex_t mutex &#x3D; PTHREAD_MUTEX_INITIALIZER; &#x2F;&#x2F;线程间互斥
sem_t full;                                        &#x2F;&#x2F;填充的个数
sem_t empty;                                       &#x2F;&#x2F;空槽的个数

struct my_buffer
&#123;
    int out;
    int in;
    char str[MAX_BUFFER_SIZE];
    int num; &#x2F;&#x2F;缓冲区里字母数量
    int is_empty;
&#125; buffer; &#x2F;&#x2F;缓冲区结构体
&#x2F;&#x2F;struct my_buffer *buffer

int get_random()&#x2F;&#x2F;得到3以内的一个随机数

char getRandChar()&#x2F;&#x2F;得到A～Z的一个随机字母
    
void printTime() &#x2F;&#x2F;打印时间

void produce_print(int *x)&#x2F;&#x2F;生产者进程的生产和信息打印

void consume_print(int *x)&#x2F;&#x2F;消费者进程的生消费和信息打印
    
void *produce(void *arg)&#x2F;&#x2F;生产者线程
&#123;
    int i;
    int *x &#x3D; (int *)arg;
    for (i &#x3D; 0; i &lt; N_WORKTIME; i++)
    &#123;
        sleep(get_random());

        sem_wait(&amp;empty); &#x2F;&#x2F;若空槽个数低于0阻塞
        pthread_mutex_lock(&amp;mutex);

        produce_print(x);

        pthread_mutex_unlock(&amp;mutex);
        sem_post(&amp;full);
    &#125;
    return (void *)1;
&#125;

void *consume(void *arg)&#x2F;&#x2F;消费者线程
&#123;
    int i;
    int *x &#x3D; (int *)arg;
    for (i &#x3D; 0; i &lt; N_WORKTIME; i++)
    &#123;
        sleep(get_random());

        sem_wait(&amp;full); &#x2F;&#x2F;若填充个数低于0阻塞
        pthread_mutex_lock(&amp;mutex);

        consume_print(x);

        pthread_mutex_unlock(&amp;mutex);
        sem_post(&amp;empty);
    &#125;

    return (void *)2;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div>
<h4 id="源代码-2"><a class="markdownIt-Anchor" href="#源代码-2"></a> 源代码</h4>
<div class="code-wrapper"><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;stdio.h&gt;
#include &lt;pthread.h&gt;
#include &lt;time.h&gt;
#include &lt;unistd.h&gt;
#include &lt;semaphore.h&gt;
#include &lt;stdlib.h&gt;

#define MAX_BUFFER_SIZE 10
const int N_WORKTIME &#x3D; 10; &#x2F;&#x2F;工作次数
&#x2F;&#x2F;三个信号量
pthread_mutex_t mutex &#x3D; PTHREAD_MUTEX_INITIALIZER; &#x2F;&#x2F;线程间互斥
sem_t full;                                        &#x2F;&#x2F;填充的个数
sem_t empty;                                       &#x2F;&#x2F;空槽的个数

struct my_buffer
&#123;
    int out;
    int in;
    char str[MAX_BUFFER_SIZE];
    int num; &#x2F;&#x2F;缓冲区里字母数量
    int is_empty;
&#125; buffer; &#x2F;&#x2F;缓冲区结构体
&#x2F;&#x2F;struct my_buffer *buffer;
&#x2F;&#x2F;得到3以内的一个随机数
int get_random()
&#123;
    int digit;
    digit &#x3D; rand() % 3;
    return digit;
&#125;

&#x2F;&#x2F;得到A～Z的一个随机字母
char getRandChar()
&#123;
    char letter;
    letter &#x3D; (char)((rand() % 26) + &#39;A&#39;);
    return letter;
&#125;

void printTime() &#x2F;&#x2F;打印时间
&#123;
    time_t now;
    struct tm *timenow; &#x2F;&#x2F;实例化tm结构指针
    time(&amp;now);
    timenow &#x3D; localtime(&amp;now);
    printf(&quot;|   %02d:%02d:%02d   |  &quot;, timenow-&gt;tm_hour, timenow-&gt;tm_min, timenow-&gt;tm_sec);
&#125;
void produce_print(int *x)&#x2F;&#x2F;生产者进程的生产和信息打印
&#123;
    &#x2F;&#x2F;sleep(get_random());
    printTime(); &#x2F;&#x2F;程序运行时间
    &#x2F;*生产产品*&#x2F;
    char c &#x3D; getRandChar(); &#x2F;&#x2F;随机获取字母
    buffer.str[buffer.in] &#x3D; c;
    buffer.in &#x3D; (buffer.in + 1) % MAX_BUFFER_SIZE;
    buffer.is_empty &#x3D; 0; &#x2F;&#x2F;写入新产品
    buffer.num++;
    &#x2F;&#x2F;打印缓冲区
    int p &#x3D; (buffer.in - 1 &gt;&#x3D; buffer.out) ? (buffer.in - 1) : (buffer.in - 1 + MAX_BUFFER_SIZE);
    for (p; !(buffer.is_empty) &amp;&amp; p &gt;&#x3D; buffer.out; p--)
    &#123;
        printf(&quot;%c&quot;, buffer.str[p % MAX_BUFFER_SIZE]);
    &#125;
    for (int j &#x3D; 0; j &lt; 10 - buffer.num; j++)
    &#123;
        printf(&quot;%c&quot;, &#39;-&#39;);
    &#125;
    printf(&quot;   |   &quot;);                 &#x2F;&#x2F;控制输出格式
    printf(&quot;producer_%d   |    &quot;, *x); &#x2F;&#x2F;进程id信息

    printf(&quot;+ %c    |\n&quot;, c); &#x2F;&#x2F;进程操作
&#125;
void consume_print(int *x)&#x2F;&#x2F;消费者进程的生消费和信息打印
&#123;
    &#x2F;&#x2F;sleep(get_random());
    printTime(); &#x2F;&#x2F;程序运行时间
    &#x2F;*生产产品*&#x2F;
    char c &#x3D; buffer.str[buffer.out];
    buffer.out &#x3D; (buffer.out + 1) % MAX_BUFFER_SIZE;
    buffer.is_empty &#x3D; (buffer.out &#x3D;&#x3D; buffer.in); &#x2F;&#x2F;
    buffer.num--;
    &#x2F;&#x2F;打印缓冲区
    int p &#x3D; (buffer.in - 1 &gt;&#x3D; buffer.out) ? (buffer.in - 1) : (buffer.in - 1 + MAX_BUFFER_SIZE);
    for (p; !(buffer.is_empty) &amp;&amp; p &gt;&#x3D; buffer.out; p--)
    &#123;
        printf(&quot;%c&quot;, buffer.str[p % MAX_BUFFER_SIZE]);
    &#125;
    for (int j &#x3D; 0; j &lt; 10 - buffer.num; j++)
    &#123;
        printf(&quot;%c&quot;, &#39;-&#39;);
    &#125;
    printf(&quot;   |   &quot;);                 &#x2F;&#x2F;控制输出格式
    printf(&quot;consumer_%d   |    &quot;, *x); &#x2F;&#x2F;进程id信息

    printf(&quot;- %c    |\n&quot;, c); &#x2F;&#x2F;进程操作
&#125;
void *produce(void *arg)
&#123;
    int i;
    int *x &#x3D; (int *)arg;
    for (i &#x3D; 0; i &lt; N_WORKTIME; i++)
    &#123;
        sleep(get_random());

        sem_wait(&amp;empty); &#x2F;&#x2F;若空槽个数低于0阻塞
        pthread_mutex_lock(&amp;mutex);

        produce_print(x);

        pthread_mutex_unlock(&amp;mutex);
        sem_post(&amp;full);
    &#125;
    return (void *)1;
&#125;

void *consume(void *arg)
&#123;
    int i;
    int *x &#x3D; (int *)arg;
    for (i &#x3D; 0; i &lt; N_WORKTIME; i++)
    &#123;
        sleep(get_random());

        sem_wait(&amp;full); &#x2F;&#x2F;若填充个数低于0阻塞
        pthread_mutex_lock(&amp;mutex);

        consume_print(x);

        pthread_mutex_unlock(&amp;mutex);
        sem_post(&amp;empty);
    &#125;

    return (void *)2;
&#125;

int main(int argc, char *argv[])
&#123;
    srand(time(NULL)); &#x2F;&#x2F;随机化时间种子

    pthread_t thid1;
    pthread_t thid2;
    pthread_t thid3;
    pthread_t thid4;

    int ret1;
    int ret2;
    int ret3;
    int ret4;
    &#x2F;&#x2F;初始化信号量
    sem_init(&amp;full, 0, 0);
    sem_init(&amp;empty, 0, 10);
    &#x2F;&#x2F;线程id
    int t1 &#x3D; 1;
    int t2 &#x3D; 2;
    &#x2F;&#x2F;初始化缓冲区
    buffer.out &#x3D; 0;
    buffer.in &#x3D; 0;
    buffer.is_empty &#x3D; 1;
    buffer.num &#x3D; 0;

    printf(&quot;---------------------Thread Execution Table------------------\n&quot;);
    printf(&quot;-------------------------------------------------------------\n&quot;);
    printf(&quot;|     time     |  buffer data  | current thread | operation |\n&quot;);
    printf(&quot;-------------------------------------------------------------\n&quot;);
    &#x2F;&#x2F;创建线程
    pthread_create(&amp;thid1, NULL, produce, (void *)&amp;t1);
    pthread_create(&amp;thid2, NULL, consume, (void *)&amp;t1);
    pthread_create(&amp;thid3, NULL, produce, (void *)&amp;t2);
    pthread_create(&amp;thid4, NULL, consume, (void *)&amp;t2);
    &#x2F;&#x2F;阻塞直到该线程结束
    pthread_join(thid1, (void **)&amp;ret1);
    pthread_join(thid2, (void **)&amp;ret2);
    pthread_join(thid3, (void **)&amp;ret3);
    pthread_join(thid4, (void **)&amp;ret4);
    printf(&quot;-------------------------------------------------------------\n&quot;);
    printf(&quot;线程全部执行完毕,主进程运行结束！\n&quot;);
    return 0;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div>
<h4 id="程序初值和运行结果-2"><a class="markdownIt-Anchor" href="#程序初值和运行结果-2"></a> 程序初值和运行结果</h4>
<p>线程</p>
<p><img src="/posts/3994810f/image-20211130090518453.png" srcset="/img/loading.gif" lazyload alt="image-20211130090518453"></p>
<p><img src="/posts/3994810f/image-20211130090454157.png" srcset="/img/loading.gif" lazyload alt="image-20211130090454157"></p>
<h3 id="五-实验总结"><a class="markdownIt-Anchor" href="#五-实验总结"></a> 五、实验总结</h3>
<p>本次实验中我学习到了如何利用共享内存通信来实现进程间的同步和互斥，开始时对shmget、shmat、shmdt、shmctl这些函数不是很了解，之后通过查阅资料了解了他们的用法，在编写代码的过程也遇到许多困难，在最后调试的时候还遇到了进程死锁的问题，后来看了半天才发现pv操作中给信号量设计的参数错误，导致每次进程结束都会被重置，这导致了死锁。但好在最后都发现了错误，顺利解决。</p>
<p>思考题让我们用线程实现，这比进程要容易很多，只需要申请一个全局变量就可以作为共享内存了，对于线程需要学习pthread_create 和pthread_join用法，最后大部分函数设计沿用进程的设计，成功实现！</p>

            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                  <div class="post-meta mr-3">
                    <i class="iconfont icon-category"></i>
                    
                      <a class="hover-with-bg" href="/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">操作系统</a>
                    
                  </div>
                
                
                  <div class="post-meta">
                    <i class="iconfont icon-tags"></i>
                    
                      <a class="hover-with-bg" href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">操作系统</a>
                    
                  </div>
                
              </div>
              
                <p class="note note-warning">
                  
                    本博客所有文章除特别声明外，著作权归作者所有，转载请注明出处！
                  
                </p>
              
              
                <div class="post-prevnext">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/posts/ab6ecd69/">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">操作系统实验五-操作系统第五次实验银行家算法</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/posts/60fc7e01/">
                        <span class="hidden-mobile">syzkaller配置小结</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
              <!-- Comments -->
              <article class="comments" id="comments" lazyload>
                
                  
                
                
  <div class="disqus" style="width:100%">
    <div id="disqus_thread"></div>
    
      <script type="text/javascript">
        var disqus_config = function() {
          this.page.url = 'https://zino00.github.io/posts/3994810f/';
          this.page.identifier = '/posts/3994810f/';
        };
        Fluid.utils.loadComments('#disqus_thread', function() {
          var d = document, s = d.createElement('script');
          s.src = '//' + 'fluid' + '.disqus.com/embed.js';
          s.setAttribute('data-timestamp', new Date());
          (d.head || d.body).appendChild(s);
        });
      </script>
    
    <noscript>Please enable JavaScript to view the comments</noscript>
  </div>


              </article>
            
          </article>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    

    
      <a id="scroll-top-button" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
    

    
  </main>

  <footer class="text-center mt-5 py-3">
  <div class="footer-content">
     <a  rel="nofollow noopener"><span>Copyrights © 2021</span></a> <i class="iconfont icon-love"></i> <a  target="_blank" rel="nofollow noopener"><span>Zino</span></a> 
  </div>
  
  <div class="statistics">
    
    

    
      
        <!-- 不蒜子统计PV -->
        <span id="busuanzi_container_site_pv" style="display: none">
            总访问量 
            <span id="busuanzi_value_site_pv"></span>
             次
          </span>
      
      
        <!-- 不蒜子统计UV -->
        <span id="busuanzi_container_site_uv" style="display: none">
            总访客数 
            <span id="busuanzi_value_site_uv"></span>
             人
          </span>
      
    
  </div>


  

  
  <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?d1745c2e21adaa6ae90b93f4f4d22da9";
      var s = document.getElementsByTagName("script")[0]; 
      s.parentNode.insertBefore(hm, s);
    })();
    </script>
    
</footer>


  <!-- SCRIPTS -->
  
  <script  src="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" ></script>
<script  src="https://cdn.jsdelivr.net/npm/bootstrap@4.6.0/dist/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>

<!-- Plugins -->


  
    <script  src="/js/img-lazyload.js" ></script>
  



  
    
  



  <script  src="https://cdn.jsdelivr.net/npm/tocbot@4.12.3/dist/tocbot.min.js" ></script>



  <script  src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js" ></script>



  <script  src="https://cdn.jsdelivr.net/npm/anchor-js@4.3.1/anchor.min.js" ></script>



  <script defer src="https://cdn.jsdelivr.net/npm/clipboard@2.0.8/dist/clipboard.min.js" ></script>



  <script  src="/js/local-search.js" ></script>



  <script defer src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" ></script>




  <script  src="https://cdn.jsdelivr.net/npm/typed.js@2.0.12/lib/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var title = document.getElementById('subtitle').title;
      
      typing(title)
      
    })(window, document);
  </script>





  

  
    <!-- KaTeX -->
    <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.13.10/dist/katex.min.css" />
  








  
    <!-- Baidu Analytics -->
    <script defer>
      var _hmt = _hmt || [];
      (function () {
        var hm = document.createElement("script");
        hm.src = "https://hm.baidu.com/hm.js?f45dcd001d67e8f9d84f91248ea31abf";
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(hm, s);
      })();
    </script>
  

  

  

  

  

  





<!-- 主题的启动项 保持在最底部 -->
<script  src="/js/boot.js" ></script>


</body>
</html>
