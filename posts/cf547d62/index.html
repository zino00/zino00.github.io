

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=&#34;auto&#34;>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/favicon.jpg">
  <link rel="icon" href="/img/favicon.jpg">
  <meta name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="description" content="介绍利用OpenSSL进行SSL通信的python实现，详细说明了通信原理、证书生成过程、通信的具体实现">
  <meta name="author" content="John Doe">
  <meta name="keywords" content="">
  
  <title>利用OpenSSL进行SSL通信的python实现 - Zino&#39;s Blog</title>

  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.6.0/dist/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/github-markdown-css@4.0.0/github-markdown.min.css" />
  <link  rel="stylesheet" href="/lib/hint/hint.min.css" />

  
    
    
      
      
        
          
          
          
        
        <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/prismjs@1.23.0/themes/prism-okaidia.min.css" />
      
      
        <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/prismjs@1.23.0/plugins/line-numbers/prism-line-numbers.min.css" />
      
    
  

  
    <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css" />
  



<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_kmeydafke9r.css">


<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->


  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    var CONFIG = {"hostname":"zino00.github.io","root":"/","version":"1.8.11","typing":{"enable":true,"typeSpeed":70,"cursorChar":"","loop":false},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"copy_btn":true,"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":1},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":true,"baidu":"f45dcd001d67e8f9d84f91248ea31abf","google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null}},"search_path":"/local-search.xml"};
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
<meta name="generator" content="Hexo 5.4.0"></head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand"
       href="/">&nbsp;<strong>Zino's Blog</strong>&nbsp;</a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" data-toggle="modal" data-target="#modalSearch">&nbsp;<i
                class="iconfont icon-search"></i>&nbsp;</a>
          </li>
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="banner" id="banner" parallax=true
         style="background: url('/img/post.jpg') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="page-header text-center fade-in-up">
            <span class="h2" id="subtitle" title="利用OpenSSL进行SSL通信的python实现">
              
            </span>

            
              <div class="mt-3">
  
  
    <span class="post-meta">
      <i class="iconfont icon-date-fill" aria-hidden="true"></i>
      <time datetime="2021-12-30 11:07" pubdate>
        2021年12月30日 上午
      </time>
    </span>
  
</div>

<div class="mt-1">
  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      5.9k 字
    </span>
  

  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      75
       分钟
    </span>
  

  
  
    
      <!-- 不蒜子统计文章PV -->
      <span id="busuanzi_container_page_pv" style="display: none">
        <i class="iconfont icon-eye" aria-hidden="true"></i>
        <span id="busuanzi_value_page_pv"></span> 次
      </span>
    
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">利用OpenSSL进行SSL通信的python实现</h1>
            
            <div class="markdown-body">
              <h1 id="openssl安装"><a class="markdownIt-Anchor" href="#openssl安装"></a> OpenSSL安装</h1>
<p>利用第三方提供的<a target="_blank" rel="noopener" href="http://slproweb.com/products/Win32OpenSSL.html">开源工具</a>直接无脑安装</p>
<p>直接按照普通的windows程序next，next的安装就行了。</p>
<p>最后我们在环境变量中，将bin文件夹配置起来，就可以在命令行中调用OpenSSL了。如果暂时没成功的话就重启一下电脑让配置生效。</p>
<p><img src="/posts/cf547d62/image-20211229172206022.png" srcset="/img/loading.gif" lazyload alt="image-20211229172206022"></p>
<p><img src="/posts/cf547d62/image-20211230110019576.png" srcset="/img/loading.gif" lazyload alt="image-20211230110019576"></p>
<h1 id="ssl-socket通信服务端和客户端"><a class="markdownIt-Anchor" href="#ssl-socket通信服务端和客户端"></a> SSL socket通信(服务端和客户端)</h1>
<blockquote>
<p>对下方函数和命令不了解可先参考<a href="#%E9%99%84%E5%BD%95">附录</a>部分</p>
</blockquote>
<h2 id="ssl通信原理"><a class="markdownIt-Anchor" href="#ssl通信原理"></a> SSL通信原理</h2>
<p><img src="/posts/cf547d62/bVbClUj.png" srcset="/img/loading.gif" lazyload alt="HTTP和HTTPS的关系"></p>
<p>SSL通信的本质是啥？本质就是客户端拿着认证机关的证书去认证对方网站到底是不是你要访问的。</p>
<p>因为有人会写一个假的网站骗取流量（及流量劫持）。如果一旦在这个假的网站上输入了用户名密码之后就存在着信息滥用的风险。</p>
<p>为了避免这样的情况，所以才有SSL这个工具。</p>
<ul>
<li>
<p>客户端以后每次访问一个重要的网站时就要拿着发证机关CA（Cerficate Authority）的证书和对方连接的时候验证一下。咋验证的呢？客户端连接的时候服务端也有证书，这个证书也是CA发给他们的，里面的内容进行了加密，只要拿CA发给客户的那个证书对接一些就知道对面网站的那个证书是不是真的。这就是SSL的基本逻辑。</p>
</li>
<li>
<p>同时通信的过程也是加密了的，这样就不太容易被窃听的人看明白（即中间人攻击）。</p>
</li>
</ul>
<p>所以SSL等于解决了两个问题，1 流量劫持 2 中间人攻击。</p>
<p><strong>SSL协议通信的握手步骤</strong>如下：</p>
<ul>
<li>
<p>第1步，SSL客户机连接至SSL服务器，并要求服务器验证它自身的身份；</p>
</li>
<li>
<p>第2步，服务器通过发送它的数字证书证明其身份。这个交换还可以包括整个证书链，直到某个根证书颁发机构（CA）。通过检查有效日期并确认证书包含可信任CA的数字签名来验证证书的有效性。</p>
</li>
<li>
<p>第3步，服务器发出一个请求，对客户端的证书进行验证，但是由于缺乏公钥体系结构，当今的大多数服务器不进行客户端认证。</p>
</li>
<li>
<p>第4步，协商用于加密的消息加密算法和用于完整性检查的哈希函数，通常由客户端提供它支持的所有算法列表，然后由服务器选择最强大的加密算法。</p>
</li>
<li>
<p>第5步，客户机和服务器通过以下步骤生成会话密钥：</p>
<ul>
<li>客户机生成一个随机数，并使用服务器的公钥（从服务器证书中获取）对它加密，以送到服务器上。</li>
<li>服务器用更加随机的数据（客户机的密钥可用时则使用客户机密钥，否则以明文方式发送数据）响应。</li>
</ul>
</li>
</ul>
<h2 id="ssl通信实现"><a class="markdownIt-Anchor" href="#ssl通信实现"></a> SSL通信实现</h2>
<h3 id="证书生成"><a class="markdownIt-Anchor" href="#证书生成"></a> 证书生成</h3>
<div class="code-wrapper"><pre class="line-numbers language-terminal" data-language="terminal"><code class="language-terminal"># 1.先创建 CA 私钥，这个是用来生成ca.crt用的
openssl genrsa -out ca.key 2048

# 2.然后生成自签名CA证书，这个才是我们要用的东西。
# req X.509证书签发请求(CSR)管理
# 	-new 新的请求
#  	-x509 输出一个X509格式的证书 
#  	-days X509证书的有效时间  
#  	-key 用于签名待生成的请求证书的私钥文件
#  	-subj 参数指定证书信息，避免在终端逐个输入
openssl req -new -x509 -days 3650 -key ca.key -out ca.crt -subj &quot;&#x2F;C&#x3D;CN&#x2F;ST&#x3D;hunan&#x2F;L&#x3D;changsha&#x2F;O&#x3D;HNU&#x2F;OU&#x3D;csee&#x2F;CN&#x3D;CA_zino&quot;

# 3.生成服务器私钥。注意这个跟刚才那个CA不是一回事了，相当于实际业务中的需要被认证的网站。
openssl genrsa -out server.key 2048

# 4.生成要颁发证书的证书签名请求
openssl req -new -key server.key -out server.csr -subj &quot;&#x2F;C&#x3D;CN&#x2F;ST&#x3D;hunan&#x2F;L&#x3D;changsha&#x2F;O&#x3D;HNU&#x2F;OU&#x3D;csee&#x2F;CN&#x3D;127.0.0.1&quot;

# 5.用刚才第2步创建的 CA 证书给第4步生成的 签名请求 进行签名，表明该证书请求已被CA信任，得到一个被CA签名过的证书。
# x509 证书处理工具。可以用来显示证书的内容，转换其格式，给CSR签名等X.509证书的管理工作
# 	-req 表明输入文件是一个&quot;请求签发证书文件(CSR)&quot;，等待进行签发
#	-CA arg 指定用于签发请求证书的根CA证书 
#	-CAkey arg 指定用于签发请求证书的CA私钥证书文件，如果这个option没有参数输入，那么缺省认为私有密钥在CA证书文件里有
openssl x509 -req  -days 3650 -in server.csr -CA ca.crt -CAkey ca.key -set_serial 01 -out server.crt

# 之后就是客户端用CA证书来对服务端被CA签名过的证书来进行认证
openssl  verify  -CAfile  ca.crt  server.crt

# 查看证书具体信息
openssl x509 -in server.crt -noout -text<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div>
<p><img src="/posts/cf547d62/image-20211230085302781.png" srcset="/img/loading.gif" lazyload alt="image-20211230085302781"></p>
<p>用CA验证服务端证书是否可信</p>
<p><img src="/posts/cf547d62/image-20211230092704065.png" srcset="/img/loading.gif" lazyload alt="image-20211230092704065"></p>
<h3 id="服务端实现"><a class="markdownIt-Anchor" href="#服务端实现"></a> 服务端实现</h3>
<p>ssl类具体函数定义和参数含义可参考<a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3/library/ssl.html#module-ssl">官方文档</a></p>
<div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> socket
<span class="token keyword">import</span> ssl
ip_port <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token string">'127.0.0.1'</span><span class="token punctuation">,</span> <span class="token number">9999</span><span class="token punctuation">)</span>
<span class="token comment"># 创建了一个 SSL上下文,ssl.PROTOCOL_TLS表示选择客户端和服务器均支持的最高协议版本</span>
context <span class="token operator">=</span> ssl<span class="token punctuation">.</span>SSLContext<span class="token punctuation">(</span>ssl<span class="token punctuation">.</span>PROTOCOL_TLS<span class="token punctuation">)</span>
<span class="token comment"># 加载一个私钥及对应的证书</span>
context<span class="token punctuation">.</span>load_cert_chain<span class="token punctuation">(</span>certfile<span class="token operator">=</span><span class="token string">"server.crt"</span><span class="token punctuation">,</span> keyfile<span class="token operator">=</span><span class="token string">"server.key"</span><span class="token punctuation">)</span>

sk <span class="token operator">=</span> socket<span class="token punctuation">.</span>socket<span class="token punctuation">(</span><span class="token punctuation">)</span>            <span class="token comment"># 创建套接字</span>
sk<span class="token punctuation">.</span>bind<span class="token punctuation">(</span>ip_port<span class="token punctuation">)</span>                <span class="token comment"># 绑定服务地址</span>
sk<span class="token punctuation">.</span>listen<span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span>                    <span class="token comment"># 监听连接请求</span>

<span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'启动socket服务，等待客户端连接...'</span><span class="token punctuation">)</span>

connect_sock<span class="token punctuation">,</span> address <span class="token operator">=</span> sk<span class="token punctuation">.</span>accept<span class="token punctuation">(</span><span class="token punctuation">)</span>     <span class="token comment"># 等待连接，此处自动阻塞</span>
<span class="token comment"># 包装一个现有的 Python socket,并返回一个ssl socket,server_side为true表示为服务器行为，默认为false则表示客户端</span>
ssl_connect_sock <span class="token operator">=</span> context<span class="token punctuation">.</span>wrap_socket<span class="token punctuation">(</span>connect_sock<span class="token punctuation">,</span> server_side<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">)</span>
<span class="token keyword">while</span> <span class="token boolean">True</span><span class="token punctuation">:</span>     <span class="token comment"># 一个死循环，直到客户端发送‘exit’的信号，才关闭连接</span>
    client_data <span class="token operator">=</span> ssl_connect_sock<span class="token punctuation">.</span>recv<span class="token punctuation">(</span><span class="token number">1024</span><span class="token punctuation">)</span><span class="token punctuation">.</span>decode<span class="token punctuation">(</span><span class="token punctuation">)</span>      <span class="token comment"># 接收信息</span>
    <span class="token keyword">if</span> client_data <span class="token operator">==</span> <span class="token string">"exit"</span><span class="token punctuation">:</span>       <span class="token comment"># 判断是否退出连接</span>
        sk<span class="token punctuation">.</span>close<span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token comment"># 关闭连接</span>
        exit<span class="token punctuation">(</span><span class="token string">"通信结束"</span><span class="token punctuation">)</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"来自%s的客户端向你发来信息：%s"</span> <span class="token operator">%</span> <span class="token punctuation">(</span>address<span class="token punctuation">,</span> client_data<span class="token punctuation">)</span><span class="token punctuation">)</span>
    ssl_connect_sock<span class="token punctuation">.</span>sendall<span class="token punctuation">(</span><span class="token string">'服务器已经收到你的信息'</span><span class="token punctuation">.</span>encode<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token comment"># 回馈信息给客户端</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div>
<h3 id="客户端实现"><a class="markdownIt-Anchor" href="#客户端实现"></a> 客户端实现</h3>
<div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> socket
<span class="token keyword">import</span> ssl
<span class="token keyword">import</span> pprint
<span class="token comment"># 创建了一个 SSL上下文,ssl.PROTOCOL_TLS表示选择客户端和服务器均支持的最高协议版本</span>
context <span class="token operator">=</span> ssl<span class="token punctuation">.</span>SSLContext<span class="token punctuation">(</span>ssl<span class="token punctuation">.</span>PROTOCOL_TLS<span class="token punctuation">)</span>
<span class="token comment"># 设置模式为CERT_REQUIRED，在此模式下，需要从套接字连接的另一端获取证书；如果未提供证书或验证失败则将引发 SSLError。</span>
context<span class="token punctuation">.</span>verify_mode <span class="token operator">=</span> ssl<span class="token punctuation">.</span>CERT_REQUIRED
<span class="token comment"># 加载一组用于验证服务器证书的CA证书</span>
context<span class="token punctuation">.</span>load_verify_locations<span class="token punctuation">(</span><span class="token string">"ca.crt"</span><span class="token punctuation">)</span>
<span class="token comment"># 设置端口</span>
ip_port <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token string">'127.0.0.1'</span><span class="token punctuation">,</span> <span class="token number">9999</span><span class="token punctuation">)</span>
<span class="token comment"># 创建套接字</span>
s <span class="token operator">=</span> socket<span class="token punctuation">.</span>socket<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token comment"># 包装一个现有的 Python 套接字 sock 并返回一个 SSLContext.sslsocket_class 的实例 (默认为 SSLSocket)。</span>
<span class="token comment"># 返回的 SSL 套接字会绑定上下文、设置以及证书</span>
ssl_sock <span class="token operator">=</span> context<span class="token punctuation">.</span>wrap_socket<span class="token punctuation">(</span>s<span class="token punctuation">,</span> server_hostname<span class="token operator">=</span><span class="token string">'127.0.0.1'</span><span class="token punctuation">)</span>

<span class="token comment"># 连接服务器</span>
ssl_sock<span class="token punctuation">.</span>connect<span class="token punctuation">(</span>ip_port<span class="token punctuation">)</span>
<span class="token comment"># 输出证书信息</span>
pprint<span class="token punctuation">.</span>pprint<span class="token punctuation">(</span>ssl_sock<span class="token punctuation">.</span>getpeercert<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token keyword">while</span> <span class="token boolean">True</span><span class="token punctuation">:</span>     <span class="token comment"># 通过一个死循环不断接收用户输入，并发送给服务器</span>
    inp <span class="token operator">=</span> <span class="token builtin">input</span><span class="token punctuation">(</span><span class="token string">"请输入要发送的信息： "</span><span class="token punctuation">)</span><span class="token punctuation">.</span>strip<span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token keyword">if</span> <span class="token keyword">not</span> inp<span class="token punctuation">:</span>     <span class="token comment"># 防止输入空信息，导致异常退出</span>
        <span class="token keyword">continue</span>
    ssl_sock<span class="token punctuation">.</span>sendall<span class="token punctuation">(</span>inp<span class="token punctuation">.</span>encode<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>

    <span class="token keyword">if</span> inp <span class="token operator">==</span> <span class="token string">"exit"</span><span class="token punctuation">:</span>   <span class="token comment"># 如果输入的是‘exit’，表示断开连接</span>
        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"结束通信！"</span><span class="token punctuation">)</span>
        <span class="token keyword">break</span>

    server_reply <span class="token operator">=</span> ssl_sock<span class="token punctuation">.</span>recv<span class="token punctuation">(</span><span class="token number">1024</span><span class="token punctuation">)</span><span class="token punctuation">.</span>decode<span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span>server_reply<span class="token punctuation">)</span>
s<span class="token punctuation">.</span>close<span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token comment"># 关闭连接</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div>
<h3 id="基于线程的实现"><a class="markdownIt-Anchor" href="#基于线程的实现"></a> 基于线程的实现</h3>
<div class="code-wrapper"><pre class="line-numbers language-python" data-language="python"><code class="language-python"><span class="token keyword">import</span> threading
<span class="token keyword">import</span> socket
<span class="token keyword">import</span> ssl
<span class="token keyword">import</span> pprint

<span class="token keyword">def</span> <span class="token function">client</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token comment"># 创建了一个 SSL上下文,ssl.PROTOCOL_TLS表示选择客户端和服务器均支持的最高协议版本</span>
    context <span class="token operator">=</span> ssl<span class="token punctuation">.</span>SSLContext<span class="token punctuation">(</span>ssl<span class="token punctuation">.</span>PROTOCOL_TLS<span class="token punctuation">)</span>
    <span class="token comment"># 设置模式为CERT_REQUIRED，在此模式下，需要从套接字连接的另一端获取证书；如果未提供证书或验证失败则将引发 SSLError。</span>
    context<span class="token punctuation">.</span>verify_mode <span class="token operator">=</span> ssl<span class="token punctuation">.</span>CERT_REQUIRED
    <span class="token comment"># 加载一组用于验证其他对等方证书的CA证书</span>
    context<span class="token punctuation">.</span>load_verify_locations<span class="token punctuation">(</span><span class="token string">"ca.crt"</span><span class="token punctuation">)</span>
    <span class="token comment"># 设置端口</span>
    ip_port <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token string">'127.0.0.1'</span><span class="token punctuation">,</span> <span class="token number">9999</span><span class="token punctuation">)</span>
    <span class="token comment"># 创建套接字</span>
    s <span class="token operator">=</span> socket<span class="token punctuation">.</span>socket<span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token comment"># 包装一个现有的 Python 套接字 sock 并返回一个 SSLContext.sslsocket_class 的实例 (默认为 SSLSocket)。</span>
    <span class="token comment"># 返回的 SSL 套接字会绑定上下文、设置以及证书</span>
    ssl_sock <span class="token operator">=</span> context<span class="token punctuation">.</span>wrap_socket<span class="token punctuation">(</span>s<span class="token punctuation">,</span> server_hostname<span class="token operator">=</span><span class="token string">'127.0.0.1'</span><span class="token punctuation">)</span>

    <span class="token comment"># 连接服务器</span>
    ssl_sock<span class="token punctuation">.</span>connect<span class="token punctuation">(</span>ip_port<span class="token punctuation">)</span>
    <span class="token comment"># 输出证书信息</span>
    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'#客户端消息#：客户端成功验证服务端证书，已成功连接，服务端证书信息如下'</span><span class="token punctuation">)</span>
    pprint<span class="token punctuation">.</span>pprint<span class="token punctuation">(</span>ssl_sock<span class="token punctuation">.</span>getpeercert<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token keyword">while</span> <span class="token boolean">True</span><span class="token punctuation">:</span>  <span class="token comment"># 通过一个死循环不断接收用户输入，并发送给服务器</span>
        inp <span class="token operator">=</span> <span class="token builtin">input</span><span class="token punctuation">(</span><span class="token string">"#客户端消息#：请输入要发送的信息： "</span><span class="token punctuation">)</span><span class="token punctuation">.</span>strip<span class="token punctuation">(</span><span class="token punctuation">)</span>
        <span class="token keyword">if</span> <span class="token keyword">not</span> inp<span class="token punctuation">:</span>  <span class="token comment"># 防止输入空信息，导致异常退出</span>
            <span class="token keyword">continue</span>
        ssl_sock<span class="token punctuation">.</span>sendall<span class="token punctuation">(</span>inp<span class="token punctuation">.</span>encode<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
        <span class="token keyword">if</span> inp <span class="token operator">==</span> <span class="token string">"exit"</span><span class="token punctuation">:</span>  <span class="token comment"># 如果输入的是‘exit’，表示断开连接</span>
            <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"#客户端消息#：结束通信！"</span><span class="token punctuation">)</span>
            <span class="token keyword">break</span>

        server_reply <span class="token operator">=</span> ssl_sock<span class="token punctuation">.</span>recv<span class="token punctuation">(</span><span class="token number">1024</span><span class="token punctuation">)</span><span class="token punctuation">.</span>decode<span class="token punctuation">(</span><span class="token punctuation">)</span>
        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"#客户端消息#：来自%s的服务端向你发来信息：%s"</span> <span class="token operator">%</span> <span class="token punctuation">(</span>ip_port<span class="token punctuation">,</span> server_reply<span class="token punctuation">)</span><span class="token punctuation">)</span>
    s<span class="token punctuation">.</span>close<span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token comment"># 关闭连接</span>


<span class="token keyword">def</span> <span class="token function">server</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
    ip_port <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token string">'127.0.0.1'</span><span class="token punctuation">,</span> <span class="token number">9999</span><span class="token punctuation">)</span>
    <span class="token comment"># 创建了一个 SSL上下文,ssl.PROTOCOL_TLS表示选择客户端和服务器均支持的最高协议版本</span>
    context <span class="token operator">=</span> ssl<span class="token punctuation">.</span>SSLContext<span class="token punctuation">(</span>ssl<span class="token punctuation">.</span>PROTOCOL_TLS<span class="token punctuation">)</span>
    <span class="token comment"># 加载一个私钥及对应的证书</span>
    context<span class="token punctuation">.</span>load_cert_chain<span class="token punctuation">(</span>certfile<span class="token operator">=</span><span class="token string">"server.crt"</span><span class="token punctuation">,</span> keyfile<span class="token operator">=</span><span class="token string">"server.key"</span><span class="token punctuation">)</span>

    sk <span class="token operator">=</span> socket<span class="token punctuation">.</span>socket<span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token comment"># 创建套接字</span>
    sk<span class="token punctuation">.</span>bind<span class="token punctuation">(</span>ip_port<span class="token punctuation">)</span>  <span class="token comment"># 绑定服务地址</span>
    sk<span class="token punctuation">.</span>listen<span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span>  <span class="token comment"># 监听连接请求</span>

    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'#服务端消息#：启动socket服务，等待客户端连接...'</span><span class="token punctuation">)</span>

    connect_sock<span class="token punctuation">,</span> address <span class="token operator">=</span> sk<span class="token punctuation">.</span>accept<span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token comment"># 等待连接，此处自动阻塞</span>
    <span class="token comment"># 包装一个现有的 Python socket,并返回一个ssl socket,server_side为true表示为服务器行为，默认为false则表示客户端</span>
    ssl_connect_sock <span class="token operator">=</span> context<span class="token punctuation">.</span>wrap_socket<span class="token punctuation">(</span>connect_sock<span class="token punctuation">,</span> server_side<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">)</span>
    <span class="token keyword">while</span> <span class="token boolean">True</span><span class="token punctuation">:</span>  <span class="token comment"># 一个死循环，直到客户端发送‘exit’的信号，才关闭连接</span>
        client_data <span class="token operator">=</span> ssl_connect_sock<span class="token punctuation">.</span>recv<span class="token punctuation">(</span><span class="token number">1024</span><span class="token punctuation">)</span><span class="token punctuation">.</span>decode<span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token comment"># 接收信息</span>
        <span class="token comment"># print(client_data)</span>
        <span class="token keyword">if</span> client_data <span class="token operator">==</span> <span class="token string">"exit"</span><span class="token punctuation">:</span>  <span class="token comment"># 判断是否退出连接</span>
            sk<span class="token punctuation">.</span>close<span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token comment"># 关闭连接</span>
            <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"#服务端消息#：客户端已结束通信！"</span><span class="token punctuation">)</span>
            exit<span class="token punctuation">(</span><span class="token string">"通信结束"</span><span class="token punctuation">)</span>
        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"#服务端消息#：来自%s的客户端向你发来信息：%s"</span> <span class="token operator">%</span> <span class="token punctuation">(</span>address<span class="token punctuation">,</span> client_data<span class="token punctuation">)</span><span class="token punctuation">)</span>
        ssl_connect_sock<span class="token punctuation">.</span>sendall<span class="token punctuation">(</span><span class="token string">'服务器已经收到你的信息'</span><span class="token punctuation">.</span>encode<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token comment"># 回馈信息给客户端</span>


thread_server <span class="token operator">=</span> threading<span class="token punctuation">.</span>Thread<span class="token punctuation">(</span>target<span class="token operator">=</span>server<span class="token punctuation">)</span>
thread_client <span class="token operator">=</span> threading<span class="token punctuation">.</span>Thread<span class="token punctuation">(</span>target<span class="token operator">=</span>client<span class="token punctuation">)</span>
thread_server<span class="token punctuation">.</span>start<span class="token punctuation">(</span><span class="token punctuation">)</span>
thread_client<span class="token punctuation">.</span>start<span class="token punctuation">(</span><span class="token punctuation">)</span>
thread_server<span class="token punctuation">.</span>join<span class="token punctuation">(</span><span class="token punctuation">)</span>
thread_client<span class="token punctuation">.</span>join<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"退出主线程"</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div>
<h3 id="运行结果"><a class="markdownIt-Anchor" href="#运行结果"></a> 运行结果</h3>
<p><img src="/posts/cf547d62/image-20211230093921353.png" srcset="/img/loading.gif" lazyload alt="image-20211230093921353"></p>
<p><img src="/posts/cf547d62/image-20211230093900981.png" srcset="/img/loading.gif" lazyload alt="image-20211230093900981"></p>
<h1 id="附录"><a class="markdownIt-Anchor" href="#附录"></a> 附录</h1>
<h2 id="基本概念"><a class="markdownIt-Anchor" href="#基本概念"></a> 基本概念</h2>
<h3 id="证书"><a class="markdownIt-Anchor" href="#证书"></a> 证书</h3>
<p>总的来说，证书是公钥/私钥系统的一个组成部分。</p>
<p>在一个证书中包含有两个主体的相关信息。</p>
<ul>
<li>
<p>其包含目标方的名称和目标方的公钥。</p>
</li>
<li>
<p>还包含由第二个主体颁发方所发布的声明：目标方的身份与他们所宣称的一致，包含的公钥也确实是目标方的公钥。 颁发方的声明使用颁发方的私钥进行签名，该私钥的内容只有颁发方自己才知道。 但是，任何人都可以找到颁发方的公钥，用它来解密这个声明，并将其与证书中的其他信息进行比较来验证颁发方声明的真实性。 证书还包含有关其有效期限的信息。 这被表示为两个字段，即 “notBefore” 和 “notAfter”。</p>
<p><img src="/posts/cf547d62/image-20211230101906909.png" srcset="/img/loading.gif" lazyload alt="image-20211230101906909"></p>
</li>
</ul>
<p>在 Python 中应用证书时，客户端或服务器可以用证书来证明自己的身份。 还可以要求网络连接的另一方提供证书，提供的证书可以用于验证以满足客户端或服务器的验证要求。 如果验证失败，连接尝试可被设置为引发一个异常。 验证是由下层的 OpenSSL 框架来自动执行的；应用程序本身不必关注其内部的机制。 但是应用程序通常需要提供一组证书以允许此过程的发生。</p>
<h3 id="ca-证书"><a class="markdownIt-Anchor" href="#ca-证书"></a> CA 证书</h3>
<p>如果想要对连接的另一方的证书进行验证，客户端必须提供一个 “CA 证书” 文件，其实就是一个CA机构的公钥，用这个公钥去验证被CA机构的颁发的目标网站的证书，这个证书相当于被CA机构的私钥签名过。所以如果通过验证，则表明该网站被CA信任，那么客户端就可以相信它。</p>
<p>验证原理可以解释如下：</p>
<ul>
<li>
<p>客户端信任CA</p>
</li>
<li>
<p>CA信任目标网站</p>
</li>
<li>
<p>客户端可以信任目标网站</p>
</li>
</ul>
<p>验证逻辑如下</p>
<p><strong>服务端端</strong></p>
<div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none"># 创建了一个 SSL上下文,ssl.PROTOCOL_TLS表示选择客户端和服务器均支持的最高协议版本
context &#x3D; ssl.SSLContext(ssl.PROTOCOL_TLS)
# 加载一个私钥及对应的证书
context.load_cert_chain(certfile&#x3D;&quot;server.crt&quot;, keyfile&#x3D;&quot;server.key&quot;)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></div>
<p><strong>客户端</strong></p>
<div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none"># 创建了一个 SSL上下文,ssl.PROTOCOL_TLS表示选择客户端和服务器均支持的最高协议版本
context &#x3D; ssl.SSLContext(ssl.PROTOCOL_TLS)
# 加载一组用于验证对方网站证书的CA证书
context.load_verify_locations(&quot;cert.pem&quot;)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></div>
<h3 id="自签名证书"><a class="markdownIt-Anchor" href="#自签名证书"></a> 自签名证书</h3>
<p>下面的命令会生成一个自签名证书，因为实验中一般不会去真的CA机构给服务器签名，所以我们可以用自签名证书来自己制作一个CA证书</p>
<div class="code-wrapper"><pre class="line-numbers language-none"><code class="language-none">openssl req -new -x509 -days 365 -nodes -out cert.pem -keyout key.pem -subj &quot;&#x2F;C&#x3D;CN&#x2F;ST&#x3D;province&#x2F;L&#x3D;city&#x2F;O&#x3D;company&#x2F;OU&#x3D;&#x2F;CN&#x3D;YourWebSiteName&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></div>
<h2 id="python-socket编程"><a class="markdownIt-Anchor" href="#python-socket编程"></a> python socket编程</h2>
<p>参见博主之前写过<a href="https://zino00.github.io/posts/79900945/">socket编程</a></p>
<h2 id="openssl命令参考"><a class="markdownIt-Anchor" href="#openssl命令参考"></a> openssl命令参考</h2>
<p>这部分参考自<a target="_blank" rel="noopener" href="https://blog.csdn.net/gengxiaoming7/article/details/78505107">openssl详解</a></p>
<div class="code-wrapper"><pre class="line-numbers language-terminal" data-language="terminal"><code class="language-terminal">1. openssl list-standard-commands(标准命令)
    1) asn1parse: asn1parse用于解释用ANS.1语法书写的语句(ASN一般用于定义语法的构成) 
    2) ca: ca用于CA的管理 
    openssl ca [options]:
        2.1) -selfsign
        使用对证书请求进行签名的密钥对来签发证书。即&quot;自签名&quot;，这种情况发生在生成证书的客户端、签发证书的CA都是同一台机器(也是我们大多数实验中的情况)，我们可以使用同一个
密钥对来进行&quot;自签名&quot;
        2.2) -in file
        需要进行处理的PEM格式的证书
        2.3) -out file
        处理结束后输出的证书文件
        2.4) -cert file
        用于签发的根CA证书
        2.5) -days arg 
        指定签发的证书的有效时间
        2.6) -keyfile arg   
        CA的私钥证书文件
        2.7) -keyform arg
        CA的根私钥证书文件格式:
            2.7.1) PEM
            2.7.2) ENGINE 
        2.8) -key arg   
        CA的根私钥证书文件的解密密码(如果加密了的话)
        2.9) -config file    
        配置文件
    example1: 利用CA证书签署请求证书
    openssl ca -in server.csr -out server.crt -cert ca.crt -keyfile ca.key  

    3) req: X.509证书签发请求(CSR)管理
    openssl req [options] &lt;infile &gt;outfile
        3.1) -inform arg
        输入文件格式
            3.1.1) DER
            3.1.2) PEM
        3.2) -outform arg   
        输出文件格式
            3.2.1) DER
            3.2.2) PEM
        3.3) -in arg
        待处理文件
        3.4) -out arg
        待输出文件
        3.5) -passin        
        用于签名待生成的请求证书的私钥文件的解密密码
        3.6) -key file
        用于签名待生成的请求证书的私钥文件
        3.7) -keyform arg  
            3.7.1) DER
            3.7.2) NET
            3.7.3) PEM
        3.8) -new
        新的请求
        3.9) -x509          
        输出一个X509格式的证书 
        3.10) -days
        X509证书的有效时间  
        3.11) -newkey rsa:bits 
        生成一个bits长度的RSA私钥文件，用于签发  
        3.12) -[digest]
        HASH算法
            3.12.1) md5
            3.12.2) sha1
            3.12.3) md2
            3.12.4) mdc2
            3.12.5) md4
        3.13) -config file   
        指定openssl配置文件
        3.14) -text: text显示格式
    example1: 利用CA的RSA密钥创建一个自签署的CA证书(X.509结构) 
    openssl req -new -x509 -days 3650 -key server.key -out ca.crt 
    example2: 用server.key生成证书签署请求CSR(这个CSR用于之外发送待CA中心等待签发)
    openssl req -new -key server.key -out server.csr
    example3: 查看CSR的细节
    openssl req -noout -text -in server.csr

    4) genrsa: 生成RSA参数
    openssl genrsa [args] [numbits]
        [args]
        4.1) 对生成的私钥文件是否要使用加密算法进行对称加密:
            4.1.1) -des: CBC模式的DES加密
            4.1.2) -des3: CBC模式的DES加密
            4.1.3) -aes128: CBC模式的AES128加密
            4.1.4) -aes192: CBC模式的AES192加密
            4.1.5) -aes256: CBC模式的AES256加密
        4.2) -passout arg: arg为对称加密(des、des、aes)的密码(使用这个参数就省去了console交互提示输入密码的环节)
        4.3) -out file: 输出证书私钥文件
        [numbits]: 密钥长度
    example: 生成一个1024位的RSA私钥，并用DES加密(密码为1111)，保存为server.key文件
    openssl genrsa -out server.key -passout pass:1111 -des3 1024 

    5) rsa: RSA数据管理
    openssl rsa [options] &lt;infile &gt;outfile
        5.1) -inform arg
        输入密钥文件格式:
            5.1.1) DER(ASN1)
            5.1.2) NET
            5.1.3) PEM(base64编码格式)
         5.2) -outform arg
         输出密钥文件格式
            5.2.1) DER
            5.2.2) NET
            5.2.3) PEM
        5.3) -in arg
        待处理密钥文件 
        5.4) -passin arg
        输入这个加密密钥文件的解密密钥(如果在生成这个密钥文件的时候，选择了加密算法了的话)
        5.5) -out arg
        待输出密钥文件
        5.6) -passout arg  
        如果希望输出的密钥文件继续使用加密算法的话则指定密码 
        5.7) -des: CBC模式的DES加密
        5.8) -des3: CBC模式的DES加密
        5.9) -aes128: CBC模式的AES128加密
        5.10) -aes192: CBC模式的AES192加密
        5.11) -aes256: CBC模式的AES256加密
        5.12) -text: 以text形式打印密钥key数据 
        5.13) -noout: 不打印密钥key数据 
        5.14) -pubin: 检查待处理文件是否为公钥文件
        5.15) -pubout: 输出公钥文件
    example1: 对私钥文件进行解密
    openssl rsa -in server.key -passin pass:111 -out server_nopass.key
    example:2: 利用私钥文件生成对应的公钥文件
    openssl rsa -in server.key -passin pass:111 -pubout -out server_public.key

    6) x509:
    本指令是一个功能很丰富的证书处理工具。可以用来显示证书的内容，转换其格式，给CSR签名等X.509证书的管理工作
    openssl x509 [args]    
        6.1) -inform arg
        待处理X509证书文件格式
            6.1.1) DER
            6.1.2) NET
            6.1.3) PEM
        6.2) -outform arg   
        待输出X509证书文件格式
            6.2.1) DER
            6.2.2) NET
            6.2.3) PEM
        6.3) -in arg 
        待处理X509证书文件
        6.4) -out arg       
        待输出X509证书文件
        6.5) -req            
        表明输入文件是一个&quot;请求签发证书文件(CSR)&quot;，等待进行签发 
        6.6) -days arg       
        表明将要签发的证书的有效时间 
        6.7) -CA arg 
        指定用于签发请求证书的根CA证书 
        6.8) -CAform arg     
        根CA证书格式(默认是PEM) 
        6.9) -CAkey arg      
        指定用于签发请求证书的CA私钥证书文件，如果这个option没有参数输入，那么缺省认为私有密钥在CA证书文件里有
        6.10) -CAkeyform arg  
        指定根CA私钥证书文件格式(默认为PEM格式)
        6.11) -CAserial arg   
        指定序列号文件(serial number file)
        6.12) -CAcreateserial 
        如果序列号文件(serial number file)没有指定，则自动创建它     
    example1: 转换DER证书为PEM格式
    openssl x509 -in cert.cer -inform DER -outform PEM -out cert.pem
    example2: 使用根CA证书对&quot;请求签发证书&quot;进行签发，生成x509格式证书
    openssl x509 -req -days 3650 -in server.csr -CA ca.crt -CAkey ca.key -CAcreateserial -out server.crt
    example3: 打印出证书的内容
    openssl x509 -in server.crt -noout -text 

    7) crl: crl是用于管理CRL列表 
    openssl crl [args]
        7.1) -inform arg
        输入文件的格式
            7.1.1) DER(DER编码的CRL对象)
            7.1.2) PEM(默认的格式)(base64编码的CRL对象)
        7.2) -outform arg
        指定文件的输出格式 
            7.2.1) DER(DER编码的CRL对象)
            7.2.2) PEM(默认的格式)(base64编码的CRL对象)
        7.3) -text: 
        以文本格式来打印CRL信息值。
        7.4) -in filename
        指定的输入文件名。默认为标准输入。
        7.5) -out filename
        指定的输出文件名。默认为标准输出。
        7.6) -hash
        输出颁发者信息值的哈希值。这一项可用于在文件中根据颁发者信息值的哈希值来查询CRL对象。
        7.7) -fingerprint
        打印CRL对象的标识。
        7.8) -issuer
        输出颁发者的信息值。
        7.9) -lastupdate
        输出上一次更新的时间。
        7.10) -nextupdate
        打印出下一次更新的时间。 
        7.11) -CAfile file
        指定CA文件，用来验证该CRL对象是否合法。 
        7.12) -verify
        是否验证证书。        
    example1: 输出CRL文件，包括(颁发者信息HASH值、上一次更新的时间、下一次更新的时间)
    openssl crl -in crl.crl -text -issuer -hash -lastupdate –nextupdate 
    example2: 将PEM格式的CRL文件转换为DER格式
    openssl crl -in crl.pem -outform DER -out crl.der  

    8) crl2pkcs7: 用于CRL和PKCS#7之间的转换 
    openssl crl2pkcs7 [options] &lt;infile &gt;outfile
    转换pem到spc
    openssl crl2pkcs7 -nocrl -certfile venus.pem -outform DER -out venus.spc
    https:&#x2F;&#x2F;www.openssl.org&#x2F;docs&#x2F;apps&#x2F;crl2pkcs7.html

    9) pkcs12: PKCS#12数据的管理
    pkcs12文件工具，能生成和分析pkcs12文件。PKCS#12文件可以被用于多个项目，例如包含Netscape、 MSIE 和 MS Outlook
    openssl pkcs12 [options] 
    http:&#x2F;&#x2F;blog.csdn.net&#x2F;as3luyuan123&#x2F;article&#x2F;details&#x2F;16105475
    https:&#x2F;&#x2F;www.openssl.org&#x2F;docs&#x2F;apps&#x2F;pkcs12.html

    10) pkcs7: PCKS#7数据的管理 
    用于处理DER或者PEM格式的pkcs#7文件
    openssl pkcs7 [options] &lt;infile &gt;outfile
    http:&#x2F;&#x2F;blog.csdn.net&#x2F;as3luyuan123&#x2F;article&#x2F;details&#x2F;16105407
    https:&#x2F;&#x2F;www.openssl.org&#x2F;docs&#x2F;apps&#x2F;pkcs7.html
 
2. openssl list-message-digest-commands(消息摘要命令)
    1) dgst: dgst用于计算消息摘要 
    openssl dgst [args]
        1.1) -hex           
        以16进制形式输出摘要
        1.2) -binary        
        以二进制形式输出摘要
        1.3) -sign file    
        以私钥文件对生成的摘要进行签名
        1.4) -verify file    
        使用公钥文件对私钥签名过的摘要文件进行验证 
        1.5) -prverify file  
        以私钥文件对公钥签名过的摘要文件进行验证
        verify a signature using private key in file
        1.6) 加密处理
            1.6.1) -md5: MD5 
            1.6.2) -md4: MD4         
            1.6.3) -sha1: SHA1 
            1.6.4) -ripemd160
    example1: 用SHA1算法计算文件file.txt的哈西值，输出到stdout
    openssl dgst -sha1 file.txt
    example2: 用dss1算法验证file.txt的数字签名dsasign.bin，验证的private key为DSA算法产生的文件dsakey.pem
    openssl dgst -dss1 -prverify dsakey.pem -signature dsasign.bin file.txt

    2) sha1: 用于进行RSA处理
    openssl sha1 [args] 
        2.1) -sign file
        用于RSA算法的私钥文件 
        2.2) -out file
        输出文件爱你
        2.3) -hex   
        以16进制形式输出
        2.4) -binary
        以二进制形式输出  
    example1: 用SHA1算法计算文件file.txt的HASH值,输出到文件digest.txt
    openssl sha1 -out digest.txt file.txt
    example2: 用sha1算法为文件file.txt签名,输出到文件rsasign.bin，签名的private key为RSA算法产生的文件rsaprivate.pem
    openssl sha1 -sign rsaprivate.pem -out rsasign.bin file.txt

3. openssl list-cipher-commands (Cipher命令的列表)
    1) aes-128-cbc
    2) aes-128-ecb
    3) aes-192-cbc
    4) aes-192-ecb
    5) aes-256-cbc
    6) aes-256-ecb
    7) base64
    8) bf
    9) bf-cbc
    10) bf-cfb
    11) bf-ecb
    12) bf-ofb
    13) cast
    14) cast-cbc
    15) cast5-cbc
    16) cast5-cfb
    17) cast5-ecb
    18) cast5-ofb
    19) des
    20) des-cbc
    21) des-cfb
    22) des-ecb
    23) des-ede
    24) des-ede-cbc
    25) des-ede-cfb
    26) des-ede-ofb
    27) des-ede3
    28) des-ede3-cbc
    29) des-ede3-cfb
    30) des-ede3-ofb
    31) des-ofb
    32) des3
    33) desx
    34) rc2
    35) rc2-40-cbc
    36) rc2-64-cbc
    37) rc2-cbc
    38) rc2-cfb
    39) rc2-ecb
    40) rc2-ofb
    41) rc4
    42) rc4-40<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></div>
<h2 id="参考链接"><a class="markdownIt-Anchor" href="#参考链接"></a> 参考链接</h2>
<p><a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3/library/ssl.html#module-ssl">python SSL官方文档</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/gengxiaoming7/article/details/78505107">openssl详解</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/sinat_41901875/article/details/103600299">关于SSL通信以及python的实现</a></p>
<p><a target="_blank" rel="noopener" href="https://www.feistyduck.com/library/openssl-cookbook/">一本openssl官网推荐的openssl命令参考书</a></p>

            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                  <div class="post-meta mr-3">
                    <i class="iconfont icon-category"></i>
                    
                      <a class="hover-with-bg" href="/categories/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/">网络编程</a>
                    
                  </div>
                
                
                  <div class="post-meta">
                    <i class="iconfont icon-tags"></i>
                    
                      <a class="hover-with-bg" href="/tags/%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1/">网络通信</a>
                    
                      <a class="hover-with-bg" href="/tags/socket/">socket</a>
                    
                      <a class="hover-with-bg" href="/tags/python/">python</a>
                    
                  </div>
                
              </div>
              
                <p class="note note-warning">
                  
                    本博客所有文章除特别声明外，著作权归作者所有，转载请注明出处！
                  
                </p>
              
              
                <div class="post-prevnext">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/posts/7e71e806/">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">使用hexo-abbrlink及解决与hexo-asset-image不适配的问题</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/posts/79900945/">
                        <span class="hidden-mobile">socket编程python实现</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
              <!-- Comments -->
              <article class="comments" id="comments" lazyload>
                
                  
                
                
  <div class="disqus" style="width:100%">
    <div id="disqus_thread"></div>
    
      <script type="text/javascript">
        var disqus_config = function() {
          this.page.url = 'https://zino00.github.io/posts/cf547d62/';
          this.page.identifier = '/posts/cf547d62/';
        };
        Fluid.utils.loadComments('#disqus_thread', function() {
          var d = document, s = d.createElement('script');
          s.src = '//' + 'fluid' + '.disqus.com/embed.js';
          s.setAttribute('data-timestamp', new Date());
          (d.head || d.body).appendChild(s);
        });
      </script>
    
    <noscript>Please enable JavaScript to view the comments</noscript>
  </div>


              </article>
            
          </article>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    

    
      <a id="scroll-top-button" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
    

    
  </main>

  <footer class="text-center mt-5 py-3">
  <div class="footer-content">
     <a  rel="nofollow noopener"><span>Copyrights © 2021</span></a> <i class="iconfont icon-love"></i> <a  target="_blank" rel="nofollow noopener"><span>Zino</span></a> 
  </div>
  
  <div class="statistics">
    
    

    
      
        <!-- 不蒜子统计PV -->
        <span id="busuanzi_container_site_pv" style="display: none">
            总访问量 
            <span id="busuanzi_value_site_pv"></span>
             次
          </span>
      
      
        <!-- 不蒜子统计UV -->
        <span id="busuanzi_container_site_uv" style="display: none">
            总访客数 
            <span id="busuanzi_value_site_uv"></span>
             人
          </span>
      
    
  </div>


  

  
  <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?d1745c2e21adaa6ae90b93f4f4d22da9";
      var s = document.getElementsByTagName("script")[0]; 
      s.parentNode.insertBefore(hm, s);
    })();
    </script>
    
</footer>


  <!-- SCRIPTS -->
  
  <script  src="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" ></script>
<script  src="https://cdn.jsdelivr.net/npm/bootstrap@4.6.0/dist/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>

<!-- Plugins -->


  
    <script  src="/js/img-lazyload.js" ></script>
  



  
    
  



  <script  src="https://cdn.jsdelivr.net/npm/tocbot@4.12.3/dist/tocbot.min.js" ></script>



  <script  src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js" ></script>



  <script  src="https://cdn.jsdelivr.net/npm/anchor-js@4.3.1/anchor.min.js" ></script>



  <script defer src="https://cdn.jsdelivr.net/npm/clipboard@2.0.8/dist/clipboard.min.js" ></script>



  <script  src="/js/local-search.js" ></script>



  <script defer src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" ></script>




  <script  src="https://cdn.jsdelivr.net/npm/typed.js@2.0.12/lib/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var title = document.getElementById('subtitle').title;
      
      typing(title)
      
    })(window, document);
  </script>





  

  
    <!-- KaTeX -->
    <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.13.10/dist/katex.min.css" />
  








  
    <!-- Baidu Analytics -->
    <script defer>
      var _hmt = _hmt || [];
      (function () {
        var hm = document.createElement("script");
        hm.src = "https://hm.baidu.com/hm.js?f45dcd001d67e8f9d84f91248ea31abf";
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(hm, s);
      })();
    </script>
  

  

  

  

  

  





<!-- 主题的启动项 保持在最底部 -->
<script  src="/js/boot.js" ></script>


</body>
</html>
