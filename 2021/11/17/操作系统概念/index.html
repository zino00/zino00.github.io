

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=&#34;auto&#34;>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/favicon.jpg">
  <link rel="icon" href="/img/favicon.jpg">
  <meta name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="description" content="操作系统的学习笔记">
  <meta name="author" content="John Doe">
  <meta name="keywords" content="">
  
  <title>操作系统笔记 - Zino&#39;s Blog</title>

  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.6.0/dist/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/github-markdown-css@4.0.0/github-markdown.min.css" />
  <link  rel="stylesheet" href="/lib/hint/hint.min.css" />

  
    
    
      
      <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@10.7.2/styles/github-gist.min.css" />
    
  

  
    <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css" />
  



<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_kmeydafke9r.css">


<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->


  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    var CONFIG = {"hostname":"example.com","root":"/","version":"1.8.11","typing":{"enable":true,"typeSpeed":70,"cursorChar":"","loop":false},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"copy_btn":true,"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":1},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":true,"baidu":"d1745c2e21adaa6ae90b93f4f4d22da9","google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null}},"search_path":"/local-search.xml"};
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
<meta name="generator" content="Hexo 5.4.0"></head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand"
       href="/">&nbsp;<strong>Zino's Blog</strong>&nbsp;</a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" data-toggle="modal" data-target="#modalSearch">&nbsp;<i
                class="iconfont icon-search"></i>&nbsp;</a>
          </li>
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="banner" id="banner" parallax=true
         style="background: url('/img/post.jpg') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="page-header text-center fade-in-up">
            <span class="h2" id="subtitle" title="操作系统笔记">
              
            </span>

            
              <div class="mt-3">
  
  
    <span class="post-meta">
      <i class="iconfont icon-date-fill" aria-hidden="true"></i>
      <time datetime="2021-11-17 13:39" pubdate>
        2021年11月17日 下午
      </time>
    </span>
  
</div>

<div class="mt-1">
  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      19.5k 字
    </span>
  

  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      208
       分钟
    </span>
  

  
  
    
      <!-- 不蒜子统计文章PV -->
      <span id="busuanzi_container_page_pv" style="display: none">
        <i class="iconfont icon-eye" aria-hidden="true"></i>
        <span id="busuanzi_value_page_pv"></span> 次
      </span>
    
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">操作系统笔记</h1>
            
            <div class="markdown-body">
              <h1 id="操作系统概念"><a href="#操作系统概念" class="headerlink" title="操作系统概念"></a>操作系统概念</h1><h2 id="第1章-导论"><a href="#第1章-导论" class="headerlink" title="第1章 导论"></a>第1章 导论</h2><h3 id="1-1-操作系统做什么"><a href="#1-1-操作系统做什么" class="headerlink" title="1.1 操作系统做什么"></a>1.1 操作系统做什么</h3><p>计算机系统可以大致分为4个组成部分：计算机硬件、操作系统、系统程序与应用程序和用户。</p>
<p><img src="/2021/11/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E5%BF%B5/image-20211114101353468.png" srcset="/img/loading.gif" lazyload alt="image-20211114101353468"></p>
<p><strong>定义操作系统</strong>：</p>
<p>操作系统是一直运行在计算机上的程序（通常称为内核），其他程序则为系统程序和应用程序。</p>
<h3 id="1-2-计算机系统组织"><a href="#1-2-计算机系统组织" class="headerlink" title="1.2 计算机系统组织"></a>1.2 计算机系统组织</h3><p><strong>1.2.1 计算机系统操作</strong></p>
<p><strong>1.2.2 存储结构</strong></p>
<p><img src="/2021/11/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E5%BF%B5/image-20211114104118324.png" srcset="/img/loading.gif" lazyload alt="image-20211114104118324"></p>
<p><strong>1.2.3 I/O结构</strong></p>
<h3 id="1-3-计算机系统体系结构"><a href="#1-3-计算机系统体系结构" class="headerlink" title="1.3 计算机系统体系结构"></a>1.3 计算机系统体系结构</h3><p><strong>1.3.1 单处理器系统</strong></p>
<p><strong>1.3.2 多处理器系统</strong></p>
<p><strong>1.3.3 集群系统</strong></p>
<p>与多处理器系统一样， 集群系统将多个CPU集中起来完成计算任务。然而，集群系统与多处理器系统不同，它是由两个或多个独立的系统藕合起来的。</p>
<h3 id="1-4-操作系统结构"><a href="#1-4-操作系统结构" class="headerlink" title="1.4 操作系统结构"></a>1.4 操作系统结构</h3><h3 id="1-5-操作系统操作"><a href="#1-5-操作系统操作" class="headerlink" title="1.5 操作系统操作"></a>1.5 操作系统操作</h3><p>1.5.1 双重模式操作<br>1.5.2 定时器</p>
<h3 id="1-6-进程管理"><a href="#1-6-进程管理" class="headerlink" title="1.6 进程管理"></a>1.6 进程管理</h3><h3 id="1-7-内存管理"><a href="#1-7-内存管理" class="headerlink" title="1.7 内存管理"></a>1.7 内存管理</h3><h3 id="1-8-存储管理"><a href="#1-8-存储管理" class="headerlink" title="1.8 存储管理"></a>1.8 存储管理</h3><p>1.8.1 文件系统管理<br>1.8.2 大容量存储器管理<br>1.8.3 高速缓存<br>1.8.4 V/O系统</p>
<h3 id="1-9-保护和安全"><a href="#1-9-保护和安全" class="headerlink" title="1.9 保护和安全"></a>1.9 保护和安全</h3><h3 id="1-10-分布式系统"><a href="#1-10-分布式系统" class="headerlink" title="1.10 分布式系统"></a>1.10 分布式系统</h3><h3 id="1-11-专用系统"><a href="#1-11-专用系统" class="headerlink" title="1.11 专用系统"></a>1.11 专用系统</h3><p>1.111 实时嵌入式系统<br>1.11.2 多媒体系统<br>1.11.3 手持系统</p>
<h3 id="1-12-计算环境"><a href="#1-12-计算环境" class="headerlink" title="1.12 计算环境"></a>1.12 计算环境</h3><p>1.12.1 传统计算<br>1.12.2 客户机服务器计算<br>1.12.3 对等计算<br>1.12.4 基于Web的计算</p>
<h2 id="第2章-操作系统结构"><a href="#第2章-操作系统结构" class="headerlink" title="第2章 操作系统结构"></a>第2章 操作系统结构</h2><h3 id="2-1-操作系统服务"><a href="#2-1-操作系统服务" class="headerlink" title="2.1 操作系统服务"></a>2.1 操作系统服务</h3><ul>
<li><p><strong>用户界面</strong>：</p>
<ul>
<li>一种是命令行界面（command-line interface CLI）， 它采用文本命令， 并用一定的方法输入（即一种允许输入并编辑的命令〉。</li>
<li>另一种是批界面， 其中控制这些命令和命令的指令被输入文件中，通过执行文件来实现。</li>
<li>最为常用的是图形用户界面（graphical user interface,GUI)， 此时界面是一个视窗系统， 它具有定位设备来指挥I/O、从菜单来选择、选中部分并用键盘输入文本。有些系统还提供了两种甚至所有这三种界面。</li>
</ul>
</li>
<li><p><strong>程序执行</strong>： 系统必须能将程序装入内存并运行程序。程序必须能结束执行， 包括正常或不正常结束（指明错误）。</p>
</li>
<li><p><strong>I/O操作</strong>：运行程序可能需要I/O，这些I/O 可能涉及文件或设备。对于特定设备，需要特定的功能（如刻录CD或DVD驱动器，或清屏）。为了提高效率和进行保护， 用户通常不能直接控制νo设备。因此，操作系统必须提供进行I/O操作的方法。</p>
</li>
<li><p><strong>文件系统操作</strong>： 文件系统特别重要。很明显， 程序需要读写文件和目录， 也需要根据文件名来创建和删除文件、搜索一个给定的文件、列出文件信息。最后，有些程序还包括了基于文件所有权的允许或拒绝对文件或目录的访问管理。</p>
</li>
<li><p><strong>通信</strong>：在许多情况下，一个进程需要与另一个进程交换信息。这种通信有两种主要形式。一种是发生在同一台计算机运行的两个进程之间。另一种是运行在由网络连接起来<br>的不同的计算机上的进程之间。通信可以通过共事冲序来实现，也可通过信息交换技术来实现（对于消息交换，消息包通过操作系统在进程之间移动）。</p>
</li>
<li><p><strong>错误检测</strong>：操作系统需要时刻知道可能出现的错误。</p>
</li>
<li><p><strong>资源分配</strong>：当多个用户或多个作业同时运行时，必须为每一个分配资源。</p>
</li>
<li><p><strong>统计</strong>：跟踪记录那些用户使用了多少资源和什么类型的资源。</p>
</li>
<li><p><strong>保护和安全</strong>：多进程并发执行时，一个进程不能干预另一个进程或操作系统本身。</p>
</li>
</ul>
<h3 id="2-2-操作系统的用户界面"><a href="#2-2-操作系统的用户界面" class="headerlink" title="2.2 操作系统的用户界面"></a>2.2 操作系统的用户界面</h3><h4 id="2-2-1-命令解释程序"><a href="#2-2-1-命令解释程序" class="headerlink" title="2.2.1 命令解释程序"></a>2.2.1 命令解释程序</h4><p>具有多个命令解释程序选择的系统中， 解释程序被称为外壳(Shell）。例如，在UNIX 和Linux 系统中，有多种不同的Shell 可供用户选择，包括：Bourne Shell、C Shell、Bourne-Again Shell、Korn Shell 等。</p>
<h4 id="2-2-2-图形用户界面"><a href="#2-2-2-图形用户界面" class="headerlink" title="2.2.2 图形用户界面"></a>2.2.2 图形用户界面</h4><p>与用户通过命令行直接输入命令不同， GUI 允许提供基于鼠标的窗口和菜单系统作为接口。</p>
<h3 id="2-3-系统调用"><a href="#2-3-系统调用" class="headerlink" title="2.3 系统调用"></a>2.3 系统调用</h3><p>系统调用Csystem call）提供了操作系统提供的有效服务界面。</p>
<p>系统调用提供了进程与操作系统之间的接口</p>
<p><strong>系统调用</strong></p>
<p>操作系统服务的编程接口<br>通常由高级语言编写（C或C++）<br>程序访问通常通过高层次 的API接口（C标准库的库函数）而不是直接进行系统调用<br>每个系统调用对应一个系统调用编号</p>
<h4 id="系统调用与函数调用的区别"><a href="#系统调用与函数调用的区别" class="headerlink" title="系统调用与函数调用的区别"></a><strong>系统调用与函数调用的区别</strong></h4><p><strong>系统调用</strong></p>
<ol>
<li><p>使用INT和IRET指令，内核和应用程序使用的是不同的堆栈，因此存在堆栈的切换，从用户态切换到内核态，从而可以使用特权指令操控设备</p>
</li>
<li><p>依赖于内核，不保证移植性</p>
</li>
<li><p>在用户空间和内核上下文环境间切换，开销较大</p>
</li>
<li><p>是操作系统的一个入口点</p>
</li>
</ol>
<p><strong>函数调用</strong></p>
<ol>
<li>使用CALL和RET指令，调用时没有堆栈切换</li>
<li>平台移植性好</li>
<li>属于过程调用，调用开销较小</li>
<li>一个普通功能函数的调用</li>
</ol>
<h4 id="API与系统调用"><a href="#API与系统调用" class="headerlink" title="API与系统调用"></a>API与系统调用</h4><p><strong>API</strong>是函数的定义，规定了这个函数的功能，跟内核无直接关系。</p>
<p><strong>系统调用</strong>是通过中断向内核发请求，实现内核提供的某些服务。     </p>
<p><strong>联系</strong>：一个API可能会需要一个或多个系统调用来完成特定功能。通俗点说就是如果这个api需要跟内核打交道就需要系统调用，否则不需要。 程序员调用的是API（API函数），然后通过与系统调用共同完成函数的功能。 </p>
<p>API是一个提供给应用程序的接口，一组函数，是与程序员进行直接交互的。 系统调用则不与程序员进行交互的，它根据API函数，通过一个软中断机制向内核提交请求，以获取内核服务的接口。   </p>
<p>并不是所有的API函数都一一对应一个系统调用。一个API函数可能需要几个系统调用来共同完成函数的功能。一些API函数不需要调用相应的系统调用（因此它所完成的不是内核提供的服务）</p>
<p><img src="/2021/11/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E5%BF%B5/image-20211114112604666.png" srcset="/img/loading.gif" lazyload alt="image-20211114112604666"></p>
<h3 id="2-4-系统调用类型"><a href="#2-4-系统调用类型" class="headerlink" title="2.4 系统调用类型"></a>2.4 系统调用类型</h3><h4 id="2-4-1-进程控制"><a href="#2-4-1-进程控制" class="headerlink" title="2.4.1 进程控制"></a>2.4.1 进程控制</h4><ul>
<li>结束， 放弃</li>
<li>装入， 执行</li>
<li>创建进程， 终止进程</li>
<li>取得进程属性， 设置进程属性</li>
<li>等待时间</li>
<li>等待事件， 唤醒事件</li>
<li>分配和释放内存</li>
</ul>
<h4 id="2-4-2-文件管理"><a href="#2-4-2-文件管理" class="headerlink" title="2.4.2 文件管理"></a>2.4.2 文件管理</h4><ul>
<li>创建文件， 删除文件</li>
<li>打开， 关闭</li>
<li>读、写、重定位</li>
<li>取得文件属性， 设置文件属性</li>
</ul>
<h4 id="2-4-3-设备管理"><a href="#2-4-3-设备管理" class="headerlink" title="2.4.3 设备管理"></a>2.4.3 设备管理</h4><ul>
<li>请求设备， 释放设备</li>
<li>读、写、重定位</li>
<li>取得设备属性， 设置设备属性</li>
<li>逻辑连接或断开设备</li>
</ul>
<h4 id="2-4-4-信息维护"><a href="#2-4-4-信息维护" class="headerlink" title="2.4.4 信息维护"></a>2.4.4 信息维护</h4><ul>
<li>读取时间或日期， 设置时间或日期</li>
<li>读取系统数据， 设置系统数据</li>
<li>读取进程， 文件或设备属性</li>
<li>设置进程， 文件或设备属性</li>
</ul>
<h4 id="2-4-5-通信"><a href="#2-4-5-通信" class="headerlink" title="2.4.5 通信"></a>2.4.5 通信</h4><ul>
<li>创建， 删除通信连接</li>
<li>发送， 接受消息</li>
<li>传递状态消息</li>
<li>连接或断开远程设备</li>
</ul>
<h3 id="2-5-系统程序"><a href="#2-5-系统程序" class="headerlink" title="2.5 系统程序"></a>2.5 系统程序</h3><p>系统程序提供了一个方便的环境， 以开发程序和执行程序。其中一小部分只是系统调用的简单接口， 其他的可能是相当复杂的。它们可分为如下几类：</p>
<ul>
<li><strong>文件管理</strong>：这些程序创建、删除、复制、重新命名、打印、转储、列出和操作文件和目录。</li>
<li><strong>状态信息</strong>：一些程序从系统那里得到日期、时间、可用内存或磁盘空间的数量、用户数或类似状态信息。另一些更为复杂， 能提供详细的性能、登录和调试信息。通常， 这些信息经格式化后，再打印到终端、输出设备或文件， 或在GUI的窗体上显示。有些系统还支持注册衰，它被用于存储和检索配置信息。</li>
<li><strong>文件修改</strong>：－ 有多个编辑器可以创建和修改位于磁盘或其他存储设备上的文件内容。也可能有特殊的命令被用于查找文件内容或完成文本的转换。</li>
<li><strong>程序语言支持</strong>： 常用程序设计语言（如C、C＋＋、Java、Visual Basic和Perl等〉的编译程序、汇编程序、调试程序和解释程序通常与操作系统一起提供给用户。</li>
<li><strong>程序装入和执行</strong>：一旦程序汇编或编译后， 它必须装入内存才能执行。系统可能要提供绝对加载程序、重定位加载程序、链接编辑器和覆盖式加载程序。系统还需要有高级语言或机器语言的调试程序。</li>
<li><strong>通信</strong>：这些程序提供了在进程、用户和计算机系统之间创建虚拟连接的机制。它们允许用户在互相的屏幕上发送消息， 浏览网页， 发送电子邮件， 远程登录， 从一台机器向另一台机器传送文件。</li>
</ul>
<h3 id="2-6-操作系统设计和实现"><a href="#2-6-操作系统设计和实现" class="headerlink" title="2.6 操作系统设计和实现"></a>2.6 操作系统设计和实现</h3><h4 id="2-6-1-设计目标"><a href="#2-6-1-设计目标" class="headerlink" title="2.6.1 设计目标"></a>2.6.1 设计目标</h4><h4 id="2-6-2-机制与策略"><a href="#2-6-2-机制与策略" class="headerlink" title="2.6.2 机制与策略"></a>2.6.2 机制与策略</h4><h4 id="2-6-3-实现"><a href="#2-6-3-实现" class="headerlink" title="2.6.3 实现"></a>2.6.3 实现</h4><h3 id="2-7-操作系统结构"><a href="#2-7-操作系统结构" class="headerlink" title="2.7 操作系统结构"></a>2.7 操作系统结构</h3><h4 id="2-7-1-简单结构"><a href="#2-7-1-简单结构" class="headerlink" title="2.7.1 简单结构"></a>2.7.1 简单结构</h4><p><img src="/2021/11/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E5%BF%B5/image-20211114121729295.png" srcset="/img/loading.gif" lazyload alt="image-20211114121729295"></p>
<p><img src="/2021/11/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E5%BF%B5/image-20211114121720130.png" srcset="/img/loading.gif" lazyload alt="image-20211114121720130"></p>
<h4 id="2-7-2-分层方法"><a href="#2-7-2-分层方法" class="headerlink" title="2.7.2 分层方法"></a>2.7.2 分层方法</h4><ul>
<li><p>操作系统被划分为若干层级，每一层都建立在较低层之上</p>
</li>
<li><p>模块化</p>
</li>
</ul>
<p><img src="/2021/11/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E5%BF%B5/image-20211114122235688.png" srcset="/img/loading.gif" lazyload alt="image-20211114122235688"></p>
<ul>
<li><p>优点</p>
<ul>
<li>便于构造和调试  简化系统设计和实现</li>
</ul>
</li>
<li><p>不足</p>
<ul>
<li>定义和划分困难  效率相对要低一些</li>
</ul>
</li>
</ul>
<h4 id="2-7-3-微内核"><a href="#2-7-3-微内核" class="headerlink" title="2.7.3 微内核"></a>2.7.3 微内核</h4><ul>
<li><p>这种方法将所有非基本部分从内核中移走，并将它们当做系统级程序和用户级程序来实现，用这种方法来构建操作系统</p>
</li>
<li><p>用户模块之间采用消息传递的方式进行通信</p>
</li>
<li><p>优点</p>
<ul>
<li>微内核易于扩展</li>
<li>易于提升OS至一个新的体系结构</li>
<li>更可靠（内核模式中运行的代码更少）</li>
<li>更安全</li>
</ul>
</li>
<li><p>缺点</p>
<ul>
<li>用户空间与内核空间的通信代价较高</li>
</ul>
</li>
</ul>
<h4 id="2-7-4-模块"><a href="#2-7-4-模块" class="headerlink" title="2.7.4 模块"></a>2.7.4 模块</h4><p>用面向对象编程技术来生成模块化的内核。这里， 内核有一组核心部件， 以及在启动或运行时对附加服务的动态链接。</p>
<ul>
<li>用面向对象的方法</li>
<li>内核的组成部分相互分离</li>
<li>任务之间的交互通过已知的接口来实现</li>
<li>每个模块在内核中是按照需要可装载的</li>
<li>比分层系统更为灵活</li>
<li>比微内核更高效（不需要调用消息传递来通信）</li>
</ul>
<p><img src="/2021/11/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E5%BF%B5/image-20211114122827683.png" srcset="/img/loading.gif" lazyload alt="image-20211114122827683"></p>
<h3 id="2-8-虚拟机"><a href="#2-8-虚拟机" class="headerlink" title="2.8 虚拟机"></a>2.8 虚拟机</h3><h4 id="2-8-1-实现"><a href="#2-8-1-实现" class="headerlink" title="2.8.1 实现"></a>2.8.1 实现</h4><h4 id="2-8-2-优点"><a href="#2-8-2-优点" class="headerlink" title="2.8.2 优点"></a>2.8.2 优点</h4><ul>
<li>通过完全保护系统资源，虚拟机提供了一个坚实的安全层</li>
<li>虚拟机允许进行系统开发而不必中断正常的系统操作</li>
</ul>
<p>缺点</p>
<ul>
<li>虚拟机概念很难提供真实的硬件效果</li>
</ul>
<h4 id="2-8-3-实例"><a href="#2-8-3-实例" class="headerlink" title="2.8.3 实例"></a>2.8.3 实例</h4><h3 id="2-9-系统生成"><a href="#2-9-系统生成" class="headerlink" title="2.9 系统生成"></a>2.9 系统生成</h3><h3 id="2-10-系统启动"><a href="#2-10-系统启动" class="headerlink" title="2.10 系统启动"></a>2.10 系统启动</h3><h3 id="2-11-小结"><a href="#2-11-小结" class="headerlink" title="2.11 小结"></a>2.11 小结</h3><h3 id="2-12-习题"><a href="#2-12-习题" class="headerlink" title="2.12 习题"></a>2.12 习题</h3><p><strong>2.1 操作系统提供的服务和功能可以主要分为两大类。简要描述这两大类并讨论它们的区别。</strong></p>
<blockquote>
<p>第一种操作系统提供的服务是<strong>用来保护在系统中同时运行的不同进程</strong>。进程只被允许获得与它们地址空间有联系的内存位置。同样，进程不允许破坏和其他用户有关的文件。一个进程同样不允许在没有操作系统的干预<br>下直接进入设备。</p>
<p>第二种服务由操作系统提供的服务是<strong>提供一种新的功能，而这种功能并不直接被底层的硬件支持</strong>。虚拟存储器和文件系统就是由操作系统提供的这种新服务的实例。</p>
</blockquote>
<p><strong>2.2 列出操作系统提供使用户更为方便地使用计算机系统的5个服务，并说明在哪些情况下用户级程序不能够提供这些服务。请解释为什么。</strong></p>
<blockquote>
<p>2.1操作系统服务</p>
</blockquote>
<p><strong>2.3 给出三种向操作系统传递参数的常用方法。</strong></p>
<blockquote>
<ol>
<li>通过寄存器来传递参数</li>
<li>寄存器传递参数块的首地址</li>
<li>参数通过程序存放或压进堆栈中， 并通过操作系统弹出堆栈。</li>
</ol>
</blockquote>
<p><strong>2.4 介绍一下如何获得一个程序在执行其不同部分的代码时所耗时间的统计简衰。讨论获得该统计简表的重要性。</strong></p>
<p><strong>2.5 操作系统关于文件管理的5个主要功能是什么？</strong></p>
<blockquote>
<p>2.4.2</p>
</blockquote>
<p><strong>2.6 操作文件和设备时，采用同样的系统调用界面有什么优点和缺点？</strong></p>
<p><strong>2.7 命令解释器的用途是什么？为什么它经常是与内核分开的？是否可能采用操作系统提供的系统调用接口为用户开发一个新的命令解释器？</strong></p>
<p><strong>2.8 进程间通信的两个模式是什么？这两种方法有何长处和缺点？</strong></p>
<blockquote>
<p>共享内存系统</p>
<ul>
<li><p>优点</p>
<ul>
<li>最快的一种通信方式，多个进程可同时访问同一片内存空间，相对其他方式来说具有更少的数据拷贝，效率较高。</li>
<li>随内核持续，相比于随进程持续生命力更强。</li>
</ul>
</li>
<li><p>缺点</p>
<p>需要结合信号灯或其他方式来实现多个进程间同步，自身不具备同步机制。</p>
</li>
</ul>
<p>消息传递系统</p>
<ul>
<li>优点<ul>
<li>可以实现通信进程间的同步</li>
</ul>
</li>
<li>缺点<ul>
<li>效率较低</li>
</ul>
</li>
</ul>
</blockquote>
<p><strong>2.9 为什么要将机制和策略区分开来？</strong></p>
<p><strong>2.10 为什么Java提供从Java程序调用以C或C＋＋编写的本地方法？举出一个本地方法的例子。</strong></p>
<p><strong>2.11 如果操作系统的两个部件相互依赖，有时实现分层方法会很困难． 请区别两个功能紧密耦合的系统部件如何分层。</strong></p>
<p><strong>2.12 系统设计采用微内核设计的主要优点是什么？用户程序和系统服务在微内核结构内如何相互影响？采用微内核设计的缺点又是什么？</strong></p>
<blockquote>
<p>优点主要包括以下几点：</p>
<ul>
<li><p><strong>灵活性高易拓展</strong>,增加一个新的服务不需要修改内核</p>
</li>
<li><p>在用户模式中中比在内核模式中<strong>更安全</strong>、更易操作</p>
</li>
<li><p>一个简单的内核设计和功能一般导致一个<strong>更可靠</strong>的操作系统</p>
</li>
<li><p><strong>可移植性强</strong></p>
</li>
<li><p>易于提升OS至一个新的体系结构</p>
</li>
</ul>
<p>用户程序和系统服务通过使用进程件的通信机制在微内核中相互作用，例如发送消息。这些消息由操作系统运送。</p>
<p>缺点是</p>
<ul>
<li>与进程间通信的过度联系和为了保证用户程序和系统服务相互作用而频繁使用操作系统的消息传递功能。使得<strong>效率较低</strong></li>
</ul>
</blockquote>
<p><strong>2.13 模块化内核方法和分层方法在哪些方面类似？哪些方面不同？</strong></p>
<blockquote>
<p>二者的相似之处在于实现了系统的模块化设计，每一部分都对外提供接口，便于对系统进行维护和修改。</p>
<p>二者的区别在于模块化内核方法比分层方法更为灵活，它的任一模块都能调用任何其他模块，提高了系统效率；而分层方法通过层层的系统调用实现上层与下层模块之间的通信，增加了系统开销。</p>
</blockquote>
<p><strong>2.14 操作系统设计员采用虚拟机结构的主要优点是什么？对用户来说主要有什么好处？</strong></p>
<p><strong>2.15 为什么说一个TIT (just-in-time）编译器对执行一个Java程序是有用的？</strong></p>
<p><strong>2.16 在VMware这样的系统中，客户操作系统与主操作系统有什么关系？选择主操作系统要考虑什么因素？</strong></p>
<h2 id="第3章-进程"><a href="#第3章-进程" class="headerlink" title="第3章 进程"></a>第3章 进程</h2><h3 id="3-1-进程概念"><a href="#3-1-进程概念" class="headerlink" title="3.1 进程概念"></a>3.1 进程概念</h3><h4 id="3-1-1-进程"><a href="#3-1-1-进程" class="headerlink" title="3.1.1 进程"></a>3.1.1 进程</h4><p><strong>进程</strong>：是一个可并发执行的具有独立功能的程序关于某个数据集合的一次执行过程，也是操作系统进行资源分配和保护的基本单位。</p>
<p><strong>进程和程序的区别</strong></p>
<ul>
<li><p><strong>进程</strong>反映的是一个动态概念，而<strong>程序</strong>是一个静态概念；程序是指令的有序集合，没有任何执行的含义，而进程则强调的是执行过程，它动态被创建、执行和消亡。</p>
</li>
<li><p><strong>进程</strong>是一个能独立运行的单位，能与其他进程并发执行，进程是作为资源申请和调度单位存在的。而<strong>程序</strong>则没有。因为程序不反映执行过程。</p>
</li>
<li><p>程序和进程并不一定具有一一对应的关系。不同的进程可以来自于同一程序，只要该程序所对应的数据集不同。</p>
</li>
</ul>
<p>进程包括文本段、堆栈段（包括临时数据，如函数参数、返回地址和局部变量）、数据段（包括全局变量）、堆（进程运行时动态分配的内存）</p>
<p><img src="/2021/11/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E5%BF%B5/image-20210622073331434.png" srcset="/img/loading.gif" lazyload alt="image-20210622073331434"></p>
<p><img src="/2021/11/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E5%BF%B5/image-20211024142834120.png" srcset="/img/loading.gif" lazyload alt="内存中的进程"></p>
<h4 id="3-1-2-进程状态"><a href="#3-1-2-进程状态" class="headerlink" title="3.1.2 进程状态"></a>3.1.2 进程状态</h4><p>进程在执行时会改变状态。进程状态在某种程度上是由当前活动所定义的。每个进程可能处于下列状态之一：</p>
<ul>
<li>新的：进程正在被创建。</li>
<li>运行： 指令正在被执行。</li>
<li>等待：进程等待某个事件的发生（如I/O完成或收到信号）。</li>
<li>就绪：进程等待分配处理器。</li>
<li>终止：进程完成执行。</li>
</ul>
<p><img src="/2021/11/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E5%BF%B5/image-20211024144135058.png" srcset="/img/loading.gif" lazyload alt="image-20211024144135058"></p>
<h4 id="3-1-3-进程控制块"><a href="#3-1-3-进程控制块" class="headerlink" title="3.1.3 进程控制块"></a>3.1.3 进程控制块</h4><p>每个进程在操作系统内用进程控制块（process control block, PCB ，也称为任务控制块）来表示。</p>
<p>图3.3 给出了一个PCB 的例子， 它包含许多与一个特定进程相关的信息。</p>
<p><img src="/2021/11/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E5%BF%B5/image-20211024144308211.png" srcset="/img/loading.gif" lazyload alt="image-20211024144308211"></p>
<ul>
<li>进程状态：状态可包括新的、就绪、运行、等待、停止等。</li>
<li>程序计数器：计数器表示进程要执行的下个指令的地址。</li>
<li> CPU 寄存器：根据计算机体系结构的不同， 寄存器的数量和类型也不同。它们包括累加器、索引寄存器、堆钱指针、通用寄存器和其他条件码信息寄存器。与程序计数器一起，这些状态信息在出现中断时也需要保存， 以便进程以后能正确地继续执行（见图3.4)。</li>
<li> CPU 调度信息：这类信息包括进程优先级、调度队列的指针和其他调度参数（第5章讨论进程调度）。</li>
<li>内存管理信息： 根据操作系统所使用的内存系统， 这类信息包括基址和界限寄存器的值、页表或段表（见第8章）。</li>
<li>记账信息：这类信息包括CPU时间、实际使用时间、时间界限、记账数据、作业或进程数量等。</li>
<li> I/O状态信息：这类信息包括分配给进程的I/O设备列表、打开的文件列表等。</li>
</ul>
<p><img src="/2021/11/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E5%BF%B5/image-20211024144700188.png" srcset="/img/loading.gif" lazyload alt="image-20211024144700188"></p>
<p><strong>PCB的作用</strong></p>
<ul>
<li>PCB可唯一标识一个进程</li>
<li>PCB中的信息为进程的控制提供依据</li>
<li>PCB将程序变成了进程</li>
<li>PCB是进程在系统中存在的唯一标志</li>
</ul>
<h4 id="3-1-4-线程"><a href="#3-1-4-线程" class="headerlink" title="3.1.4 线程"></a>3.1.4 线程</h4><p>迄今为止所讨论的进程模型暗示： 一个进程是一个只能进行单个执行线程的程序。例如， 如果一个进程运行一个字处理器程序， 那么只能执行单个线程指令。这种单一控制线程使得进程一次只能执行一个任务。例如， 用户不能在同一进程内， 同时输入字符和进行拼写检查。</p>
<p>许多现代操作系统扩展了进程概念以支持一次能执行多个线程。第4章将讨论多线程进程。</p>
<h3 id="3-2-进程调度"><a href="#3-2-进程调度" class="headerlink" title="3.2 进程调度"></a>3.2 进程调度</h3><p>多道程序设计的目的是无论何时都有进程在运行，从而使CPU利用率达到最大化。</p>
<p>分时系统的目的是在进程之间快速切换CPU以便用户在程序运行时能与其进行交互。</p>
<h4 id="3-2-1-调度队列"><a href="#3-2-1-调度队列" class="headerlink" title="3.2.1 调度队列"></a>3.2.1 调度队列</h4><p>讨论进程调度的常用表示方法是队列图， 如图3.7 所示。每个长方形表示一个队列。<br>有两种队列： 就绪队列和一组设备队列。圆形表示为队列服务的资源， 箭头表示系统内进程的流向。</p>
<p>新进程开始处于就绪队列。它在就绪队列中等待直到被选中执行或被派遣。当进程分配到CPU 并执行时， 可能发生下面几种事件中的一种：</p>
<ul>
<li>进程可能发出一个I/O请求， 并被放到I/O队列中。</li>
<li>进程可能创建一个新的子进程， 并等待其结束。</li>
<li>进程可能会由于中断而强制释放CPU， 并被放回到就绪队列中。</li>
</ul>
<p>对于前两种情况， 进程最终从等待状态切换到就绪态， 并放回到就绪队列中。进程继续这一循环直到终止， 到时它将从所有队列中删除， 其PCB 和资源将得以释放。</p>
<p><img src="/2021/11/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E5%BF%B5/image-20211025195355812.png" srcset="/img/loading.gif" lazyload alt="image-20211025195355812"></p>
<h4 id="3-2-2-调度程序"><a href="#3-2-2-调度程序" class="headerlink" title="3.2.2 调度程序"></a>3.2.2 调度程序</h4><p>进程在其生命周期中会在各种调度队列之间迁移。为了调度， 操作系统必须按某种方式从这些队列中选择进程。进程选择是由相应的<strong>调度程序</strong>（ scheduler ）来执行的。</p>
<p>通常对于批处理系统， 进程更多地是被提交， 而不是马上执行。这些进程被放到大容量存储设备（通常为磁盘〉的缓冲池中，保存在那里以便以后执行。</p>
<p><strong>长期调度程序</strong>（long-term scheduler ）或作业调度程序（job scheduler ） 从缓冲池中选择进程， 井装入内存以准备执行。</p>
<p><strong>短期调度程序</strong>（ short-term scheduler ）或CPU 调度程序从准备执行的进程中选择进程， 并为之分配CPU。</p>
<p>这两个调度程序的<strong>主要差别</strong>是它们执行的频率。</p>
<p><strong>中期调度程序</strong>的核心思想是能将进程从内存（或从CPU 竞争）中移出， 从而降低多道程序设计的程度。之后， 进程能被重新调入内存， 并从中断处继续执行。</p>
<p><img src="/2021/11/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E5%BF%B5/image-20211025200346176.png" srcset="/img/loading.gif" lazyload alt="image-20211025200346176"></p>
<h4 id="3-2-3-上下文切换"><a href="#3-2-3-上下文切换" class="headerlink" title="3.2.3 上下文切换"></a>3.2.3 上下文切换</h4><p>当发生一个中断时，系统需要保存当前运行在CPU 中进程的上下文， 从而在其处理完后能恢复上下文， 即先中断进程， 之后再继续。</p>
<p><strong>进程上下文</strong>用进程的PCB 表示， 它包括CPU 寄存器的值、进程状态（见图3.2） 和内存管理信息等。通常，通过执行一个<strong>状态保存</strong>（ state save） 来保存CPU当前状态（不管它是内核模式还是用户模式）， 之后执行一个<strong>状态恢复</strong>（ state restore）重新开始运行。</p>
<p>将CPU切换到另一个进程需要保存当前进程的状态并恢复另一个进程的状态，这一任务称为<strong>上下文切换</strong>（ context switch）。当发生上下文切换时， 内核会将旧进程的状态保存在其PCB中，然后装入经调度要执行的并己保存的新进程的上下文。</p>
<h3 id="3-3-进程操作"><a href="#3-3-进程操作" class="headerlink" title="3.3 进程操作"></a>3.3 进程操作</h3><h4 id="3-3-1-进程创建"><a href="#3-3-1-进程创建" class="headerlink" title="3.3.1 进程创建"></a>3.3.1 进程创建</h4><p>进程在其执行过程中， 能通过创建进程系统调用（ create-process system call） 创建多个新进程。创建进程称为父进程， 而新进程称为子进程。每个新进程可以再创建其他进程，从而形成了进程树。</p>
<p><strong>创建过程</strong></p>
<ul>
<li><p>申请空白PCB</p>
</li>
<li><p>分配资源</p>
</li>
<li><p>初始化PCB</p>
</li>
<li><p>插入就绪队列</p>
</li>
</ul>
<p>进程创建实质上是生成一个PCB</p>
<p><img src="/2021/11/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E5%BF%B5/image-20211114152544023.png" srcset="/img/loading.gif" lazyload alt="image-20211114152544023"></p>
<p>当进程创建新进程时， 有两种执行可能：<br>①父进程与子进程并发执行。<br>②父进程等待， 直到某个或全部子进程执行完。</p>
<p>新进程的地址空间也有两种可能：<br>①子进程是父进程的复制品（具有与父进程相同的程序和数据）。<br>②子进程装入另一个新程序。</p>
<p><img src="/2021/11/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E5%BF%B5/image-20211025201136927.png" srcset="/img/loading.gif" lazyload alt="image-20211025201136927"></p>
<h4 id="3-3-2-进程终止"><a href="#3-3-2-进程终止" class="headerlink" title="3.3.2 进程终止"></a>3.3.2 进程终止</h4><p><strong>进程终止的过程</strong></p>
<ul>
<li><p>查找进程</p>
</li>
<li><p>查找该进程的PCB</p>
</li>
<li><p>中止执行</p>
</li>
<li><p>终止子进程</p>
</li>
<li><p>归还资源</p>
</li>
<li><p>将PCB从所在队列移出</p>
</li>
<li><p>释放PCB</p>
</li>
</ul>
<p><img src="/2021/11/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E5%BF%B5/image-20211114152857377.png" srcset="/img/loading.gif" lazyload alt="image-20211114152857377"></p>
<p>当进程完成执行最后的语句并使用系统调用exit()请求操作系统删除自身时， 进程终止。这时， 进程可以返回状态值（通常为整数〉到父进程（通过系统调用wait（））。所有进程资源（包括物理和虚拟内存、打开文件和I/O缓冲〉会被操作系统释放。</p>
<p>在其他情况下也会出现终止。进程通过适当的系统调用（如Win32 中的TerminatePorcess（）） 能终止另一个进程。通常， 只有被终止进程的父进程才能执行这一系统调用。否则， 用户可以任意地终止彼此的作业。</p>
<h4 id="3-3-3-进程阻塞"><a href="#3-3-3-进程阻塞" class="headerlink" title="3.3.3 进程阻塞"></a>3.3.3 进程阻塞</h4><p><strong>阻塞过程</strong></p>
<ul>
<li><p>停止执行</p>
</li>
<li><p>更改PCB为阻塞</p>
</li>
<li><p>保留现场</p>
</li>
<li><p>PCB插入相应阻塞队列</p>
</li>
<li><p>提示重新调度</p>
</li>
</ul>
<p><strong>唤醒过程</strong></p>
<ul>
<li>根据释放条件寻找相应进程</li>
<li>改PCB状态为就绪</li>
<li>将PCB插入就绪队列</li>
</ul>
<h3 id="3-4-进程间通信"><a href="#3-4-进程间通信" class="headerlink" title="3.4 进程间通信"></a>3.4 进程间通信</h3><p><strong>允许进程协作的理由</strong></p>
<ul>
<li>信息共享（information sharing）：由于多个用户可能对同样的信息感兴趣（例如共享的文件）， 所以必须提供环境以允许对这些信息进行并发访问。</li>
<li>提高运算速度（computation speedup）： 如果希望一个特定任务快速运行， 那么必须将它分成子任务，每个子任务可以与其他子任务并行执行。注意，如果要实现这样的加速，需要计算机有多个处理单元（例如CPU或I/0通道）。</li>
<li>模块化（modularity）：可能需要按模块化方式构造系统， 如第2章所讨论， 可将系统功能分成独立进程或线程。</li>
<li>方便（convenience）：单个用户也可能同时执行许多任务。例如，一个用户可以并行进行编辑、打印和编译操作。</li>
</ul>
<p>进程间通信有两种基本模式：</p>
<p><strong>(1) 共享内存</strong></p>
<p>在共享内存模式中， 建立起一块供协作进程共享的内存区域， 进程通过向此共享区域读或写入数据来交换信息。</p>
<p><strong>(2) 消息传递</strong></p>
<p>在消息传递模式中，通过在协作进程间交换消息来实现通信。</p>
<p>图3.13 给出了这两种模式的对比。</p>
<p><img src="/2021/11/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E5%BF%B5/image-20211026154454752.png" srcset="/img/loading.gif" lazyload alt="image-20211026154454752"></p>
<h4 id="3-4-1-共享内存系统"><a href="#3-4-1-共享内存系统" class="headerlink" title="3.4.1 共享内存系统"></a>3.4.1 共享内存系统</h4><p>采用共享内存的进程间通信需要通信进程建立<strong>共享内存区域</strong>。通常， 一块共享内存区域驻留在生成共享内存段进程的地址空间。其他希望使用这个共享内存段进行通信的进程必须将此放到它们自己的地址空间上。</p>
<p>采用共享内存是解决生产者一消费者问题方法中的一种。为了允许生产者进程和消费进程能并发执行， 必须要有一个缓冲来被生产者填充并被消费者所使用。此缓冲驻留在生产者进程和消费者进程的共享内存区域内， 当消费者使用一项时， 生产者能产生另一项。生产者和消费者必须同步， 以免消费者消费一个没有生产出来的项。</p>
<p>可以使用两种缓冲。<strong>无限缓冲</strong>（unbounded-buffer）对缓冲大小没有限制。消费者可能不得不等待新的项， 但生产者总是可以产生新项。有限缓冲（ bounded-buffer）假设缓冲大小固定。对于这种情况， 如果缓冲为空， 那么消费者必须等待：如果缓冲为满， 那么生产者必须等待。</p>
<p>共享缓冲是通过循环数组和两个逻辑指针来实现的： in 和out。变量in 指向缓冲中下一个空位： out 指向缓冲中的第一个满位。当in==out 时， 缓冲为空： (in+1)%BUFFER_SIZE= out 时，缓冲为满。</p>
<p><img src="/2021/11/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E5%BF%B5/image-20211026155644352.png" srcset="/img/loading.gif" lazyload alt="image-20211026155644352"></p>
<h4 id="3-4-2-消息传递系统"><a href="#3-4-2-消息传递系统" class="headerlink" title="3.4.2 消息传递系统"></a>3.4.2 消息传递系统</h4><p>消息传递提供一种机制以允许进程不必通过共享地址空间来实现通信和同步。</p>
<p>消息传递工具提供至少两种操作：发送（消息） 和接收（消息） 。</p>
<ol>
<li><p><strong>命名</strong></p>
<p><strong>直接通信</strong>:</p>
<p>对于<strong>直接通信</strong>， 需要通信的每个进程必须明确地命名通信的接收者或发送者。采用这种方案， 原语send()和receive()定义如下：</p>
<ul>
<li>send(P,message）：发送消息到进程P。</li>
<li>receive(Q, message）： 接收来自进程Q的消息。</li>
</ul>
<p>这种方案的通信线路具有如下属性：</p>
<ul>
<li>在需要通信的每对进程之间自动建立线路。进程仅需知道相互通信的标识符。</li>
<li>一个线路只与两个进程相关。</li>
<li>每对进程之间只有一个线路。</li>
</ul>
<p>这种方案展示了<strong>对称寻址</strong>， 即发送和接收进程必须命名对方以便通信。</p>
<p>这种方案一个变形采用<strong>非对称寻址</strong>， 即只要发送者命名接收者， 而接收者不需要命名发送者。采用这种方案， 原语send()和receive()定义如下：</p>
<ul>
<li>send(P,message）：发送消息到进程P。</li>
<li> receive(id, message）：接收来自任何进程的消息，变量id设置成与其通信的进程名称。</li>
</ul>
<p>对称和非对称寻址方案的<strong>缺点</strong></p>
<ul>
<li>是限制了进程定义的模块化。改变进程的名称可能必须检查所有其他进程定义。所有旧名称的引用都必须找到， 以便修改成为新名称。</li>
<li>有可能造成依赖于特定的操作系统，因为不同操作系统对进程的ID号的指定方式可能不一致；</li>
<li>每对进程间只能够建立一条链路是一个重大的缺陷。</li>
</ul>
<p><strong>间接通信</strong>:</p>
<p>在<strong>间接通信</strong>中， 通过邮箱或端口来发送和接收消息。邮箱可以抽象成一个对象， 进程可以向其中存放消息，也可从中删除消息，每个邮箱都有一个唯一的标识符。例如，POSIX消息队列采用一个整数值来标识一个邮箱。对于这种方案， 一个进程可能通过许多不同的邮箱与其他进程通信， 但两个进程仅在其共享至少一个邮箱时可相互通信。原语send()和receive()定义如下：</p>
<ul>
<li>send(A , message）：发送一个消息到邮箱A。</li>
<li> receive(A, message）： 接收来自邮箱A 的消息。</li>
</ul>
<p>对于这种方案， 通信线路具有如下属性：</p>
<ul>
<li>只有在两个进程共享一个邮箱时， 才能建立通信线路。</li>
<li> 一个线路可以与两个或更多的进程相关联。</li>
<li>两个通信进程之间可有多个不同的线路， 每个线路对应于一个邮箱。</li>
</ul>
</li>
<li><p><strong>同步</strong></p>
<p>进程间的通信可以通过调用原语send（）和receiveO来进行。这些原语的实现有不同的设计选项。消息传递可以是阻塞或非阻塞一一一也称为同步或异步。</p>
<ul>
<li>阻塞send：发送进程阻塞，直到消息被接收进程或邮箱所接收。</li>
<li>非阻塞send：发送进程发送消息并再继续操作。</li>
<li>阻塞receive：接收者阻塞，直到有消息可用。</li>
<li>非阻塞receive：接收者收到一个有效消息或空消息。</li>
</ul>
<p>send（）和receive（）可以进行多种组合。当send（）和receive（）都阻塞时，则在发送者和接收者之间就有一个集合点（rendezvous）。当使用阻塞sendO和receive(）时，如何解决生产者－消费者问题就不再重要了。生产者仅需调用阻塞send（）调用并等待，直到消息被送到接收者或邮箱。同样地，当消费者调用receive（）时，发生阻塞直到有一个消息可用。</p>
</li>
<li><p><strong>缓冲</strong></p>
<p>不管通信是直接的或是间接的， 通信进程所交换的消息都驻留在临时队列中。简单地讲， 队列实现有三种方法：</p>
<ul>
<li>零容量：队列的最大长度为0：因此， 线路中不能有任何消息处于等待。对于这种<br>情况， 必须阻塞发送， 直到接收者接收到消息。</li>
<li>有限容量：队列的长度为有限的n： 因此， 最多只能有n个消息驻留其中。如果在发送新消息时队列未满，那么该消息可以放在队列中（或者复制消息或者保存消息的指针），且发送者可继续执行而不必等待。不过， 线路容量有限。如果线路满， 必须阻塞发送者直到队列中的空间可用为止。</li>
<li>无限容量：队列长度可以无限，因此， 不管多少消息都可在其中等待， 从不阻塞发送者。</li>
</ul>
<p>零容量情况称为没有缓冲的消息系统， 其他情况称为自动缓冲。</p>
</li>
</ol>
<h3 id="3-5-IPC系统的实例"><a href="#3-5-IPC系统的实例" class="headerlink" title="3.5 IPC系统的实例"></a>3.5 IPC系统的实例</h3><h4 id="3-5-1-实例：POSX共享内存"><a href="#3-5-1-实例：POSX共享内存" class="headerlink" title="3.5.1 实例：POSX共享内存"></a>3.5.1 实例：POSX共享内存</h4><h4 id="3-5-2-实例：Mach"><a href="#3-5-2-实例：Mach" class="headerlink" title="3.5.2 实例：Mach"></a>3.5.2 实例：Mach</h4><h4 id="3-5-3-实例：Windows-XP"><a href="#3-5-3-实例：Windows-XP" class="headerlink" title="3.5.3 实例：Windows XP"></a>3.5.3 实例：Windows XP</h4><h3 id="3-6-客户机服务器系统通信"><a href="#3-6-客户机服务器系统通信" class="headerlink" title="3.6 客户机服务器系统通信"></a>3.6 客户机服务器系统通信</h3><h4 id="3-6-1-Socket"><a href="#3-6-1-Socket" class="headerlink" title="3.6.1 Socket"></a>3.6.1 Socket</h4><p><strong>Socket</strong> （套接字〉可定义为通信的端点。一对通过网络通信的进程需要使用一对Socket一一即每个进程各有一个。</p>
<p>Socket 由IP 地址与一个端口号连接组成。通常， Socket采用客户机一服务器结构。服务器通过监昕指定端口来等待进来的客户请求。一旦收到请求，服务器就接受来自客户Socket 的连接， 从而完成连接。</p>
<p>Java提供了三种不同类型的Socket。</p>
<ul>
<li>面向连接（TCP) Socket是用Socket类实现的。</li>
<li>无连接（UDP) Socket 使用了DatagramSocket 类。</li>
<li>最后一种类型是多点传送Socket 类(MulticastSocket class）， 它是DatagramSocket类的子类。多点传送Socket允许数据发送给多个接收者。</li>
</ul>
<p><img src="/2021/11/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E5%BF%B5/image-20211114161059376.png" srcset="/img/loading.gif" lazyload alt="image-20211114161059376"></p>
<p><img src="/2021/11/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E5%BF%B5/image-20211114161112895.png" srcset="/img/loading.gif" lazyload alt="image-20211114161112895"></p>
<p>无论一个Socket通信程序的功能多么齐全、程序多么复杂，其基本结构都是一样的，都包括以下四个基本步骤：</p>
<ol>
<li>在客户方和服务器方创建Socket/ServerSocket实例。</li>
<li>打开连接到Socket的输入/输出流。</li>
<li>利用输入/输出流，按照一定的协议对Socket进行读/写操作。</li>
<li>关闭输入/输出流和Socket。//如果网络的一端已经关闭，另一端读到null</li>
</ol>
<p>通常，程序员的主要工作是针对所要完成的功能在第3步进行编程，第1、2、4步对所有的通信程序来说几乎都是一样的。</p>
<p><img src="/2021/11/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E5%BF%B5/image-20211114162712864.png" srcset="/img/loading.gif" lazyload alt="image-20211114162712864"></p>
<p><img src="/2021/11/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E5%BF%B5/image-20211114162726368.png" srcset="/img/loading.gif" lazyload alt="image-20211114162726368"></p>
<h4 id="3-6-2-远程过程调用"><a href="#3-6-2-远程过程调用" class="headerlink" title="3.6.2 远程过程调用"></a>3.6.2 远程过程调用</h4><p><img src="/2021/11/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E5%BF%B5/image-20211114162954112.png" srcset="/img/loading.gif" lazyload alt="image-20211114162954112"></p>
<h4 id="3-6-3-远程方法调用"><a href="#3-6-3-远程方法调用" class="headerlink" title="3.6.3 远程方法调用"></a>3.6.3 远程方法调用</h4><p>远程方法调用（remote method invocation, RMI） 是一个类似于RPC 的Java 特性。RMI允许线程调用远程对象的方法。如果对象位于不同的JVM 上，那么就认为它是远程的。因此， 远程可能在同一计算机或通过网络连接的主机的不同JVM 上。这种情况如图3.22所示。</p>
<p><img src="/2021/11/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E5%BF%B5/image-20211114163017447.png" srcset="/img/loading.gif" lazyload alt="image-20211114163017447"></p>
<h3 id="3-7-小结"><a href="#3-7-小结" class="headerlink" title="3.7 小结"></a>3.7 小结</h3><p>进程是执行中的程序。随着进程的执行， 它改变状态。进程状态由进程当前活动所定义。每个进程可处于： <strong>新的、就绪、运行、等待或终止</strong>等状态。每个进程在操作系统内通过自己的<strong>进程控制块（PCB）</strong>来表示。</p>
<p>当前不在执行的进程会放在某个等待队列中。操作系统有两种主要队列：<strong>I/O请求队列</strong>和<strong>就绪队列</strong>。就绪队列包括所有准备执行并等待CPU的进程。每个进程都有PCB , PCB链接起来就形成了就绪队列。长期（作业）调度通过选择进程来争用CPU。通常， <strong>长期调度</strong>会受资源分配考虑， 尤其是内存管理的影响。<strong>短期调度</strong>从就绪队列中选择进程。操作系统必须为父进程创建子进程提供一种机制。父进程在继续之前可以等待它的子进程终止， 也可以并发执行父进程和子进程。并发执行有许多优点， 例如信息共享、提高运算速度、模块化和便利性等。</p>
<p>操作系统的执行进程可以是独立进程或协作进程。协作进程需要进程间有互相通信的机制。主要有两种形式的通信： <strong>共享内存和消息系统</strong>。共享内存方法要求通信进程共享一些变量。进程通过使用这些共享变量来交换信息。对于<strong>共享内存系统</strong>， 主要由应用程序员提供通信， 操作系统只需要提供共享内存。<strong>消息系统方法</strong>允许进程交换信息。提供通信的主要责任在于操作系统本身。这两种方法并不互相排斥， 能在同一操作系统内同时实现。</p>
<p>客户机一服务器系统中的通信可能使用：</p>
<p>(1) <strong>Socket</strong>,(2) <strong>远程过程调用(RPC)</strong>,(3) <strong>Java的远程方法调用（RMI）</strong>。</p>
<p>Socket定义为通信的端点。一对应用程序间的连接由一对Socket组成，每端各有一个通信频道。RPC 是另一种形式的分布式通信。当一个进程（或线程） 调用一个远程应用的方法时， 就出现了RPC。RMI是RPC 的Java版。RMI允许线程如同调用本地对象一样来调用远程对象的方法。RPC 和RMI的主要区别是RPC传递给远程过程的数据是按普通数据结构形式的， 而RMI允许把对象传递给远程方法。</p>
<h3 id="3-8-习题"><a href="#3-8-习题" class="headerlink" title="3.8 习题"></a>3.8 习题</h3><p><strong>1.什么是多道程序的度（degree of multiprogramming），它的上限由哪些因素确定？</strong></p>
<blockquote>
<p>多道即计算机内存中同时存放几道相互独立的程序。多道程序的度就是操作系统将多少个进程放入了内存。上限的限制因素有CPU的核数、所采用的的调度算法、内存的大小等。</p>
</blockquote>
<p><strong>3.1 论述长期、中期、短期调度之间的区别。</strong></p>
<blockquote>
<p>a.<strong>短期调度</strong>：从准备执行的进程中选择进程， 并为之分配CPU。<br>b.<strong>中期调度</strong>：作为一种中等程度的调度程序，尤其被用于分时系统，一个交换方案的实施，将部分运行程序移出内存，之后，从中断处继续执行。<br>c.<strong>长期调度</strong>（作业调度程序）：通常对于批处理系统， 进程更多地是被提交， 而不是马上执行。这些进程被放到大容量存储设备（通常为磁盘）的缓冲池中，保存在那里以便以后执行。长期调度程序从缓冲池中选择进程， 井装入内存以准备执行。</p>
<p>它们主要的<strong>不同之处</strong>是它们的执行的频率。短期调度必须经常调用一个新进程，由于在系统中，长期调度处理移动的作业时，并不频繁被调用，可能在进程离开系统时才被唤起。</p>
</blockquote>
<p><strong>3.2 描述内核在两个进程间进行上下文切换的过程。</strong></p>
<blockquote>
<p>进程上下文是由进程的PCB来表示的，它包括CPU寄存器的值和内存管理信息等。</p>
<p>通常，通过执行一个状态保存（ state save） 来保存CPU当前状态（不管它是内核模式还是用户模式）， 之后执行一个状态恢复（ state restore）重新开始运行。</p>
<p>当发生上下文切换时， 内核会将旧进程的状态保存在其PCB中，然后装入经调度要执行的并己保存的新进程的上下文</p>
</blockquote>
<p><strong>3.5 下面设计的好处和坏处分别是什么？系统层次和用户层次都要考虑到</strong>．<br>A，对称和非对称通信</p>
<p>B，自动和显式缓冲</p>
<p>C， 复制发送和引用发送</p>
<p>D，固定大小和可变大小消息</p>
<h2 id="第4章-线程"><a href="#第4章-线程" class="headerlink" title="第4章 线程"></a>第4章 线程</h2><h3 id="4-1-概述"><a href="#4-1-概述" class="headerlink" title="4.1 概述"></a>4.1 概述</h3><p>线程是CPU使用的基本单元， 它由线程由、程序计数器、寄存器集合和技组成。它与属于同一进程的其他线程共享代码段、数据段和其他操作系统资源，如打开文件和信号。一个传统重量级（ heavyweight ）的进程只有单个控制线程。如果进程有多个控制线程， 那么它能同时做多个任务。图4.1 说明了传统单线程进程和多线程进程的差别。</p>
<p><img src="/2021/11/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E5%BF%B5/image-20211114231912641.png" srcset="/img/loading.gif" lazyload alt="image-20211114231912641"></p>
<h4 id="4-1-1-动机"><a href="#4-1-1-动机" class="headerlink" title="4.1.1 动机"></a>4.1.1 动机</h4><h4 id="4-1-2-优点"><a href="#4-1-2-优点" class="headerlink" title="4.1.2 优点"></a>4.1.2 优点</h4><p>多线程编程具有如下4个优点：</p>
<p>①响应度高： 如果对一个交互程序采用多线程， 那么即使其部分阻塞或执行较冗长的操作，该程序仍能继续执行，从而增加了对用户的响应程度。例如，多线程Web浏览器在用一个线程装入图像时，能通过另一个线程与用户交互。</p>
<p>②资源共享： 线程默认共享它们所属进程的内存和资源。代码和数据共享的优点是它能允许一个应用程序在同一地址空间有多个不同的活动线程。</p>
<p>③经济： 进程创建所需要的内存和资源的分配比较昂贵。由于线程能共享它们所属进程的资源，所以创建和切换线程会更为经济。</p>
<p>④多处理器体系结构的利用： 多钱程的优点之一是能充分使用多处理器体系结构，以便每个进程能井行运行在不同的处理器上。不管有多少CPU， 单线程进程只能运行在一个CPU上。在多CPU上使用多线程加强了并发功能。</p>
<h3 id="4-2-多线程模型"><a href="#4-2-多线程模型" class="headerlink" title="4.2 多线程模型"></a>4.2 多线程模型</h3><p>有两种不同方法来提供线程支持： 用户层的<strong>用户线程</strong>或内核层的<strong>内核线程</strong>。</p>
<p>用户线程受内核支持， 而无须内核管理： 而内核线程由操作系统直接支持和管理。</p>
<h4 id="4-2-1-多对一模型"><a href="#4-2-1-多对一模型" class="headerlink" title="4.2.1 多对一模型"></a>4.2.1 多对一模型</h4><p>多对一模型（见图4.2 ）将许多用户级线程映射到一个内核线程。</p>
<p><strong>优点</strong>：</p>
<ul>
<li>线程管理是由线程库在用户空间进行的， 因而效率比较高。</li>
</ul>
<p><strong>缺点</strong>：</p>
<ul>
<li><p>但是如果一个线程执行了阻塞系统调用， 那么整个进程会阻塞。</p>
</li>
<li><p>而且， 因为任一时刻只有一个线程能访问内核， 多个线程不能并行运行在多处理器上。</p>
</li>
</ul>
<p><img src="/2021/11/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E5%BF%B5/image-20211114232532605.png" srcset="/img/loading.gif" lazyload alt="image-20211114232532605"></p>
<h4 id="4-2-2-一对一模型"><a href="#4-2-2-一对一模型" class="headerlink" title="4.2.2 一对一模型"></a>4.2.2 一对一模型</h4><p>一对一模型（见图4.3） 将每个用户线程映射到一个内核线程。</p>
<p><strong>优点</strong>：</p>
<ul>
<li>该模型在一个线程执行阻塞系统调用时， 能允许另一个线程继续执行， 所以它提供了比多对一模型更好的并发功能；</li>
<li>它也允许多个线程能并行地运行在多处理器系统上。</li>
</ul>
<p>这种模型的唯一<strong>缺点</strong>是：</p>
<ul>
<li>每创建一个用户线程就需要创建一个相应的内核线程。由于创建内核线程的开销会影响应用程序的性能， 所以这种模型的绝大多数实现限制了系统所支持的线程数</li>
</ul>
<p><img src="/2021/11/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E5%BF%B5/image-20211114232838467.png" srcset="/img/loading.gif" lazyload alt="image-20211114232838467"></p>
<h4 id="4-2-3-多对多模型"><a href="#4-2-3-多对多模型" class="headerlink" title="4.2.3 多对多模型"></a>4.2.3 多对多模型</h4><p>多对多模型（见图4.4） 多路复用了许多用户线程到同样数量或更小数量的内核线程上。内核线程的数量可能与特定应用程序或特定机器有关（位于多处理器上的应用程序可比单处理器上分配更多数量的内核线程）。</p>
<p>虽然多对一模型允许开发人员创建任意多的用户线程， 但是因为内核只能一次调度一个线程， 所以并没有增加并发性。一对一模型提供了更大的并发性， 但是开发人员必须小心， 不要在应用程序内创建太多的线程（有时可能会限制创建线程的数量）。</p>
<p>多对多模型没有这两者的缺点：</p>
<ul>
<li><p>开发人员可创建任意多的用户线程，并且相应内核线程能在多处理器系统上并发执行。</p>
</li>
<li><p>而且，当一个线程执行阻塞系统调用时，内核能调度另一个线程来执行。</p>
</li>
</ul>
<p>一个流行的多对多模型的变种仍然多路复用了许多用户线程到同样数量或更小数量的内核线程上， 但也允许将一个用户线程绑定到某个内核线程上。这个变种有时被称为二级模型（见图4.5）</p>
<p><img src="/2021/11/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E5%BF%B5/image-20211114233616173.png" srcset="/img/loading.gif" lazyload alt="image-20211114233616173"></p>
<h3 id="4-3-线程库"><a href="#4-3-线程库" class="headerlink" title="4.3 线程库"></a>4.3 线程库</h3><p>线程库（也read library）为程序员提供创建和管理线程的API。</p>
<p>主要有两种方法来实现线程库。</p>
<ul>
<li>第一种方法是在用户空间中提供一个没有内核支持的库， 此库的所有代码和数据结构都存在于用户空间中。调用库中的一个函数只是导致了用户空间中的一个本地函数调<br>用， 而不是系统调用。</li>
<li>第二种方法是执行一个由操作系统直接支持的内核级的库。此时，库的代码和数据结构存在于内核空间中。调用库中的一个API 函数通常会导致对内核的系统调用。</li>
</ul>
<h4 id="4-3-1-Pthread"><a href="#4-3-1-Pthread" class="headerlink" title="4.3.1 Pthread"></a>4.3.1 Pthread</h4><h4 id="4-3-2-Win32线程"><a href="#4-3-2-Win32线程" class="headerlink" title="4.3.2 Win32线程"></a>4.3.2 Win32线程</h4><h4 id="4-3-3-Java线程"><a href="#4-3-3-Java线程" class="headerlink" title="4.3.3 Java线程"></a>4.3.3 Java线程</h4><h3 id="4-4-多线程问题"><a href="#4-4-多线程问题" class="headerlink" title="4.4 多线程问题"></a>4.4 多线程问题</h3><h4 id="4-4-1-系统调用fork-和exec"><a href="#4-4-1-系统调用fork-和exec" class="headerlink" title="4.4.1 系统调用fork()和exec()"></a>4.4.1 系统调用fork()和exec()</h4><h4 id="4-4-2-取消"><a href="#4-4-2-取消" class="headerlink" title="4.4.2 取消"></a>4.4.2 取消</h4><h4 id="4-4-3-信号处理"><a href="#4-4-3-信号处理" class="headerlink" title="4.4.3 信号处理"></a>4.4.3 信号处理</h4><h4 id="4-4-4-线程池"><a href="#4-4-4-线程池" class="headerlink" title="4.4.4 线程池"></a>4.4.4 线程池</h4><h4 id="4-4-5-线程特定数据"><a href="#4-4-5-线程特定数据" class="headerlink" title="4.4.5 线程特定数据"></a>4.4.5 线程特定数据</h4><h4 id="4-4-6-调度程序激活"><a href="#4-4-6-调度程序激活" class="headerlink" title="4.4.6 调度程序激活"></a>4.4.6 调度程序激活</h4><h3 id="4-5-操作系统实例"><a href="#4-5-操作系统实例" class="headerlink" title="4.5 操作系统实例"></a>4.5 操作系统实例</h3><h4 id="4-5-1-Windows-XP线程"><a href="#4-5-1-Windows-XP线程" class="headerlink" title="4.5.1 Windows XP线程"></a>4.5.1 Windows XP线程</h4><h4 id="4-5-2-Linux线程"><a href="#4-5-2-Linux线程" class="headerlink" title="4.5.2 Linux线程"></a>4.5.2 Linux线程</h4><h3 id="4-6-小结"><a href="#4-6-小结" class="headerlink" title="4.6 小结"></a>4.6 小结</h3><h3 id="4-7-习题"><a href="#4-7-习题" class="headerlink" title="4.7 习题"></a>4.7 习题</h3><p><strong>4.1 举两个多线程程序设计的例子， 其中多线程的性能比单线程的性能差。</strong></p>
<p><strong>4.2 描述线程库进行用户级线程上下文切换的过程所采取的措施。</strong></p>
<p><strong>4.3 在什么环境中， 采用多内核线程的多线程方法比单处理器系统的单线程提供更好的性能？</strong></p>
<p><strong>4.4 在多线程进程中， 下列哪些程序状态组成被共享？</strong><br><strong>a. 寄存器值</strong><br><strong>b. 堆内存</strong><br><strong>c. 全局变量</strong><br><strong>d. 栈内存</strong></p>
<blockquote>
<p>一个线程程序的线程共享<strong>堆内存</strong>和<strong>全局变量</strong>，但每个线程都有属于自己的一组<strong>寄存器值</strong>和<strong>栈内存</strong>。</p>
</blockquote>
<p><strong>4.5 使用多用户线程的多线程解决方案，在多处理器系统中可以比在单处理器系统中获得更好的性能吗？</strong></p>
<p>一个包括多用户线程的多线程系统无法在多处理系统上同时使用不同的处理器。操作系统只能看到一个单一的进程且不会调度在不同处剧器土的不同进程的线程。<br>因此， 多处理器系统执行多个用户线程是没有性能优势的。</p>
<p><strong>4.6 如4.5.2小节所介绍，Linux并不区分进程和线程，而是将两者同样对待，将一个任务视为进程或线程， 这取决于传递给clone（）系统调用的标志集。然而， 许多操作系统， 如Windows XP和Solaris,对待进程和线程是不一样的。通常， 这类系统使用标记， 其中进程的数据结构中包含指向属于进程的不同线程。试在内核中比较这两种对进程和线程建模的方法。</strong></p>
<h2 id="第5章-CPU调度"><a href="#第5章-CPU调度" class="headerlink" title="第5章 CPU调度"></a>第5章 CPU调度</h2><h3 id="5-1-基本概念"><a href="#5-1-基本概念" class="headerlink" title="5.1 基本概念"></a>5.1 基本概念</h3><p>多道程序的目标是在任何时候都有某些进程在运行，以使CPU使用率最大化。多道程序的思想较为简单。进程执行直到它必须等待， 通常等待某些I/O请求的完成。</p>
<p>当一个进程必须等待时， 操作系统会从该进程拿走CPU 的使用权，·而将CPU交给其他进程， 如此继续。在该进程必须等待的时间内，另一个进程就可以拿走CPU的使用权。</p>
<h4 id="5-1-1-CPU-I-O区间周期"><a href="#5-1-1-CPU-I-O区间周期" class="headerlink" title="5.1.1 CPU-I/O区间周期"></a>5.1.1 CPU-I/O区间周期</h4><p>CPU的成功调度依赖于进程的如下属性：进程执行由CPU执行和I/O等待周期组成。进程在这两个状态之间切换。</p>
<h4 id="5-1-2-CPU调度程序"><a href="#5-1-2-CPU调度程序" class="headerlink" title="5.1.2 CPU调度程序"></a>5.1.2 CPU调度程序</h4><p>每当CPU空闲时，操作系统就必须从就绪队列中选择一个进程来执行。进程选择由短期调度程序（ short-termscheduler）或CPU调度程序执行。调度程序从内存中选择一个能够执行的进程，并为之分配CPU。</p>
<h4 id="5-1-3-抢占调度"><a href="#5-1-3-抢占调度" class="headerlink" title="5.1.3 抢占调度"></a>5.1.3 抢占调度</h4><p>CPU调度决策可在如下4种环境下发生：</p>
<ul>
<li>当一个进程从运行状态切换到等待状态（例如，I/O请求，或调用wait等待一个子进程的终止〉。</li>
<li>当一个进程从运行状态切换到就绪状态（例如， 当出现中断时）。</li>
<li>当一个进程从等待状态切换到就绪状态（例如，νo完成）。</li>
<li>当一个进程终止时。</li>
</ul>
<p>对于第1 和第4 两种情况， 没有选择而只有调度。一个新进程（如果就绪队列中已有一个进程存在〉必须被选择执行。不过， 对于第2 和第3 两种情况， 可以进行选择。</p>
<p>当调度只能发生在第1 和第4 两种情况下时，称调度方案是<strong>非抢占的</strong>（ nonpreemptive)的或协作的（ cooperative）：否则， 称调度方案是<strong>抢占的</strong>（preemptive）。采用非抢占调度，一旦CPU 分配给一个进程，那么该进程会一直使用CPU 直到进程终止或切换到等待状态。</p>
<h4 id="5-1-4-分派程序"><a href="#5-1-4-分派程序" class="headerlink" title="5.1.4 分派程序"></a>5.1.4 分派程序</h4><p>分派程序是一个模块，用来将CPU 的控制交给由短期调度程序选择的进程。其功能包括：</p>
<ul>
<li>切换上下文。</li>
<li>切换到用户模式。</li>
<li>跳转到用户程序的合适位置， 以重新启动程序。</li>
</ul>
<p>分派程序应尽可能快， 因为在每次进程切换时都要使用。分派程序停止一个进程而启动另一个所要花的时间称为分派延迟（dispatch latency）。</p>
<h3 id="5-2-调度准则"><a href="#5-2-调度准则" class="headerlink" title="5.2 调度准则"></a>5.2 调度准则</h3><ul>
<li><strong>CPU 使用率</strong>： 需要使CPU 尽可能忙。从概念上讲， CPU 使用率从0%～100%。对于真实系统， 它应从40% C轻负荷系统）～90%（重负荷系统）。</li>
<li><strong>吞吐量</strong>：如果CPU 忙于执行进程，那么就有工作在完成。一种测量工作量的方法称为在吞吐量， 它指一个时间单元内所完成进程的数量。对于长进程，吞吐量可能为每小时一个进程：对于短进程， 吞吐量可能为每秒10 个进程。</li>
<li><strong>周转时间</strong>：从一个特定进程的角度来看， 一个重要准则是运行该进程需要多长时间。从进程提交到进程完成的时间段称为周转时间。周转时间为所有时间段之和， 包括等待进入内存、在就绪队列中等待、在CPU 上执行和νo执行。</li>
<li><strong>等待时间</strong>： CPU 调度算法并不影响进程运行和执行I/O的时间： 它只影响进程在就绪队列中等待所花的时间。等待时间为在就绪队列中等待所花费时间之和。</li>
<li><strong>响应时间</strong>： 对于交互系统， 周转时间并不是最佳准则。通常， 进程能相当早就产生输出， 并继续计算新结果同时输出以前的结果给用户。因此， 另一时间是从提交请求到产生第一响应的时间。这种时间称为响应时间， 是开始响应所需要的时间， 而不是输出响应所需要的时间。周转时间通常受输出设备速度的限制。</li>
</ul>
<p>需要使CPU 使用率和吞吐量最大化，而使周转时间、等待时间和响应时间最小化。</p>
<h3 id="5-3-调度算法"><a href="#5-3-调度算法" class="headerlink" title="5.3 调度算法"></a>5.3 调度算法</h3><h4 id="5-3-1-先到先服务调度（FCFS）"><a href="#5-3-1-先到先服务调度（FCFS）" class="headerlink" title="5.3.1 先到先服务调度（FCFS）"></a>5.3.1 先到先服务调度（FCFS）</h4><p><strong>first-come，first-served</strong></p>
<p>先请求CPU 的进程先分配到CPU。</p>
<p>FCFS是非抢占的</p>
<p><img src="/2021/11/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E5%BF%B5/image-20211103111439645.png" srcset="/img/loading.gif" lazyload alt="image-20211103111439645"></p>
<h4 id="5-3-2-最短作业优先调度-SJF"><a href="#5-3-2-最短作业优先调度-SJF" class="headerlink" title="5.3.2 最短作业优先调度(SJF)"></a>5.3.2 最短作业优先调度(SJF)</h4><p><strong>shortest job-first (SJF) scheduling algorithm</strong> </p>
<p>这一算法将每个进程与其下一个CPU 区间段相关联。当CPU 为空闲时，它会赋给具有最短CPU 区间的进程。</p>
<p><img src="/2021/11/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E5%BF%B5/image-20211103112112804.png" srcset="/img/loading.gif" lazyload alt="image-20211103112112804"></p>
<p>SJF 调度算法可证明为最佳的， 这是因为对于给定的一组进程， SJF 算法的平均等待时间最小。</p>
<p>SJF调度经常用于长期调度。</p>
<p>对于短期调度，一种方法是使用近似SJF调度，虽然不知道下一个CPU区间的长度，但是可以预测它。认为下一个CPU区间的长度与以前的相似。下一个CPU区间通常可预测为以前CPU区间的测量长度的指数平均。</p>
<p>SJF 算法可能是抢占的或非抢占的。</p>
<p>抢占SJF 调度有时称为<strong>最短剩余时间优先调度</strong>（shortest-remaining-time-first scheduling）。</p>
<p><img src="/2021/11/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E5%BF%B5/image-20211103113129077.png" srcset="/img/loading.gif" lazyload alt="image-20211103113129077"></p>
<h4 id="5-3-3-优先级调度"><a href="#5-3-3-优先级调度" class="headerlink" title="5.3.3 优先级调度"></a>5.3.3 优先级调度</h4><p><strong>priority scheduling algorithm</strong></p>
<p>每个进程都有一个优先级与其关联，具有最高优先级的进程会分配到CPU。具有相同优先级的进程按FCFS 顺序调度。SJF 算法属于简单优先级算法，其优先级（p） 为下一个（预测的） CPU 区间的倒数。</p>
<p><img src="/2021/11/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E5%BF%B5/image-20211103113523515.png" srcset="/img/loading.gif" lazyload alt="image-20211103113523515"></p>
<p>优先调度可以是<strong>抢占的或者非抢占</strong>的。当一个进程到达就绪队列时， 其优先级与当前运行进程的优先级相比较。如果新到达进程的优先级高于当前运行进程的优先级，那么抢占优先级调度算法会抢占CPU。而非抢占优先级调度算法只是将新进程加到就绪队列的头部。</p>
<p>优先级调度算法的一个主要问题是<strong>无穷阻塞</strong>（indefinite blocking）或饥饿（ starvation）。可以运行但缺乏CPU 的进程可认为是阻塞的，它在等待CPU。优先级调度算法会使某个低优先级进程无穷等待CPU。</p>
<p>低优先级进程无穷等待问题的解决之一是<strong>老化</strong>（aging）。老化是一种技术，以逐渐增加在系统中等待很长时间的进程的优先级。</p>
<h4 id="5-3-4-轮转法调度-RR"><a href="#5-3-4-轮转法调度-RR" class="headerlink" title="5.3.4 轮转法调度(RR)"></a>5.3.4 轮转法调度(RR)</h4><p>轮转法（round-robin, RR） 调度算法是专门为分时系统设计的。它类似于FCFS 调度，但是增加了抢占以切换进程。定义一个较小时间单元称为时间片（ time quantun, or time slice)。时间片通常为10~100ms。将就绪队列作为循环队列。CPU调度程序循环就绪队列为每个进程分配不超过ー个时间片的CPU。</p>
<p><img src="/2021/11/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E5%BF%B5/image-20211103114645373.png" srcset="/img/loading.gif" lazyload alt="image-20211103114645373"></p>
<p>RR算法的性能很大程度上依赖于时间片的大小。在极端情况下，如果时间片非常大，那么RR算法与FCFS算法一样，如果时间片很小(如1ms):那么R算法称为处理器共享。</p>
<h4 id="5-3-5-多级队列调度"><a href="#5-3-5-多级队列调度" class="headerlink" title="5.3.5 多级队列调度"></a>5.3.5 多级队列调度</h4><p><strong>多级队列调度算法</strong>（multilevel queue scheduling algori也m）将就绪队列分成多个独立队列（见图5.6〕。根据进程的属性， 如内存大小、进程优先级、进程类型， 一个进程被永久地分配到一个队列。每个队列有自己的调度算法。例如， 前台进程和后台进程可处于不同队列。前台队列可能采用RR 算法调度， 而后台队列可能采用FCFS 算法调度。</p>
<p>另外， 队列之间必须有调度， 通常采用固定优先级抢占调度。例如， 前台队列可以比后台队列具有绝对的优先级。且是抢占式的。</p>
<p>另一种可能是在队列之间划分时间片。每个队列都有一定的CPU时间，这可用于调度队列内的进程。例如， 对于前台－后台队列的例子， 前台队列可以有80%的CPU时间用于在进程之间进行RR调度， 而后台队列可以有20%的CPU时间采用FCFS算法调度进程。</p>
<p>优点是低调度开销， 缺点是不够灵活</p>
<h4 id="5-3-6-多级反馈队列调度"><a href="#5-3-6-多级反馈队列调度" class="headerlink" title="5.3.6 多级反馈队列调度"></a>5.3.6 多级反馈队列调度</h4><p><strong>多级反馈队列调度算法</strong>（multilevelfeedback queue scheduling a lgorithm）允许进程在队列之间移动。主要思想是根据不同CPU区间的特点以区分进程。如果进程使用过多CPU时间， 那么它会被转移到更低优先级队列。这种方案将I/O约束和交互进程留在更高优先级队列。此外， 在较低优先级队列中等待时间过长的进程会被转移到更高优先级队列。这种形式的老化阻止饥饿的发生。</p>
<h3 id="5-4-多处理器调度"><a href="#5-4-多处理器调度" class="headerlink" title="5.4 多处理器调度"></a>5.4 多处理器调度</h3><h4 id="5-4-1-多处理器调度的方法"><a href="#5-4-1-多处理器调度的方法" class="headerlink" title="5.4.1 多处理器调度的方法"></a>5.4.1 多处理器调度的方法</h4><p>一种是种<strong>非对称多处理</strong>（asymmetric multiprocessing）方法。是让一个处理器（主服务器）处理所有的调度决定、I/O处理以及其他系统活动， 其他的处理器只执行用户代码。</p>
<p>另一种方法是使用<strong>对称多处理</strong>（ symmetric multiprocessing, <strong>SMP</strong>）方法， 即每个处理器自我调度。所有进程可能处于一个共同的就绪队列中， 或每个处理器都有它自己的私有就绪进程队列。无论如何，调度通过每个处理器检查共同就绪队列并选择一个进程来执行。</p>
<h4 id="5-4-2-处理器亲和性"><a href="#5-4-2-处理器亲和性" class="headerlink" title="5.4.2 处理器亲和性"></a>5.4.2 处理器亲和性</h4><p>处理器亲和性有几种形式。当一个操作系统具有设法让一个进程保持在同一个处理器上运行的策略， 但不能做任何保证时， 则会出现<strong>软亲和性</strong>（ soft affinity ）。 此时， 进程可能<br>在处理器之间移动。有些系统， 如Linux， 还提供一个支持<strong>硬亲和性</strong>（ hard affinity） 的系统调用， 从而允许进程指定它不允许移至其他处理器上。</p>
<h4 id="5-4-3-负载平衡"><a href="#5-4-3-负载平衡" class="headerlink" title="5.4.3 负载平衡"></a>5.4.3 负载平衡</h4><h4 id="5-4-4-对称多线程"><a href="#5-4-4-对称多线程" class="headerlink" title="5.4.4 对称多线程"></a>5.4.4 对称多线程</h4><h3 id="5-5-线程调度"><a href="#5-5-线程调度" class="headerlink" title="5.5 线程调度"></a>5.5 线程调度</h3><h4 id="5-5-1-竞争范国"><a href="#5-5-1-竞争范国" class="headerlink" title="5.5.1 竞争范国"></a>5.5.1 竞争范国</h4><h4 id="5-5-2-Pthread调度"><a href="#5-5-2-Pthread调度" class="headerlink" title="5.5.2 Pthread调度"></a>5.5.2 Pthread调度</h4><h3 id="5-6-操作系统实例"><a href="#5-6-操作系统实例" class="headerlink" title="5.6 操作系统实例"></a>5.6 操作系统实例</h3><h4 id="5-6-1-实例：-Solaris调度"><a href="#5-6-1-实例：-Solaris调度" class="headerlink" title="5.6.1 实例： Solaris调度"></a>5.6.1 实例： Solaris调度</h4><h4 id="5-6-2-实例：-Windows-XP调度"><a href="#5-6-2-实例：-Windows-XP调度" class="headerlink" title="5.6.2 实例： Windows XP调度"></a>5.6.2 实例： Windows XP调度</h4><h4 id="5-6-3-实例：-Linux调度"><a href="#5-6-3-实例：-Linux调度" class="headerlink" title="5.6.3 实例： Linux调度"></a>5.6.3 实例： Linux调度</h4><h3 id="5-7-算法评估"><a href="#5-7-算法评估" class="headerlink" title="5.7 算法评估"></a>5.7 算法评估</h3><h4 id="5-7-1-确定模型"><a href="#5-7-1-确定模型" class="headerlink" title="5.7.1 确定模型"></a>5.7.1 确定模型</h4><p>一种类型的分析评估是确定模型法（ deterministic modeling）。这种方法采用特殊预先确定的负荷， 计算在给定负荷下每个算法的性能。</p>
<p>确定模型不但简单而且快速。它给出了数字， 以允许人们对算法进行比较。然而， 它要求输入为精确数字， 而且其答案只适用于这些情况。确定模型的主要用途在于描述调度算法和提供例子。</p>
<h4 id="5-7-2-排队模型"><a href="#5-7-2-排队模型" class="headerlink" title="5.7.2 排队模型"></a>5.7.2 排队模型</h4><p>知道了到达率和服务率， 可计算使用率、平均队列长度、平均等待时间等。这种研究称为排队网络分析（queueing-network analysis）。</p>
<p>作为一个例子， 设n为平均队列长度（不包括正在服务的进程）， w 为队列的平均等待时间，A为新进程到达队列的平均到达率（如每秒三个进程）。那么，在进程等待的W时间内， 则有λ ×w个新进程到达队列。如果系统处于稳定状态， 那么离开队列的进程的数量必须等于到达进程的数量。</p>
<p>因此，    <strong>n ＝ λ × W</strong><br>这一公式称为Little公式。Little 公式特别有用， 因为它适用于任何调度算法和到达分布。</p>
<h4 id="5-7-3-模拟"><a href="#5-7-3-模拟" class="headerlink" title="5.7.3 模拟"></a>5.7.3 模拟</h4><p>为了获得更为精确的调度算法评估， 可使用模拟（simulation）。模拟涉及对计算机系统进行建模。软件数据结构表示系统的主要组成部分。模拟程序有一个变量以表示时钟；当该变量的值增加时， 模拟程序会修改系统状态以反映设备、进程和调度程序的活动。随着模拟程序的执行， 用以表示算法性能的统计数字可以被收集并打印出来。</p>
<h4 id="5-7-4-实现"><a href="#5-7-4-实现" class="headerlink" title="5.7.4 实现"></a>5.7.4 实现</h4><p>针对评估调度算法， 唯一完全精确的方法是对它进行编程， 将它放在操作系统内， 并观测它如何工作。这一方法将真实算法放入操作系统，然后在真实操作系统内进行评估。</p>
<h3 id="5-8-小结"><a href="#5-8-小结" class="headerlink" title="5.8 小结"></a>5.8 小结</h3><p>CPU 调度的任务是从就绪队列中选择一个等待进程，并为其分配CPU。CPU由调度程序分配给所选中的进程。</p>
<p>先到先服务（FCFS）调度是最简单的调度算法，但是它会让短进程等待非常长的进程。</p>
<p>最短作业优先（ SJF ）调度可证明是最佳的，它提供了最短平均等待时间。实现SJF 调度比较困难，因为预测下一个CPU区间的长度有难度。SJF算法是通用优先级调度算法（将CPU 简单地分配给具有最高优先级的进程〉的特例。优先级和SJF调度会产生饥饿。老化技术可阻止饥饿。</p>
<p>轮转法（RR）调度对于分时（交互〉系统更为合适。RR调度让就绪队列的第一个进程使用CPU 的q个时间单元，这里q是时间片。在q时间单元之后，如果该进程还没有释放CPU，那么它被抢占并放到就绪队列的尾部。该算法的主要问题是选择时间片。如果时间片太大， 那么RR调度就成了FCFS调度；如果时间片太小， 那么因上下文切换而引起的调度开销就过大。</p>
<p>FCFS算法是非抢占的，而RR算法是抢占的。SJF和优先级算法可以是抢占的，也可以是非抢占的。</p>
<p>多级队列调度算法允许多个不同算法用于各种类型的进程。最为常用的模型包括使用眼调度的前台交互队列，以及使用FCFS 调度的后台批处理队列。多级反馈队列调度算法允许进程在队列之间迁移。</p>
<p>许多当前的计算机系统支持多处理器， 井允许每个处理器独立地调度它自己。通常，每个处理器维护自己的私有进程（或线程）队列， 它们都可以运行。与多处理器调度相关<br>的问题包括处理器亲和性和负载平衡。</p>
<p>如果操作系统在内核级支持线程， 那么必须调度线程而不是进程来执行。Solaris和Windows XP就是这样的系统， 它们采用抢占的、基于优先级的调度算法， 并支持实时线程。Linux进程调度也使用基于优先级算法， 并提供实时支持。这三种操作系统通常偏爱交互进程而不是批处理进程或CPU 约束进程。</p>
<p>因为有多种不同的调度算法可用， 所以需要某种方法来选择它们。分析方法使用数学分析以确定算法性能。模拟方法通过对代表性的进程采用调度算法模拟并计算其性能来确定优劣。不过， 模拟最多也只是提供对真实系统性能的近似， 评估调度算法唯一可靠的技术是在真实系统上的实现算法并在真实环境中进行性能跟踪。</p>
<h3 id="5-9-习题"><a href="#5-9-习题" class="headerlink" title="5.9 习题"></a>5.9 习题</h3><p><strong>5.1 为什么对调度来说，区分I/0 限制的程序和CPU 限制的程序是重要的？</strong></p>
<blockquote>
<p>I /0 限制的程序有在运行I /0 操作前只运行很少数量的计算机操作的性质。这种程序一般来说不会使用很多的CPU。 但是 CPU 限制的程序会利用整个的时间片，且不做任何阻碍I/0 操作的工作。</p>
<p>I/O约束程序通常具有很多短CPU区间。CPU约束程序可能有少量的长CPU区间。</p>
<p>因此，通过给I/0 限制的程序优先权和允许在CPU 限制的程序之前运行， 可以很好的利用计算机资源</p>
</blockquote>
<p><strong>5.10 解释下面调度算法对短进程偏好程度上的区别：</strong><br><strong>a. FCFS</strong><br><strong>b. RR</strong><br><strong>c. 多级反馈队列</strong></p>
<blockquote>
<p>a. FCFS一一区别短任务是因为任何在长任务之后到达的短任务部将会有很长的等待时间.<br>b. RR一一对所有的任务都是能够相同的（给它们相同的CPU 时间区间） ， 所以， 短任务可以很快的离开系统， 只要它们可以先完成．<br>c . 多级反馈队列和RR 调度算法相似一一它们不会先选择短任务。</p>
</blockquote>
<h2 id="第6章进程同步"><a href="#第6章进程同步" class="headerlink" title="第6章进程同步"></a>第6章进程同步</h2><h3 id="6-1-背景"><a href="#6-1-背景" class="headerlink" title="6.1 背景"></a>6.1 背景</h3><p>允许两个进程并发操作变量counter会得到不正确的状态。</p>
<p>多个进程并发访问和操作同一数据且执行结果与访问发生的特定顺序有关， 称为竞争条件（race condition）。为了避免竞争条件， 需要确保一段时间内只有一个进程能操作变量counter。为了实现这种保证， 要求进行一定形式的进程同步。</p>
<h3 id="6-2-临界区问题"><a href="#6-2-临界区问题" class="headerlink" title="6.2 临界区问题"></a>6.2 临界区问题</h3><p>每个进程有一个代码段称为<strong>临界区</strong>（critical section）， 在该区中进程可能改变共同变量、更新一个表、写一个文件等。</p>
<p>这种系统的<strong>重要特征</strong>是当一个进程进入临界区， 没有其他进程可被允许在临界区内执行， 即没有两个进程可同时在临界区内执行。</p>
<p><strong>临界区问题</strong>(critical-section problem ） 是设计一个以便进程协作的协议。每个进程必须请求允许进入其<strong>临界区</strong>。实现这一请求的代码段称为<strong>进入区</strong>（entry section）， 临界区之后可有<strong>退出区</strong>（exit section）， 其他代码为剩余区（remainder section）。</p>
<p><img src="/2021/11/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E5%BF%B5/image-20211116161533895.png" srcset="/img/loading.gif" lazyload alt="image-20211116161533895"></p>
<p>临界区问题的解答必须满足如下三项要求：</p>
<ul>
<li><strong>互斥</strong>（mutual exclusion）： 如果进程P； 在其临界区<br>内执行， 那么其他进程都不能在其临界区内执行。</li>
<li><strong>有空让进</strong>（progress）： 如果没有进程在其临界区内执行，且有进程需进入临界区，那么只有那些不在剩余区内执行<br>的进程可参加选择， 以确定谁能下一个进入临界区， 且这种选择不能无限推迟。</li>
<li><strong>有限等待</strong>(bounded waiting）：从一个进程做出进入临界区的请求， 直到该请求允许为止， 其他进程允许进入其临界区的次数有上限。</li>
</ul>
<h3 id="6-3-Peterson算法"><a href="#6-3-Peterson算法" class="headerlink" title="6.3 Peterson算法"></a>6.3 Peterson算法</h3><p><img src="/2021/11/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E5%BF%B5/image-20211116161739706.png" srcset="/img/loading.gif" lazyload alt="image-20211116161739706"></p>
<h3 id="6-3-0-面包师算法"><a href="#6-3-0-面包师算法" class="headerlink" title="6.3.0 面包师算法"></a>6.3.0 面包师算法</h3><p><img src="/2021/11/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E5%BF%B5/image-20211116161850602.png" srcset="/img/loading.gif" lazyload alt="image-20211116161850602"></p>
<p><img src="/2021/11/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E5%BF%B5/image-20211116161908057.png" srcset="/img/loading.gif" lazyload alt="image-20211116161908057"></p>
<h3 id="6-4-硬件同步"><a href="#6-4-硬件同步" class="headerlink" title="6.4 硬件同步"></a>6.4 硬件同步</h3><p>TestAndSet()</p>
<img src="/2021/11/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E5%BF%B5/image-20211116162032902.png" srcset="/img/loading.gif" lazyload alt="image-20211116162032902">

<p>Swap()</p>
<p><img src="/2021/11/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E5%BF%B5/image-20211116162152258.png" srcset="/img/loading.gif" lazyload alt="image-20211116162152258"></p>
<p>上面两种算法未解决互斥</p>
<p>boolean waiting[n];<br>boolean lock;</p>
<p>这些数据结构均初始化false。</p>
<p><img src="/2021/11/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E5%BF%B5/image-20211116162305381.png" srcset="/img/loading.gif" lazyload alt="image-20211116162305381"></p>
<ul>
<li><p>互斥</p>
<p>为了证明满足互斥要求，注意，只有waiting[i]==false 或key==flase 时， 进程P<del>i</del> 才进入临界区。只有当TestAndSet执行时， key的值才变成false。执行TestAndSet的第一个进程会发现key==false；所有其他进程必须等待。只有其他进程离开其临界区时，变量waiting[i］的值才能变成false：每次只有一个waiting[i］被设置为false,以满足互斥要求。</p>
</li>
<li><p>有空让进</p>
<p>任何一个已经进入CS的进程在“exit section” 时，设置：lock =false 或 waiting[ j ]= false，确保了至少可以让一个进程进入CS</p>
</li>
<li><p>有限等待条件</p>
<p>任何一个已经进入CS的进程Pi在“exit section” 时， 将会依次扫描waiting 数组（i+1,i+2,…n-1,0,…i-1)，并仅将Pi后面最先找到的进程j的waiting[ j]设置为false</p>
<p>这就使进程能依此循环进入CS</p>
</li>
</ul>
<p><strong>硬件指令实现的缺点</strong></p>
<ul>
<li>硬件指令虽然可以有效地保证进程间互斥，但有一个缺点，就是当进程正在临界段中执行时，其它想进入临界段的进程必须不断地测试布尔变量lock的值，这就造成了处理机机时的浪费，我们常称这种情况为“忙等待”</li>
<li>可能“饥饿”<strong>：</strong>如果从等待进程中随机选择一个进入临界区<strong>，</strong>有的进程可能一直选不上<strong>。</strong></li>
</ul>
<h3 id="6-5-信号量"><a href="#6-5-信号量" class="headerlink" title="6.5 信号量"></a>6.5 信号量</h3><p>信号量S是个整数变量，除了初始化外，它只能通过两个标准原子操作：wait()和signal()来访问。</p>
<p><img src="/2021/11/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E5%BF%B5/image-20211116162927219.png" srcset="/img/loading.gif" lazyload alt="image-20211116162927219"></p>
<h4 id="6-5-1-用法"><a href="#6-5-1-用法" class="headerlink" title="6.5.1 用法"></a>6.5.1 用法</h4><p><img src="/2021/11/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E5%BF%B5/image-20211116163758185.png" srcset="/img/loading.gif" lazyload alt="image-20211116163758185"></p>
<h4 id="6-5-2-实现"><a href="#6-5-2-实现" class="headerlink" title="6.5.2 实现"></a>6.5.2 实现</h4><p>信号量的主要缺点是都要求<strong>忙等待</strong>（busy waiting）。当一个进程位于其临界区内时， 任何其他试图进入其临界区的进程都必须在其进入代码中连续地循环。这种类型的信号量也称<br>为<strong>自旋锁</strong>（spinlock）</p>
<p>为了克服忙等， 可以修改信号量操作wait()和signal()的定义。当一个进程执行wait()操作时， 发现信号量值不为正， 则它必须等待。然而， 该进程不是忙等而是阻塞自己。阻塞操作将一个进程放入到与信号量相关的等待队列中，井将该进程的状态切换成等待状态。接着， 控制转到CPU调度程序， 以选择另一个进程来执行。</p>
<p>一个被阻塞在等待信号量S上的进程，可以在其他进程执行signal()操作之后被重新执行。该进程的重新执行是通过wakeup()操作来进行的， 该操作将进程从等待状态切换到就<br>绪状态。接着， 该进程被放入到就绪队列中（根据CPU调度算法的不同，CPU有可能会、也可能不会从正在运行的进程切换到刚刚就绪的进程）。</p>
<p><img src="/2021/11/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E5%BF%B5/image-20211116164332005.png" srcset="/img/loading.gif" lazyload alt="image-20211116164332005"></p>
<p><img src="/2021/11/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E5%BF%B5/image-20211116164343388.png" srcset="/img/loading.gif" lazyload alt="image-20211116164343388"></p>
<p><img src="/2021/11/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E5%BF%B5/image-20211116165105798.png" srcset="/img/loading.gif" lazyload alt="image-20211116165105798"></p>
<h4 id="6-5-3-死锁与饥饿"><a href="#6-5-3-死锁与饥饿" class="headerlink" title="6.5.3 死锁与饥饿"></a>6.5.3 死锁与饥饿</h4><p><strong>死锁</strong>：两个或多个进程无限地等待一个事件，而该事件只能由这些等待进程之一来产生。这里的事件是signal()操作的执行。当出现这样的状态时， 这些进程就称为死锁（deadlocked）。</p>
<p><strong>无限期阻塞</strong>(indefinite blocking）或<strong>饥饿</strong>（starvation）：即进程在信号量内无限期等待。如果对与信号量相关的链表按LIFO顺序来增加和移动进程，<br>那么可能会发生无限期阻塞。</p>
<h4 id="6-5-4-信号量小结"><a href="#6-5-4-信号量小结" class="headerlink" title="6.5.4 信号量小结"></a>6.5.4 信号量小结</h4><ol>
<li><p><strong>信号量的物理含义：</strong></p>
<p> <strong>S&gt;0：</strong>表示有S个资源可用</p>
<p> <strong>S=0：</strong>表示无资源可用</p>
<p> <strong>S&lt;0：</strong>则|S|表示S等待队列中的进程个数</p>
<p> <strong>P(S)：</strong>表示申请一个资源</p>
<p> <strong>V(S)：</strong>表示释放一个资源。</p>
</li>
<li><p><strong>P.V操作必须成对出现，有一个P操作就一定有一个V操作</strong></p>
<p> 当为<strong>互斥操作</strong>时，它们同处于同一进程</p>
<p> 当为<strong>同步操作</strong>时，则不在同一进程中出现</p>
<p> 如果P(S1)和P(S2)两个操作在一起，那么P操作的顺序至关重要,一个同步P操作与一个互斥P操作在一起时，同步P操作在互斥P操作前。</p>
<p> 而两个V操作无关紧要</p>
</li>
<li><p><strong>P.V操作的优缺点</strong></p>
<ul>
<li>优点：简单，而且表达能力强（用P.V操作可解决任何同步互斥问题）</li>
<li>缺点：不够安全；P.V操作使用不当会出现死锁；遇到复杂同步互斥问题时实现复杂</li>
</ul>
</li>
</ol>
<p> <strong>而两个V操作无关紧要</strong></p>
<h3 id="6-6-经典同步问题"><a href="#6-6-经典同步问题" class="headerlink" title="6.6 经典同步问题"></a>6.6 经典同步问题</h3><p>使用PV操作完成进程间的<strong>同步与互斥步骤</strong>：</p>
<ol>
<li>分析同步关系（制约关系）</li>
<li>设置信号量（一般情况下，有几项制约条件就应设置几个信号量）</li>
<li>选择并确定信号量的初值（初值和初始可用资源有关）</li>
<li>利用PV操作写出同步关系。</li>
</ol>
<h4 id="6-6-1-有限缓冲问题"><a href="#6-6-1-有限缓冲问题" class="headerlink" title="6.6.1 有限缓冲问题"></a>6.6.1 有限缓冲问题</h4><p><img src="/2021/11/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E5%BF%B5/image-20211116164843159.png" srcset="/img/loading.gif" lazyload alt="image-20211116164843159"></p>
<p>下图会发生死锁，生产者一直等待</p>
<p><img src="/2021/11/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E5%BF%B5/image-20211116165556108.png" srcset="/img/loading.gif" lazyload alt="image-20211116165556108"></p>
<h4 id="6-6-2-读者写者问题"><a href="#6-6-2-读者写者问题" class="headerlink" title="6.6.2 读者写者问题"></a>6.6.2 读者写者问题</h4><p><strong>制约条件分析：</strong></p>
<p>1、允许多个进程同时读文件（读－读允许）；<br>2、不允许在进程读文件时让另外一进程去写文件；有进程在写文件时不让另外一个进程去读该文件（“读-写”互斥）；<br>3、不允许多个写进程同时写同一文件（“写-写”互斥）。</p>
<h5 id="读者优先："><a href="#读者优先：" class="headerlink" title="读者优先："></a><strong>读者优先：</strong></h5><p>只要不断的有读者来读，那么readcount就一直会大于0，那么永远不会触发signal(wrt)条件，从而导致写者饥饿。</p>
<p>该问题被称为第一读者优先问题 </p>
<p><img src="/2021/11/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E5%BF%B5/image-20211116170507558.png" srcset="/img/loading.gif" lazyload alt="image-20211116170507558"></p>
<h5 id="写者优先"><a href="#写者优先" class="headerlink" title="写者优先:"></a><strong>写者优先:</strong></h5><p>1.写者线程的优先级高于读者线程。<br>2.当写者到来时，只有那些已经获得授权的读进程才被允许完成它们的操作，写者之后到来的读者将被推迟，直到写者完成。<br>3.当没有写者进程时读者进程应该能够同时读取文件。</p>
<p><strong>具体实现:</strong><br>1.通过添加信号量<code>read</code>实现写者到来时能够阻止读者进程。<br>2.设置信号量<code>fileSrc</code>实现读写者对临界资源的访问。<br>3.设置计数器<code>writeCount</code>来统计当前阻塞的写者进程的数目，设置信号量<code>writeCountSignal</code>完成对<code>writeCount</code>计数器资源的互斥访问。<br>4.设置计数器<code>readCount</code>来统计访问临界资源的读者数目，设置信号量<code>readCountSignal</code>完成对<code>readCount</code>计数器资源的互斥访问。</p>
<p><img src="/2021/11/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E5%BF%B5/image-20211116170755343.png" srcset="/img/loading.gif" lazyload alt="image-20211116170755343"></p>
<h5 id="读者写者公平竞争："><a href="#读者写者公平竞争：" class="headerlink" title="读者写者公平竞争："></a>读者写者公平竞争：</h5><ol>
<li>优先级相同。</li>
<li>写者、读者互斥访问。</li>
<li>只能有一个写者访问临界区。</li>
<li>可以有多个读者同时访问临界资源。</li>
</ol>
<p><strong>具体实现:</strong></p>
<ol>
<li>设置<code>file</code>信号量实现对临界资源的互斥访问。</li>
<li>设置计数器<code>readCount</code>实现多个读者访问临界资源，通过设置信号量<code>readCountSignal</code>实现对<code>readCount</code>计数器的互斥访问。</li>
<li>设置信号量<code>keySignal</code>实现读者和写者的公平竞争（令牌）。</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/* 读者队列初始值为0，其他资源初始值为1*/</span><br><span class="hljs-keyword">int</span> readCount = <span class="hljs-number">0</span>;<br>semaphore keySignal = <span class="hljs-number">1</span>;<br>semaphore fileSrc = <span class="hljs-number">1</span>;<br>semaphore readCountSignal = <span class="hljs-number">1</span>;<br><br><span class="hljs-built_in">reader</span>()<br>&#123;<br>    <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)<br>    &#123;<br>      <span class="hljs-built_in">wait</span>(keySignal);        <span class="hljs-comment">//申请令牌</span><br>      <span class="hljs-built_in">wait</span>(readCountSignal);  <span class="hljs-comment">//申请计数器资源</span><br>      <span class="hljs-keyword">if</span>(!readCount)          <span class="hljs-comment">//为零则申请文件资源</span><br>         <span class="hljs-built_in">wait</span>(fileSrc);<br>      readCount++;<br>      <span class="hljs-built_in">signal</span>(readCountSignal); <span class="hljs-comment">//释放计数器资源</span><br>      <span class="hljs-built_in">signal</span>(keySignal);      <span class="hljs-comment">//释放令牌</span><br> <br>      ...<br>      perform read operation  <span class="hljs-comment">//执行临界区代码</span><br>      ...<br>  <br>      <span class="hljs-built_in">wait</span>(readCountSignal);  <span class="hljs-comment">//申请计数器资源</span><br>      readCount--;<br>      <span class="hljs-keyword">if</span>(!readCount)                <span class="hljs-comment">//为零则释放文件资源</span><br>         <span class="hljs-built_in">signal</span>(fileSrc);<br>      <span class="hljs-built_in">signal</span>(readCountSignal); <span class="hljs-comment">//释放读者计数器资源</span><br>    &#125;<br>&#125;<br> <br><span class="hljs-built_in">writer</span>()<br>&#123;<br>     <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)<br>     &#123;<br>        <span class="hljs-built_in">wait</span>(keySignal);     <span class="hljs-comment">//申请令牌</span><br>        <span class="hljs-built_in">wait</span>(fileSrc);       <span class="hljs-comment">//申请文件资源</span><br> <br>        ...<br>        perform write operation <span class="hljs-comment">//执行临界区代码</span><br>        ...<br> <br>        <span class="hljs-built_in">signal</span>(fileSrc);   <span class="hljs-comment">//释放文件资源</span><br>        <span class="hljs-built_in">signal</span>(keysignal); <span class="hljs-comment">//释放令牌</span><br>     &#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<h4 id="6-6-3-哲学家进餐回题"><a href="#6-6-3-哲学家进餐回题" class="headerlink" title="6.6.3 哲学家进餐回题"></a>6.6.3 哲学家进餐回题</h4><p><img src="/2021/11/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E5%BF%B5/image-20211116170946819.png" srcset="/img/loading.gif" lazyload alt="image-20211116170946819"></p>
<p><strong>死锁解决方法：</strong></p>
<ul>
<li>至多只允许四位哲学家同时去拿左边的筷子；</li>
<li>仅当哲学家左右两边的筷子均可用时才允许他拿起筷子；</li>
<li>规定奇数号哲学家先拿起他左边的筷子，而偶数号哲学家先拿起他右边的筷子。</li>
</ul>
<p><img src="/2021/11/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E5%BF%B5/image-20211116171117548.png" srcset="/img/loading.gif" lazyload alt="image-20211116171117548"></p>
<p><img src="/2021/11/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E5%BF%B5/image-20211116171127875.png" srcset="/img/loading.gif" lazyload alt="image-20211116171127875"></p>
<h3 id="6-7-管程"><a href="#6-7-管程" class="headerlink" title="6.7 管程"></a>6.7 管程</h3><h4 id="6-7-1-使用"><a href="#6-7-1-使用" class="headerlink" title="6.7.1 使用"></a>6.7.1 使用</h4><h4 id="6-7-2-哲学家进餐问题的管程解决方案"><a href="#6-7-2-哲学家进餐问题的管程解决方案" class="headerlink" title="6.7.2 哲学家进餐问题的管程解决方案"></a>6.7.2 哲学家进餐问题的管程解决方案</h4><h4 id="6-7-3-基于信号量的管程实现"><a href="#6-7-3-基于信号量的管程实现" class="headerlink" title="6.7.3 基于信号量的管程实现"></a>6.7.3 基于信号量的管程实现</h4><h4 id="6-7-4-管程内的进程重启"><a href="#6-7-4-管程内的进程重启" class="headerlink" title="6.7.4 管程内的进程重启"></a>6.7.4 管程内的进程重启</h4><h3 id="6-8-同步实例"><a href="#6-8-同步实例" class="headerlink" title="6.8 同步实例"></a>6.8 同步实例</h3><h4 id="6-8-1-Solaris同步"><a href="#6-8-1-Solaris同步" class="headerlink" title="6.8.1 Solaris同步"></a>6.8.1 Solaris同步</h4><h4 id="6-8-2-Windows-XP同步"><a href="#6-8-2-Windows-XP同步" class="headerlink" title="6.8.2 Windows XP同步"></a>6.8.2 Windows XP同步</h4><h4 id="6-8-3-Linux同步"><a href="#6-8-3-Linux同步" class="headerlink" title="6.8.3 Linux同步"></a>6.8.3 Linux同步</h4><h4 id="6-8-4-Pthread同步"><a href="#6-8-4-Pthread同步" class="headerlink" title="6.8.4 Pthread同步"></a>6.8.4 Pthread同步</h4><h3 id="6-9-原子事务"><a href="#6-9-原子事务" class="headerlink" title="6.9 原子事务"></a>6.9 原子事务</h3><h4 id="6-9-1-系统模型"><a href="#6-9-1-系统模型" class="headerlink" title="6.9.1 系统模型"></a>6.9.1 系统模型</h4><h4 id="6-9-2-基于日志的恢复"><a href="#6-9-2-基于日志的恢复" class="headerlink" title="6.9.2 基于日志的恢复"></a>6.9.2 基于日志的恢复</h4><h4 id="6-9-3-检查点"><a href="#6-9-3-检查点" class="headerlink" title="6.9.3 检查点"></a>6.9.3 检查点</h4><h4 id="6-9-4-并发原子操作"><a href="#6-9-4-并发原子操作" class="headerlink" title="6.9.4 并发原子操作"></a>6.9.4 并发原子操作</h4><h3 id="6-10-小结"><a href="#6-10-小结" class="headerlink" title="6.10 小结"></a>6.10 小结</h3><h3 id="6-11-习题"><a href="#6-11-习题" class="headerlink" title="6.11 习题"></a>6.11 习题</h3><p><strong>试分析说明为何自旋锁（spinlocks）不适合单处理器系统但却常用于多处理器系统</strong></p>
<blockquote>
<p>解答：<br>自旋锁（进程在其等待锁时还在运行）的缺点是忙等待，当一个进程位于其临界区内时，任何其它试图进入其临界区的进程都必须在其进入代码中连续地循环。在单处理器系统中，忙等待浪费了CPU时钟（这些时钟本来可以有效地为其他进程所使用）。<br>自旋锁的优点就是，进程在等待锁时不会进行上下文切换，而上下文切换可能需要花费相当长的时间。因此，如果锁的占用时间短，自旋锁就可以变得非常有用。它常常用于多处理器系统中，这样一个线程在一个处理器自旋时，另一线程可在另一处理器上在其临界区内执行。</p>
</blockquote>

            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                  <div class="post-meta mr-3">
                    <i class="iconfont icon-category"></i>
                    
                      <a class="hover-with-bg" href="/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">操作系统</a>
                    
                  </div>
                
                
                  <div class="post-meta">
                    <i class="iconfont icon-tags"></i>
                    
                      <a class="hover-with-bg" href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">操作系统</a>
                    
                  </div>
                
              </div>
              
                <p class="note note-warning">
                  
                    本博客所有文章除特别声明外，著作权归作者所有，转载请注明出处！
                  
                </p>
              
              
                <div class="post-prevnext">
                  <article class="post-prev col-6">
                    
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2021/10/29/Shellshock_Attack_lab/">
                        <span class="hidden-mobile">Shellshock Attack lab</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
              <!-- Comments -->
              <article class="comments" id="comments" lazyload>
                
                  
                
                
  <div class="disqus" style="width:100%">
    <div id="disqus_thread"></div>
    
      <script type="text/javascript">
        var disqus_config = function() {
          this.page.url = 'http://example.com/2021/11/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E5%BF%B5/';
          this.page.identifier = '/2021/11/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E5%BF%B5/';
        };
        Fluid.utils.loadComments('#disqus_thread', function() {
          var d = document, s = d.createElement('script');
          s.src = '//' + 'fluid' + '.disqus.com/embed.js';
          s.setAttribute('data-timestamp', new Date());
          (d.head || d.body).appendChild(s);
        });
      </script>
    
    <noscript>Please enable JavaScript to view the comments</noscript>
  </div>


              </article>
            
          </article>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    

    
      <a id="scroll-top-button" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
    

    
  </main>

  <footer class="text-center mt-5 py-3">
  <div class="footer-content">
     <a  rel="nofollow noopener"><span>Copyrights © 2021</span></a> <i class="iconfont icon-love"></i> <a  target="_blank" rel="nofollow noopener"><span>Zino</span></a> 
  </div>
  
  <div class="statistics">
    
    

    
      
        <!-- 不蒜子统计PV -->
        <span id="busuanzi_container_site_pv" style="display: none">
            总访问量 
            <span id="busuanzi_value_site_pv"></span>
             次
          </span>
      
      
        <!-- 不蒜子统计UV -->
        <span id="busuanzi_container_site_uv" style="display: none">
            总访客数 
            <span id="busuanzi_value_site_uv"></span>
             人
          </span>
      
    
  </div>


  

  
  <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?d1745c2e21adaa6ae90b93f4f4d22da9";
      var s = document.getElementsByTagName("script")[0]; 
      s.parentNode.insertBefore(hm, s);
    })();
    </script>
    
</footer>


  <!-- SCRIPTS -->
  
  <script  src="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" ></script>
<script  src="https://cdn.jsdelivr.net/npm/bootstrap@4.6.0/dist/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>

<!-- Plugins -->


  
    <script  src="/js/img-lazyload.js" ></script>
  



  



  <script  src="https://cdn.jsdelivr.net/npm/tocbot@4.12.3/dist/tocbot.min.js" ></script>



  <script  src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js" ></script>



  <script  src="https://cdn.jsdelivr.net/npm/anchor-js@4.3.1/anchor.min.js" ></script>



  <script defer src="https://cdn.jsdelivr.net/npm/clipboard@2.0.8/dist/clipboard.min.js" ></script>



  <script  src="/js/local-search.js" ></script>



  <script defer src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" ></script>




  <script  src="https://cdn.jsdelivr.net/npm/typed.js@2.0.12/lib/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var title = document.getElementById('subtitle').title;
      
      typing(title)
      
    })(window, document);
  </script>












  
    <!-- Baidu Analytics -->
    <script defer>
      var _hmt = _hmt || [];
      (function () {
        var hm = document.createElement("script");
        hm.src = "https://hm.baidu.com/hm.js?d1745c2e21adaa6ae90b93f4f4d22da9";
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(hm, s);
      })();
    </script>
  

  

  

  

  

  





<!-- 主题的启动项 保持在最底部 -->
<script  src="/js/boot.js" ></script>


</body>
</html>
