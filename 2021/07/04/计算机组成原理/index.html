

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=&#34;auto&#34;>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/favicon.jpg">
  <link rel="icon" href="/img/favicon.jpg">
  <meta name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="description" content="学习计算机系统课程过程中的笔记">
  <meta name="author" content="John Doe">
  <meta name="keywords" content="">
  
  <title>计算机系统笔记 - Hexo</title>

  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.6.0/dist/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/github-markdown-css@4.0.0/github-markdown.min.css" />
  <link  rel="stylesheet" href="/lib/hint/hint.min.css" />

  
    
    
      
      <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@10.7.2/styles/github-gist.min.css" />
    
  

  
    <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css" />
  



<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_kmeydafke9r.css">


<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->


  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    var CONFIG = {"hostname":"example.com","root":"/","version":"1.8.11","typing":{"enable":true,"typeSpeed":70,"cursorChar":"","loop":false},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"copy_btn":true,"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":1},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":true,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null}},"search_path":"/local-search.xml"};
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
<meta name="generator" content="Hexo 5.4.0"></head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand"
       href="/">&nbsp;<strong>Zino's Blog</strong>&nbsp;</a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" data-toggle="modal" data-target="#modalSearch">&nbsp;<i
                class="iconfont icon-search"></i>&nbsp;</a>
          </li>
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="banner" id="banner" parallax=true
         style="background: url('/img/post.jpg') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="page-header text-center fade-in-up">
            <span class="h2" id="subtitle" title="计算机系统笔记">
              
            </span>

            
              <div class="mt-3">
  
  
    <span class="post-meta">
      <i class="iconfont icon-date-fill" aria-hidden="true"></i>
      <time datetime="2021-07-04 20:00" pubdate>
        2021年7月4日 晚上
      </time>
    </span>
  
</div>

<div class="mt-1">
  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      19.8k 字
    </span>
  

  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      209
       分钟
    </span>
  

  
  
    
      <!-- 不蒜子统计文章PV -->
      <span id="busuanzi_container_page_pv" style="display: none">
        <i class="iconfont icon-eye" aria-hidden="true"></i>
        <span id="busuanzi_value_page_pv"></span> 次
      </span>
    
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">计算机系统笔记</h1>
            
            <div class="markdown-body">
              <h1 id="计算机组成原理"><a href="#计算机组成原理" class="headerlink" title="计算机组成原理"></a>计算机组成原理</h1><h2 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h2><p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210414171144939.png" srcset="/img/loading.gif" lazyload alt="image-20210414171144939"></p>
<p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210414171238561.png" srcset="/img/loading.gif" lazyload alt="image-20210414171238561"></p>
<ul>
<li><p>终端</p>
<p>.c  -&gt;  .i    (预处理)           gcc -E hello.c -o hello.i    </p>
<p>.i   -&gt;  .s（汇编语言）     gcc -S hello.o -o hello.s</p>
<p>.s  -&gt;  .o（机器代码）     gcc -c  hello.o -o hello.o</p>
<p>查看.o    objdump hello.o  </p>
<p>变成可执行文件（链接）   gcc hello.o -o hello</p>
</li>
</ul>
<hr>
<h2 id="第二章-汇编入门"><a href="#第二章-汇编入门" class="headerlink" title="第二章 汇编入门"></a>第二章 汇编入门</h2><h3 id="通用寄存器"><a href="#通用寄存器" class="headerlink" title="通用寄存器"></a>通用寄存器</h3><p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210315165706496.png" srcset="/img/loading.gif" lazyload alt="image-20210315165706496"></p>
<p><img src="https://gitee.com/zino00/img_bed/raw/master/img/image-20210316104330207.png" srcset="/img/loading.gif" lazyload alt="image-20210316104330207"></p>
<h3 id="数据传送"><a href="#数据传送" class="headerlink" title="数据传送"></a>数据传送</h3><p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210315165822191.png" srcset="/img/loading.gif" lazyload alt="image-20210315165822191"></p>
<h3 id="寻址方式"><a href="#寻址方式" class="headerlink" title="寻址方式"></a>寻址方式</h3><p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210316111854447.png" srcset="/img/loading.gif" lazyload alt="image-20210316111854447"></p>
<p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210316112953982.png" srcset="/img/loading.gif" lazyload></p>
<h3 id="gdb-x-命令详解"><a href="#gdb-x-命令详解" class="headerlink" title="gdb x 命令详解"></a>gdb x 命令详解</h3><p>格式：x/&lt;n/f/u&gt; <addr></addr></p>
<p><strong>n</strong>:</p>
<p>是正整数，表示需要显示的内存单元的个数，即从当前地址向后显示n个内存单元的内容，一个内存单元的大小由第三个参数u定义。</p>
<p><strong>f</strong>:</p>
<p>表示addr指向的内存内容的输出格式，s对应输出字符串，此处需特别注意输出整型数据的格式：</p>
<p>x 按十六进制格式显示变量。</p>
<p>d 按十进制格式显示变量。</p>
<p>u 按十六进制格式显示无符号整型。</p>
<p>o 按八进制格式显示变量。</p>
<p>t 按二进制格式显示变量。</p>
<p>a 按十六进制格式显示变量。</p>
<p>c 按字符格式显示变量。</p>
<p>f 按浮点数格式显示变量。</p>
<p><strong>u</strong>:</p>
<p>就是指以多少个字节作为一个内存单元-unit,默认为4。当然u还可以用被一些字符表示，如b=1 byte, h=2 bytes,w=4 bytes,g=8 bytes.<br><addr>:表示内存地址。</addr></p>
<p>整合这个命令的诠释：就是以addr为起始地址，返回n个单元的值，每个单元对应u个字节，输出格式是f。</p>
<p>如：x/ 3uh 0x54320表示：以地址0x54320为起始地址，返回3个单元的值，每个单元有两个字节，输出格式为无符号十六进制。</p>
<p>也就是说返回了3*2=6个字节的数据，以十六进制输出，这6个字节的数据，每两个字节为一个单元输出，共输出3个单元。</p>
<h3 id="栈操作指令"><a href="#栈操作指令" class="headerlink" title="栈操作指令"></a>栈操作指令</h3><p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210315190744590.png" srcset="/img/loading.gif" lazyload alt="image-20210315190744590"></p>
<p>栈顶是朝着低地址方向生长</p>
<h3 id="算术逻辑运算指令"><a href="#算术逻辑运算指令" class="headerlink" title="算术逻辑运算指令"></a>算术逻辑运算指令</h3><p>高32位放%edx</p>
<p>算术右移：填充符号位</p>
<p>逻辑移位：左边填0</p>
<p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210315190841025.png" srcset="/img/loading.gif" lazyload alt="image-20210315190841025"></p>
<p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210414183735292.png" srcset="/img/loading.gif" lazyload alt="image-20210414183735292"></p>
<p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210414183744478.png" srcset="/img/loading.gif" lazyload alt="image-20210414183744478"></p>
<h3 id="条件跳转指令"><a href="#条件跳转指令" class="headerlink" title="条件跳转指令"></a>条件跳转指令</h3><p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210315195500018.png" srcset="/img/loading.gif" lazyload alt="image-20210315195500018"></p>
<p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210315195530982.png" srcset="/img/loading.gif" lazyload alt="image-20210315195530982"></p>
<h3 id="标志位指令"><a href="#标志位指令" class="headerlink" title="标志位指令"></a>标志位指令</h3><p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210414173258979.png" srcset="/img/loading.gif" lazyload alt="image-20210414173258979"></p>
<p>最后一提：计算机对带/无符号数的机器码统一处理<br>O F ， Ｃ Ｆ 等 标 志 位 是 由 机 器 码 运 算 结 果 决 定 的 ， 是 否 为 带 符 号 数 并 不 影 响 </p>
<p>终极简单的判定方法：</p>
<p>求OF就把机器码转成带符号数然后运算，看有没有溢出</p>
<p>求CF同理，转成无符号数，然后运算看有没有溢出</p>
<h3 id="正溢出-和-负溢出"><a href="#正溢出-和-负溢出" class="headerlink" title="正溢出 和 负溢出"></a>正溢出 和 负溢出</h3><p>如果位数 为w 的两个数x,y;且在系统中为补码表示，<br>如果：      -2^(w-1)&lt;=x+y&lt;2^(w-1) 则结果正常</p>
<p>x+y&lt;-2^(w-1)^发生负溢出 结果为x+y+2^w^<br>x+y&gt;=2^(w-1)^发生正溢出 结果为x+y-2^w^</p>
<p>推导过程:<br>对于一个w位，他所能表达值得范围：</p>
<p>比如 w=4:           0 0 0 0        最大值 0 1 1 1=7  (2^(4-1)-1)<br>最小值 1 0 0 0=-8  (-2^(4-1) )</p>
<p>超出这个范围将发生溢出，截断溢出位：            </p>
<p>负溢出+2^w<br>正溢出-2^w<br><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210414173419106.png" srcset="/img/loading.gif" lazyload alt="image-20210414173419106"></p>
<h3 id="条件码相关知识"><a href="#条件码相关知识" class="headerlink" title="条件码相关知识"></a>条件码相关知识</h3><p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210315200213357.png" srcset="/img/loading.gif" lazyload alt="image-20210315200213357"></p>
<h2 id="第三章-位字节和信息存储"><a href="#第三章-位字节和信息存储" class="headerlink" title="第三章 位字节和信息存储"></a>第三章 位字节和信息存储</h2><h3 id="信息的位与表示"><a href="#信息的位与表示" class="headerlink" title="信息的位与表示"></a>信息的位与表示</h3><ul>
<li><strong>典型数据类型的长度</strong></li>
</ul>
<p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210414182913863.png" srcset="/img/loading.gif" lazyload></p>
<ul>
<li><p><strong>字节顺序</strong></p>
<p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210414175028953.png" srcset="/img/loading.gif" lazyload alt="image-20210414175028953"></p>
</li>
</ul>
<h3 id="整数"><a href="#整数" class="headerlink" title="整数"></a>整数</h3><p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210414180814272.png" srcset="/img/loading.gif" lazyload></p>
<h3 id="浮点数"><a href="#浮点数" class="headerlink" title="浮点数"></a>浮点数</h3><h4 id="IEEE浮点数标准"><a href="#IEEE浮点数标准" class="headerlink" title="IEEE浮点数标准"></a>IEEE<strong>浮点数标准</strong></h4><p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210414181040336.png" srcset="/img/loading.gif" lazyload alt="image-20210414181040336"></p>
<p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210414181054897.png" srcset="/img/loading.gif" lazyload alt="image-20210414181054897"></p>
<blockquote>
<p><strong>规格化值</strong></p>
</blockquote>
<p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210414181116849.png" srcset="/img/loading.gif" lazyload alt="image-20210414181116849"></p>
<p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210414181322258.png" srcset="/img/loading.gif" lazyload alt="image-20210414181322258"></p>
<blockquote>
<p><strong>非规格化值</strong></p>
</blockquote>
<p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210414181242656.png" srcset="/img/loading.gif" lazyload alt="image-20210414181242656"></p>
<blockquote>
<p><strong>特殊值</strong></p>
</blockquote>
<p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210414181430845.png" srcset="/img/loading.gif" lazyload alt="image-20210414181430845"></p>
<p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210621222546804.png" srcset="/img/loading.gif" lazyload alt="image-20210621222546804"></p>
<h4 id="舍入和运算"><a href="#舍入和运算" class="headerlink" title="舍入和运算"></a><strong>舍入和运算</strong></h4><blockquote>
<p><strong>浮点数舍入规则</strong></p>
</blockquote>
<p>如果以形式1.RR..RDD..D表示浮点数（R表示有效位，或保留位，而D表示舍去位），舍入规则就是：</p>
<p>如果DD..D &lt; 10..0，则向下舍入</p>
<p>如果DD..D &gt; 10..0，则向上舍入</p>
<p>如要DD..D = 10..0，则向最近偶数舍入，细则如下 ：</p>
<p>a. 如果RR..R = XX..0 （最低有效位是0），则向下舍入</p>
<p>b. 如果RR..R = XX..1（最低有效位是1），则向上舍入</p>
<blockquote>
<p><strong>浮点数运算</strong></p>
</blockquote>
<p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210414182405160.png" srcset="/img/loading.gif" lazyload alt="image-20210414182405160"></p>
<p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210414182418619.png" srcset="/img/loading.gif" lazyload alt="image-20210414182418619"></p>
<h2 id="第四章-程序的机器级表示"><a href="#第四章-程序的机器级表示" class="headerlink" title="第四章  程序的机器级表示"></a>第四章  程序的机器级表示</h2><h3 id="基本"><a href="#基本" class="headerlink" title="基本"></a>基本</h3><h4 id="IA32寄存器"><a href="#IA32寄存器" class="headerlink" title="IA32寄存器"></a>IA32寄存器</h4><p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210414184335897.png" srcset="/img/loading.gif" lazyload alt="image-20210414184335897"></p>
<h4 id="算术操作"><a href="#算术操作" class="headerlink" title="算术操作"></a>算术操作</h4><p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210414184419105.png" srcset="/img/loading.gif" lazyload alt="image-20210414184419105"></p>
<p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210414184428359.png" srcset="/img/loading.gif" lazyload alt="image-20210414184428359"></p>
<p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210414184615336.png" srcset="/img/loading.gif" lazyload alt="image-20210414184615336"></p>
<h3 id="控制"><a href="#控制" class="headerlink" title="控制"></a>控制</h3><p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210414185557502.png" srcset="/img/loading.gif" lazyload alt="image-20210414185557502"></p>
<h4 id="条件码设置"><a href="#条件码设置" class="headerlink" title="条件码设置"></a>条件码设置</h4><p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210414185743149.png" srcset="/img/loading.gif" lazyload alt="image-20210414185743149"></p>
<p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210414185759630.png" srcset="/img/loading.gif" lazyload alt="image-20210414185759630"></p>
<p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210414185811106.png" srcset="/img/loading.gif" lazyload alt="image-20210414185811106"></p>
<p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210414185821323.png" srcset="/img/loading.gif" lazyload alt="image-20210414185821323"></p>
<h3 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h3><h4 id="栈帧"><a href="#栈帧" class="headerlink" title="栈帧"></a>栈帧</h4><p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210416102006727.png" srcset="/img/loading.gif" lazyload alt="image-20210416102006727"></p>
<blockquote>
<p><strong>call指令</strong></p>
</blockquote>
<ol>
<li><p>把下一条指令地址压栈b</p>
</li>
<li><p>再把调用的函数地址给eip</p>
</li>
</ol>
<blockquote>
<p><strong>leave指令</strong></p>
</blockquote>
<ol>
<li>movl %ebp %esp  将esp回到上一个过程的栈顶位置，即ebp的地址</li>
<li>popl %ebp              将旧的ebp地址返回ebp</li>
</ol>
<blockquote>
<p><strong>ret</strong></p>
</blockquote>
<p>pop %eip  将下一条指令地址给%eip</p>
<h3 id="复杂数据的机器级表示"><a href="#复杂数据的机器级表示" class="headerlink" title="复杂数据的机器级表示"></a>复杂数据的机器级表示</h3><h2 id="第五章-优化程序性能"><a href="#第五章-优化程序性能" class="headerlink" title="第五章 优化程序性能"></a>第五章 优化程序性能</h2><h3 id="编译器的局限"><a href="#编译器的局限" class="headerlink" title="编译器的局限"></a>编译器的局限</h3><ul>
<li><p>妨碍优化的因素</p>
<ol>
<li><p>存储器的别名使用</p>
<p><strong>存储器别名使用</strong>是指两个指针可能同时指向同一个存储器的位置的情况。在只考虑执行安全的优化中，编译器必须假设不同的指针可能会指向存储器的同一个位置，这造成了<strong>第一个妨碍优化的因素</strong>，这也是可能严重限制编译器产生优化代码机会的程序的一个方面。如果编译器不能确定指针的指向，它就会假设所有的情况都有可能，所以我们需要做的就是在<strong>编写程序的时候明确指针的指向</strong>。</p>
</li>
<li><p>函数调用</p>
<p><strong>函数调用</strong>是<strong>第二个妨碍优化的因素</strong>。尽可能减少函数的调用可以优化程序，但是编译器会假设最糟糕的情况，并<strong>保持所有的函数调用不变</strong>。所以，我们需要在<strong>编写程序的时候将函数调用的次数尽可能减少</strong>，这件事情只能coder来做，编译器为了安全是不会去做的。</p>
</li>
</ol>
</li>
</ul>
<h3 id="表示程序性能"><a href="#表示程序性能" class="headerlink" title="表示程序性能"></a>表示程序性能</h3><ul>
<li><p>用<strong>每元素的周期数</strong>（Cycles Per Element ，<strong>CPE</strong>）作为<strong>程序性能的度量标准</strong>。它的计算过程是：先得到函数的元素个数和周期的散点图，后经过<strong>最小二乘方拟合</strong>得到折线图，其中<strong>折线的斜率</strong>表明<strong>每元素的周期数CPE</strong>。</p>
</li>
<li><p><strong>运行时间：</strong>一个元素完成功能所运行的时间</p>
</li>
<li><p><strong>周期数每元素(Cycles Per Element, CPE )</strong> ：运行时间/时钟周期</p>
</li>
<li><p><strong>时间周期：</strong>CPU完成一个基本动作的时间（对应一个电平信号宽度）</p>
</li>
<li><p>一个时钟周期是多长时间呢？<br>通常当一个标有“4GHz”的处理器，表示处理器每秒运行4X10^9个时钟周期，一个时钟周<br>期的时长是时钟频率的倒数，为0.25X10^{-9}秒=0.25纳秒（250皮秒）<br>Hz， KHz， MHz, GHz<br>秒， 毫秒， 微秒，纳秒</p>
</li>
</ul>
<h3 id="不依赖于机器特性的优化"><a href="#不依赖于机器特性的优化" class="headerlink" title="不依赖于机器特性的优化"></a>不依赖于机器特性的优化</h3><h4 id="1-消除循环的低效率"><a href="#1-消除循环的低效率" class="headerlink" title="1. 消除循环的低效率"></a>1. 消除循环的低效率</h4><p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210608153952303.png" srcset="/img/loading.gif" lazyload alt="image-20210608153952303"></p>
<p>这个优化是一类常见的优化的一个例子，称为<strong>代码移动( code motion</strong>)。这类优化包括识别要执行多次（例如在循环里）但是计算结果不会改变的计算。因而可以将计算移动到代码前面不会被多次求值的部分。</p>
<h4 id="2-减少过程调用"><a href="#2-减少过程调用" class="headerlink" title="2. 减少过程调用"></a>2. 减少过程调用</h4><p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210609142759377.png" srcset="/img/loading.gif" lazyload alt="image-20210609142759377"></p>
<h4 id="3-消除不必要的存储器引用"><a href="#3-消除不必要的存储器引用" class="headerlink" title="3. 消除不必要的存储器引用"></a>3. 消除不必要的存储器引用</h4><p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210609143101235.png" srcset="/img/loading.gif" lazyload alt="image-20210609143101235"></p>
<h3 id="理解现代处理器"><a href="#理解现代处理器" class="headerlink" title="理解现代处理器"></a>理解现代处理器</h3><h4 id="功能单元的性能"><a href="#功能单元的性能" class="headerlink" title="功能单元的性能"></a>功能单元的性能</h4><p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210609162108070.png" srcset="/img/loading.gif" lazyload alt="image-20210609162108070"></p>
<p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210609162041644.png" srcset="/img/loading.gif" lazyload alt="image-20210609162041644"></p>
<ul>
<li><strong>延迟</strong>：完成运算所需要的总时间</li>
<li><strong>发射时间</strong>：表示两个连续的同类型的运算之间所需要的最小时钟周期数</li>
<li><strong>最大吞吐量</strong>：发射时间的倒数</li>
<li><strong>廷迟界限</strong>：给出了任何必须按照严格顺序完成合并运算的函数所需要的最小CPE值。</li>
<li><strong>吞吐量界限</strong>：根据功能单元产生结果的最大速率，吞吐量界限给出了CPE的最小界限。</li>
</ul>
<h4 id="处理器操作的抽象模型"><a href="#处理器操作的抽象模型" class="headerlink" title="处理器操作的抽象模型"></a>处理器操作的抽象模型</h4><h5 id="1-从机器级代码到数据流图"><a href="#1-从机器级代码到数据流图" class="headerlink" title="1.从机器级代码到数据流图"></a>1.从机器级代码到数据流图</h5><p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210609162352543.png" srcset="/img/loading.gif" lazyload alt="image-20210609162352543"></p>
<p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210609162425613.png" srcset="/img/loading.gif" lazyload alt="image-20210609162425613"></p>
<p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210609162517278.png" srcset="/img/loading.gif" lazyload alt="image-20210609162517278"></p>
<p>图中的链是限制性能的关键路径</p>
<h5 id="2-其他性能因素"><a href="#2-其他性能因素" class="headerlink" title="2.其他性能因素"></a>2.其他性能因素</h5><ul>
<li>数据流表示的的<strong>关键路径</strong>提供的只是<strong>程序需要周期数的下界</strong>，还有其他一些因素会限制性能，包括<br><strong>可用的功能单元的数量</strong>和<strong>任何一步中功能单元之间能够传递数据值的数量</strong>。</li>
</ul>
<h3 id="基于机器特性的优化"><a href="#基于机器特性的优化" class="headerlink" title="基于机器特性的优化"></a>基于机器特性的优化</h3><h4 id="1-循环展开"><a href="#1-循环展开" class="headerlink" title="1.循环展开"></a>1.循环展开</h4><p><strong>循环展开</strong>是一种程序变换，通过增加每次迭代计算的元素的数量，减少循环的迭代次数。</p>
<p>循环展开能够从<strong>两个方面</strong>改程序的性能：</p>
<ul>
<li><p>首先，它减少了不直接有助于程序结果的操作的数量，例如循环索引计算和条件分支。</p>
</li>
<li><p>其次，它提供了ー些方法，可以进一步变化代码，减少整个计算中关键路径上的操作数量。在本节中，我们会看一些简单的循环展开，不做任何进一步的变化</p>
</li>
</ul>
<p>循环展开示例：<img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210609163517926.png" srcset="/img/loading.gif" lazyload alt="image-20210609163517926"></p>
<p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210609163640228.png" srcset="/img/loading.gif" lazyload alt="image-20210609163640228"></p>
<p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210619165210954.png" srcset="/img/loading.gif" lazyload alt="image-20210619165210954"></p>
<p>循环展开可以提高整数加法和乘法的性能，因为GCC会对整数乘法做重关联变换，但不会改变浮点加法和乘法做做这种变化，所以性能并没有提升</p>
<h4 id="2-提高并行性"><a href="#2-提高并行性" class="headerlink" title="2.提高并行性"></a>2.提高并行性</h4><h5 id="1-多个累计变量"><a href="#1-多个累计变量" class="headerlink" title="1) 多个累计变量"></a>1) 多个累计变量</h5><p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210609164539108.png" srcset="/img/loading.gif" lazyload alt="image-20210609164539108"></p>
<p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210609164604747.png" srcset="/img/loading.gif" lazyload alt="image-20210609164604747"></p>
<p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210619165230377.png" srcset="/img/loading.gif" lazyload alt="image-20210619165230377"></p>
<h5 id="2-重新结合变换"><a href="#2-重新结合变换" class="headerlink" title="2) 重新结合变换"></a>2) 重新结合变换</h5><p>改变合并顺序：</p>
<p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210609164646452.png" srcset="/img/loading.gif" lazyload alt="image-20210609164646452"></p>
<p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210609164734377.png" srcset="/img/loading.gif" lazyload alt="image-20210609164734377"></p>
<p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210609164801356.png" srcset="/img/loading.gif" lazyload alt="image-20210609164801356"></p>
<p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210619165247136.png" srcset="/img/loading.gif" lazyload alt="image-20210619165247136"></p>
<h3 id="一些限制因素"><a href="#一些限制因素" class="headerlink" title="一些限制因素"></a>一些限制因素</h3><ol>
<li>寄存器溢出</li>
<li>分支预测和预测错误处罚</li>
</ol>
<h3 id="理解存储器的性能"><a href="#理解存储器的性能" class="headerlink" title="理解存储器的性能"></a>理解存储器的性能</h3><h4 id="加载的性能"><a href="#加载的性能" class="headerlink" title="加载的性能"></a>加载的性能</h4><p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210609171007080.png" srcset="/img/loading.gif" lazyload alt="image-20210609171007080"></p>
<h4 id="存储的性能"><a href="#存储的性能" class="headerlink" title="存储的性能"></a>存储的性能</h4><h3 id="优化程序性能的基本策略"><a href="#优化程序性能的基本策略" class="headerlink" title="优化程序性能的基本策略"></a>优化程序性能的基本策略</h3><p><strong>1)高级设计</strong></p>
<p>为遇到的问题选择适当的算法和数据结构。要特别警觉，避免使用那些会渐进地产生糟糕性能的算法或编码技术。<br><strong>2)基本编码原则</strong></p>
<p>避免限制优化的因素，这样编译器就能产生高效的代码。</p>
<ul>
<li>消除连续的函数调用。在可能时，将计算移到循环外。考虑有选择地妥协程序的模块性以<br>获得更大的效率。</li>
<li>消除不必要的存储器引用。引人临时变量来保存中间结果。只有在最后的值计算出来时，<br>才将结果存放到数组或全局变量中。</li>
</ul>
<p><strong>3)低级优化</strong></p>
<ul>
<li>展开循环，降低开销，并且使得进一步的优化成为可能。</li>
<li>通过使用例如多个累积变量和重新结合等技术，找到方法提高指令级并行。</li>
<li>用功能的风格重写条件操作，使得编译采用条件数据传送。</li>
</ul>
<p><strong>Amdahl定律</strong></p>
<p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210609171724722.png" srcset="/img/loading.gif" lazyload alt="image-20210609171724722"></p>
<h2 id="第六章-存储器体系结构"><a href="#第六章-存储器体系结构" class="headerlink" title="第六章 存储器体系结构"></a>第六章 存储器体系结构</h2><h3 id="6-1-存储技术"><a href="#6-1-存储技术" class="headerlink" title="6.1 存储技术"></a>6.1 存储技术</h3><h4 id="1-1-随机访问存储器"><a href="#1-1-随机访问存储器" class="headerlink" title="1.1 随机访问存储器"></a>1.1 随机访问存储器</h4><p>分为静态的(SRAM)和动态的(DRAM)</p>
<p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210614140955548.png" srcset="/img/loading.gif" lazyload alt="image-20210614140955548"></p>
<p><strong>传统的DRAM</strong></p>
<p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210614141026087.png" srcset="/img/loading.gif" lazyload alt="image-20210614141026087"></p>
<p><strong>存储器模块</strong></p>
<p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210614141219177.png" srcset="/img/loading.gif" lazyload alt="image-20210614141219177"></p>
<h4 id="1-2-磁盘存储"><a href="#1-2-磁盘存储" class="headerlink" title="1.2 磁盘存储"></a>1.2 磁盘存储</h4><p>磁盘是广为应用的保存大量数据的存储设备，存储数据的数量级可以达到几百到几千千兆字节，而基于RAM的存储器只能有几百或几千兆字节。不过，从磁盘上读信息的时间为毫秒级，从DRAM读比从磁盘读快10万倍，从SRAM读比从磁盘读快100万倍。</p>
<p><strong>磁盘容量计算</strong></p>
<p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210614141419194.png" srcset="/img/loading.gif" lazyload alt="image-20210614141419194"></p>
<p><strong>磁盘操作</strong></p>
<p>磁盘以扇区大小的块来读写数据。对扇区的访问时间有三个主要的部分：寻道时间、旋转时间、传送时间。</p>
<p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210614141748772.png" srcset="/img/loading.gif" lazyload alt="image-20210614141748772"></p>
<p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210614141816855.png" srcset="/img/loading.gif" lazyload alt="image-20210614141816855"></p>
<p>因为寻道时间和旋转延迟大致是相等的，所以将寻道时间乘2是估计磁盘访问时间的简单而合理的办法。</p>
<h4 id="1-3-固态硬盘"><a href="#1-3-固态硬盘" class="headerlink" title="1.3 固态硬盘"></a>1.3 固态硬盘</h4><p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210614162059129.png" srcset="/img/loading.gif" lazyload alt="image-20210614162059129"></p>
<h3 id="6-2-局部性"><a href="#6-2-局部性" class="headerlink" title="6.2 局部性"></a>6.2 局部性</h3><h4 id="局部性原理"><a href="#局部性原理" class="headerlink" title="局部性原理"></a>局部性原理</h4><p>一个编写良好的计算机程序常常具有良好的局部性，它们倾向于引用邻近于其他最近引用过的数据项的数据项，或者最近引用过的数据项本身，这种倾向性，被称为局部性原理。</p>
<h4 id="量化评价局部性的简单原则"><a href="#量化评价局部性的简单原则" class="headerlink" title="量化评价局部性的简单原则"></a><strong>量化评价局部性的简单原则</strong></h4><ul>
<li>重复引用同一个变量的程序有良好的时间局部性。</li>
<li>对于具有步长为k的引用模式的程序，步长越小，空间局部性越好。具有步长为1的引用模式的程序有很好的空间局部性。在存储器中以大步长跳来跳去的程序空间局部性会很差。</li>
<li>对于取指令来说，循环有好的时间和空间局部性。循环体越小，循环迭代次数越多，局部性越好。</li>
</ul>
<h3 id="6-3-存储器层次结构"><a href="#6-3-存储器层次结构" class="headerlink" title="6.3 存储器层次结构"></a>6.3 存储器层次结构</h3><p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210614144247180.png" srcset="/img/loading.gif" lazyload alt="image-20210614144247180"></p>
<h4 id="存储器层次结构中的缓存"><a href="#存储器层次结构中的缓存" class="headerlink" title="存储器层次结构中的缓存"></a>存储器层次结构中的缓存</h4><p><strong>存储器层次结构的中心思想</strong></p>
<p>对于每个k,位于k层的更快更小的存储设备作为位于k+1层的更大更慢的存储设备的缓存。换句话说，层次结构中的每一层都缓存来自较低一层的数据对象。例如，本地磁盘作为通过网络从远程磁盘取出的文件(例如Web页面)的缓存，主存作为本地磁盘上数据的缓存，依此类推，直到最小的缓存CPU寄存器集合。</p>
<p><strong>缓存命中</strong></p>
<p>当程序需要第k+1层的某个数据对象d时，它首先在当前存储在第k层的一个块中査找d。如果d刚好缓存在第k层中，那么就是我们所说的<strong>缓存命中</strong>( cache hit)。</p>
<p><strong>缓存不命中</strong></p>
<p>另ー方面，如果第k层中没有缓存数据对象d,那么就是我们所说的<strong>缓存不命中</strong>（ cache miss).当发生缓存不命中时，第k层的缓存从第k+1层缓存中取出包含d的那个块，如果第k层的缓存已经满了的话，可能就会覆盖现存的一个块。</p>
<p>覆盖一个现存的块的过程称为<strong>替换</strong>( replacing)或<strong>驱逐</strong>( evicting)这个块。被驱逐的这个块有时也称为<strong>牺牲块</strong>( victim block)。决定该替换哪个块是由缓存的<strong>替换策略</strong>(replacement policy)来控制的。例如，一个具有随机替换策略的缓存会随机选择一个牺性块。一个具有最近最少被使用(LRU)替换策略的缓存会选择那个最后被访问的时间距现在最远的块。</p>
<p><strong>缓存不命中的种类</strong></p>
<ul>
<li><p>冷不命中</p>
<p>如果第k层的缓存是空的，那么对任何数据对象的访问都会不命中。一个空的缓存有时称为冷缓存( cold cache)，此类不命中称为<strong>强制性不命中</strong>或<strong>冷不命中</strong></p>
</li>
<li><p>冲突不命中</p>
<p>在这种情况下，缓存足够大，能够保存被引用的数据对象，但是因为这些对象会映射到同一个缓存块，缓存会一直不命中。</p>
<p>例如，如果程序请求块0,然后块8,然后块0,然后块8,依此类推，在第k层的缓存中，对这两个块的每次引用都会不命中，即使是这个缓存总共可以容纳4个块。</p>
</li>
<li><p>容量不命中</p>
<p>当工作集的大小超过缓存的大小时，缓存会经历<strong>容量不命中</strong>( capacity miss)。换句话说，缓存就是太小了，不能处理这个工作集。</p>
</li>
</ul>
<h3 id="6-4-高速缓存存储器"><a href="#6-4-高速缓存存储器" class="headerlink" title="6.4 高速缓存存储器"></a>6.4 高速缓存存储器</h3><h4 id="4-1-通用的高速缓存存储器结构"><a href="#4-1-通用的高速缓存存储器结构" class="headerlink" title="4.1 通用的高速缓存存储器结构"></a>4.1 通用的高速缓存存储器结构</h4><p>考虑一个计算机系统，其中每个存储器地址有m位，形成M=2^m^个不同的地址。如图6-27a所示。</p>
<p>这样一个机器的高速缓存被组织成一个有S=2^s^个<strong>高速缓存组</strong>的数组。</p>
<p>每个组包含E个<strong>高速缓存行</strong>( cache line)。</p>
<p>每个行是由一个B=2^b^字节的<strong>数据块</strong>( block)组成的，一个<br>有效位( valid bit)指明这个行是否包含有意义的信息，还有t=m-(b+s)个标记位(是当前块的存储器地址的位的一个子集），它们唯一地标识存储在这个高速缓存行中的块。</p>
<p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210614150943188.png" srcset="/img/loading.gif" lazyload alt="image-20210614150943188"></p>
<p><strong>高速缓存的大小</strong>：C=S×E×B</p>
<p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210614152049400.png" srcset="/img/loading.gif" lazyload alt="image-20210614152049400"></p>
<h4 id="4-2-直接映射高速缓存"><a href="#4-2-直接映射高速缓存" class="headerlink" title="4.2 直接映射高速缓存"></a>4.2 直接映射高速缓存</h4><p>根据E（每个组的高速缓存行数）高速缓存被分为不同的类。每个组只有一行(E=1)的高速缓存称为<strong>直接映射高速缓存</strong></p>
<p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210614152338888.png" srcset="/img/loading.gif" lazyload alt="image-20210614152338888"></p>
<p><strong>1.直接映射高速缓存的组选择</strong></p>
<p>在这一步中，高速缓存从w的地址中间抽取出s个组索引位。这些位被解释成一个对应于个组号的无符号整数。换句话来说，如果我们把高速缓存看成是一个关于组的一维数组，那么这些组索引位就是一个到这个数组的索引。</p>
<p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210614152556380.png" srcset="/img/loading.gif" lazyload alt="image-20210614152556380"></p>
<p><strong>2.直接映射高速缓存的行匹配</strong></p>
<p>当且仅当设置了有效位，而且高速缓存行中的标记与w的地址中的标记相匹配时，这一行中包含w的一个拷贝。</p>
<p><strong>3.直接映射高速缓存的字选择</strong></p>
<p>如图6-31所示，块偏移位提供了所需要的字的第一个字节的偏移。就像我们把高速缓存看成一个行的数组一样，我们把块看成一个字节的数组，而字节偏移是到这个数组的一个索引。在这个示例中，块偏移位是100<del>2</del>,它表明w的拷贝是从块中的字节4开始的（我们假设字长为4字节）。</p>
<p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210614152831935.png" srcset="/img/loading.gif" lazyload alt="image-20210614152831935"></p>
<p><strong>4.直接映射高速缓存中不命中时的行替换</strong></p>
<p>如果缓存不命中，那么它需要从存储器层次结构中的下一层取出被请求的块，然后将新的块存储在组索引位指示的组中的一个高速缓存行中。一般而言，如果组中都是有效高速缓存行了，那么必须要驱逐出一个现存的行。对于直接映射高速缓存来说，每个组只包含有一行，替换策略非常简单：<strong>用新取出的行替换当前的行</strong>。</p>
<ul>
<li>用中间位做索引高速缓存的使用效率更高。</li>
</ul>
<h4 id="4-3-组相连高速缓存"><a href="#4-3-组相连高速缓存" class="headerlink" title="4.3 组相连高速缓存"></a>4.3 组相连高速缓存</h4><p><strong>1.组相联高速缓存中的组选择</strong><br>它的组选择与直接映射高速缓存的组选择一样，组索引位标识组。</p>
<p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210614160744314.png" srcset="/img/loading.gif" lazyload alt="image-20210614160744314"></p>
<p><strong>2.组相联高速缓存中的行匹配和字选择</strong></p>
<p>图6-36展示了相联高速缓存中行匹配的基本思想。这里的一个重要思想就是组中的任何行都可以包含任何映射到这个组的存储器块。所以高速缓存必须<strong>捜索组中的每一行</strong>，寻找一个有效的行，其标记与地址中的标记相匹配。如果高速缓存找到了这样一行，那么我们就命中，块偏移从这个块中选择一个字，和前面一样。</p>
<p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210614160949149.png" srcset="/img/loading.gif" lazyload alt="image-20210614160949149"></p>
<p><strong>3.组相联高速缓存中不命中时的行替换</strong></p>
<p>有空行选择空行。</p>
<p>最简单的替换策略是<strong>随机选择要替换的</strong>行。</p>
<p><strong>最不常使用</strong>( Least-frequently-Used,LFU)策略会替换在<br>过去某个时间窗口内引用次数最少的那一行。</p>
<p><strong>最近最少使用</strong>( Least- Recently-Used,LRU)策略会替换最后一次访问时间最久远的那一行。所有这些策略都需要额外的时间和硬件。</p>
<h4 id="4-4-全相连高速缓存"><a href="#4-4-全相连高速缓存" class="headerlink" title="4.4 全相连高速缓存"></a>4.4 全相连高速缓存</h4><p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210614161050792.png" srcset="/img/loading.gif" lazyload alt="image-20210614161050792"></p>
<p><strong>1.全相联高速缓存中的组选择</strong></p>
<p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210614161201608.png" srcset="/img/loading.gif" lazyload alt="image-20210614161201608"></p>
<p><strong>2.全相联高速缓存中的行匹配和字选择</strong></p>
<p>全相联高速缓存中的行匹配和字选择与组相联高速缓存中的是一样的，如图6-39所示。它们之间的区别主要是个规模大小的问题。因为高速缓存电路必须并行地捜索许多相匹配的标记，造一个又大又快的相联高速缓存很困难，而且很昂贵。因此，全相联高速缓存只适合做小的高速缓存，例如虚拟存储器系统中的翻译备用缓冲器(TLB),它缓存页表项。</p>
<p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210614161349454.png" srcset="/img/loading.gif" lazyload alt="image-20210614161349454"></p>
<h4 id="4-5-有关写的问题"><a href="#4-5-有关写的问题" class="headerlink" title="4.5 有关写的问题"></a>4.5 有关写的问题</h4><p><strong>第一个问题：</strong>在高速缓存更新了它的w的拷贝之后，怎么更新w在层次结构中紧接着低一层中的拷贝？</p>
<ul>
<li><p><strong>直写</strong></p>
<p>就是立即将w的高速缓存块写回到紧接着的低一层中。虽然简单，但是直写的缺点是每次写都会引起总线流量。</p>
</li>
<li><p><strong>写回</strong></p>
<p>尽可能地推迟存储器更新，只有当替换算法要驱逐更新过的块时，才把它写到紧接着的低一层中。由于局部性，写回能显著地减少总线流量，但是它的缺点是增加了复杂性。高速缓存必须为每个高速缓存行维护一个额外的修改位( dirty bit),表明这个高速缓存块是否被修改过。</p>
</li>
</ul>
<p><strong>第二个问题：</strong>如何处理写不命中</p>
<ul>
<li><p><strong>写分配</strong></p>
<p>加载相应的低一层中的块到高速缓存中，然后更新这个高速缓存块。写分配试图利用写的空间局部性，但是缺点是每次不命中都会导致一个块从低一层传送到高速缓存。</p>
</li>
<li><p><strong>非写分配</strong></p>
<p>避开高速缓存，直接把这个字写到低一层中。</p>
</li>
</ul>
<p>直写高速缓存通常是非写分配的。写回高速缓存通常是写分配的。</p>
<h4 id="4-6一个真实的高速缓存层次结构的解剖"><a href="#4-6一个真实的高速缓存层次结构的解剖" class="headerlink" title="4.6一个真实的高速缓存层次结构的解剖"></a>4.6一个真实的高速缓存层次结构的解剖</h4><p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210614163042361.png" srcset="/img/loading.gif" lazyload alt="image-20210614163042361"></p>
<h4 id="4-7-高速缓存参数的性能影响"><a href="#4-7-高速缓存参数的性能影响" class="headerlink" title="4.7 高速缓存参数的性能影响"></a>4.7 <strong>高速缓存参数的性能影响</strong></h4><p><strong>衡量高速缓存的性能指标</strong></p>
<ul>
<li><p><strong>不命中率</strong></p>
<p>不命中数量/引用数量</p>
</li>
<li><p><strong>命中率</strong></p>
<p>命中率=1-不命中率</p>
</li>
<li><p><strong>命中时间</strong></p>
<p>从高速缓存传送一个字到CPU所需的时间，包括组选择、行确认和字选择的时间。</p>
</li>
<li><p><strong>不命中处罚</strong></p>
<p>由于不命中所需要的额外的时间。</p>
</li>
</ul>
<p><strong>1.高速缓存大小的影响</strong></p>
<p><strong>2.块大小的影响</strong></p>
<p><strong>3.相联度的影响</strong></p>
<p><strong>4.写策略的影响</strong></p>
<h2 id="第七章-链接"><a href="#第七章-链接" class="headerlink" title="第七章 链接"></a>第七章 链接</h2><h3 id="7-1-编译器驱动程序"><a href="#7-1-编译器驱动程序" class="headerlink" title="7.1 编译器驱动程序"></a>7.1 编译器驱动程序</h3><p>大多数编译系统提供<strong>编译驱动桯序</strong>( compiler driver),它代表用户在需要时调用语言预处理器、编译器、汇编器和链接器。</p>
<hr>
<h3 id="7-2-静态链接"><a href="#7-2-静态链接" class="headerlink" title="7.2 静态链接"></a>7.2 静态链接</h3><p>像Unix ld程序这样的<strong>静态链接器</strong>以一组可重定位目标文件和命令行参数作为输人，生成一个完全链接的可以加载和运行的可执行目标文件作为输出。</p>
<p>输入的<strong>可重定位目标文件</strong>由各种不同的代码和数据节(section)组成。指令在一个节中，初始化的全局变量在另一个节中，而未初始化的变量又在另外一个节中。</p>
<p><strong>链接器主要任务：</strong></p>
<ul>
<li><strong>符号解析</strong>( symbol resolution)。目标文件定义和引用符号。符号解析的目的是将每个符号<br>引用刚好和一个符号定义联系起来。</li>
<li><strong>重定位</strong>( relocation)。编译器和汇编器生成从地址0开始的代码和数据节。链接器通过把<br>每个符号定义与一个存储器位置联系起来，然后修改所有对这些符号的引用，使得它们指<br>向这个存储器位置，从而重定位这些节。</li>
</ul>
<hr>
<h3 id="7-3-目标文件"><a href="#7-3-目标文件" class="headerlink" title="7.3 目标文件"></a>7.3 目标文件</h3><p>目标文件三种形式：</p>
<ul>
<li><strong>可重定位目标文件</strong>。包含二进制代码和数据。其形式可以在编译时与其他可重定位目标文件合并起来，创建一个可执行文件。</li>
<li><strong>可执行目标文件</strong>。包含二进制代码和数据。可被直接拷贝到存储器执行。</li>
<li><strong>共享目标文件</strong>。一种特殊的可重定位目标文件。可以在加载时或者在运行时被动态地加载到存储器并链接。</li>
</ul>
<p>编译器和汇编器生成可重定位目标文件（包括共享目标文件）。</p>
<p>链接器生成可执行目标文件。</p>
<hr>
<h3 id="7-4-可重定位目标文件"><a href="#7-4-可重定位目标文件" class="headerlink" title="7.4 可重定位目标文件"></a>7.4 可重定位目标文件</h3><p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210614174042988.png" srcset="/img/loading.gif" lazyload alt="image-20210614174042988"></p>
<ul>
<li><p><strong>ELF头</strong></p>
<ul>
<li><p>以一个<strong>16字节的序列</strong>开始，这个序列描述了<strong>生成该文件的系统的字的大小和字节顺序</strong>。</p>
</li>
<li><p>ELF头剩下的部分包含帮助链接器语法分析和解释目标文件的信息。</p>
<p>其中包括：</p>
<ul>
<li><p>ELF头的大小。</p>
</li>
<li><p>目标文件的类型（如可重定位、可执行或者是共享的）</p>
</li>
<li><p>机器类型（IA32）</p>
</li>
<li><p>节头部表的文件偏移</p>
</li>
<li><p>节头部表中的条目大小和数量。</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>夹在ELF头和节头部表之间的都是<strong>节</strong>。一个典型的ELF可重定位目标文件包含下面几个节：</p>
<ul>
<li><strong>.text：</strong>已编译程序的机器代码。</li>
<li><strong>.rodata：</strong>只读数据。比如printf语句中的格式串和switch语句的跳转表。</li>
<li><strong>.data：</strong>已初始化的全局C变量。局部C变量在运行时保存在栈中，既不出现在.data节中，也不出现在.bss节中。</li>
<li><strong>.bss：</strong>未初始化的全局C变量。在目标文件中，未初始化变量不需要占据任何实际的磁盘空间，仅仅是为了空间效率的占位符。</li>
<li><strong>.symtab：</strong>一个符号表，它存放在程序中定义和引用的函数和全局变量的信息。</li>
<li><strong>.rel.text：</strong>一个.text节中位置的列表，在与其他可重定位目标文件结合时需要修改这些位置。</li>
<li><strong>.rel.data：</strong>被模块引用或定义的任何全局变量的重定位信息。</li>
<li><strong>.debug：</strong>一个调试符号表。包括局部变量、全局变量以及原始的C源文件。只有用**<code>-g</code>选项**才会得到这张表。</li>
<li><strong>.line：</strong>原始C源程序中的行号和.text节中机器指令之间的映射。只有用**<code>-g</code>选项**才会得到这张表。</li>
<li><strong>.strtab：</strong>一个字符串表，其内容包括.symtab和.debug节中的符号表，以及节头部中的节名字。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="7-5-符号和符号表"><a href="#7-5-符号和符号表" class="headerlink" title="7.5 符号和符号表"></a>7.5 符号和符号表</h3><p><strong>链接器符号是什么？符号表又是什么？</strong></p>
<ul>
<li><strong>链接器符号</strong>其实就是程序中的变量名、函数名。</li>
<li><strong>符号表</strong>是编译器为存储变量名、函数名、对象、类、接口等各种实体的出现情况而创建和维护的一种重要的<strong>数据结构</strong>。</li>
</ul>
<p><strong>链接器符号分为三种：</strong></p>
<ul>
<li><strong>由本模块m定义并能被其他模块引用的全局符号</strong>。对应于非静态的的c函数以及被定义为不带c语言static属性的全局变量。</li>
<li><strong>由其他模块定义并被模块m引用的全局符号成为外部符号</strong>。对应于定义在其他模块中的c语 言函数和变量。</li>
<li><strong>仅由本模块m定义和引用的本地符号</strong>。对应于在模块中定义的带static的C语言函数和全局变量，这些函数和变量只能在本模块中引用，不能在其他模块中引用。</li>
<li><strong>注意：链接器的局部符号不是指程序中的局部变量（分配在栈中的临时性变量），链接器不关心这种局部变量。</strong></li>
</ul>
<p><strong>全局符号的强弱：</strong></p>
<ul>
<li>在编译时，<strong>编译器向汇编器输出</strong>的每个<strong>全局符号</strong>，或者是<strong>强符号</strong>，或者是<strong>弱符号</strong>。</li>
<li><strong>强符号</strong>：函数和已初始化的全局变量。</li>
<li><strong>弱符号</strong>：未初始化的全局变量。</li>
<li>对于<strong>多重定义的全局符号</strong>：强符号和弱符号中选强符号，强符号只能有一个，如果没有则选弱符号其中之一。</li>
<li>所以我们在<strong>编程时要注意</strong>尽可能地<strong>避免使用全局变量</strong>，若要使用需要合理使用<strong>static、extern</strong>，记得<strong>变量初始化</strong>。</li>
</ul>
<p><strong>.symtab节的中包含的ELF符号表举例：</strong></p>
<p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210529134717830.png" srcset="/img/loading.gif" lazyload alt="image-20210529134717830"></p>
<hr>
<h3 id="7-6-符号解析"><a href="#7-6-符号解析" class="headerlink" title="7.6 符号解析"></a>7.6 符号解析</h3><p><strong>链接器解析符号引用的方法：</strong>将每个引用与它输入的可重定位目标文件的符号表中的一个确定的符号联系起来。</p>
<h4 id="6-1-链接器如何解析多重定义的全局符号"><a href="#6-1-链接器如何解析多重定义的全局符号" class="headerlink" title="6.1 链接器如何解析多重定义的全局符号"></a>6.1 链接器如何解析多重定义的全局符号</h4><p><strong>按如下规则处理：</strong></p>
<p>规则1: 不允许有多个强符号。<br>规则2: 如果有一个强符号和多个弱符号，那么选择强符号。<br>规则3: 如果有多个弱符号，那么从这些弱符号中任意选择一个。</p>
<h4 id="6-2-与静态库链接"><a href="#6-2-与静态库链接" class="headerlink" title="6.2 与静态库链接"></a>6.2 与静态库链接</h4><p><strong>静态库：</strong>相关函数可以被编译为独立的目标模块，然后封装成一个单独的静态库文件。在链接时，链接器将只拷贝被程序引用的目标模块。</p>
<p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210615150100376.png" srcset="/img/loading.gif" lazyload alt="image-20210615150100376"></p>
<h4 id="6-3-链接器如何使用静态库来解析引用"><a href="#6-3-链接器如何使用静态库来解析引用" class="headerlink" title="6.3 链接器如何使用静态库来解析引用"></a>6.3 链接器如何使用静态库来解析引用</h4><p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210615151116120.png" srcset="/img/loading.gif" lazyload alt="image-20210615151116120"></p>
<p>关于<strong>库的一般准则</strong>是将它们<strong>放在命令行的结尾</strong>。如果各个库的成员是相互独立的（也就是说没有成员引用另一个成员定义的符号），那么这些库就可以按照任何顺序放置在命令行的结尾处。<br>另一方面，如果库不是相互独立的，那么它们<strong>必须排序</strong>，使得对于每个被存档文件的成员外部引用的符号s,在命令行中至少有一个s的定义是在对s的引用之后的。</p>
<p>如果需要满足依赖需求，可以在<strong>命令行上重复库</strong></p>
<hr>
<h3 id="7-7-重定位"><a href="#7-7-重定位" class="headerlink" title="7.7 重定位"></a>7.7 重定位</h3><p>重定位将合并输入模块，并为每个符号分配运行时地址。</p>
<p>重定位由两步组成：</p>
<ul>
<li><strong>重定位节和符号定义。</strong>在这一步中，链接器将所有相同类型的节合并为同一类型的新的聚合节。例如，来自输入模块的.data节被全部合并成一个节，这个节成为输出的可执行<br>目标文件的.data节。然后，链接器将运行时存储器地址赋给新的聚合节，赋给输入模块定义的每个节，以及赋给输入模块定义的每个符号。当这一步完成时，程序中的每个指令和全局变量都有唯一的运行时存储器地址了。</li>
<li><strong>重定位节中的符号引用。</strong>在这一步中，链接器修改代码节和数据节中对每个符号的引用，使得它们指向正确的运行时地址。为了执行这一步，链接器依赖于称为<strong>重定位条目</strong>( relocation entry)的可重定位目标模块中的数据结构</li>
</ul>
<h4 id="7-7-1-重定位条目"><a href="#7-7-1-重定位条目" class="headerlink" title="7.7.1 重定位条目"></a>7.7.1 重定位条目</h4><p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210615152035610.png" srcset="/img/loading.gif" lazyload alt="image-20210615152035610"></p>
<p><strong>两种最基本的重定位类型：</strong></p>
<ul>
<li><p><strong>R_386_PC32：</strong>重定位一个使用32位PC相对地址的引用。</p>
<p>一个PC相对地址就是距程序计数器(PC)的当前运行时值的偏移量。当CPU执行一条使用PC相对寻址的指令时，它就将在指令中编码的32位值上加上PC的当前运行时值，得到有效地址(如ca11指令的目标)，PC值通常是存储器中下一条指令的地址。</p>
</li>
<li><p><strong>R_386_32：</strong>重定位一个使用32绝对地址的引用。</p>
<p>通过绝对寻址，CPU直接使用在指令中编码的32位值作为有效地址，不需要进一步修改。</p>
</li>
</ul>
<h4 id="7-7-2-重定位符号引用"><a href="#7-7-2-重定位符号引用" class="headerlink" title="7.7.2 重定位符号引用"></a>7.7.2 重定位符号引用</h4><p><strong>重定位算法</strong></p>
<p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210615154815219.png" srcset="/img/loading.gif" lazyload alt="image-20210615154815219"></p>
<p>ADDR(s)：每个节运行时地址</p>
<p>ADDR(r.symbol)：每个符号运行时地址</p>
<p><strong>1.重定位PC相对引用</strong></p>
<p>待重定位的代码</p>
<p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210615155050140.png" srcset="/img/loading.gif" lazyload alt="image-20210615155050140"></p>
<p>重定位条目</p>
<p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210615155230646.png" srcset="/img/loading.gif" lazyload alt="image-20210615155230646"></p>
<p>链接器已经确定</p>
<p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210615155304801.png" srcset="/img/loading.gif" lazyload alt="image-20210615155304801"></p>
<p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210615155314174-1623743596124.png" srcset="/img/loading.gif" lazyload alt="image-20210615155314174"></p>
<p>首先计算出引用的运行时地址，即偏移量的实际起始地址</p>
<p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210615155600812.png" srcset="/img/loading.gif" lazyload alt="image-20210615155600812"></p>
<p>然后计算新的引用，即新的偏移量，从PC的当前值（当前指令的下一条指令起始地址）要偏移多少才会到swap的实际运行时地址</p>
<p>这个公式可以理解为引用的运行时地址加上引用所占据的字节数（bb+4)，然后用目标地址减去上面的值就是我们要得到的偏移量。</p>
<p>-4是由不同机器的引用长度决定的</p>
<p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210615155705059.png" srcset="/img/loading.gif" lazyload alt="image-20210615155705059"></p>
<p>于是指令被修改为</p>
<p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210615155856359.png" srcset="/img/loading.gif" lazyload alt="image-20210615155856359"></p>
<p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210615155910631.png" srcset="/img/loading.gif" lazyload alt="image-20210615155910631"></p>
<p><strong>2.重定位PC绝对引用</strong></p>
<p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210615160238171.png" srcset="/img/loading.gif" lazyload alt="image-20210615160238171"></p>
<p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210615160318085.png" srcset="/img/loading.gif" lazyload alt="image-20210615160318085"></p>
<hr>
<h3 id="7-8-可执行目标文件"><a href="#7-8-可执行目标文件" class="headerlink" title="7.8 可执行目标文件"></a>7.8 可执行目标文件</h3><p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210615161745659.png" srcset="/img/loading.gif" lazyload alt="image-20210615161745659"></p>
<p>可执行文件p的段头部表</p>
<p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210615161847318.png" srcset="/img/loading.gif" lazyload alt="image-20210615161847318"></p>
<p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210615161900425.png" srcset="/img/loading.gif" lazyload alt="image-20210615161900425"></p>
<hr>
<h3 id="7-9-加载可执行目标文件"><a href="#7-9-加载可执行目标文件" class="headerlink" title="7.9 加载可执行目标文件"></a>7.9 加载可执行目标文件</h3><p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210615162558215.png" srcset="/img/loading.gif" lazyload alt="image-20210615162558215"></p>
<p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210615162610066.png" srcset="/img/loading.gif" lazyload alt="image-20210615162610066"></p>
<hr>
<h3 id="7-10-动态链接共享库"><a href="#7-10-动态链接共享库" class="headerlink" title="7.10 动态链接共享库"></a>7.10 动态链接共享库</h3><p>静态库存在如下缺点: </p>
<ul>
<li><p>在存储中的可执行文件中有多个副本 (每一个函数均需要静态库文件 ) </p>
</li>
<li><p>在运行中的可执行文件中存在多个副本 </p>
</li>
<li><p>即便是对系统库进行小bug的修复，也需要对使用到这个库的所有应用显示地重新链接</p>
</li>
</ul>
<p><strong>共享库</strong>( shared library)是致力于解决静态库缺陷的一个现代创新产物。共享库是一个目标模块，在运行时，可以加载到任意的存储器地址，并和一个在存储器中的程序链接起来。这个过程称为动态链接( dynamic linking),是由一个叫做动态链接器(dynamic linker)的程序来执行的。<br>共享库也称为共享目标( shared object),在Uniⅸ系统中通常用.so后缀来表示。微软的操作系统大量地利用了共享库，它们称为DLL（动态链接库）。</p>
<p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210615164131444.png" srcset="/img/loading.gif" lazyload alt="image-20210615164131444"></p>
<hr>
<h3 id="7-13-处理目标文件的工具"><a href="#7-13-处理目标文件的工具" class="headerlink" title="7.13 处理目标文件的工具"></a>7.13 处理目标文件的工具</h3><p>在Unix系统中有大量可用的工具可以帮助你理解和处理目标文件。特别地， GNU binutils包尤其有帮助，而且可以运行在每个Unⅸ平台上。</p>
<ul>
<li><strong>AR</strong>: 创建静态库，插入、删除、列出和提取成员。</li>
<li><strong>STRINGS</strong>: 列出一个目标文件中所有可打印的字符串。</li>
<li><strong>STRIP</strong>: 从目标文件中删除符号表信息。</li>
<li><strong>NM</strong>: 列出一个目标文件的符号表中定义的符号。</li>
<li><strong>SIZE</strong>: 列出目标文件中节的名字和大小</li>
<li><strong>READELF</strong>: 显示一个目标文件的完整结构，包括ELF头中编码的所有信息。包含SIZE和NM的功能</li>
<li><strong>OBJDUMP</strong>: 所有二进制工具之母。能够显示一个目标文件中所有的信息。它最大的作用是反汇编。text节中的二进制指今</li>
</ul>
<p>Unix系统为操作共亨库还提供了LDD程序：</p>
<ul>
<li><strong>LDD</strong>: 列出一个可执行文件在运行时所需要的共享库。</li>
</ul>
<hr>
<h2 id="第八章-异常控制流"><a href="#第八章-异常控制流" class="headerlink" title="第八章 异常控制流"></a>第八章 异常控制流</h2><h3 id="8-1-异常"><a href="#8-1-异常" class="headerlink" title="8.1 异常"></a>8.1 异常</h3><p><strong>异常</strong>就是控制流中的突变，用来响应处理器状态中的某些变化。</p>
<p>状态变化称为<strong>事件</strong>。事件可能和当前指令的执行直接相关。<br>比如，发生虚拟存储器缺页、算术溢出，或者一条指令试图除以零。另一方面，事件也可能和当前指令的执行没有关系。比如，一个系统定时器产生信号或者一个I/O请求完成。</p>
<p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210615171511841.png" srcset="/img/loading.gif" lazyload alt="image-20210615171511841"></p>
<p>在任何情况下，当处理器检测到有事件发生时，它就会通过一张叫做<strong>异常表</strong>(exception table)的跳转表，进行一个<strong>间接过程调用</strong>（异常)，到一个专门设计用来处理这类事件的操作系统子程序（<strong>异常处理程序</strong>( exception handler))</p>
<p>当异常处理程序完成处理后，根据引起异常的事件的类型，会发生以下三种情况中的一种：</p>
<ol>
<li>处理程序将控制返回给当前指令I<del>curr</del>，即当事件发生时正在执行的指令。</li>
<li>处理程序将控制返回给I<del>next</del>，即如果没有发生异常将会执行的下一条指令。</li>
<li>处理程序终止被中断的程序。</li>
</ol>
<h4 id="8-1-1-异常处理"><a href="#8-1-1-异常处理" class="headerlink" title="8.1.1 异常处理"></a>8.1.1 异常处理</h4><p>在系统启动时（当计算机重启或者加电时），操作系统分配和初始化一张称为<strong>异常表</strong>的跳转表，使得条目k包含异常k的处理程序的地址。图8-2展示了一张异常表的格式。</p>
<p>异常表的起始地址放在一个叫做<strong>异常表基址寄存器</strong>的特殊CPU寄存器中。</p>
<p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210615171950006.png" srcset="/img/loading.gif" lazyload alt="image-20210615171950006"></p>
<p><strong>异常</strong>类似于过程调用，但也有一些不同之处：</p>
<ul>
<li>过程调用时，在跳转到处理程序之前，处理器将返回地址压入栈中。然而，根据异常的类型，返回地址要么是当前指令（当事件发生时正在执行的指令），要么是下一条描指令（如果事件不发生，将会在当前指令后执行的指令）。</li>
<li>处理器也把一些额外的处理器状态压到栈里，在处理程序返回时，重新开始被中断的程序会需要这些状态。比如，一个IA32系统将包含当前条件码和其他内容的EFLAGS寄存器压人栈中。</li>
<li>如果控制从一个用户程序转移到内核，那么所有这些项目都被压到内核栈中，而不是压到用户栈中。</li>
<li>异常处理程序运行在内核模式下(见8.2.4节)，这意味着它们对所有的系统资源都有完全的访问权限。</li>
</ul>
<h4 id="8-1-2-异常的类别"><a href="#8-1-2-异常的类别" class="headerlink" title="8.1.2 异常的类别"></a>8.1.2 异常的类别</h4><p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210615172726725.png" srcset="/img/loading.gif" lazyload alt="image-20210615172726725"></p>
<h5 id="1-中断"><a href="#1-中断" class="headerlink" title="1.中断"></a>1.中断</h5><p>中断是异步发生的，是来自处理器外部的I/O设备的信号的结果。</p>
<p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210615172954970.png" srcset="/img/loading.gif" lazyload alt="image-20210615172954970"></p>
<h5 id="2-陷阱和系统调用"><a href="#2-陷阱和系统调用" class="headerlink" title="2.陷阱和系统调用"></a>2.陷阱和系统调用</h5><p>陷阱是有意的异常，是执行一条指令的结果。</p>
<p>陷阱<strong>最重要的用途</strong>是在用户程序和内核之间提供一个像过程一样的接口，叫做<strong>系统调用</strong>。</p>
<p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210615173310199.png" srcset="/img/loading.gif" lazyload alt="image-20210615173310199"></p>
<p><strong>系统调用和普通的函数调用</strong>实现非常不同：</p>
<ul>
<li>普通的函数运行在用户模式(user mode)中，用户模式<br>限制了函数可以执行的指令的类型，而且它们只能访问与调用函数相同的栈。</li>
<li>系统调用运行在内核模式(kernel mode)中，内核模式允许系统调用执行指令，并访问定义在内核中的栈。</li>
</ul>
<h5 id="3-故障"><a href="#3-故障" class="headerlink" title="3.故障"></a>3.故障</h5><p>故障由错误情况引起，它可能能够被故障处理程序修正。当故障发生时，处理器将控制转移给故障处理程序。如果处理程序能够修正这个错误情况，它就将控制返回到引起故障的指令，从而重新执行它。否则，处理程序返回到内核中的 abort例程， abort例程会终止引起故障的应用程序。</p>
<p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210615173712103.png" srcset="/img/loading.gif" lazyload alt="image-20210615173712103"></p>
<h5 id="4-终止"><a href="#4-终止" class="headerlink" title="4.终止"></a>4.终止</h5><p>终止是不可恢复的致命错误造成的结果，通常是一些硬件错误，比如DRAM或者SRAM位被损坏时发生的奇偶错误。终止处理程序从不将控制返回给应用程序。如图8-8所示，处理程序将控制返回给一个 abort例程，该例程会终止这个应用程序。</p>
<p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210615173835444.png" srcset="/img/loading.gif" lazyload alt="image-20210615173835444"></p>
<h4 id="8-1-3-Linux-IA32系统中的异常"><a href="#8-1-3-Linux-IA32系统中的异常" class="headerlink" title="8.1.3 Linux/IA32系统中的异常"></a>8.1.3 Linux/IA32系统中的异常</h4><h5 id="1-Linux-IA32故障和终止"><a href="#1-Linux-IA32故障和终止" class="headerlink" title="1.Linux/IA32故障和终止"></a>1.Linux/IA32故障和终止</h5><p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210615174044372.png" srcset="/img/loading.gif" lazyload alt="image-20210615174044372"></p>
<h5 id="2-Linux-IA32系统调用"><a href="#2-Linux-IA32系统调用" class="headerlink" title="2.Linux/IA32系统调用"></a>2.Linux/IA32系统调用</h5><p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210615174116950.png" srcset="/img/loading.gif" lazyload alt="image-20210615174116950"></p>
<hr>
<h3 id="8-2-进程"><a href="#8-2-进程" class="headerlink" title="8.2 进程"></a>8.2 进程</h3><p><strong>进程</strong>的经典定义就是一个执行中的程序的实例。系统中的每个程序都是运行在某个进程的上下文( context)中的。上下文是由程序正确运行所需的状态组成的。这个状态包括存放在存储器中的程序的代码和数据、它的栈、通用目的寄存器的内容、程序计数器、环境变量以及打开文件描述符的集合。</p>
<p>进程提供给应用程序两个<strong>关键抽象</strong>：</p>
<ul>
<li>一个独立的逻辑控制流，它提供一个假象，好像我们的程序独占地使用处理器。</li>
<li>一个私有的地址空间，它提供一个假象，好像我们的程序独占地使用存储器系统。</li>
</ul>
<h4 id="8-2-1-逻辑控制流"><a href="#8-2-1-逻辑控制流" class="headerlink" title="8.2.1 逻辑控制流"></a>8.2.1 逻辑控制流</h4><p><strong>逻辑控制流</strong>提供一个假象，好像我们的程序在独占地使用处理器。如果想用调试器单步执行程序，我们会看到一系列的程序计数器(PC)的值，这些值唯一地对应于包含在程序的可执行目标文件中的指令，或者是包含在运行时动态链接到程序的共享对象中的指令。这个PC值的序列叫做<strong>逻辑控制流</strong>，或者简称逻辑流。</p>
<p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210615190649412.png" srcset="/img/loading.gif" lazyload alt="image-20210615190649412"></p>
<h4 id="8-2-2-并发流"><a href="#8-2-2-并发流" class="headerlink" title="8.2.2 并发流"></a>8.2.2 并发流</h4><p><strong>并发流</strong>：一个逻辑流的执行在时间上与另一个流重叠。更准确地说，流Ⅹ和Y互相并发，当且仅当X在Y开始之后和Y结束之前开始，或者Y在X开始之后和X结束之前开始。</p>
<p><strong>并发：</strong>多个流并发地执行的一般现象</p>
<p><strong>多任务：</strong>一个进程和其他进程轮流运行的概念</p>
<p><strong>时间片：</strong>一个进程执行它的控制流的一部分的每一时间叫做时间片，多任务也叫作时间分片。</p>
<p><strong>并行流：</strong>两个流并发的运行在不同的处理器核或者计算机上，它们并行地运行，且并行地执行</p>
<h4 id="8-2-3-私有地址空间"><a href="#8-2-3-私有地址空间" class="headerlink" title="8.2.3 私有地址空间"></a>8.2.3 私有地址空间</h4><p>进程也为每个程序提供一种假象，好像它独占地使用系统地址空间。</p>
<p>一个进程为每个程序提供它自己的私有地址空间。一般而言，和这个空间中某个地址相关联的那个存储器字节是不能被其他进程读或者写的，从这个意义上说，这个地址空间是私有的。</p>
<p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210622073331434.png" srcset="/img/loading.gif" lazyload alt="image-20210622073331434"></p>
<h4 id="8-2-4-用户模式和内核模式"><a href="#8-2-4-用户模式和内核模式" class="headerlink" title="8.2.4 用户模式和内核模式"></a>8.2.4 用户模式和内核模式</h4><p>通过模式位来控制</p>
<p><strong>内核模式：</strong>设置了模式位后，一个运行在内核模式的进程可以执行指令集中的任何指令，并且可以访问系统中任何存储器位置。</p>
<p><strong>用户模式：</strong>没有设置模式位时，进程就运行在用户模式中。用户模式中的进程不允许执行特权指令(privileged instruction),比如停止处理器、改变模式位，或者发起一个IO操作。也不允许用户模式中的进程直接引用地址空间中内核区内的代码和数据。任何这样的尝试都会导致致命的保护故障。反之，用户程序必须通过系统调用接口间接地访问内核代码和数据。</p>
<h4 id="8-2-5-上下文切换"><a href="#8-2-5-上下文切换" class="headerlink" title="8.2.5 上下文切换"></a>8.2.5 上下文切换</h4><p>操作系统内核使用一种称为<strong>上下文切换</strong>的较高层形式的异常控制流来实现多任务。</p>
<p><strong>上下文</strong>就是内核重新启动一个被抢占的进程所需的状态。它由一些对象的值组成，这些对象包括通用目的寄存器、浮点寄存器、程序计数器、用户栈、状态寄存器、内核栈和各种内核数据结构，比如描绘地址空间的页表、包含有关当前进程信息的进程表，以及包含进程已打开文件的信息的文件表。<br>在进程执行的某些时刻，内核可以决定抢占当前进程，并重新开始一个先前被抢占的进程。这种决定就叫做<strong>调度</strong>( schedule),是由内核中称为<strong>调度器</strong>( scheduler)的代码处理的。当内核选择一个新的进程运行时，我们就说内核调度了这个进程。在内核调度了一个新的进程运行后，它就抢占当前进程，并使用一种称为上下文切换的机制来将控制转移到新的进程。</p>
<p><strong>上下文切换：</strong></p>
<ol>
<li><p>保存当前进程的上下文</p>
</li>
<li><p>恢复某个先前被抢占的进程被保存的上下文</p>
</li>
<li><p>将控制传递给这个新恢复的进程。</p>
</li>
</ol>
<p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210615194036573.png" srcset="/img/loading.gif" lazyload alt="image-20210615194036573"></p>
<hr>
<h3 id="8-3-系统调用错误处理"><a href="#8-3-系统调用错误处理" class="headerlink" title="8.3 系统调用错误处理"></a>8.3 系统调用错误处理</h3><p>当Unix系统级函数遇到错误时，它们典型地返回-1,并设置全局整数变量errno来表示什么出错了。</p>
<p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210615194451811.png" srcset="/img/loading.gif" lazyload alt="image-20210615194451811"></p>
<p>简化</p>
<p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210615194500771.png" srcset="/img/loading.gif" lazyload alt="image-20210615194500771"></p>
<p>再简化</p>
<p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210615194519890.png" srcset="/img/loading.gif" lazyload alt="image-20210615194519890"></p>
<p>再简化</p>
<p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210615194534416.png" srcset="/img/loading.gif" lazyload alt="image-20210615194534416"></p>
<hr>
<h3 id="8-4-进程控制"><a href="#8-4-进程控制" class="headerlink" title="8.4 进程控制"></a>8.4 进程控制</h3><h4 id="8-4-1-获取进程ID"><a href="#8-4-1-获取进程ID" class="headerlink" title="8.4.1 获取进程ID"></a>8.4.1 获取进程ID</h4><p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210615200923542.png" srcset="/img/loading.gif" lazyload alt="image-20210615200923542"></p>
<h4 id="8-4-2-创建和终止进程"><a href="#8-4-2-创建和终止进程" class="headerlink" title="8.4.2 创建和终止进程"></a>8.4.2 创建和终止进程</h4><p>从程序员的角度，我们可以认为进程总是处于下面三种状态之一：</p>
<ul>
<li><p><strong>运行</strong>。进程要么在CPU上执行，要么在等待被执行且最终会被内核调度。</p>
</li>
<li><p><strong>停止</strong>。进程的执行被挂起( suspend),且不会被调度。当收到 SIGSTOP、 SIGTSTP、SIDTTIN或者 SIGTTOU信号时，进程就停止，并且保持停止直到它收到一个 SIGCONT信号，在这个时刻，进程再次开始运行。</p>
</li>
<li><p><strong>终止</strong>。进程永远地停止了。进程会因为三种原因终止：</p>
<ol>
<li><p>收到一个信号，该信号的默认行为是终止进程，</p>
</li>
<li><p>从主程序返回</p>
</li>
<li><p>调用exit函数。</p>
</li>
</ol>
</li>
</ul>
<p><strong>子进程（fork函数如何创建）：</strong>新创建的子讲程几乎但不完全与父进程相同。子进程得到与父进程用户级虚拟地址空间相同的（但是独立的）一份拷贝，包括文本、数据和bss段、堆以及用户栈。子进程还获得与父进程任何打开文件描述符相同的拷贝，这就意味着当父进程调用fork时，子进程可以读写父进程中打开的任何文件。父进程和新创建的子进程之间<strong>最大的区别</strong>在于它们有<strong>不同的PID</strong>。</p>
<p>示例程序：</p>
<p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210615201819338.png" srcset="/img/loading.gif" lazyload alt="image-20210615201819338"></p>
<p><strong>fork函数的特点：</strong>调用一次，返回两次一次是在调用进程（父进程）中，一次是在新创建的子进程中。在父进程中，fork返回子进程的<br>PID。在子进程中，fork返回0。因为子进程的PID总是非零的，返回值就提供一个明确的方法来分辨程序是在父进程还是在子进程中执行。</p>
<p><strong>这个例子（父子进程）的一些特点：</strong></p>
<ul>
<li><p><strong>调用一次，返回两次。</strong>fork函数被父进程调用一次，但是却返回两次。一次是返回到父进程，一次是返回到新创建的子进程。</p>
</li>
<li><p><strong>并发执行。</strong>父进程和子进程是并发运行的独立进程。内核能够以任意方式交替执行它们的逻辑控制流中的指令。当我们在系统上运行这个程序时，父进程先完成它的 printf语句，然后是子进程。然而，在另一个系统上可能正好相反。一般而言，作为程序员，我们决不能对不同进程中指令的交替执行做任何假设。</p>
</li>
<li><p><strong>相同的但是独立的地址空间。</strong>如果能够在fork函数在父进程和子进程中返回后立即暂停这两个进程，我们会看到每个进程的地址空间都是相同的。每个进程有相同的用户栈、相同的本地变量值、相同的堆、相同的全局变量值，以及相同的代码。</p>
<p>因此，在我们的示例程序中，当fork函数在第8行返回时，本地变量x在父进程和子进程中都为1。然而因为父进程和子进程是独立的进程，它们都有自己的私有地址空间。父进程和子进程对所做的任何改变都是独立的，不会反映在另一个进程的存储器中。这就是为什么当父进程和子进程调用它们各自的 printf语句时，它们中的变量x会有不同的值的原因。</p>
</li>
<li><p><strong>共享文件。</strong>当运行这个示例程序时，我们注意到父进程和子进程都把它们的输出显示在屏幕上。原因是子进程继承了父进程所有的打开文件。当父进程调用fork时， stdout文件是被打开的，并指向屏幕。子进程继承了这个文件，因此它的输出也是指向屏幕的。</p>
</li>
</ul>
<p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210615201857583.png" srcset="/img/loading.gif" lazyload alt="image-20210615201857583"></p>
<h4 id="8-4-3-回收子进程"><a href="#8-4-3-回收子进程" class="headerlink" title="8.4.3 回收子进程"></a>8.4.3 回收子进程</h4><p><strong>僵死进程：</strong>一个终止了但未被回收的进程</p>
<p><strong>waitpid函数：</strong></p>
<p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210615203910901.png" srcset="/img/loading.gif" lazyload alt="image-20210615203910901"></p>
<p>默认地(当 options=0时)， waitpid<strong>挂起</strong>调用进程的执行，直到它的等待集合中的一个子进程终止。</p>
<p>如果等待集合中的一个进程在刚调用的时刻就已经终止了，那么 waitpid就立即返回。在这两种情况下， waitpid返回导致 waitpid返回的<strong>已终止子进程的PID</strong>,并且将这个已终止的子进程从系统中去除。</p>
<ol>
<li><p><strong>判断等待集合的成员</strong></p>
<p>等待集合的成员是由参数pid来确定的：</p>
<ul>
<li>如果pid&gt;0,那么等待集合就是一个单独的子进程，它的进程D等于pid</li>
<li>如果pid=-1,那么等待集合就是由父进程所有的子进程组成的。</li>
</ul>
</li>
<li><p><strong>修改默认行为</strong></p>
<p>可以通过将 options设置为常量 WNOHANG和WUNTIRACED的各种组合，修改默认行为</p>
<ul>
<li>**WNOHANG:**如果等待集合中的任何子进程都还没有终止，那么就立即返回（返回值为0)。默认的行为是挂起调用进程，直到有子进程终止。在等待子进程终止的同时，如果还想做些有用的工作，这个选项会有用</li>
<li>**WUNTRACED:**挂起调用进程的执行，直到等待集合中的一个进程变成已终止或者被停止。返回的PD为导致返回的已终止或被停止子进程的PD。默认的行为是只返回已终止的子进程。当你想要检查已终止和被停止的子进程时，这个选项会有用。</li>
<li><strong>WNOHANG|WUNTRACED</strong>:立即返回，如果等待集合中没有任何子进程被停止或已终止，那么返回值为0,或者返回值等于那个被停止或者已终止的子进程的PID。</li>
</ul>
</li>
<li><p><strong>检查已回收子进程的退出状态</strong></p>
<p>如果 status参数是非空的，那么 waitpid就会在 status参数中放上关于导致返回的子进程的状态信息。wait,h头文件定义了解释 status参数的几个宏：</p>
<ul>
<li>**WIFEXITED(status)**：如果子进程通过调用exit或者一个返回(return)正常终止，就返回真。</li>
<li><strong>WEXITSTATUS(status):</strong> 返回一个正常终止的子进程的退出状态。只有在 WIFEXITED返回为真时，才会定义这个状态。</li>
<li><strong>WIFSIGNALED(status):</strong> 如果子进程是因为一个未被捕获的信号终止的，那么就返回真(将在8.5节中解释说明信号)。</li>
<li><strong>WTERMSIG(status):</strong> 返回导致子进程终止的信号的数量。只有在 WIFSIGNALED(status)返回为真时，才定义这个状态。</li>
<li><strong>WIFSTOPPED(status):</strong> 如果引起返回的子进程当前是被停止的，那么就返回真。</li>
<li>WSTOPSIG(status): 返回引起子进程停止的信号的数量。只有在 WIFSTOPPED(status)返回为真时，才定义这个状态。</li>
</ul>
</li>
<li><p><strong>错误条件</strong></p>
<p>如果调用进程没有子进程，那么 waitpid返回-1,并且设置 errno为 <strong>ECHILD</strong>。如果waitpid函数被一个信号中断，那么它返回-1,并设置 errno为 <strong>EINTR</strong>。</p>
</li>
<li><p>wait<strong>函数</strong></p>
<p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210615205135841.png" srcset="/img/loading.gif" lazyload alt="image-20210615205135841"></p>
</li>
</ol>
<h4 id="8-4-4-让进程休眠"><a href="#8-4-4-让进程休眠" class="headerlink" title="8.4.4 让进程休眠"></a>8.4.4 让进程休眠</h4><p><strong>sleep函数</strong></p>
<p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210615205249733.png" srcset="/img/loading.gif" lazyload alt="image-20210615205249733"></p>
<p><strong>pause函数</strong></p>
<p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210615205335143.png" srcset="/img/loading.gif" lazyload alt="image-20210615205335143"></p>
<h4 id="8-4-5-加载并运行程序"><a href="#8-4-5-加载并运行程序" class="headerlink" title="8.4.5 加载并运行程序"></a>8.4.5 加载并运行程序</h4><h4 id="8-4-6-利用fork和execve运行程序"><a href="#8-4-6-利用fork和execve运行程序" class="headerlink" title="8.4.6 利用fork和execve运行程序"></a>8.4.6 利用fork和execve运行程序</h4><hr>
<h3 id="8-5-信号"><a href="#8-5-信号" class="headerlink" title="8.5 信号"></a>8.5 信号</h3><p><strong>信号</strong>就是一条小消息，它通知进程系统中发射了一个某种类型的事件。</p>
<p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210616132126470.png" srcset="/img/loading.gif" lazyload alt="image-20210616132126470"></p>
<h4 id="8-5-1-信号术语"><a href="#8-5-1-信号术语" class="headerlink" title="8.5.1 信号术语"></a>8.5.1 信号术语</h4><p>传送一个信号到目的进程是由两个不同步骤组成的：</p>
<ul>
<li><strong>发送信号</strong>。内核通过更新目的进程上下文中的某个状态，发送（递送）一个信号给目的进程。发送信号可以有如下两个原因：<ul>
<li><ol>
<li>内核检测到一个系统事件，比如被零除错误或者<br>子进程终止。</li>
</ol>
</li>
<li><ol start="2">
<li>一个进程调用了kill函数（在下一节中讨论），显式地要求内核发送一个信号给目的进程。一个进程可以发送信号给它自己。</li>
</ol>
</li>
</ul>
</li>
<li><strong>接收信号</strong>。当目的进程被内核强迫以某种方式对信号的发送做出反应时，目的进程就接收了信号。进程可以忽略这个信号，终止或者通过执行一个称为信号处理程序（signal handler)的用户层函数捕获这个信号。</li>
</ul>
<p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210616134151781-1623822116278.png" srcset="/img/loading.gif" lazyload alt="image-20210616134151781"></p>
<p><strong>待处理信号（pending signal)：</strong>一个只发出而没有被接收的信号。</p>
<ul>
<li><p>在任何时刻，一种类型只会有有一个待处理信号。</p>
</li>
<li><p>一个进程可以有选择性地阻塞接受某种信号。当一种信号被阻塞时，它仍可以被发送，但是产生的待处理信号不会被接受，知道进程取消对这种信号的阻塞。</p>
</li>
<li><p>一个待处理信号最多被接受一次。</p>
</li>
</ul>
<h4 id="8-5-2-发送信号"><a href="#8-5-2-发送信号" class="headerlink" title="8.5.2 发送信号"></a>8.5.2 发送信号</h4><ol>
<li><p><strong>进程组</strong></p>
<p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210616135725636.png" srcset="/img/loading.gif" lazyload alt="image-20210616135725636"></p>
<p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210616135744711.png" srcset="/img/loading.gif" lazyload alt="image-20210616135744711"></p>
</li>
<li><p><strong>用/bin/kill程序发送信号</strong></p>
<p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210616135759238.png" srcset="/img/loading.gif" lazyload alt="image-20210616135759238"></p>
</li>
<li><p><strong>从键盘发送信号</strong></p>
<p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210616140206513.png" srcset="/img/loading.gif" lazyload alt="image-20210616140206513"></p>
<p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210616140217571.png" srcset="/img/loading.gif" lazyload alt="image-20210616140217571"></p>
</li>
<li><p><strong>用kill函数发送信号</strong></p>
<p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210616140454210.png" srcset="/img/loading.gif" lazyload alt="image-20210616140454210"></p>
</li>
<li><p><strong>用alarm函数发生信号</strong></p>
<p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210616141623550.png" srcset="/img/loading.gif" lazyload alt="image-20210616141623550"></p>
<p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210616141648506.png" srcset="/img/loading.gif" lazyload alt="image-20210616141648506"></p>
</li>
</ol>
<h4 id="8-5-3-接收信号"><a href="#8-5-3-接收信号" class="headerlink" title="8.5.3 接收信号"></a>8.5.3 接收信号</h4><p>当内核从一个异常处理程序返回，准备将控制传递给进程P时，它会检查进程P的未被阻塞的待处理信号的集合( pending&amp;~ blocked)。如果这个集合为空（通常情况下），那么内核将控制传递到p的逻辑控制流中的下一条指令(l<del>next</del>).<br>然而，如果集合是非空的，那么内核选择集合中的某个信号k(通常是最小的k),并且强制P接收信号k。收到这个信号会触发进程的某种行为。一旦进程完成了这个行为，那么控制就传递回P的逻辑控制流中的下一条指令(l<del>next</del>)。</p>
<p>每个信号类型都有一个预定义的<strong>默认行为</strong>，是下面中的一种：</p>
<ul>
<li>进程终止。</li>
<li>进程终止并转储存储器 (dump core)。</li>
<li>进程停止直到被 SIGCONT信号重启。</li>
<li>进程忽略该信号。</li>
</ul>
<p><strong>signal函数：</strong></p>
<p>进程通过使用一个signal函数修改和信号相关联的默认行为</p>
<p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210616143233373.png" srcset="/img/loading.gif" lazyload alt="image-20210616143233373"></p>
<p>signal函数可以通过下列三种方法之一来改变和信号 signum相关联的行为：</p>
<ul>
<li>如果 handler是SIG_IGN,那么忽略类型为 signum的信号。</li>
<li>如果 handler是SIG_DFL,那么类型为 signum的信号行为恢复为默认行为。</li>
<li>否则， handler就是用户定义的函数的地址，这个函数称为<strong>信号处理程序</strong>（ signal handler),只要进程接收到一个类型为 signum的信号，就会调用这个程序。通过把处理程序的地址传递到 signal函数从而改变默认行为，这叫做<strong>设置信号处理程序</strong>（installing the handler)。调用信号处理程序称为<strong>捕获信号</strong>。执行信号处理程序称为<strong>处理信号</strong>。</li>
</ul>
<p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210616150205507.png" srcset="/img/loading.gif" lazyload alt="image-20210616150205507"></p>
<p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210616150220611.png" srcset="/img/loading.gif" lazyload alt="image-20210616150220611"></p>
<h4 id="8-5-4-信号处理问题"><a href="#8-5-4-信号处理问题" class="headerlink" title="8.5.4 信号处理问题"></a>8.5.4 信号处理问题</h4><p>要捕获多个信号的一些问题：</p>
<ul>
<li><strong>待处理信号被阻塞</strong>。Unix信号处理程序通常会阻塞当前处理程序正在处理的类型的待处理信号。比如，假设一个进程捕获了一个 SIGINT信号，并且当前正在运行它的 SIGINT处理程序。如果另一个 SIGINT信号传递到这个进程，那么这个 SIGINT将变成待处理的，但是不会被接收，直到处理程序返回。</li>
<li><strong>待处理信号不会排队等待</strong>。任意类型至多只有一个待处理信号。因此，如果有两个类型为k的信号传送到一个目的进程，而由于目的进程当前正在执行信号k的处理程序，所以信号k是阻塞的，那么第二个信号就被简单地丢弃，它不会排队等待。关键思想是存在一个待处理的信号仅仅表明至少已经有一个信号到达了。</li>
<li><strong>系统调用可以被中断</strong>。像read、wait和 accept这样的系统调用潜在地会阻塞进程一段较长的时间，称为慢速系统调用。在某些系统中，当处理程序捕获到一个信号时，被中断的慢速系统调用在信号处理程序返回时不再继续，而是立即返回给用户一个错误条件，并将 errno设置为 EINTR。</li>
</ul>
<h4 id="8-5-5-可移植的信号处理"><a href="#8-5-5-可移植的信号处理" class="headerlink" title="8.5.5 可移植的信号处理"></a>8.5.5 可移植的信号处理</h4><p>为了处理不同系统之间信号处理语义的差异，可以定义一个包装函数，称为Signal。它的调用方式和signal函数的调用方式一样。</p>
<p>Signal包装函数设置了一个信号处理程序，其信号处理语义如下：</p>
<ul>
<li>只有这个处理程序当前正在处理的那种类型的信号被阻塞</li>
<li>和所有信号实现一样，信号不会排队等待。</li>
<li>只要可能，被中断的系统调用会自动重启。</li>
<li>一旦设置了信号处理程序，它就会一直保持，直到 Signal带着 handler参数为SIG_IGN或者 SIG_DFL被调用。（一些比较老的Unⅸ系统会在一个处理程序处理完一个信号之后，将信号行为恢复为它的默认行为。）</li>
</ul>
<h4 id="8-5-6-显示地阻塞和取消阻塞信号"><a href="#8-5-6-显示地阻塞和取消阻塞信号" class="headerlink" title="8.5.6 显示地阻塞和取消阻塞信号"></a>8.5.6 显示地阻塞和取消阻塞信号</h4><p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210616155200810.png" srcset="/img/loading.gif" lazyload alt="image-20210616155200810"></p>
<h4 id="8-5-7-同步流以避免讨厌的并发错误"><a href="#8-5-7-同步流以避免讨厌的并发错误" class="headerlink" title="8.5.7 同步流以避免讨厌的并发错误"></a>8.5.7 同步流以避免讨厌的并发错误</h4><p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210616155703781.png" srcset="/img/loading.gif" lazyload alt="image-20210616155703781"></p>
<p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210616155808141.png" srcset="/img/loading.gif" lazyload alt="image-20210616155808141"></p>
<p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210616155726929.png" srcset="/img/loading.gif" lazyload alt="image-20210616155726929"></p>
<p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210616155823683.png" srcset="/img/loading.gif" lazyload alt="image-20210616155823683"></p>
<p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210616155903713.png" srcset="/img/loading.gif" lazyload alt="image-20210616155903713"></p>
<hr>
<h3 id="8-6-非本地跳转"><a href="#8-6-非本地跳转" class="headerlink" title="8.6 非本地跳转"></a>8.6 非本地跳转</h3><p><strong>非本地跳转：</strong></p>
<p>C语言提供了一种用户级异常控制流形式，称为<strong>非本地跳转</strong>( nonlocal jump),它将控制直接从一个函数转移到另一个当前正在执行的函数，而不需要经过正常的调用一返回序列。非本地跳转是通过 setjmp和longjmp函数来提供的。</p>
<p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210616160043032.png" srcset="/img/loading.gif" lazyload alt="image-20210616160043032"></p>
<ul>
<li><p>非本地跳转的一个重要应用：允许从一个深层嵌套的函数调用中立即返回，通常是由检测到某个错误情况引起的。</p>
</li>
<li><p>非本地跳转的另一个重要应用：是使一个信号处理程序分支到一个特殊的代码位置，而不是返回到被信号到达中断了的指令的位置。</p>
</li>
</ul>
<h3 id="8-7-操作进程的工具"><a href="#8-7-操作进程的工具" class="headerlink" title="8.7 操作进程的工具"></a>8.7 操作进程的工具</h3><p>Linux系统提供了大量的监控和操作进程的有用工具：</p>
<ul>
<li><strong>STRACE</strong>: 打印一个正在运行的程序和它的子进程调用的每个系统调用的轨迹。对于好奇的学生而言，这是一个令人着迷的工具。用- static编译你的程序，能得到一个更干净的、不带有大量与共享库相关的输出的轨迹。</li>
<li><strong>PS</strong>: 列出当前系统中的进程（包括僵死进程）。</li>
<li><strong>TOP</strong>: 打印出关于当前进程资源使用的信息</li>
<li><strong>PMAP</strong>: 显示进程的存储器映射。</li>
<li>/<strong>proc</strong>: 一个虚拟文件系统，以ASCII文本格式输出大量内核数据结构的内容，用户程序可以读取这些内容。比如，输入“cat/proc/loadavg”，观察在Linux系统上当前的平均负载。</li>
</ul>
<hr>
<h2 id="第九章-虚拟存储器"><a href="#第九章-虚拟存储器" class="headerlink" title="第九章 虚拟存储器"></a>第九章 虚拟存储器</h2><h3 id="9-1-物理和虚拟寻址"><a href="#9-1-物理和虚拟寻址" class="headerlink" title="9.1 物理和虚拟寻址"></a>9.1 物理和虚拟寻址</h3><p><strong>物理寻址：</strong></p>
<p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210616173343847.png" srcset="/img/loading.gif" lazyload alt="image-20210616173343847"></p>
<p><strong>虚拟寻址：</strong></p>
<p>使用虚拟寻址时，CPU通过生成一个虚拟地址( Virtual Address,VA)来访问主存，这个虚拟地址在被送到存储器之前先转换成适当的物理地址。将一个虚拟地址转换为物理地址的任务叫做地址翻译(address translation)。</p>
<p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210616173400967.png" srcset="/img/loading.gif" lazyload alt="image-20210616173400967"></p>
<hr>
<h3 id="9-2-地址空间"><a href="#9-2-地址空间" class="headerlink" title="9.2 地址空间"></a>9.2 地址空间</h3><p>地址空间是一个非负整数的有序集合：</p>
<p>{0,1,2，···}</p>
<p>虚拟地址空间：{0,1,2，···，N-1}</p>
<p>物理地址空间：{0,1,2，···，M-1}</p>
<p>地址空间的概念是很重要的，因为它清楚地区分了数据对象（字节）和它们的属性（地址）。一旦认识到了这种区别，那么我们就可以将其推广，允许每个数据对象有多个独立的地址，其中每个地址都选自一个不同的地址空间。这就是虚拟存储器的基本思想。主存中的每个字节都有个选自虚拟地址空间的虚拟地址和一个选自物理地址空间的物理地址。</p>
<hr>
<h3 id="9-3-虚拟存储器作为缓存的工具"><a href="#9-3-虚拟存储器作为缓存的工具" class="headerlink" title="9.3 虚拟存储器作为缓存的工具"></a>9.3 虚拟存储器作为缓存的工具</h3><p><strong>虚拟存储器</strong>(VM)被组织为一个由存放在磁盘上的N个连续的字节大小的单元组成的数组。每字节都有一个唯一的虚拟地址，这个唯一的虚拟地址是作为到数组的索引的。</p>
<p>VM系统将虚拟存储器分割为称为<strong>虚拟页</strong>( Virtual Page,VP)的大小固定的块。每个虚拟页的大小为P=2^p^字节。</p>
<p>类似地，物理存储器被分割为<strong>物理页</strong>( Physical Page,PP),大小也为P字节（物理页也称为页帧( page frame))。</p>
<p>一个n位的地址空间有2^n-p^页</p>
<p>在任意时刻，虚拟页面的集合都分为三个不相交的子集：</p>
<ul>
<li><strong>未分配的</strong>：VM系统还未分配（或者创建）的页。未分配的块没有任何数据和它们相关联，因此也就不占用任何磁盘空间。</li>
<li><strong>缓存的</strong>：当前缓存在物理存储器中的已分配页。</li>
<li><strong>未缓存的</strong>：没有缓存在物理存储器中的已分配页。</li>
</ul>
<p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210616175211113.png" srcset="/img/loading.gif" lazyload alt="image-20210616175211113"></p>
<h4 id="9-3-1-DRAM缓存的组织结构"><a href="#9-3-1-DRAM缓存的组织结构" class="headerlink" title="9.3.1 DRAM缓存的组织结构"></a>9.3.1 DRAM缓存的组织结构</h4><p>SRAM缓存：位于CPU和主存之间的L1、L2和L3高速缓存</p>
<p>DRAM缓存：虚拟存储器系统的缓存，它在主存中缓存虚拟页</p>
<p><strong>DRAM缓存的组织结构：</strong></p>
<ul>
<li>SRAM比DRAM快大约10倍，DRAM要比磁盘快大约100000多倍</li>
<li>巨大的不命中处罚和访问第一字节的开销</li>
<li>由于大的不命中处罚，DRAM缓存是全相连的</li>
<li>使用写回而不是直写</li>
</ul>
<h4 id="9-3-2-页表"><a href="#9-3-2-页表" class="headerlink" title="9.3.2 页表"></a>9.3.2 页表</h4><p>页表存放在<strong>物理存储器</strong>中</p>
<p><strong>页表</strong>就是一个<strong>页表条目</strong>（PTE）的数组，负责将虚拟页映射到物理页。每次地址翻译软件将一个虚拟地址转换成物理地址时都会读取页表。操作系统负责维护页表的内容，以及在磁盘和DRAM之间来回传送页。</p>
<p>每个PTE由一个有效位和一个n位地址字段组成</p>
<ul>
<li><p>设置了有效位（已缓存）</p>
<p>表明该虚拟页被缓存在DRAM中，地址字段表示DRAM中相应的物理页的起始位置，这个物理页缓存了该虚拟页</p>
</li>
<li><p>未设置有效位（还未被缓存）</p>
<ul>
<li>一个空地址表示这个虚拟页还未被分配</li>
<li>否则这个地址指向该虚拟页在磁盘上的起始位置（已分配未缓存）</li>
</ul>
</li>
</ul>
<p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210616211103583.png" srcset="/img/loading.gif" lazyload alt="image-20210616211103583"></p>
<h4 id="9-3-3-页命中"><a href="#9-3-3-页命中" class="headerlink" title="9.3.3 页命中"></a>9.3.3 页命中</h4><p>地址翻译硬件将虚拟地址作为一个索引来定位PTE 2,并从存储器中读取它。因为设置了有效位，那么地址翻译硬件就知道VP 2是缓存在存储器中的了。所以它使用PTE中的物理存储器地址（该地址指向PP 1中缓存页的起始位置），构造出这个字的物理地址。</p>
<h4 id="9-3-4-缺页"><a href="#9-3-4-缺页" class="headerlink" title="9.3.4 缺页"></a>9.3.4 缺页</h4><p>DRAM缓存不命中称为<strong>缺页</strong></p>
<p>发现缺页后触发一个缺页异常，调用内核中的缺页异常处理程序，在物理页中选择一个牺牲页，如果牺牲页被修改过了则将牺牲页保存回磁盘，无论是否修改，内核都会修改牺牲页的PTE，然后将目标虚拟页缓存到磁盘中对应的物理页，更新目标页的PTE，然后异常处理程序返回，它会重新启动导致缺页的指令。</p>
<p><strong>交换</strong>( swapping)或者<strong>页面调度</strong>( paging)：在磁盘和存储器之间传送页的活动。</p>
<p>页从磁盘换入（或者页面调入）DRAM和从DRAM换出（或者页面调出）磁盘。</p>
<p><strong>按需页面调度：</strong>一直等待，直到最后时刻，也就是当有不命中发生时，才换入页面的一种策略</p>
<h4 id="9-3-5-分配页面"><a href="#9-3-5-分配页面" class="headerlink" title="9.3.5 分配页面"></a>9.3.5 分配页面</h4><p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210616212903869.png" srcset="/img/loading.gif" lazyload alt="image-20210616212903869"></p>
<h4 id="9-3-6-又是局部性救了我们"><a href="#9-3-6-又是局部性救了我们" class="headerlink" title="9.3.6 又是局部性救了我们"></a>9.3.6 又是局部性救了我们</h4><p>尽管在整个运行过程中程序引用的不同页面的总数可能超出物理存储器总的大小，但是局部性原则保证了在任意时刻，程序将往往在一个较小的活动页面( active page)集合上工作，这个集合叫做工作集( working set)或者常驻集( resident set)。在初始开销，也就是将工作集页面调度到存储器中之后，接下来对这个工作集的引用将导致命中，而不会产生额外的磁盘流量</p>
<p>如果工作集的大小超出了物理存储器的大小，那么程序将产生一种不幸的状态，叫做<strong>颠簸(</strong> thrashing),这时页面将不断地<br>换进换出。虽然虚拟存储器通常是有效的，但会很慢。</p>
<hr>
<h3 id="9-4-虚拟存储器作为存储器管理的工具"><a href="#9-4-虚拟存储器作为存储器管理的工具" class="headerlink" title="9.4 虚拟存储器作为存储器管理的工具"></a>9.4 虚拟存储器作为存储器管理的工具</h3><p>VM简化了链接和加载、代码和数据共享，以及应用程序的存储器分配。</p>
<ul>
<li><strong>简化链接</strong>。独立的地址空间允许每个进程的存储器映像使用相同的基本格式，而不管代码和数据实际存放在物理存储器的何处。例如，像我们在图813中看到的，个给定的Linux系统上的每个进程都使用类似的存储器格式。文本节总是从虛拟地址0x08048000处开始(对于32位地址空间)，或者从0x400000处开始(对于64位地址空间)。数据和节紧跟在文本节后面。栈占据进程地址空间最高的部分，并向下生长。这样的一致性极大地简化了链接器的设计和实现，允许链接器生成全链接的可执行文件，这些可执行文件是独立于物理存储器中代码和数据的最终位置的。</li>
<li><strong>简化加载</strong>。虚拟存储器还使得容易向存储器中加载可执行文件和共享对象文件。回想一下第7章，在ELF可执行文件中.text和.data节是连续的。要把这些节加载到一个新创建的进程中， Linux加载器分配虚拟页的一个连续的片(chunk),从地址0x08048000处开始(对于32位地址空间)，或者从0x400000处开始(对于64位地址空间)，把这些虚拟页标记为无效的（即未被缓存的），将页表条目指向目标文件中适当的位置。有趣的是，加载器从不实际拷贝任何数据从磁盘到存储器。在每个页初次被引用时，要么是CPU取指令时引用的，要么是一条正在执行的指令引用一个存储器位置时引用的，虚拟存储器系统会按照需要自动地调入数据页。</li>
<li><strong>简化共享</strong>。独立地址空间为操作系统提供了一个管理用户进程和操作系统自身之间共享的致机制。一般而言，每个进程都有自己私有的代码、数据、堆以及栈区域，是不和其他进程共享的。在这种情况下，操作系统创建页表，将相应的虚拟页映射到不同的物理页面。</li>
<li><strong>简化存储器分配</strong>。虚拟存储器为向用户进程提供一个简单的分配额外存储器的机制。当个运行在用户进程中的程序要求额外的堆空间时(如调用ma11oc的结果)，操作系统分配一个适当数字(例如k)个连续的虚拟存储器页面，并且将它们映射到物理存储器中任意位置的k个任意的物理页面。由于页表工作的方式，操作系统没有必要分配k个连续的物理存储器页面。页面可以随机地分散在物理存储器中。</li>
</ul>
<hr>
<h3 id="9-5-虚拟存储器作为存储器保护的工具"><a href="#9-5-虚拟存储器作为存储器保护的工具" class="headerlink" title="9.5 虚拟存储器作为存储器保护的工具"></a>9.5 虚拟存储器作为存储器保护的工具</h3><p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210616214509999.png" srcset="/img/loading.gif" lazyload alt="image-20210616214509999"></p>
<p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210616214520599.png" srcset="/img/loading.gif" lazyload alt="image-20210616214520599"></p>
<p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210616214457345.png" srcset="/img/loading.gif" lazyload alt="image-20210616214457345"></p>
<hr>
<h3 id="9-6-地址翻译"><a href="#9-6-地址翻译" class="headerlink" title="9.6 地址翻译"></a>9.6 地址翻译</h3><p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210617120441290.png" srcset="/img/loading.gif" lazyload alt="image-20210617120441290">地址翻译是一个N元素的虚拟地址空间（VAS)中的元素和一个M元素的物理地址空间（PAS)中元素之间的映射，</p>
<p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210618142508589.png" srcset="/img/loading.gif" lazyload alt="image-20210618142508589"></p>
<p><strong>MMU如何利用页表来实现这种映射:</strong></p>
<p>CPU中的一个控制寄存器，<strong>页表基址寄存器</strong>( Page Table Base Register,PTBR)指向当前页表。</p>
<p>n位的虚拟地址包含两个部分：一个p位的<strong>虚拟页面偏移</strong>( Virtual Page Offset,<strong>VPO</strong>)和一个(n-p)位的<strong>虚拟页号</strong>（ Virtual Page Number,<strong>VPN</strong>).</p>
<p>MMU利用VPN来选择适当的PTE。例如，VPN0选择PTE0,VPN1选择PTE1,以此类推。</p>
<p>将页表条目中<strong>物理页号</strong>( Physical Page Number,PPN)和虚拟地址中的<strong>VPO</strong>串联起来，就得到相应的物理地址。</p>
<p>注意，因为物理和虚拟页面都是P字节的，所以<strong>物理页面</strong><br><strong>偏移</strong>( Physical Page Offset,PPO)和VPO是相同的。</p>
<p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210618142837272.png" srcset="/img/loading.gif" lazyload alt="image-20210618142837272"></p>
<p><strong>当页面命中时，CPU硬件执行的步骤:</strong></p>
<p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210618143403713.png" srcset="/img/loading.gif" lazyload alt="image-20210618143403713"></p>
<ul>
<li>第一步：处理器生成一个虚拟地址，并把它传送给MMU</li>
<li>第二步：MMU生成PTE地址，并从高速缓存/主存请求得到它。</li>
<li>第三步：高速缓存/主存向MMU返回PTE.</li>
<li>第四步：MMU构造物理地址，并把它传送给高速缓存/主存。</li>
<li>第五步：高速缓存/主存返回所请求的数据字给处理器。</li>
</ul>
<p>页面命中完全是由硬件来处理的，与之不同的是，<strong>处理缺页</strong>要求硬件和操作系统内核协作完成:</p>
<p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210618143420468.png" srcset="/img/loading.gif" lazyload alt="image-20210618143420468"></p>
<ul>
<li>第一步到第三步：和图9-13a中的第一步到第三步相同。</li>
<li>第四步：PTE中的有效位是零，所以MMU触发了一次异常，传递CPU中的控制到操作系统内核中的缺页异常处理程序。</li>
<li>第五步：缺页处理程序确定出物理存储器中的牺牲页，如果这个页面已经被修改了，则把它换出到磁盘。</li>
<li>第六步：缺页处理程序页面调入新的页面，并更新存储器中的PTE.</li>
<li>第七步：缺页处理程序返回到原来的进程，再次执行导致缺页的指令。CPU将引起缺页的虚拟地址重新发送给MMU。因为虚拟页面现在缓存在物理存储器中，所以就会命中，在MMU执行了图9-13b中的步骤之后，主存就会将所请求字返回给处理器。</li>
</ul>
<h4 id="9-6-1-结合高速缓存和虚拟存储器"><a href="#9-6-1-结合高速缓存和虚拟存储器" class="headerlink" title="9.6.1 结合高速缓存和虚拟存储器"></a>9.6.1 结合高速缓存和虚拟存储器</h4><p>图9-14展示了<strong>一个物理寻址的高速缓存如何和虚拟存储器结合起来</strong>。主要的思路是地址翻译发生在高速缓存査找之前。注意，页表条目可以缓存，就像其他的数据字一样。</p>
<p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210618144221444.png" srcset="/img/loading.gif" lazyload alt="image-20210618144221444"></p>
<h4 id="9-6-2-利用TLB加速地址翻译"><a href="#9-6-2-利用TLB加速地址翻译" class="headerlink" title="9.6.2 利用TLB加速地址翻译"></a>9.6.2 利用TLB加速地址翻译</h4><p><strong>翻译后备缓冲器（TLB）：</strong>许多系统为了消除存储器读数据的开销，它们在MMU中包括了一个关于PTE的小的缓存。</p>
<p>它用于组选择和行匹配的索引和标记字段是从虚拟地址中<br>的虚拟页号中提取出来的。如果TLB有T=2^t^个组，那么TLB索引(TLBI)是由VPN的t个最低位组成的，而TLB标记(TLBT)是由VPN中剩余的位组成的。</p>
<p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210618145747729.png" srcset="/img/loading.gif" lazyload alt="image-20210618145747729"></p>
<p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210618145533203.png" srcset="/img/loading.gif" lazyload alt="image-20210618145533203"></p>
<p><strong>TLB命中时的步骤：</strong></p>
<ul>
<li>第一步：CPU产生一个虚拟地址。</li>
<li>第二步和第三步：MMU从TLB中取出相应的PTE.</li>
<li>第四步：MMU将这个虚拟地址翻译成一个物理地址，并且将它发送到高速缓存/主存。</li>
<li>第五步：高速缓存/主存将所请求的数据字返回给CPU.</li>
</ul>
<p>当TLB不命中时，MMU必须从L1缓存中取出相应的PTE,如图9-16b所示。新取出的PTE存放在TLB中，可能会覆盖一个已经存在的条目。</p>
<h4 id="9-6-3-多级页表"><a href="#9-6-3-多级页表" class="headerlink" title="9.6.3 多级页表"></a>9.6.3 多级页表</h4><p><strong>一级页表</strong>中的每个PTE负责映射虚拟地址空间中一个4MB的片( chunk),这里每一片都是由1024个连续的页面组成的。比如，PTE0映射第一片，PTE1映射接下来的一片，以此类推。假设地址空间是4GB,1024个PTE已经足够覆盖整个空间了。</p>
<p><strong>二级页表</strong>中的每个PTE都负责映射一个4KB的虚拟存储器页面，就像我们査看只有一级的页表一样。注意，使用4字节的PTE,每个一级和二级页表都是4KB字节，这刚好和一个页面<br>的大小是一样的。</p>
<p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210618152422961.png" srcset="/img/loading.gif" lazyload alt="image-20210618152422961"></p>
<p>这种方法从<strong>两个方面减少了存储器要求：</strong></p>
<ul>
<li>第一，如果一级页表中的一个PTE是空的，那么相应的二级页表就根本不会存在，这代表着一种巨大的潜在节约，因为对于一个典型的程序，4GB的虚拟地址空间的大部分都将是未分配的。</li>
<li>第二，只有一级页表才需要总是在主存中；虚拟存储器系统可以在需要时创建、页面调入或调出二级页表，这就减少了主存的压力；只有最经常使用的二级页表才需要缓存在主存中</li>
</ul>
<p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210618152610119.png" srcset="/img/loading.gif" lazyload alt="image-20210618152610119"></p>
<h4 id="9-6-4-综合：端到端的地址翻译"><a href="#9-6-4-综合：端到端的地址翻译" class="headerlink" title="9.6.4 综合：端到端的地址翻译"></a>9.6.4 综合：端到端的地址翻译</h4><p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210619114131611.png" srcset="/img/loading.gif" lazyload alt="image-20210619114131611"></p>
<p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210619114151547.png" srcset="/img/loading.gif" lazyload alt="image-20210619114151547"></p>
<p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210619114205017.png" srcset="/img/loading.gif" lazyload alt="image-20210619114205017"></p>
<p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210619114233781.png" srcset="/img/loading.gif" lazyload alt="image-20210619114233781"></p>
<p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210619114250559.png" srcset="/img/loading.gif" lazyload alt="image-20210619114250559"></p>
<hr>
<h3 id="9-7-案例研究：-Intel-Core-i7-Linux存储器系统"><a href="#9-7-案例研究：-Intel-Core-i7-Linux存储器系统" class="headerlink" title="9.7 案例研究： Intel Core i7/ Linux存储器系统"></a>9.7 案例研究： Intel Core i7/ Linux存储器系统</h3><hr>
<h3 id="9-8-存储器映射"><a href="#9-8-存储器映射" class="headerlink" title="9.8 存储器映射"></a>9.8 存储器映射</h3><h4 id="9-8-1-再看共亨对象"><a href="#9-8-1-再看共亨对象" class="headerlink" title="9.8.1 再看共亨对象"></a>9.8.1 再看共亨对象</h4><p>一个对象可以被映射到虚拟存储器的一个区域，要么作为<strong>共享对象</strong>，要么作为<strong>私有对象</strong>。</p>
<p>如果一个进程将一个<strong>共享对象</strong>映射到它的虚拟地址空间的一个区域内，那么这个进程对这个区域的任何写操作，对于那些也把这个共享对象映射到它们虚拟存储器的其他进程而言也是可见的。而且，这些变化也会反映在磁盘上的原始对象中。<br>另一方面，对一个映射到<strong>私有对象</strong>的区域做的改变，对于其他进程来说是不可见的，并且进程对这个区域所做的任何写操作都不会反映在磁盘上的对象中。一个映射到共享对象的虚拟存储器区域叫做共享区域。类似地，也有私有区域。</p>
<p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210621163041564.png" srcset="/img/loading.gif" lazyload alt="image-20210621163041564"></p>
<p><strong>写时拷贝</strong></p>
<p>私有对象是使用一种叫做<strong>写时拷贝</strong>(copy-on- write)的巧妙技术被映射到虚拟存储器中的。<br>一个私有对象开始生命周期的方式基本上与共享对象的一样，在物理存储器中只保存有私有对象的一份拷贝。比如，图9-30a展示了一种情况，其中两个进程将一个私有对象映射到它们虚拟存储器的不同区城，但是共享这个对象同一个物理拷贝。对于每个映射私有对象的进程，相应私有区域的页表条目都被标记为<strong>只读</strong>，并且区域结构被标记为私有的写时拷贝。只要没有进程试图写它自己的私有区域，它们就可以继续共享物理存储器中对象的一个单独拷贝。然而，只要有一个进程试图写私有区城内的某个页面，那么这个写操作就会触发一个保护故障。<br>当故障处理程序注意到保护异常是由于进程试图写私有的写时拷贝区城中的一个页面而引起的，它就会在物理存储器中<strong>创建这个页面的一个新拷贝</strong>，<strong>更新页表条目</strong>指向这个新的拷贝，然后<strong>恢复</strong>这个页面的<strong>可写权限</strong>，如图9-30b所示。当故障处理程序返回时，CPU重新执行这个写操作，现在在新创建的页面上这个写操作就可以正常执行了。<br>通过延迟私有对象中的拷贝直到最后可能的时刻，写时拷贝最充分地使用了稀有的物理存储器。</p>
<p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210621163448754.png" srcset="/img/loading.gif" lazyload alt="image-20210621163448754"></p>
<h4 id="9-8-2-再看fork函数"><a href="#9-8-2-再看fork函数" class="headerlink" title="9.8.2 再看fork函数"></a>9.8.2 再看fork函数</h4><p>新创建的子进程几乎但不完全与父进程相同。<strong>子进程得到与父进程用户级虚拟地址空间相同</strong><br><strong>的（但是独立的）一份拷贝，包括文本、数据和bss段、堆以及用户栈。子进程还获得与父进程</strong><br><strong>任何打开文件描述符相同的拷贝，这就意味着当父进程调用fork时，子进程可以读写父进程中</strong><br><strong>打开的任何文件。父进程和新创建的子进程之间最大的区别在于它们有不同的PID。</strong></p>
<p>既然我们理解了虚拟存储器和存储器映射，那么我们可以清晰地知道fork函数是如何创建一个带有自己独立虚拟地址空间的新进程的。<br><strong>当fork函数被当前进程调用时，内核为新进程创建各种数据结构，并分配给它一个唯一的PID.为了给这个新进程创建虚拟存储器，它创建了当前进程的 mm_struct、区域结构和页表的原样拷贝。它将两个进程中的每个页面都标记为只读，并将两个进程中的每个区域结构都标记为私有的写时拷贝。</strong></p>
<p>当fork在新进程中返回时，新进程现在的虚拟存储器刚好和调用fork时存在的虚拟存储器相同。当这两个进程中的任一个后来进行写操作时，写时拷贝机制就会创建新页面，因此，也就为每个进程保持了私有地址空间的抽象概念。</p>
<h4 id="9-8-3-再看-execvel函数"><a href="#9-8-3-再看-execvel函数" class="headerlink" title="9.8.3 再看 execvel函数"></a>9.8.3 再看 execvel函数</h4><p>正如在第8章中学到的， execve函数在当前进程中加载并运行包含在可执行目标文件a.out中的程序，用a.out程序有效地替代了当前程序。加载并运行a.out需要以下几个步骤：</p>
<ul>
<li><strong>删除已存在的用户区域</strong>。删除当前进程虚拟地址的用户部分中的已存在的区域结构。</li>
<li><strong>映射私有区域</strong>。为新程序的文本、数据、bss和栈区域创建新的区域结构。所有这些新的区域都是私有的、写时拷贝的。文本和数据区域被映射为a.out文件中的文本和数据区。bbs区域是请求二进制零的，映射到匿名文件，其大小包含在a.out中。栈和堆区域也是请求二进制零的，初始长度为零。图9-31概括了私有区域的不同映射。</li>
<li><strong>映射共享区域</strong>。如果a.out程序与共享对象（或目标）链接，比如标准C库libc.so,那么这些对象都是动态链接到这个程序的，然后再映射到用户虚拟地址空间中的共享区域内。</li>
<li>**设置程序计数器(PC)**。 execve的最后一件事情就是设置当前进程上下文中的程序计数器，使之指向文本区域的入口点。</li>
</ul>
<p>下一次调度这个进程时，它将从这个入口点开始执行。Linux将根据需要换入代码和数据页面。</p>
<p><img src="/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/image-20210621164152972.png" srcset="/img/loading.gif" lazyload alt="image-20210621164152972"></p>
<h4 id="9-8-4-使用mmap函数的用户级存储器映射"><a href="#9-8-4-使用mmap函数的用户级存储器映射" class="headerlink" title="9.8.4 使用mmap函数的用户级存储器映射"></a>9.8.4 使用mmap函数的用户级存储器映射</h4><hr>
<h3 id="9-9-动态存储器分配"><a href="#9-9-动态存储器分配" class="headerlink" title="9.9 动态存储器分配"></a>9.9 动态存储器分配</h3><hr>
<h3 id="9-10-垃圾收集"><a href="#9-10-垃圾收集" class="headerlink" title="9.10 垃圾收集"></a>9.10 垃圾收集</h3><hr>
<h3 id="9-11-C程序中常见的与存储器有关的"><a href="#9-11-C程序中常见的与存储器有关的" class="headerlink" title="9.11 C程序中常见的与存储器有关的"></a>9.11 C程序中常见的与存储器有关的</h3>
            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                  <div class="post-meta mr-3">
                    <i class="iconfont icon-category"></i>
                    
                      <a class="hover-with-bg" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/">计算机系统</a>
                    
                  </div>
                
                
                  <div class="post-meta">
                    <i class="iconfont icon-tags"></i>
                    
                      <a class="hover-with-bg" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/">计算机系统</a>
                    
                  </div>
                
              </div>
              
                <p class="note note-warning">
                  
                    本博客所有文章除特别声明外，著作权归作者所有，转载请注明出处！
                  
                </p>
              
              
                <div class="post-prevnext">
                  <article class="post-prev col-6">
                    
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2021/07/04/Attack_lab/">
                        <span class="hidden-mobile">lab4_attack lab</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
              <!-- Comments -->
              <article class="comments" id="comments" lazyload>
                
                  
                
                
  <div class="disqus" style="width:100%">
    <div id="disqus_thread"></div>
    
      <script type="text/javascript">
        var disqus_config = function() {
          this.page.url = 'http://example.com/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/';
          this.page.identifier = '/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/';
        };
        Fluid.utils.loadComments('#disqus_thread', function() {
          var d = document, s = d.createElement('script');
          s.src = '//' + 'fluid' + '.disqus.com/embed.js';
          s.setAttribute('data-timestamp', new Date());
          (d.head || d.body).appendChild(s);
        });
      </script>
    
    <noscript>Please enable JavaScript to view the comments</noscript>
  </div>


              </article>
            
          </article>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    

    
      <a id="scroll-top-button" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
    

    
  </main>

  <footer class="text-center mt-5 py-3">
  <div class="footer-content">
     <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
  </div>
  
  <div class="statistics">
    
    

    
      
        <!-- 不蒜子统计PV -->
        <span id="busuanzi_container_site_pv" style="display: none">
            总访问量 
            <span id="busuanzi_value_site_pv"></span>
             次
          </span>
      
      
        <!-- 不蒜子统计UV -->
        <span id="busuanzi_container_site_uv" style="display: none">
            总访客数 
            <span id="busuanzi_value_site_uv"></span>
             人
          </span>
      
    
  </div>


  

  
</footer>


  <!-- SCRIPTS -->
  
  <script  src="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" ></script>
<script  src="https://cdn.jsdelivr.net/npm/bootstrap@4.6.0/dist/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>

<!-- Plugins -->


  
    <script  src="/js/img-lazyload.js" ></script>
  



  



  <script  src="https://cdn.jsdelivr.net/npm/tocbot@4.12.3/dist/tocbot.min.js" ></script>



  <script  src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js" ></script>



  <script  src="https://cdn.jsdelivr.net/npm/anchor-js@4.3.1/anchor.min.js" ></script>



  <script defer src="https://cdn.jsdelivr.net/npm/clipboard@2.0.8/dist/clipboard.min.js" ></script>



  <script  src="/js/local-search.js" ></script>



  <script defer src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" ></script>




  <script  src="https://cdn.jsdelivr.net/npm/typed.js@2.0.12/lib/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var title = document.getElementById('subtitle').title;
      
      typing(title)
      
    })(window, document);
  </script>












  

  

  

  

  

  





<!-- 主题的启动项 保持在最底部 -->
<script  src="/js/boot.js" ></script>


</body>
</html>
